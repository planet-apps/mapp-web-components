var Ov = Object.defineProperty;
var Ku = (o) => {
  throw TypeError(o);
};
var Rv = (o, n, t) => n in o ? Ov(o, n, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[n] = t;
var m = (o, n, t) => Rv(o, typeof n != "symbol" ? n + "" : n, t), Yu = (o, n, t) => n.has(o) || Ku("Cannot " + t);
var Be = (o, n, t) => (Yu(o, n, "read from private field"), t ? t.call(o) : n.get(o)), yl = (o, n, t) => n.has(o) ? Ku("Cannot add the same private member more than once") : n instanceof WeakSet ? n.add(o) : n.set(o, t), Cl = (o, n, t, e) => (Yu(o, n, "write to private field"), e ? e.call(o, t) : n.set(o, t), t);
const Vv = "5";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(Vv);
const Fv = 1, jv = 2, Hv = 16, Uv = 1, $v = 4, qv = 8, Wv = 16, Gv = 4, Kv = 1, Yv = 2, Sp = "[", Rd = "[!", Vd = "]", Br = {}, je = Symbol(), Ip = !1;
function Fd(o) {
  console.warn("hydration_mismatch");
}
var jd = Array.isArray, Hd = Array.from, aa = Object.keys, la = Object.defineProperty, Yi = Object.getOwnPropertyDescriptor, Zv = Object.getOwnPropertyDescriptors, Qv = Object.prototype, Jv = Array.prototype, Mc = Object.getPrototypeOf;
function Xv(o) {
  return typeof o == "function";
}
const dr = () => {
};
function Mp(o) {
  for (var n = 0; n < o.length; n++)
    o[n]();
}
const ii = 2, Dp = 4, Za = 8, Qa = 16, vn = 32, ms = 64, oo = 128, ca = 256, Ke = 512, Ei = 1024, gs = 2048, Mn = 4096, fs = 8192, Pp = 16384, Ja = 32768, t0 = 1 << 18, Lp = 1 << 19, Ho = Symbol("$state"), e0 = Symbol("");
function Bp(o) {
  return o === this.v;
}
function n0(o, n) {
  return o != o ? n == n : o !== n || o !== null && typeof o == "object" || typeof o == "function";
}
function Np(o) {
  return !n0(o, this.v);
}
function i0(o) {
  throw new Error("effect_in_teardown");
}
function o0() {
  throw new Error("effect_in_unowned_derived");
}
function r0(o) {
  throw new Error("effect_orphan");
}
function s0() {
  throw new Error("effect_update_depth_exceeded");
}
function a0() {
  throw new Error("hydration_failed");
}
function l0(o) {
  throw new Error("props_invalid_value");
}
function c0() {
  throw new Error("state_descriptors_fixed");
}
function d0() {
  throw new Error("state_prototype_fixed");
}
function u0() {
  throw new Error("state_unsafe_local_read");
}
function h0() {
  throw new Error("state_unsafe_mutation");
}
let zp = !1;
function on(o) {
  return {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: o,
    reactions: null,
    equals: Bp,
    version: 0
  };
}
function Zi(o) {
  return /* @__PURE__ */ m0(on(o));
}
// @__NO_SIDE_EFFECTS__
function Ud(o, n = !1) {
  const t = on(o);
  return n || (t.equals = Np), t;
}
// @__NO_SIDE_EFFECTS__
function m0(o) {
  return xt !== null && xt.f & ii && (Dn === null ? C0([o]) : Dn.push(o)), o;
}
function Xt(o, n) {
  return xt !== null && x0() && xt.f & (ii | Qa) && // If the source was created locally within the current derived, then
  // we allow the mutation.
  (Dn === null || !Dn.includes(o)) && h0(), Op(o, n);
}
function Op(o, n) {
  return o.equals(n) || (o.v = n, o.version = tb(), Rp(o, Ei), lt !== null && lt.f & Ke && !(lt.f & vn) && (Ae !== null && Ae.includes(o) ? (di(lt, Ei), tl(lt)) : yi === null ? A0([o]) : yi.push(o))), n;
}
function Rp(o, n) {
  var t = o.reactions;
  if (t !== null)
    for (var e = t.length, i = 0; i < e; i++) {
      var r = t[i], s = r.f;
      s & Ei || (di(r, n), s & (Ke | oo) && (s & ii ? Rp(
        /** @type {Derived} */
        r,
        gs
      ) : tl(
        /** @type {Effect} */
        r
      )));
    }
}
// @__NO_SIDE_EFFECTS__
function Vp(o) {
  var n = ii | Ei;
  lt === null ? n |= oo : lt.f |= Lp;
  const t = {
    children: null,
    ctx: Re,
    deps: null,
    equals: Bp,
    f: n,
    fn: o,
    reactions: null,
    v: (
      /** @type {V} */
      null
    ),
    version: 0,
    parent: lt
  };
  if (xt !== null && xt.f & ii) {
    var e = (
      /** @type {Derived} */
      xt
    );
    (e.children ?? (e.children = [])).push(t);
  }
  return t;
}
function Fp(o) {
  var n = o.children;
  if (n !== null) {
    o.children = null;
    for (var t = 0; t < n.length; t += 1) {
      var e = n[t];
      e.f & ii ? $d(
        /** @type {Derived} */
        e
      ) : ro(
        /** @type {Effect} */
        e
      );
    }
  }
}
function jp(o) {
  var n, t = lt;
  ln(o.parent);
  try {
    Fp(o), n = eb(o);
  } finally {
    ln(t);
  }
  return n;
}
function Hp(o) {
  var n = jp(o), t = (zo || o.f & oo) && o.deps !== null ? gs : Ke;
  di(o, t), o.equals(n) || (o.v = n, o.version = tb());
}
function $d(o) {
  Fp(o), Qr(o, 0), di(o, fs), o.v = o.children = o.deps = o.ctx = o.reactions = null;
}
function g0(o) {
  lt === null && xt === null && r0(), xt !== null && xt.f & oo && o0(), Yd && i0();
}
function f0(o, n) {
  var t = n.last;
  t === null ? n.last = n.first = o : (t.next = o, o.prev = t, n.last = o);
}
function ps(o, n, t, e = !0) {
  var i = (o & ms) !== 0, r = lt, s = {
    ctx: Re,
    deps: null,
    deriveds: null,
    nodes_start: null,
    nodes_end: null,
    f: o | Ei,
    first: null,
    fn: n,
    last: null,
    next: null,
    parent: i ? null : r,
    prev: null,
    teardown: null,
    transitions: null,
    version: 0
  };
  if (t) {
    var a = Uo;
    try {
      Zu(!0), Xa(s), s.f |= Pp;
    } catch (d) {
      throw ro(s), d;
    } finally {
      Zu(a);
    }
  } else n !== null && tl(s);
  var l = t && s.deps === null && s.first === null && s.nodes_start === null && s.teardown === null && (s.f & Lp) === 0;
  if (!l && !i && e && (r !== null && f0(s, r), xt !== null && xt.f & ii)) {
    var c = (
      /** @type {Derived} */
      xt
    );
    (c.children ?? (c.children = [])).push(s);
  }
  return s;
}
function p0(o) {
  g0();
  var n = lt !== null && (lt.f & vn) !== 0 && Re !== null && !Re.m;
  if (n) {
    var t = (
      /** @type {ComponentContext} */
      Re
    );
    (t.e ?? (t.e = [])).push({
      fn: o,
      effect: lt,
      reaction: xt
    });
  } else {
    var e = rr(o);
    return e;
  }
}
function Up(o) {
  const n = ps(ms, o, !0);
  return () => {
    ro(n);
  };
}
function rr(o) {
  return ps(Dp, o, !1);
}
function qd(o) {
  return ps(Za, o, !0);
}
function mt(o) {
  return Wd(o);
}
function Wd(o, n = 0) {
  return ps(Za | Qa | n, o, !0);
}
function Yr(o, n = !0) {
  return ps(Za | vn, o, !0, n);
}
function $p(o) {
  var n = o.teardown;
  if (n !== null) {
    const t = Yd, e = xt;
    Qu(!0), Ln(null);
    try {
      n.call(null);
    } finally {
      Qu(t), Ln(e);
    }
  }
}
function qp(o) {
  var n = o.deriveds;
  if (n !== null) {
    o.deriveds = null;
    for (var t = 0; t < n.length; t += 1)
      $d(n[t]);
  }
}
function Wp(o, n = !1) {
  var t = o.first;
  for (o.first = o.last = null; t !== null; ) {
    var e = t.next;
    ro(t, n), t = e;
  }
}
function b0(o) {
  for (var n = o.first; n !== null; ) {
    var t = n.next;
    n.f & vn || ro(n), n = t;
  }
}
function ro(o, n = !0) {
  var t = !1;
  if ((n || o.f & t0) && o.nodes_start !== null) {
    for (var e = o.nodes_start, i = o.nodes_end; e !== null; ) {
      var r = e === i ? null : (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Pi(e)
      );
      e.remove(), e = r;
    }
    t = !0;
  }
  Wp(o, n && !t), qp(o), Qr(o, 0), di(o, fs);
  var s = o.transitions;
  if (s !== null)
    for (const l of s)
      l.stop();
  $p(o);
  var a = o.parent;
  a !== null && a.first !== null && Gp(o), o.next = o.prev = o.teardown = o.ctx = o.deps = o.parent = o.fn = o.nodes_start = o.nodes_end = null;
}
function Gp(o) {
  var n = o.parent, t = o.prev, e = o.next;
  t !== null && (t.next = e), e !== null && (e.prev = t), n !== null && (n.first === o && (n.first = e), n.last === o && (n.last = t));
}
function Dc(o, n) {
  var t = [];
  Gd(o, t, !0), Kp(t, () => {
    ro(o), n && n();
  });
}
function Kp(o, n) {
  var t = o.length;
  if (t > 0) {
    var e = () => --t || n();
    for (var i of o)
      i.out(e);
  } else
    n();
}
function Gd(o, n, t) {
  if (!(o.f & Mn)) {
    if (o.f ^= Mn, o.transitions !== null)
      for (const s of o.transitions)
        (s.is_global || t) && n.push(s);
    for (var e = o.first; e !== null; ) {
      var i = e.next, r = (e.f & Ja) !== 0 || (e.f & vn) !== 0;
      Gd(e, n, r ? t : !1), e = i;
    }
  }
}
function da(o) {
  Yp(o, !0);
}
function Yp(o, n) {
  if (o.f & Mn) {
    bs(o) && Xa(o), o.f ^= Mn;
    for (var t = o.first; t !== null; ) {
      var e = t.next, i = (t.f & Ja) !== 0 || (t.f & vn) !== 0;
      Yp(t, i ? n : !1), t = e;
    }
    if (o.transitions !== null)
      for (const r of o.transitions)
        (r.is_global || n) && r.in();
  }
}
const k0 = typeof requestIdleCallback > "u" ? (o) => setTimeout(o, 1) : requestIdleCallback;
let ua = !1, ha = !1, Pc = [], Lc = [];
function Zp() {
  ua = !1;
  const o = Pc.slice();
  Pc = [], Mp(o);
}
function Qp() {
  ha = !1;
  const o = Lc.slice();
  Lc = [], Mp(o);
}
function Kd(o) {
  ua || (ua = !0, queueMicrotask(Zp)), Pc.push(o);
}
function w0(o) {
  ha || (ha = !0, k0(Qp)), Lc.push(o);
}
function _0() {
  ua && Zp(), ha && Qp();
}
function v0(o) {
  throw new Error("lifecycle_outside_component");
}
const Jp = 0, y0 = 1;
let Xs = Jp, Zr = !1, Uo = !1, Yd = !1;
function Zu(o) {
  Uo = o;
}
function Qu(o) {
  Yd = o;
}
let Gi = [], $o = 0;
let xt = null;
function Ln(o) {
  xt = o;
}
let lt = null;
function ln(o) {
  lt = o;
}
let Dn = null;
function C0(o) {
  Dn = o;
}
let Ae = null, He = 0, yi = null;
function A0(o) {
  yi = o;
}
let Xp = 0, zo = !1, Re = null;
function tb() {
  return ++Xp;
}
function x0() {
  return !zp;
}
function bs(o) {
  var s, a;
  var n = o.f;
  if (n & Ei)
    return !0;
  if (n & gs) {
    var t = o.deps, e = (n & oo) !== 0;
    if (t !== null) {
      var i;
      if (n & ca) {
        for (i = 0; i < t.length; i++)
          ((s = t[i]).reactions ?? (s.reactions = [])).push(o);
        o.f ^= ca;
      }
      for (i = 0; i < t.length; i++) {
        var r = t[i];
        if (bs(
          /** @type {Derived} */
          r
        ) && Hp(
          /** @type {Derived} */
          r
        ), e && lt !== null && !zo && !((a = r == null ? void 0 : r.reactions) != null && a.includes(o)) && (r.reactions ?? (r.reactions = [])).push(o), r.version > o.version)
          return !0;
      }
    }
    e || di(o, Ke);
  }
  return !1;
}
function E0(o, n, t) {
  throw o;
}
function eb(o) {
  var h;
  var n = Ae, t = He, e = yi, i = xt, r = zo, s = Dn, a = Re, l = o.f;
  Ae = /** @type {null | Value[]} */
  null, He = 0, yi = null, xt = l & (vn | ms) ? null : o, zo = !Uo && (l & oo) !== 0, Dn = null, Re = o.ctx;
  try {
    var c = (
      /** @type {Function} */
      (0, o.fn)()
    ), d = o.deps;
    if (Ae !== null) {
      var u;
      if (Qr(o, He), d !== null && He > 0)
        for (d.length = He + Ae.length, u = 0; u < Ae.length; u++)
          d[He + u] = Ae[u];
      else
        o.deps = d = Ae;
      if (!zo)
        for (u = He; u < d.length; u++)
          ((h = d[u]).reactions ?? (h.reactions = [])).push(o);
    } else d !== null && He < d.length && (Qr(o, He), d.length = He);
    return c;
  } finally {
    Ae = n, He = t, yi = e, xt = i, zo = r, Dn = s, Re = a;
  }
}
function T0(o, n) {
  let t = n.reactions;
  if (t !== null) {
    var e = t.indexOf(o);
    if (e !== -1) {
      var i = t.length - 1;
      i === 0 ? t = n.reactions = null : (t[e] = t[i], t.pop());
    }
  }
  t === null && n.f & ii && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Ae === null || !Ae.includes(n)) && (di(n, gs), n.f & (oo | ca) || (n.f ^= ca), Qr(
    /** @type {Derived} **/
    n,
    0
  ));
}
function Qr(o, n) {
  var t = o.deps;
  if (t !== null)
    for (var e = n; e < t.length; e++)
      T0(o, t[e]);
}
function Xa(o) {
  var n = o.f;
  if (!(n & fs)) {
    di(o, Ke);
    var t = lt;
    lt = o;
    try {
      n & Qa ? b0(o) : Wp(o), qp(o), $p(o);
      var e = eb(o);
      o.teardown = typeof e == "function" ? e : null, o.version = Xp;
    } catch (i) {
      E0(
        /** @type {Error} */
        i
      );
    } finally {
      lt = t;
    }
  }
}
function nb() {
  $o > 1e3 && ($o = 0, s0()), $o++;
}
function ib(o) {
  var n = o.length;
  if (n !== 0) {
    nb();
    var t = Uo;
    Uo = !0;
    try {
      for (var e = 0; e < n; e++) {
        var i = o[e];
        i.f & Ke || (i.f ^= Ke);
        var r = [];
        ob(i, r), S0(r);
      }
    } finally {
      Uo = t;
    }
  }
}
function S0(o) {
  var n = o.length;
  if (n !== 0)
    for (var t = 0; t < n; t++) {
      var e = o[t];
      !(e.f & (fs | Mn)) && bs(e) && (Xa(e), e.deps === null && e.first === null && e.nodes_start === null && (e.teardown === null ? Gp(e) : e.fn = null));
    }
}
function I0() {
  if (Zr = !1, $o > 1001)
    return;
  const o = Gi;
  Gi = [], ib(o), Zr || ($o = 0);
}
function tl(o) {
  Xs === Jp && (Zr || (Zr = !0, queueMicrotask(I0)));
  for (var n = o; n.parent !== null; ) {
    n = n.parent;
    var t = n.f;
    if (t & (ms | vn)) {
      if (!(t & Ke)) return;
      n.f ^= Ke;
    }
  }
  Gi.push(n);
}
function ob(o, n) {
  var t = o.first, e = [];
  t: for (; t !== null; ) {
    var i = t.f, r = (i & vn) !== 0, s = r && (i & Ke) !== 0;
    if (!s && !(i & Mn))
      if (i & Za) {
        r ? t.f ^= Ke : bs(t) && Xa(t);
        var a = t.first;
        if (a !== null) {
          t = a;
          continue;
        }
      } else i & Dp && e.push(t);
    var l = t.next;
    if (l === null) {
      let u = t.parent;
      for (; u !== null; ) {
        if (o === u)
          break t;
        var c = u.next;
        if (c !== null) {
          t = c;
          continue t;
        }
        u = u.parent;
      }
    }
    t = l;
  }
  for (var d = 0; d < e.length; d++)
    a = e[d], n.push(a), ob(a, n);
}
function rb(o) {
  var n = Xs, t = Gi;
  try {
    nb();
    const i = [];
    Xs = y0, Gi = i, Zr = !1, ib(t);
    var e = o == null ? void 0 : o();
    return _0(), (Gi.length > 0 || i.length > 0) && rb(), $o = 0, e;
  } finally {
    Xs = n, Gi = t;
  }
}
function z(o) {
  var a;
  var n = o.f, t = (n & ii) !== 0;
  if (t && n & fs) {
    var e = jp(
      /** @type {Derived} */
      o
    );
    return $d(
      /** @type {Derived} */
      o
    ), e;
  }
  if (xt !== null) {
    Dn !== null && Dn.includes(o) && u0();
    var i = xt.deps;
    Ae === null && i !== null && i[He] === o ? He++ : Ae === null ? Ae = [o] : Ae.push(o), yi !== null && lt !== null && lt.f & Ke && !(lt.f & vn) && yi.includes(o) && (di(lt, Ei), tl(lt));
  } else if (t && /** @type {Derived} */
  o.deps === null) {
    var r = (
      /** @type {Derived} */
      o
    ), s = r.parent;
    s !== null && !((a = s.deriveds) != null && a.includes(r)) && (s.deriveds ?? (s.deriveds = [])).push(r);
  }
  return t && (r = /** @type {Derived} */
  o, bs(r) && Hp(r)), o.v;
}
function Jr(o) {
  const n = xt;
  try {
    return xt = null, o();
  } finally {
    xt = n;
  }
}
const M0 = ~(Ei | gs | Ke);
function di(o, n) {
  o.f = o.f & M0 | n;
}
function Ve(o, n = !1, t) {
  Re = {
    p: Re,
    c: null,
    e: null,
    m: !1,
    s: o,
    x: null,
    l: null
  };
}
function Fe(o) {
  const n = Re;
  if (n !== null) {
    const s = n.e;
    if (s !== null) {
      var t = lt, e = xt;
      n.e = null;
      try {
        for (var i = 0; i < s.length; i++) {
          var r = s[i];
          ln(r.effect), Ln(r.reaction), rr(r.fn);
        }
      } finally {
        ln(t), Ln(e);
      }
    }
    Re = n.p, n.m = !0;
  }
  return (
    /** @type {T} */
    {}
  );
}
function $t(o, n = null, t) {
  if (typeof o != "object" || o === null || Ho in o)
    return o;
  const e = Mc(o);
  if (e !== Qv && e !== Jv)
    return o;
  var i = /* @__PURE__ */ new Map(), r = jd(o), s = on(0);
  r && i.set("length", on(
    /** @type {any[]} */
    o.length
  ));
  var a;
  return new Proxy(
    /** @type {any} */
    o,
    {
      defineProperty(l, c, d) {
        (!("value" in d) || d.configurable === !1 || d.enumerable === !1 || d.writable === !1) && c0();
        var u = i.get(c);
        return u === void 0 ? (u = on(d.value), i.set(c, u)) : Xt(u, $t(d.value, a)), !0;
      },
      deleteProperty(l, c) {
        var d = i.get(c);
        if (d === void 0)
          c in l && i.set(c, on(je));
        else {
          if (r && typeof c == "string") {
            var u = (
              /** @type {Source<number>} */
              i.get("length")
            ), h = Number(c);
            Number.isInteger(h) && h < u.v && Xt(u, h);
          }
          Xt(d, je), Ju(s);
        }
        return !0;
      },
      get(l, c, d) {
        var f;
        if (c === Ho)
          return o;
        var u = i.get(c), h = c in l;
        if (u === void 0 && (!h || (f = Yi(l, c)) != null && f.writable) && (u = on($t(h ? l[c] : je, a)), i.set(c, u)), u !== void 0) {
          var g = z(u);
          return g === je ? void 0 : g;
        }
        return Reflect.get(l, c, d);
      },
      getOwnPropertyDescriptor(l, c) {
        var d = Reflect.getOwnPropertyDescriptor(l, c);
        if (d && "value" in d) {
          var u = i.get(c);
          u && (d.value = z(u));
        } else if (d === void 0) {
          var h = i.get(c), g = h == null ? void 0 : h.v;
          if (h !== void 0 && g !== je)
            return {
              enumerable: !0,
              configurable: !0,
              value: g,
              writable: !0
            };
        }
        return d;
      },
      has(l, c) {
        var g;
        if (c === Ho)
          return !0;
        var d = i.get(c), u = d !== void 0 && d.v !== je || Reflect.has(l, c);
        if (d !== void 0 || lt !== null && (!u || (g = Yi(l, c)) != null && g.writable)) {
          d === void 0 && (d = on(u ? $t(l[c], a) : je), i.set(c, d));
          var h = z(d);
          if (h === je)
            return !1;
        }
        return u;
      },
      set(l, c, d, u) {
        var _;
        var h = i.get(c), g = c in l;
        if (r && c === "length")
          for (var f = d; f < /** @type {Source<number>} */
          h.v; f += 1) {
            var p = i.get(f + "");
            p !== void 0 ? Xt(p, je) : f in l && (p = on(je), i.set(f + "", p));
          }
        h === void 0 ? (!g || (_ = Yi(l, c)) != null && _.writable) && (h = on(void 0), Xt(h, $t(d, a)), i.set(c, h)) : (g = h.v !== je, Xt(h, $t(d, a)));
        var b = Reflect.getOwnPropertyDescriptor(l, c);
        if (b != null && b.set && b.set.call(u, d), !g) {
          if (r && typeof c == "string") {
            var k = (
              /** @type {Source<number>} */
              i.get("length")
            ), w = Number(c);
            Number.isInteger(w) && w >= k.v && Xt(k, w + 1);
          }
          Ju(s);
        }
        return !0;
      },
      ownKeys(l) {
        z(s);
        var c = Reflect.ownKeys(l).filter((h) => {
          var g = i.get(h);
          return g === void 0 || g.v !== je;
        });
        for (var [d, u] of i)
          u.v !== je && !(d in l) && c.push(d);
        return c;
      },
      setPrototypeOf() {
        d0();
      }
    }
  );
}
function Ju(o, n = 1) {
  Xt(o, o.v + n);
}
function Xu(o) {
  return o !== null && typeof o == "object" && Ho in o ? o[Ho] : o;
}
function D0(o, n) {
  return Object.is(Xu(o), Xu(n));
}
var th, sb, ab;
function Bc() {
  if (th === void 0) {
    th = window;
    var o = Element.prototype, n = Node.prototype;
    sb = Yi(n, "firstChild").get, ab = Yi(n, "nextSibling").get, o.__click = void 0, o.__className = "", o.__attributes = null, o.__styles = null, o.__e = void 0, Text.prototype.__t = void 0;
  }
}
function Zo(o = "") {
  return document.createTextNode(o);
}
// @__NO_SIDE_EFFECTS__
function Xi(o) {
  return sb.call(o);
}
// @__NO_SIDE_EFFECTS__
function Pi(o) {
  return ab.call(o);
}
function R(o, n) {
  if (!It)
    return /* @__PURE__ */ Xi(o);
  var t = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ Xi(Ft)
  );
  if (t === null)
    t = Ft.appendChild(Zo());
  else if (n && t.nodeType !== 3) {
    var e = Zo();
    return t == null || t.before(e), pn(e), e;
  }
  return pn(t), t;
}
function sr(o, n) {
  if (!It) {
    var t = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ Xi(
        /** @type {Node} */
        o
      )
    );
    return t instanceof Comment && t.data === "" ? /* @__PURE__ */ Pi(t) : t;
  }
  return Ft;
}
function et(o, n = 1, t = !1) {
  let e = It ? Ft : o;
  for (; n--; )
    e = /** @type {TemplateNode} */
    /* @__PURE__ */ Pi(e);
  if (!It)
    return e;
  var i = e.nodeType;
  if (t && i !== 3) {
    var r = Zo();
    return e == null || e.before(r), pn(r), r;
  }
  return pn(e), /** @type {TemplateNode} */
  e;
}
function lb(o) {
  o.textContent = "";
}
let It = !1;
function Qn(o) {
  It = o;
}
let Ft;
function pn(o) {
  if (o === null)
    throw Fd(), Br;
  return Ft = o;
}
function ks() {
  return pn(
    /** @type {TemplateNode} */
    /* @__PURE__ */ Pi(Ft)
  );
}
function D(o) {
  if (It) {
    if (/* @__PURE__ */ Pi(Ft) !== null)
      throw Fd(), Br;
    Ft = o;
  }
}
function Nc() {
  for (var o = 0, n = Ft; ; ) {
    if (n.nodeType === 8) {
      var t = (
        /** @type {Comment} */
        n.data
      );
      if (t === Vd) {
        if (o === 0) return n;
        o -= 1;
      } else (t === Sp || t === Rd) && (o += 1);
    }
    var e = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Pi(n)
    );
    n.remove(), n = e;
  }
}
let eh = !1;
function cb() {
  eh || (eh = !0, document.addEventListener(
    "reset",
    (o) => {
      Promise.resolve().then(() => {
        var n;
        if (!o.defaultPrevented)
          for (
            const t of
            /**@type {HTMLFormElement} */
            o.target.elements
          )
            (n = t.__on_r) == null || n.call(t);
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
    { capture: !0 }
  ));
}
function P0(o) {
  var n = xt, t = lt;
  Ln(null), ln(null);
  try {
    return o();
  } finally {
    Ln(n), ln(t);
  }
}
function db(o, n, t, e = t) {
  o.addEventListener(n, () => P0(t));
  const i = o.__on_r;
  i ? o.__on_r = () => {
    i(), e();
  } : o.__on_r = e, cb();
}
const ub = /* @__PURE__ */ new Set(), zc = /* @__PURE__ */ new Set();
function Vn(o) {
  for (var n = 0; n < o.length; n++)
    ub.add(o[n]);
  for (var t of zc)
    t(o);
}
function Ts(o) {
  var w;
  var n = this, t = (
    /** @type {Node} */
    n.ownerDocument
  ), e = o.type, i = ((w = o.composedPath) == null ? void 0 : w.call(o)) || [], r = (
    /** @type {null | Element} */
    i[0] || o.target
  ), s = 0, a = o.__root;
  if (a) {
    var l = i.indexOf(a);
    if (l !== -1 && (n === document || n === /** @type {any} */
    window)) {
      o.__root = n;
      return;
    }
    var c = i.indexOf(n);
    if (c === -1)
      return;
    l <= c && (s = l);
  }
  if (r = /** @type {Element} */
  i[s] || o.target, r !== n) {
    la(o, "currentTarget", {
      configurable: !0,
      get() {
        return r || t;
      }
    });
    var d = xt, u = lt;
    Ln(null), ln(null);
    try {
      for (var h, g = []; r !== null; ) {
        var f = r.assignedSlot || r.parentNode || /** @type {any} */
        r.host || null;
        try {
          var p = r["__" + e];
          if (p !== void 0 && !/** @type {any} */
          r.disabled)
            if (jd(p)) {
              var [b, ...k] = p;
              b.apply(r, [o, ...k]);
            } else
              p.call(r, o);
        } catch (_) {
          h ? g.push(_) : h = _;
        }
        if (o.cancelBubble || f === n || f === null)
          break;
        r = f;
      }
      if (h) {
        for (let _ of g)
          queueMicrotask(() => {
            throw _;
          });
        throw h;
      }
    } finally {
      o.__root = n, delete o.currentTarget, Ln(d), ln(u);
    }
  }
}
function L0(o) {
  var n = document.createElement("template");
  return n.innerHTML = o, n.content;
}
function qo(o, n) {
  var t = (
    /** @type {Effect} */
    lt
  );
  t.nodes_start === null && (t.nodes_start = o, t.nodes_end = n);
}
// @__NO_SIDE_EFFECTS__
function W(o, n) {
  var t = (n & Kv) !== 0, e = (n & Yv) !== 0, i, r = !o.startsWith("<!>");
  return () => {
    if (It)
      return qo(Ft, null), Ft;
    i === void 0 && (i = L0(r ? o : "<!>" + o), t || (i = /** @type {Node} */
    /* @__PURE__ */ Xi(i)));
    var s = (
      /** @type {TemplateNode} */
      e ? document.importNode(i, !0) : i.cloneNode(!0)
    );
    if (t) {
      var a = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Xi(s)
      ), l = (
        /** @type {TemplateNode} */
        s.lastChild
      );
      qo(a, l);
    } else
      qo(s, s);
    return s;
  };
}
function hb() {
  if (It)
    return qo(Ft, null), Ft;
  var o = document.createDocumentFragment(), n = document.createComment(""), t = Zo();
  return o.append(n, t), qo(n, t), o;
}
function U(o, n) {
  if (It) {
    lt.nodes_end = Ft, ks();
    return;
  }
  o !== null && o.before(
    /** @type {Node} */
    n
  );
}
const B0 = ["touchstart", "touchmove"];
function N0(o) {
  return B0.includes(o);
}
let Oc = !0;
function Zt(o, n) {
  var t = n == null ? "" : typeof n == "object" ? n + "" : n;
  t !== (o.__t ?? (o.__t = o.nodeValue)) && (o.__t = t, o.nodeValue = t == null ? "" : t + "");
}
function mb(o, n) {
  return gb(o, n);
}
function z0(o, n) {
  Bc(), n.intro = n.intro ?? !1;
  const t = n.target, e = It, i = Ft;
  try {
    for (var r = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Xi(t)
    ); r && (r.nodeType !== 8 || /** @type {Comment} */
    r.data !== Sp); )
      r = /** @type {TemplateNode} */
      /* @__PURE__ */ Pi(r);
    if (!r)
      throw Br;
    Qn(!0), pn(
      /** @type {Comment} */
      r
    ), ks();
    const s = gb(o, { ...n, anchor: r });
    if (Ft === null || Ft.nodeType !== 8 || /** @type {Comment} */
    Ft.data !== Vd)
      throw Fd(), Br;
    return Qn(!1), /**  @type {Exports} */
    s;
  } catch (s) {
    if (s === Br)
      return n.recover === !1 && a0(), Bc(), lb(t), Qn(!1), mb(o, n);
    throw s;
  } finally {
    Qn(e), pn(i);
  }
}
const ko = /* @__PURE__ */ new Map();
function gb(o, { target: n, anchor: t, props: e = {}, events: i, context: r, intro: s = !0 }) {
  Bc();
  var a = /* @__PURE__ */ new Set(), l = (u) => {
    for (var h = 0; h < u.length; h++) {
      var g = u[h];
      if (!a.has(g)) {
        a.add(g);
        var f = N0(g);
        n.addEventListener(g, Ts, { passive: f });
        var p = ko.get(g);
        p === void 0 ? (document.addEventListener(g, Ts, { passive: f }), ko.set(g, 1)) : ko.set(g, p + 1);
      }
    }
  };
  l(Hd(ub)), zc.add(l);
  var c = void 0, d = Up(() => {
    var u = t ?? n.appendChild(Zo());
    return Yr(() => {
      if (r) {
        Ve({});
        var h = (
          /** @type {ComponentContext} */
          Re
        );
        h.c = r;
      }
      i && (e.$$events = i), It && qo(
        /** @type {TemplateNode} */
        u,
        null
      ), Oc = s, c = o(u, e) || {}, Oc = !0, It && (lt.nodes_end = Ft), r && Fe();
    }), () => {
      var f;
      for (var h of a) {
        n.removeEventListener(h, Ts);
        var g = (
          /** @type {number} */
          ko.get(h)
        );
        --g === 0 ? (document.removeEventListener(h, Ts), ko.delete(h)) : ko.set(h, g);
      }
      zc.delete(l), Rc.delete(c), u !== t && ((f = u.parentNode) == null || f.removeChild(u));
    };
  });
  return Rc.set(c, d), c;
}
let Rc = /* @__PURE__ */ new WeakMap();
function O0(o) {
  const n = Rc.get(o);
  n && n();
}
function me(o, n, t, e = null, i = !1) {
  It && ks();
  var r = o, s = null, a = null, l = null, c = i ? Ja : 0;
  Wd(() => {
    if (l === (l = !!n())) return;
    let d = !1;
    if (It) {
      const u = (
        /** @type {Comment} */
        r.data === Rd
      );
      l === u && (r = Nc(), pn(r), Qn(!1), d = !0);
    }
    l ? (s ? da(s) : s = Yr(() => t(r)), a && Dc(a, () => {
      a = null;
    })) : (a ? da(a) : e && (a = Yr(() => e(r))), s && Dc(s, () => {
      s = null;
    })), d && Qn(!0);
  }, c), It && (r = Ft);
}
function be(o, n) {
  return n;
}
function R0(o, n, t, e) {
  for (var i = [], r = n.length, s = 0; s < r; s++)
    Gd(n[s].e, i, !0);
  var a = r > 0 && i.length === 0 && t !== null;
  if (a) {
    var l = (
      /** @type {Element} */
      /** @type {Element} */
      t.parentNode
    );
    lb(l), l.append(
      /** @type {Element} */
      t
    ), e.clear(), ki(o, n[0].prev, n[r - 1].next);
  }
  Kp(i, () => {
    for (var c = 0; c < r; c++) {
      var d = n[c];
      a || (e.delete(d.k), ki(o, d.prev, d.next)), ro(d.e, !a);
    }
  });
}
function ke(o, n, t, e, i, r = null) {
  var s = o, a = { flags: n, items: /* @__PURE__ */ new Map(), first: null };
  {
    var l = (
      /** @type {Element} */
      o
    );
    s = It ? pn(
      /** @type {Comment | Text} */
      /* @__PURE__ */ Xi(l)
    ) : l.appendChild(Zo());
  }
  It && ks();
  var c = null, d = !1;
  Wd(() => {
    var u = t(), h = jd(u) ? u : u == null ? [] : Hd(u), g = h.length;
    if (d && g === 0)
      return;
    d = g === 0;
    let f = !1;
    if (It) {
      var p = (
        /** @type {Comment} */
        s.data === Rd
      );
      p !== (g === 0) && (s = Nc(), pn(s), Qn(!1), f = !0);
    }
    if (It) {
      for (var b = null, k, w = 0; w < g; w++) {
        if (Ft.nodeType === 8 && /** @type {Comment} */
        Ft.data === Vd) {
          s = /** @type {Comment} */
          Ft, f = !0, Qn(!1);
          break;
        }
        var _ = h[w], y = e(_, w);
        k = fb(Ft, a, b, null, _, y, w, i, n), a.items.set(y, k), b = k;
      }
      g > 0 && pn(Nc());
    }
    if (!It) {
      var C = (
        /** @type {Effect} */
        xt
      );
      V0(h, a, s, i, n, (C.f & Mn) !== 0, e);
    }
    r !== null && (g === 0 ? c ? da(c) : c = Yr(() => r(s)) : c !== null && Dc(c, () => {
      c = null;
    })), f && Qn(!0), t();
  }), It && (s = Ft);
}
function V0(o, n, t, e, i, r, s) {
  var a = o.length, l = n.items, c = n.first, d = c, u, h = null, g = [], f = [], p, b, k, w;
  for (w = 0; w < a; w += 1) {
    if (p = o[w], b = s(p, w), k = l.get(b), k === void 0) {
      var _ = d ? (
        /** @type {TemplateNode} */
        d.e.nodes_start
      ) : t;
      h = fb(
        _,
        n,
        h,
        h === null ? n.first : h.next,
        p,
        b,
        w,
        e,
        i
      ), l.set(b, h), g = [], f = [], d = h.next;
      continue;
    }
    if (F0(k, p, w), k.e.f & Mn && da(k.e), k !== d) {
      if (u !== void 0 && u.has(k)) {
        if (g.length < f.length) {
          var y = f[0], C;
          h = y.prev;
          var x = g[0], I = g[g.length - 1];
          for (C = 0; C < g.length; C += 1)
            nh(g[C], y, t);
          for (C = 0; C < f.length; C += 1)
            u.delete(f[C]);
          ki(n, x.prev, I.next), ki(n, h, x), ki(n, I, y), d = y, h = I, w -= 1, g = [], f = [];
        } else
          u.delete(k), nh(k, d, t), ki(n, k.prev, k.next), ki(n, k, h === null ? n.first : h.next), ki(n, h, k), h = k;
        continue;
      }
      for (g = [], f = []; d !== null && d.k !== b; )
        (r || !(d.e.f & Mn)) && (u ?? (u = /* @__PURE__ */ new Set())).add(d), f.push(d), d = d.next;
      if (d === null)
        continue;
      k = d;
    }
    g.push(k), h = k, d = k.next;
  }
  if (d !== null || u !== void 0) {
    for (var P = u === void 0 ? [] : Hd(u); d !== null; )
      (r || !(d.e.f & Mn)) && P.push(d), d = d.next;
    var Y = P.length;
    if (Y > 0) {
      var it = a === 0 ? t : null;
      R0(n, P, it, l);
    }
  }
  lt.first = n.first && n.first.e, lt.last = h && h.e;
}
function F0(o, n, t, e) {
  Op(o.v, n), o.i = t;
}
function fb(o, n, t, e, i, r, s, a, l) {
  var c = (l & Fv) !== 0, d = (l & Hv) === 0, u = c ? d ? /* @__PURE__ */ Ud(i) : on(i) : i, h = l & jv ? on(s) : s, g = {
    i: h,
    v: u,
    k: r,
    a: null,
    // @ts-expect-error
    e: null,
    prev: t,
    next: e
  };
  try {
    return g.e = Yr(() => a(o, u, h), It), g.e.prev = t && t.e, g.e.next = e && e.e, t === null ? n.first = g : (t.next = g, t.e.next = g.e), e !== null && (e.prev = g, e.e.prev = g.e), g;
  } finally {
  }
}
function nh(o, n, t) {
  for (var e = o.next ? (
    /** @type {TemplateNode} */
    o.next.e.nodes_start
  ) : t, i = n ? (
    /** @type {TemplateNode} */
    n.e.nodes_start
  ) : t, r = (
    /** @type {TemplateNode} */
    o.e.nodes_start
  ); r !== e; ) {
    var s = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Pi(r)
    );
    i.before(r), r = s;
  }
}
function ki(o, n, t) {
  n === null ? o.first = t : (n.next = t, n.e.next = t && t.e), t !== null && (t.prev = n, t.e.prev = n && n.e);
}
function pb(o, n, t, e, i) {
  var a;
  It && ks();
  var r = (a = n.$$slots) == null ? void 0 : a[t], s = !1;
  r === !0 && (r = n.children, s = !0), r === void 0 || r(o, s ? () => e : e);
}
function fe(o, n) {
  Kd(() => {
    var t = o.getRootNode(), e = (
      /** @type {ShadowRoot} */
      t.host ? (
        /** @type {ShadowRoot} */
        t
      ) : (
        /** @type {Document} */
        t.head ?? /** @type {Document} */
        t.ownerDocument.head
      )
    );
    if (!e.querySelector("#" + n.hash)) {
      const i = document.createElement("style");
      i.id = n.hash, i.textContent = n.code, e.appendChild(i);
    }
  });
}
function el(o) {
  if (It) {
    var n = !1, t = () => {
      if (!n) {
        if (n = !0, o.hasAttribute("value")) {
          var e = o.value;
          At(o, "value", null), o.value = e;
        }
        if (o.hasAttribute("checked")) {
          var i = o.checked;
          At(o, "checked", null), o.checked = i;
        }
      }
    };
    o.__on_r = t, w0(t), cb();
  }
}
function At(o, n, t, e) {
  var i = o.__attributes ?? (o.__attributes = {});
  It && (i[n] = o.getAttribute(n), n === "src" || n === "srcset" || n === "href" && o.nodeName === "LINK") || i[n] !== (i[n] = t) && (n === "style" && "__styles" in o && (o.__styles = {}), n === "loading" && (o[e0] = t), t == null ? o.removeAttribute(n) : typeof t != "string" && j0(o).includes(n) ? o[n] = t : o.setAttribute(n, t));
}
var ih = /* @__PURE__ */ new Map();
function j0(o) {
  var n = ih.get(o.nodeName);
  if (n) return n;
  ih.set(o.nodeName, n = []);
  for (var t, e = Mc(o), i = Element.prototype; i !== e; ) {
    t = Zv(e);
    for (var r in t)
      t[r].set && n.push(r);
    e = Mc(e);
  }
  return n;
}
function ta(o, n) {
  var t = o.__className, e = H0(n);
  It && o.className === e ? o.__className = e : (t !== e || It && o.className !== e) && (n == null ? o.removeAttribute("class") : o.className = e, o.__className = e);
}
function H0(o) {
  return o ?? "";
}
function Wo(o, n, t) {
  if (t) {
    if (o.classList.contains(n)) return;
    o.classList.add(n);
  } else {
    if (!o.classList.contains(n)) return;
    o.classList.remove(n);
  }
}
const U0 = () => performance.now(), _i = {
  // don't access requestAnimationFrame eagerly outside method
  // this allows basic testing of user code without JSDOM
  // bunder will eval and remove ternary when the user's app is built
  tick: (
    /** @param {any} _ */
    (o) => requestAnimationFrame(o)
  ),
  now: () => U0(),
  tasks: /* @__PURE__ */ new Set()
};
function bb(o) {
  _i.tasks.forEach((n) => {
    n.c(o) || (_i.tasks.delete(n), n.f());
  }), _i.tasks.size !== 0 && _i.tick(bb);
}
function $0(o) {
  let n;
  return _i.tasks.size === 0 && _i.tick(bb), {
    promise: new Promise((t) => {
      _i.tasks.add(n = { c: o, f: t });
    }),
    abort() {
      _i.tasks.delete(n);
    }
  };
}
function Ss(o, n) {
  o.dispatchEvent(new CustomEvent(n));
}
function q0(o) {
  if (o === "float") return "cssFloat";
  if (o === "offset") return "cssOffset";
  if (o.startsWith("--")) return o;
  const n = o.split("-");
  return n.length === 1 ? n[0] : n[0] + n.slice(1).map(
    /** @param {any} word */
    (t) => t[0].toUpperCase() + t.slice(1)
  ).join("");
}
function oh(o) {
  const n = {}, t = o.split(";");
  for (const e of t) {
    const [i, r] = e.split(":");
    if (!i || r === void 0) break;
    const s = q0(i.trim());
    n[s] = r.trim();
  }
  return n;
}
const W0 = (o) => o;
function G0(o, n, t, e) {
  var i = (o & Gv) !== 0, r = "both", s, a = n.inert, l, c;
  function d() {
    var p = xt, b = lt;
    Ln(null), ln(null);
    try {
      return s ?? (s = t()(n, (e == null ? void 0 : e()) ?? /** @type {P} */
      {}, {
        direction: r
      }));
    } finally {
      Ln(p), ln(b);
    }
  }
  var u = {
    is_global: i,
    in() {
      n.inert = a, Ss(n, "introstart"), l = Vc(n, d(), c, 1, () => {
        Ss(n, "introend"), l == null || l.abort(), l = s = void 0;
      });
    },
    out(p) {
      n.inert = !0, Ss(n, "outrostart"), c = Vc(n, d(), l, 0, () => {
        Ss(n, "outroend"), p == null || p();
      });
    },
    stop: () => {
      l == null || l.abort(), c == null || c.abort();
    }
  }, h = (
    /** @type {Effect} */
    lt
  );
  if ((h.transitions ?? (h.transitions = [])).push(u), Oc) {
    var g = i;
    if (!g) {
      for (var f = (
        /** @type {Effect | null} */
        h.parent
      ); f && f.f & Ja; )
        for (; (f = f.parent) && !(f.f & Qa); )
          ;
      g = !f || (f.f & Pp) !== 0;
    }
    g && rr(() => {
      Jr(() => u.in());
    });
  }
}
function Vc(o, n, t, e, i) {
  var r = e === 1;
  if (Xv(n)) {
    var s, a = !1;
    return Kd(() => {
      if (!a) {
        var b = n({ direction: r ? "in" : "out" });
        s = Vc(o, b, t, e, i);
      }
    }), {
      abort: () => {
        a = !0, s == null || s.abort();
      },
      deactivate: () => s.deactivate(),
      reset: () => s.reset(),
      t: () => s.t()
    };
  }
  if (t == null || t.deactivate(), !(n != null && n.duration))
    return i(), {
      abort: dr,
      deactivate: dr,
      reset: dr,
      t: () => e
    };
  const { delay: l = 0, css: c, tick: d, easing: u = W0 } = n;
  var h = [];
  if (r && t === void 0 && (d && d(0, 1), c)) {
    var g = oh(c(0, 1));
    h.push(g, g);
  }
  var f = () => 1 - e, p = o.animate(h, { duration: l });
  return p.onfinish = () => {
    var b = (t == null ? void 0 : t.t()) ?? 1 - e;
    t == null || t.abort();
    var k = e - b, w = (
      /** @type {number} */
      n.duration * Math.abs(k)
    ), _ = [];
    if (w > 0) {
      if (c)
        for (var y = Math.ceil(w / 16.666666666666668), C = 0; C <= y; C += 1) {
          var x = b + k * u(C / y), I = c(x, 1 - x);
          _.push(oh(I));
        }
      f = () => {
        var P = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          p.currentTime
        );
        return b + k * u(P / w);
      }, d && $0(() => {
        if (p.playState !== "running") return !1;
        var P = f();
        return d(P, 1 - P), !0;
      });
    }
    p = o.animate(_, { duration: w, fill: "forwards" }), p.onfinish = () => {
      f = () => e, d == null || d(e, 1 - e), i();
    };
  }, {
    abort: () => {
      p && (p.cancel(), p.effect = null, p.onfinish = dr);
    },
    deactivate: () => {
      i = dr;
    },
    reset: () => {
      e === 0 && (d == null || d(1, 0));
    },
    t: () => f()
  };
}
function nl(o, n, t = n) {
  db(o, "input", () => {
    var e = rh(o) ? sh(o.value) : o.value;
    t(e), e !== (e = n()) && (o.value = e ?? "");
  }), qd(() => {
    var e = n();
    if (It && o.defaultValue !== o.value) {
      t(o.value);
      return;
    }
    rh(o) && e === sh(o.value) || o.type === "date" && !e && !o.value || e !== o.value && (o.value = e ?? "");
  });
}
function rh(o) {
  var n = o.type;
  return n === "number" || n === "range";
}
function sh(o) {
  return o === "" ? null : +o;
}
function kb(o, n, t) {
  if (o.multiple)
    return Z0(o, n);
  for (var e of o.options) {
    var i = Nr(e);
    if (D0(i, n)) {
      e.selected = !0;
      return;
    }
  }
  (!t || n !== void 0) && (o.selectedIndex = -1);
}
function K0(o, n) {
  rr(() => {
    var t = new MutationObserver(() => {
      var e = o.__value;
      kb(o, e);
    });
    return t.observe(o, {
      // Listen to option element changes
      childList: !0,
      subtree: !0,
      // because of <optgroup>
      // Listen to option element value attribute changes
      // (doesn't get notified of select value changes,
      // because that property is not reflected as an attribute)
      attributes: !0,
      attributeFilter: ["value"]
    }), () => {
      t.disconnect();
    };
  });
}
function Y0(o, n, t = n) {
  var e = !0;
  db(o, "change", () => {
    var i;
    if (o.multiple)
      i = [].map.call(o.querySelectorAll(":checked"), Nr);
    else {
      var r = o.querySelector(":checked");
      i = r && Nr(r);
    }
    t(i);
  }), rr(() => {
    var i = n();
    if (kb(o, i, e), e && i === void 0) {
      var r = o.querySelector(":checked");
      r !== null && (i = Nr(r), t(i));
    }
    o.__value = i, e = !1;
  }), K0(o);
}
function Z0(o, n) {
  for (var t of o.options)
    t.selected = ~n.indexOf(Nr(t));
}
function Nr(o) {
  return "__value" in o ? o.__value : o.value;
}
function ah(o, n) {
  return o === n || (o == null ? void 0 : o[Ho]) === n;
}
function Q0(o = {}, n, t, e) {
  return rr(() => {
    var i, r;
    return qd(() => {
      i = r, r = (e == null ? void 0 : e()) || [], Jr(() => {
        o !== t(...r) && (n(o, ...r), i && ah(t(...i), o) && n(null, ...i));
      });
    }), () => {
      Kd(() => {
        r && ah(t(...r), o) && n(null, ...r);
      });
    };
  }), o;
}
function wb(o) {
  Re === null && v0(), p0(() => {
    const n = Jr(o);
    if (typeof n == "function") return (
      /** @type {() => void} */
      n
    );
  });
}
let Is = !1;
function J0(o) {
  var n = Is;
  try {
    return Is = !1, [o(), Is];
  } finally {
    Is = n;
  }
}
function X0(o) {
  for (var n = lt, t = lt; n !== null && !(n.f & (vn | ms)); )
    n = n.parent;
  try {
    return ln(n), o();
  } finally {
    ln(t);
  }
}
function $(o, n, t, e) {
  var C;
  var i = (t & Uv) !== 0, r = !zp, s = (t & qv) !== 0, a = (t & Wv) !== 0, l = !1, c;
  s ? [c, l] = J0(() => (
    /** @type {V} */
    o[n]
  )) : c = /** @type {V} */
  o[n];
  var d = (C = Yi(o, n)) == null ? void 0 : C.set, u = (
    /** @type {V} */
    e
  ), h = !0, g = !1, f = () => (g = !0, h && (h = !1, a ? u = Jr(
    /** @type {() => V} */
    e
  ) : u = /** @type {V} */
  e), u);
  c === void 0 && e !== void 0 && (d && r && l0(), c = f(), d && d(c));
  var p;
  if (p = () => {
    var x = (
      /** @type {V} */
      o[n]
    );
    return x === void 0 ? f() : (h = !0, g = !1, x);
  }, !(t & $v))
    return p;
  if (d) {
    var b = o.$$legacy;
    return function(x, I) {
      return arguments.length > 0 ? ((!I || b || l) && d(I ? p() : x), x) : p();
    };
  }
  var k = !1, w = !1, _ = /* @__PURE__ */ Ud(c), y = X0(
    () => /* @__PURE__ */ Vp(() => {
      var x = p(), I = z(_);
      return k ? (k = !1, w = !0, I) : (w = !1, _.v = x);
    })
  );
  return i || (y.equals = Np), function(x, I) {
    if (arguments.length > 0) {
      const P = I ? z(y) : s ? $t(x) : x;
      return y.equals(P) || (k = !0, Xt(_, P), g && u !== void 0 && (u = P), Jr(() => z(y))), x;
    }
    return z(y);
  };
}
function t1(o) {
  return new e1(o);
}
var Zn, nn;
class e1 {
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(n) {
    /** @type {any} */
    yl(this, Zn);
    /** @type {Record<string, any>} */
    yl(this, nn);
    var r;
    var t = /* @__PURE__ */ new Map(), e = (s, a) => {
      var l = /* @__PURE__ */ Ud(a);
      return t.set(s, l), l;
    };
    const i = new Proxy(
      { ...n.props || {}, $$events: {} },
      {
        get(s, a) {
          return z(t.get(a) ?? e(a, Reflect.get(s, a)));
        },
        has(s, a) {
          return z(t.get(a) ?? e(a, Reflect.get(s, a))), Reflect.has(s, a);
        },
        set(s, a, l) {
          return Xt(t.get(a) ?? e(a, l), l), Reflect.set(s, a, l);
        }
      }
    );
    Cl(this, nn, (n.hydrate ? z0 : mb)(n.component, {
      target: n.target,
      anchor: n.anchor,
      props: i,
      context: n.context,
      intro: n.intro ?? !1,
      recover: n.recover
    })), (!((r = n == null ? void 0 : n.props) != null && r.$$host) || n.sync === !1) && rb(), Cl(this, Zn, i.$$events);
    for (const s of Object.keys(Be(this, nn)))
      s === "$set" || s === "$destroy" || s === "$on" || la(this, s, {
        get() {
          return Be(this, nn)[s];
        },
        /** @param {any} value */
        set(a) {
          Be(this, nn)[s] = a;
        },
        enumerable: !0
      });
    Be(this, nn).$set = /** @param {Record<string, any>} next */
    (s) => {
      Object.assign(i, s);
    }, Be(this, nn).$destroy = () => {
      O0(Be(this, nn));
    };
  }
  /** @param {Record<string, any>} props */
  $set(n) {
    Be(this, nn).$set(n);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(n, t) {
    Be(this, Zn)[n] = Be(this, Zn)[n] || [];
    const e = (...i) => t.call(this, ...i);
    return Be(this, Zn)[n].push(e), () => {
      Be(this, Zn)[n] = Be(this, Zn)[n].filter(
        /** @param {any} fn */
        (i) => i !== e
      );
    };
  }
  $destroy() {
    Be(this, nn).$destroy();
  }
}
Zn = new WeakMap(), nn = new WeakMap();
let _b;
typeof HTMLElement == "function" && (_b = class extends HTMLElement {
  /**
   * @param {*} $$componentCtor
   * @param {*} $$slots
   * @param {*} use_shadow_dom
   */
  constructor(n, t, e) {
    super();
    /** The Svelte component constructor */
    m(this, "$$ctor");
    /** Slots */
    m(this, "$$s");
    /** @type {any} The Svelte component instance */
    m(this, "$$c");
    /** Whether or not the custom element is connected */
    m(this, "$$cn", !1);
    /** @type {Record<string, any>} Component props data */
    m(this, "$$d", {});
    /** `true` if currently in the process of reflecting component props back to attributes */
    m(this, "$$r", !1);
    /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
    m(this, "$$p_d", {});
    /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
    m(this, "$$l", {});
    /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
    m(this, "$$l_u", /* @__PURE__ */ new Map());
    /** @type {any} The managed render effect for reflecting attributes */
    m(this, "$$me");
    this.$$ctor = n, this.$$s = t, e && this.attachShadow({ mode: "open" });
  }
  /**
   * @param {string} type
   * @param {EventListenerOrEventListenerObject} listener
   * @param {boolean | AddEventListenerOptions} [options]
   */
  addEventListener(n, t, e) {
    if (this.$$l[n] = this.$$l[n] || [], this.$$l[n].push(t), this.$$c) {
      const i = this.$$c.$on(n, t);
      this.$$l_u.set(t, i);
    }
    super.addEventListener(n, t, e);
  }
  /**
   * @param {string} type
   * @param {EventListenerOrEventListenerObject} listener
   * @param {boolean | AddEventListenerOptions} [options]
   */
  removeEventListener(n, t, e) {
    if (super.removeEventListener(n, t, e), this.$$c) {
      const i = this.$$l_u.get(t);
      i && (i(), this.$$l_u.delete(t));
    }
  }
  async connectedCallback() {
    if (this.$$cn = !0, !this.$$c) {
      let n = function(i) {
        return (r) => {
          const s = document.createElement("slot");
          i !== "default" && (s.name = i), U(r, s);
        };
      };
      if (await Promise.resolve(), !this.$$cn || this.$$c)
        return;
      const t = {}, e = n1(this);
      for (const i of this.$$s)
        i in e && (i === "default" && !this.$$d.children ? (this.$$d.children = n(i), t.default = !0) : t[i] = n(i));
      for (const i of this.attributes) {
        const r = this.$$g_p(i.name);
        r in this.$$d || (this.$$d[r] = ea(r, i.value, this.$$p_d, "toProp"));
      }
      for (const i in this.$$p_d)
        !(i in this.$$d) && this[i] !== void 0 && (this.$$d[i] = this[i], delete this[i]);
      this.$$c = t1({
        component: this.$$ctor,
        target: this.shadowRoot || this,
        props: {
          ...this.$$d,
          $$slots: t,
          $$host: this
        }
      }), this.$$me = Up(() => {
        qd(() => {
          var i;
          this.$$r = !0;
          for (const r of aa(this.$$c)) {
            if (!((i = this.$$p_d[r]) != null && i.reflect)) continue;
            this.$$d[r] = this.$$c[r];
            const s = ea(
              r,
              this.$$d[r],
              this.$$p_d,
              "toAttribute"
            );
            s == null ? this.removeAttribute(this.$$p_d[r].attribute || r) : this.setAttribute(this.$$p_d[r].attribute || r, s);
          }
          this.$$r = !1;
        });
      });
      for (const i in this.$$l)
        for (const r of this.$$l[i]) {
          const s = this.$$c.$on(i, r);
          this.$$l_u.set(r, s);
        }
      this.$$l = {};
    }
  }
  // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
  // and setting attributes through setAttribute etc, this is helpful
  /**
   * @param {string} attr
   * @param {string} _oldValue
   * @param {string} newValue
   */
  attributeChangedCallback(n, t, e) {
    var i;
    this.$$r || (n = this.$$g_p(n), this.$$d[n] = ea(n, e, this.$$p_d, "toProp"), (i = this.$$c) == null || i.$set({ [n]: this.$$d[n] }));
  }
  disconnectedCallback() {
    this.$$cn = !1, Promise.resolve().then(() => {
      !this.$$cn && this.$$c && (this.$$c.$destroy(), this.$$me(), this.$$c = void 0);
    });
  }
  /**
   * @param {string} attribute_name
   */
  $$g_p(n) {
    return aa(this.$$p_d).find(
      (t) => this.$$p_d[t].attribute === n || !this.$$p_d[t].attribute && t.toLowerCase() === n
    ) || n;
  }
});
function ea(o, n, t, e) {
  var r;
  const i = (r = t[o]) == null ? void 0 : r.type;
  if (n = i === "Boolean" && typeof n != "boolean" ? n != null : n, !e || !t[o])
    return n;
  if (e === "toAttribute")
    switch (i) {
      case "Object":
      case "Array":
        return n == null ? null : JSON.stringify(n);
      case "Boolean":
        return n ? "" : null;
      case "Number":
        return n ?? null;
      default:
        return n;
    }
  else
    switch (i) {
      case "Object":
      case "Array":
        return n && JSON.parse(n);
      case "Boolean":
        return n;
      case "Number":
        return n != null ? +n : n;
      default:
        return n;
    }
}
function n1(o) {
  const n = {};
  return o.childNodes.forEach((t) => {
    n[
      /** @type {Element} node */
      t.slot || "default"
    ] = !0;
  }), n;
}
function ae(o, n, t, e, i, r) {
  let s = class extends _b {
    constructor() {
      super(o, t, i), this.$$p_d = n;
    }
    static get observedAttributes() {
      return aa(n).map(
        (a) => (n[a].attribute || a).toLowerCase()
      );
    }
  };
  return aa(n).forEach((a) => {
    la(s.prototype, a, {
      get() {
        return this.$$c && a in this.$$c ? this.$$c[a] : this.$$d[a];
      },
      set(l) {
        var u;
        l = ea(a, l, n), this.$$d[a] = l;
        var c = this.$$c;
        if (c) {
          var d = (u = Yi(c, a)) == null ? void 0 : u.get;
          d ? c[a] = l : c.$set({ [a]: l });
        }
      }
    });
  }), e.forEach((a) => {
    la(s.prototype, a, {
      get() {
        var l;
        return (l = this.$$c) == null ? void 0 : l[a];
      }
    });
  }), o.element = /** @type {any} */
  s, s;
}
var i1 = /* @__PURE__ */ W('<button type="button"><!></button>');
const o1 = {
  hash: "svelte-1bto172",
  code: ".button.svelte-1bto172 {display:inline-block;cursor:pointer;border:0;margin-left:14px;border-radius:3em;font-weight:700;line-height:1;font-family:'Nunito Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;}.button--primary.svelte-1bto172 {background-color:#1ea7fd;color:white;}.button--secondary.svelte-1bto172 {box-shadow:rgba(0, 0, 0, 0.15) 0px 0px 0px 1px inset;background-color:transparent;color:#333;}.button--small.svelte-1bto172 {padding:10px 16px;font-size:12px;}.button--medium.svelte-1bto172 {padding:11px 20px;font-size:14px;}.button--large.svelte-1bto172 {padding:12px 24px;font-size:16px;}"
};
function r1(o, n) {
  fe(o, o1);
  const t = $(n, "type", 3, "primary"), e = $(n, "size", 3, "medium");
  $(n, "label", 3, "Button");
  const i = $(n, "onClick", 3, void 0);
  var r = i1();
  r.__click = function(...a) {
    var l;
    (l = i()) == null || l.apply(this, a);
  };
  var s = R(r);
  pb(s, n, "default", {}), D(r), mt(() => ta(r, `${"button button--" + e() + " button--" + t()} svelte-1bto172`)), U(o, r);
}
Vn(["click"]);
customElements.define("ing-button", ae(r1, { type: {}, size: {}, label: {}, onClick: {} }, ["default"], [], !0));
var s1 = /* @__PURE__ */ W('<div class="input_label svelte-1hyy719"> </div>'), a1 = /* @__PURE__ */ W('<span class="input_icon svelte-1hyy719"><img width="16px" alt="in"></span>'), l1 = (o, n) => {
  n(o);
}, c1 = /* @__PURE__ */ W('<div class="input_frame svelte-1hyy719"><!> <div class="input_box svelte-1hyy719"><!> <input class="input_field svelte-1hyy719"></div></div>');
const d1 = {
  hash: "svelte-1hyy719",
  code: `.input_frame.svelte-1hyy719 {padding-right:24px;margin-bottom:14px;}.input_label.svelte-1hyy719 {margin-bottom:6px;}.input_box.svelte-1hyy719 {display:flex;color:#4a5073;background-color:#fff;border:0.0625rem solid #d1d7e0;border-radius:0.5rem;
    /* padding-right: 14px; */}.input_icon.svelte-1hyy719 {width:32px;position:relative;top:12px;left:9px;}.input_field.svelte-1hyy719 {box-shadow:none;width:280px;border:0.0625rem solid #d1d7e0;color:#66799e;background-color:transparent;background-clip:padding-box;appearance:none;border:transparent;height:40px;font-size:16px;border-style:none;border-radius:0.5rem;margin-left:4px;margin-right:8px;width:98%;}.input_field.svelte-1hyy719:focus {outline:none;}`
};
function vb(o, n) {
  Ve(n, !0), fe(o, d1);
  let t = $(n, "label", 3, ""), e = $(n, "icon", 3, ""), i = $(n, "type", 3, "text"), r = $(n, "placeholder", 3, ""), s = $(n, "input", 15, ""), a = $(n, "style", 3, "");
  const l = (f) => {
    f && f.target && f.target.value && n.$$host && n.$$host.dispatchEvent(new CustomEvent("update", { detail: { input: f.target.value } }));
  };
  var c = c1(), d = R(c);
  me(d, t, (f) => {
    var p = s1(), b = R(p, !0);
    D(p), mt(() => Zt(b, t())), U(f, p);
  });
  var u = et(d, 2), h = R(u);
  me(h, e, (f) => {
    var p = a1(), b = R(p);
    D(p), mt(() => At(b, "src", e())), U(f, p);
  });
  var g = et(h, 2);
  el(g), g.__input = [l1, l], D(u), D(c), mt(() => {
    At(c, "style", a()), At(g, "type", i()), At(g, "placeholder", r());
  }), nl(g, s), U(o, c), Fe();
}
Vn(["input"]);
customElements.define("ing-input", ae(
  vb,
  {
    label: {},
    icon: {},
    type: {},
    placeholder: {},
    input: {},
    style: {}
  },
  [],
  [],
  !0
));
var u1 = /* @__PURE__ */ W('<span class="user_button svelte-gns4bd"><img class="msg_icon svelte-gns4bd" alt="alerts" src="bell.svg"> <span class="msg_new svelte-gns4bd"></span> <img class="user_icon svelte-gns4bd" alt="profile"> <span class="user_name svelte-gns4bd"> </span></span>'), h1 = /* @__PURE__ */ W("<span></span>"), m1 = /* @__PURE__ */ W('<div class="header svelte-gns4bd"><div style="width: 364px;"><!> <span></span></div> <div><!></div></div>');
const g1 = {
  hash: "svelte-gns4bd",
  code: ".header.svelte-gns4bd {display:flex;justify-content:space-between;align-items:center;padding:26px 20px;font-family:'Nunito Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;}.msg_icon.svelte-gns4bd {width:20px;margin-right:22px;}.msg_new.svelte-gns4bd {background-color:red;height:7px;width:7px;border-radius:50% !important;position:relative;top:4px;left:-22px;}.user_button.svelte-gns4bd {display:flex;position:relative;top:-6px;}.user_button.svelte-gns4bd:hover {cursor:pointer;}.user_name.svelte-gns4bd {padding-top:12px;padding-left:8px;}.user_icon.svelte-gns4bd {border-radius:50% !important;width:40px;}"
};
function yb(o, n) {
  fe(o, g1), $(n, "title", 3, "Apint.org");
  const t = $(n, "searchicon", 3, ""), e = $(n, "supportuser", 3, !1), i = $(n, "username", 3, ""), r = $(n, "userpic", 3, "");
  let s = "";
  var a = m1(), l = R(a), c = R(l);
  vb(c, {
    get icon() {
      return t();
    },
    placeholder: "Search",
    input: s
  });
  var d = et(c, 2);
  d.textContent = s, D(l);
  var u = et(l, 2), h = R(u);
  me(
    h,
    e,
    (g) => {
      var f = u1(), p = et(R(f), 4), b = et(p, 2), k = R(b, !0);
      D(b), D(f), mt(() => {
        At(p, "src", r()), Zt(k, i());
      }), U(g, f);
    },
    (g) => {
      var f = hb(), p = sr(f);
      me(
        p,
        e,
        (b) => {
          var k = h1();
          U(b, k);
        },
        null,
        !0
      ), U(g, f);
    }
  ), D(u), D(a), U(o, a);
}
customElements.define("ing-headerlite", ae(
  yb,
  {
    title: {},
    searchicon: {},
    supportuser: {},
    username: {},
    userpic: {}
  },
  [],
  [],
  !0
));
function f1(o) {
  const n = o - 1;
  return n * n * n + 1;
}
function p1(o, { delay: n = 0, duration: t = 400, easing: e = f1, axis: i = "y" } = {}) {
  const r = getComputedStyle(o), s = +r.opacity, a = i === "y" ? "height" : "width", l = parseFloat(r[a]), c = i === "y" ? ["top", "bottom"] : ["left", "right"], d = c.map(
    (k) => (
      /** @type {'Left' | 'Right' | 'Top' | 'Bottom'} */
      `${k[0].toUpperCase()}${k.slice(1)}`
    )
  ), u = parseFloat(r[`padding${d[0]}`]), h = parseFloat(r[`padding${d[1]}`]), g = parseFloat(r[`margin${d[0]}`]), f = parseFloat(r[`margin${d[1]}`]), p = parseFloat(
    r[`border${d[0]}Width`]
  ), b = parseFloat(
    r[`border${d[1]}Width`]
  );
  return {
    delay: n,
    duration: t,
    easing: e,
    css: (k) => `overflow: hidden;opacity: ${Math.min(k * 20, 1) * s};${a}: ${k * l}px;padding-${c[0]}: ${k * u}px;padding-${c[1]}: ${k * h}px;margin-${c[0]}: ${k * g}px;margin-${c[1]}: ${k * f}px;border-${c[0]}-width: ${k * p}px;border-${c[1]}-width: ${k * b}px;`
  };
}
function b1(o) {
  return o;
}
var k1 = (o, n, t) => n(z(t).title), w1 = /* @__PURE__ */ W('<img alt="option" width="18px">'), _1 = /* @__PURE__ */ W('<svg width="18px" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="chart-pie" class="svg-inline--fa fa-chart-pie fa-w-17 " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 544 512"><path fill="currentColor" d="M527.79 288H290.5l158.03 158.03c6.04 6.04 15.98 6.53 22.19.68 38.7-36.46 65.32-85.61 73.13-140.86 1.34-9.46-6.51-17.85-16.06-17.85zm-15.83-64.8C503.72 103.74 408.26 8.28 288.8.04 279.68-.59 272 7.1 272 16.24V240h223.77c9.14 0 16.82-7.68 16.19-16.8zM224 288V50.71c0-9.55-8.39-17.4-17.84-16.06C86.99 51.49-4.1 155.6.14 280.37 4.5 408.51 114.83 513.59 243.03 511.98c50.4-.63 96.97-16.87 135.26-44.03 7.9-5.6 8.42-17.23 1.57-24.08L224 288z"></path></svg>'), v1 = /* @__PURE__ */ W('<span><svg class="icon icon-sm" fill="#fff" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg></span>'), y1 = (o, n, t) => n(z(t).title), C1 = /* @__PURE__ */ W('<a><span><span class="menu_item_icon svelte-v1mgvt"></span> <span class="menu_item_text"> </span></span></a>'), A1 = /* @__PURE__ */ W('<div class="menu_item_frame svelte-v1mgvt"></div>'), x1 = /* @__PURE__ */ W('<a><span><span class="menu_item_icon svelte-v1mgvt"><!></span> <span class="menu_item_text"> </span> <!></span></a> <!>', 1), E1 = /* @__PURE__ */ W('<div class="outer_frame svelte-v1mgvt"><div class="left_menu svelte-v1mgvt"><div class="menu_frame svelte-v1mgvt"></div></div> <div class="right_panel svelte-v1mgvt"><!> <div class="right_panel_content svelte-v1mgvt"><!></div></div></div>');
const T1 = {
  hash: "svelte-v1mgvt",
  code: `a.svelte-v1mgvt:link {text-decoration:none;}a.svelte-v1mgvt:visited {text-decoration:none;color:#eaedf2;}a.svelte-v1mgvt:hover {text-decoration:none;color:#eaedf2;}a.svelte-v1mgvt:active {text-decoration:none;}.outer_frame.svelte-v1mgvt {position:fixed;left:0px;top:0px;display:flex;height:100vh;width:100vw;font-family:"Nunito Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;}.left_menu.svelte-v1mgvt {display:flex;flex-flow:row nowrap;width:260px !important;min-width:260px;height:100%;background-color:#262b40 !important;color:#eaedf2;}.menu_frame.svelte-v1mgvt {margin:20px 30px 20px 30px;width:100%;}.menu_item.svelte-v1mgvt {display:block;width:100%;text-align:left;padding:10px 0px;color:#eaedf2;border-radius:.5rem;margin-bottom:8px;border:.0625rem solid transparent;}.menu_item.svelte-v1mgvt:hover {background-color:#2e3650;}.menu_item_active.svelte-v1mgvt {background-color:#2e3650;border:.0625rem solid #4c5680;}.menu_item_icon.svelte-v1mgvt {display:inline-block;margin-left:12px;margin-right:.5rem;color:#fff;position:relative;top:3px;width:18px;}.menu_item_expand.svelte-v1mgvt {float:right;width:22px;}.expanded.svelte-v1mgvt {position:relative;
    /* left: -4px; */
    /* top: -2px; */transform:rotate(90deg) translateX(-2px) translateY(4px);transition:all 0.2s ease;}.menu_item_frame.svelte-v1mgvt {width:100%;}.right_panel.svelte-v1mgvt {color:#4a5073;background-color:#f5f8fb;flex:auto;height:100%;overflow-y:auto;}.right_panel_content.svelte-v1mgvt {padding:0px 20px;}`
};
function S1(o, n) {
  Ve(n, !0), fe(o, T1), $(n, "title", 3, "Mapp"), $(n, "icon", 3, "");
  let t = $(n, "searchicon", 3, ""), e = $(n, "supportuser", 3, !0), i = $(n, "username", 3, ""), r = $(n, "userpic", 3, ""), s = $(n, "activeitem", 3, ""), a = $(n, "menuconfig", 7, void 0);
  typeof a() == "string" && a(JSON.parse(a()));
  let l = $t({}), c = (k) => {
    l[k] ? l[k] = !l[k] : l[k] = !0;
  };
  var d = E1(), u = R(d), h = R(u);
  ke(h, 21, () => a().items, be, (k, w) => {
    var _ = x1(), y = sr(_);
    y.__click = [k1, c, w];
    var C = R(y), x = R(C), I = R(x);
    me(
      I,
      () => z(w).icon,
      (ct) => {
        var ee = w1();
        mt(() => At(ee, "src", z(w).icon)), U(ct, ee);
      },
      (ct) => {
        var ee = _1();
        U(ct, ee);
      }
    ), D(x);
    var P = et(x, 2), Y = R(P, !0);
    D(P);
    var it = et(P, 2);
    me(it, () => z(w).subitems, (ct) => {
      var ee = v1();
      mt(() => ta(ee, `${(l[z(w).title] ? "menu_item_expand expanded" : "menu_item_expand") ?? ""} svelte-v1mgvt`)), U(ct, ee);
    }), D(C), D(y);
    var te = et(y, 2);
    me(te, () => l[z(w).title] && z(w).subitems, (ct) => {
      var ee = A1();
      ke(ee, 21, () => z(w).subitems, be, (ie, Le) => {
        var Cn = C1();
        Cn.__click = [y1, c, Le];
        var Qt = R(Cn), ui = et(R(Qt), 2), bo = R(ui, !0);
        D(ui), D(Qt), D(Cn), mt(() => {
          At(Cn, "href", z(Le).url), ta(Cn, `${(z(Le).title == s() ? "menu_item menu_item_active" : "menu_item") ?? ""} svelte-v1mgvt`), Zt(bo, z(Le).title);
        }), U(ie, Cn);
      }), D(ee), G0(3, ee, () => p1, () => ({ duration: 300, easing: b1 })), U(ct, ee);
    }), mt(() => {
      At(y, "href", z(w).url), ta(y, `${(z(w).title == s() ? "menu_item menu_item_active" : "menu_item") ?? ""} svelte-v1mgvt`), Zt(Y, z(w).title);
    }), U(k, _);
  }), D(h), D(u);
  var g = et(u, 2), f = R(g);
  yb(f, {
    get searchicon() {
      return t();
    },
    get supportuser() {
      return e();
    },
    get username() {
      return i();
    },
    get userpic() {
      return r();
    }
  });
  var p = et(f, 2), b = R(p);
  pb(b, n, "default", {}), D(p), D(g), D(d), U(o, d), Fe();
}
Vn(["click"]);
customElements.define("ing-buffet", ae(
  S1,
  {
    title: {},
    icon: {},
    searchicon: {},
    supportuser: {},
    username: {},
    userpic: {},
    activeitem: {},
    menuconfig: {}
  },
  ["default"],
  [],
  !0
));
function I1(o, n, t, e, i, r) {
  if (z(n)) {
    let s = [];
    for (let a of t()) {
      let l = !1;
      for (let c of e())
        if ((i().length === 0 || i().includes(c)) && a[c].toString().toLowerCase().includes(z(n).toLowerCase())) {
          l = !0;
          break;
        }
      l && s.push(a);
    }
    Xt(r, $t(s));
  } else
    Xt(r, $t(t()));
}
var M1 = /* @__PURE__ */ W('<th class="svelte-15ql2st"> </th>'), D1 = /* @__PURE__ */ W('<td class="svelte-15ql2st"><a class="table_row svelte-15ql2st"> </a></td>'), P1 = /* @__PURE__ */ W('<tr class="svelte-15ql2st"></tr>'), L1 = /* @__PURE__ */ W('<div class="card_frame svelte-15ql2st"><div class="filter svelte-15ql2st"><svg data-icon-name="filterIcon" viewBox="0 0 18 18" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M2 4h14v2H2V4zm2 4h10v2H4V8zm2 4h6v2H6v-2z"></path></svg> <span class="filter_input_box svelte-15ql2st">Filter <input class="filter_input svelte-15ql2st" placeholder="Value to filter for"></span></div> <table class="svelte-15ql2st"><thead class="svelte-15ql2st"><tr class="svelte-15ql2st"></tr></thead><tbody class="svelte-15ql2st"></tbody></table></div>');
const B1 = {
  hash: "svelte-15ql2st",
  code: `.card_frame.svelte-15ql2st {border-color:#eaedf2 !important;box-shadow:0 2px 18px rgba(0, 0, 0, 0.02) !important;min-width:0;word-wrap:break-word;background-color:#fff;background-clip:border-box;border:0.0625rem solid rgba(46, 54, 80, 0.125);border-radius:0.5rem;padding:22px 32px;font-family:"Nunito Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;}table.svelte-15ql2st {width:100%;margin-bottom:1rem;color:#4a5073;vertical-align:top;border-color:#eaedf2;font-family:"Nunito Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;border-collapse:collapse;}table.svelte-15ql2st thead:where(.svelte-15ql2st) tr:where(.svelte-15ql2st) th:where(.svelte-15ql2st) {vertical-align:center;text-align:left;border-bottom:1px solid #eaedf2 !important;font-size:12px;font-weight:bold;padding-left:14px;padding-bottom:10px;}.table_row.svelte-15ql2st {padding-left:14px;padding-top:14px;padding-bottom:14px;border-bottom:1px solid #eaedf2 !important;}table.svelte-15ql2st tbody:where(.svelte-15ql2st) tr:where(.svelte-15ql2st):hover {background-color:#eff0f2;cursor:pointer;border-radius:0.5rem;}a.svelte-15ql2st:link {text-decoration:none;color:#4a5073;}a.svelte-15ql2st:visited {text-decoration:none;color:#4a5073;}a.svelte-15ql2st:hover {text-decoration:none;color:#4a5073;}a.svelte-15ql2st:active {text-decoration:none;}td.svelte-15ql2st a:where(.svelte-15ql2st) {display:block;}.filter.svelte-15ql2st {margin-top:20px;margin-bottom:8px;margin-left:8px;}.filter_input_box.svelte-15ql2st {position:relative;top:-3px;font-weight:bold;font-size:14px;}.filter_input.svelte-15ql2st {width:50%;margin-left:8px;font-family:Google Sans,
      Roboto,
      Helvetica,
      Arial,
      sans-serif;padding:var(--padding);
    /* border: 2px solid gray; */border:0px;outline:none;border-radius:0px;
    /* background-color: #f1f3f4; */background-color:rgb(255, 255, 255);}`
};
function N1(o, n) {
  Ve(n, !0), fe(o, B1);
  let t = $(n, "headers", 23, () => []), e = $(n, "headerssearchable", 23, () => []), i = $(n, "rows", 23, () => []), r = $(n, "linkprefix", 3, ""), s = $(n, "linkcolumnname", 3, ""), a = $(n, "update", 3, void 0);
  typeof t() == "string" && t(JSON.parse(t())), typeof e() == "string" && e(JSON.parse(e())), typeof i() == "string" && i(JSON.parse(i()));
  let l = Zi($t(i())), c = Zi("");
  const d = (_) => {
    n.$$host.dispatchEvent(new CustomEvent("update", { detail: { rowIndex: _ } })), a() && a()({ detail: { rowIndex: _ } });
  };
  var u = L1(), h = R(u), g = et(R(h), 2), f = et(R(g));
  el(f), f.__keyup = [
    I1,
    c,
    i,
    t,
    e,
    l
  ], D(g), D(h);
  var p = et(h, 2), b = R(p), k = R(b);
  ke(k, 21, t, be, (_, y) => {
    var C = M1(), x = R(C, !0);
    D(C), mt(() => Zt(x, z(y))), U(_, C);
  }), D(k), D(b);
  var w = et(b);
  ke(w, 21, () => z(l), be, (_, y, C) => {
    var x = P1();
    x.__click = () => {
      d(C);
    }, ke(x, 21, () => Object.entries(z(y)), be, (P, Y) => {
      var it = D1(), te = R(it), ct = R(te, !0);
      D(te), D(it), mt(() => {
        At(te, "href", r() + z(y)[s()]), Zt(ct, z(Y)[1]);
      }), U(P, it);
    }), D(x), U(_, x);
  }), D(w), D(p), D(u), nl(f, () => z(c), (_) => Xt(c, _)), U(o, u), Fe();
}
Vn(["keyup", "click"]);
customElements.define("ing-table", ae(
  N1,
  {
    headers: {},
    headerssearchable: {},
    rows: {},
    linkprefix: {},
    linkcolumnname: {},
    update: {}
  },
  [],
  [],
  !0
));
var z1 = /* @__PURE__ */ W('<div class="menu_item svelte-15kv3ld"><a href="https://google.com" target="_blank"> </a></div>'), O1 = /* @__PURE__ */ W('<div class="menu_frame svelte-15kv3ld"><div class="arrow svelte-15kv3ld"></div> <div class="menu svelte-15kv3ld"></div></div>');
const R1 = {
  hash: "svelte-15kv3ld",
  code: '.menu_frame.svelte-15kv3ld {position:fixed;top:"57px";left:calc(100vw-24);min-width:200px;min-height:200px;max-width:180px;background:#fff;box-shadow:#00000026 0 2px 10px;border:1px solid rgb(242, 242, 242);z-index:6;}.arrow.svelte-15kv3ld {position:relative;top:-31px;left:163px;border:1px solid rgb(242, 242, 242);box-shadow:#00000026 -1px -1px 1px -1px;transform:rotate(45deg) translate(16px, 16px);background:#fff;height:14px;width:14px;display:block;content:"";pointer-events:none;z-index:1;}.menu.svelte-15kv3ld {position:relative;top:-16px;background:#fff;min-height:140px;z-index:2;padding:14px;}.menu_item.svelte-15kv3ld {height:14px;width:100%;font-size:18px;padding-bottom:12px;}'
};
function Cb(o, n) {
  Ve(n, !0), fe(o, R1);
  let t = $(n, "position", 19, () => ({})), e = $(n, "menuItems", 19, () => []);
  var i = O1(), r = et(R(i), 2);
  ke(r, 21, e, be, (s, a) => {
    var l = z1(), c = R(l), d = R(c, !0);
    D(c), D(l), mt(() => Zt(d, z(a).title)), U(s, l);
  }), D(r), D(i), mt(() => At(i, "style", `top: ${t().top}; left: ${t().left};`)), U(o, i), Fe();
}
customElements.define("mv-elegant-dropdown", ae(Cb, { position: {}, menuItems: {} }, [], [], !0));
var V1 = /* @__PURE__ */ W('<img class="title_logo" alt="logo" width="36px" height="34px" style="padding: 6px; margin-top: 4px;">'), F1 = /* @__PURE__ */ W('<span class="title_text svelte-zwv9rr"> </span>'), j1 = /* @__PURE__ */ W('<a href="https://google.com" target="_blank" class="title svelte-zwv9rr"><!> <!></a>'), H1 = (o, n, t) => n(o, z(t).title), U1 = /* @__PURE__ */ W('<button class="menu_button svelte-zwv9rr"><img class="menu_icon svelte-zwv9rr"></button> <!>', 1), $1 = /* @__PURE__ */ W('<div class="header svelte-zwv9rr"><!> <div class="right_menus svelte-zwv9rr"></div></div>');
const q1 = {
  hash: "svelte-zwv9rr",
  code: ".header.svelte-zwv9rr {display:flex;flex-flow:row wrap;justify-content:space-between;align-items:flex-start;background-color:rgba(255, 255, 255, 1);height:57px;font-weight:560;color:#333;font-size:20px;padding:0px;margin:0px;position:sticky;top:0;z-index:2;border-bottom:solid 1px rgba(222, 222, 222, 1);}.title.svelte-zwv9rr {height:100%;display:flex;margin-left:12px;color:#111;font-family:'Nunito Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;}.title.svelte-zwv9rr:link {text-decoration:none;}.title.svelte-zwv9rr:visited {text-decoration:none;color:#222;}.title.svelte-zwv9rr:hover {text-decoration:none;color:darkgray}.title.svelte-zwv9rr:active {text-decoration:none;}.title_text.svelte-zwv9rr {display:flex;align-items:center;}.right_menus.svelte-zwv9rr {display:flex;height:100%;flex:auto;flex-flow:row-reverse;}.menu_button.svelte-zwv9rr {height:100%;display:flex;align-items:center;margin-right:18px;cursor:pointer;border:0px;background-color:transparent;}.menu_icon.svelte-zwv9rr {height:30px;width:30px;object-fit:cover;}.menu_icon.svelte-zwv9rr:hover {cursor:pointer;}.round.svelte-zwv9rr {height:40px;width:40px;border-radius:50%;}"
};
function Ab(o, n) {
  Ve(n, !0), fe(o, q1);
  let t = $(n, "title", 3, ""), e = $(n, "titleImageUrl", 3, ""), i = $(n, "headerMenus", 23, () => []);
  typeof i() == "string" && i(JSON.parse(i()));
  let r = $t({}), s = $t({});
  function a(g, f) {
    g && g.stopPropagation();
    for (const p of Object.keys(r))
      p != f && (r[p] = !1);
    r[f] ? r[f] = !1 : r[f] = !0;
  }
  function l(g) {
    let f = {}, p;
    if (s[g] && (p = s[g]), p) {
      var b = p.getBoundingClientRect();
      f.top = (b.top + b.height + 12).toString() + "px", f.left = (b.left - 150).toString() + "px", console.log(f);
    } else
      console.log("Could not find element with id: " + g);
    return f;
  }
  function c(g) {
    return g.toLowerCase().replaceAll(" ", "_");
  }
  document.onclick = function() {
    for (const f of Object.keys(r))
      r[f] = !1;
  };
  var d = $1(), u = R(d);
  me(u, () => t() || e(), (g) => {
    var f = j1(), p = R(f);
    me(p, e, (k) => {
      var w = V1();
      mt(() => At(w, "src", e())), U(k, w);
    });
    var b = et(p, 2);
    me(b, t, (k) => {
      var w = F1(), _ = R(w, !0);
      D(w), mt(() => Zt(_, t())), U(k, w);
    }), D(f), U(g, f);
  });
  var h = et(u, 2);
  ke(h, 21, i, be, (g, f) => {
    var p = U1(), b = sr(p);
    mt(() => At(b, "id", c(z(f).title + "_button"))), b.__click = [H1, a, f];
    var k = R(b);
    Q0(k, (_, y) => s[c(y.title + "_button")] = _, (_) => s == null ? void 0 : s[c(_.title + "_button")], () => [z(f)]), D(b);
    var w = et(b, 2);
    me(w, () => r[z(f).title], (_) => {
      var y = /* @__PURE__ */ Vp(() => l(c(z(f).title + "_button")));
      Cb(_, {
        get menuItems() {
          return z(f).items;
        },
        get position() {
          return z(y);
        }
      });
    }), mt(() => {
      At(k, "alt", z(f).title), At(k, "src", z(f).imageUrl), Wo(k, "round", z(f).imageShape === "round");
    }), U(g, p);
  }), D(h), D(d), U(o, d), Fe();
}
Vn(["click"]);
customElements.define("mv-elegant-header", ae(
  Ab,
  {
    title: {},
    titleImageUrl: {},
    headerMenus: {}
  },
  [],
  [],
  !0
));
function W1(o, n, t, e) {
  n.searchloadresults && Xt(t, $t(n.searchloadresults(e())));
}
function G1(o, n, t, e) {
  o.key === "Escape" ? Xt(n, $t([])) : o.key === "Enter" && (t.searchsubmit && t.searchsubmit(e()), document.dispatchEvent(new CustomEvent("SearchSubmit", { detail: { text: e() } })), e(""));
}
var K1 = /* @__PURE__ */ W('<div class="result svelte-ihhy65"> </div>'), Y1 = /* @__PURE__ */ W('<div class="results svelte-ihhy65"><div class="results_frame svelte-ihhy65"><div class="results_list svelte-ihhy65"></div></div></div>'), Z1 = /* @__PURE__ */ W('<div class="input_frame svelte-ihhy65"><div class="search_frame svelte-ihhy65"><div class="search_icon svelte-ihhy65"><svg width="18px" focusable="false" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#9aa0a6" d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path></svg></div> <input class="search_input svelte-ihhy65"></div></div> <!>', 1);
const Q1 = {
  hash: "svelte-ihhy65",
  code: `.input_frame.svelte-ihhy65 {min-height:44px;background:#fff;border:1px solid #dfe1e5;box-shadow:0px 2px 8px 0px rgba(60, 64, 67, 0.25);border-radius:24px;margin:0 auto;max-width:584px;}.search_frame.svelte-ihhy65 {display:flex;flex-flow:row wrap;width:100%;flex:1;padding:0 8px 0 0;}.search_icon.svelte-ihhy65 {display:flex;align-items:center;padding-right:13px;padding-left:14px;height:46px;color:#9aa0a6;z-index:11;}.search_input.svelte-ihhy65 {display:flex;flex-wrap:wrap;flex:1;border:none;border-radius:24px;font-size:18px;width:100%;z-index:11;background-color:transparent;}.search_input.svelte-ihhy65:focus,
  .search_input.svelte-ihhy65:focus {outline:none;}.results.svelte-ihhy65 {position:absolute;margin:0px 0px 0px 0px;width:398px;border:1px solid #dfe1e5;z-index:10;background:#fff;border-radius:0px 0px 24px 24px;}.results_list.svelte-ihhy65 {margin-top:10px;background:#fff;width:100%;z-index:10;}.results_frame.svelte-ihhy65 {position:relative;top:-22px;background:#fff;border-left:1px solid #dfe1e5;border-right:1px solid #dfe1e5;width:398px;left:-1px;z-index:10;height:300px;overflow-x:hidden;}.result.svelte-ihhy65 {width:100%;padding:4px 0px 4px 16px;}.result.svelte-ihhy65:hover {cursor:pointer;background-color:#dfe1e5;}`
};
function xb(o, n) {
  Ve(n, !0), fe(o, Q1);
  let t = $(n, "searchtext", 15), e = Zi($t([]));
  document.addEventListener("SearchResults", (c) => {
    c.detail.results && Xt(e, $t(c.detail.results));
  });
  var i = Z1(), r = sr(i), s = R(r), a = et(R(s), 2);
  el(a), a.__input = [W1, n, e, t], a.__keyup = [G1, e, n, t], D(s), D(r);
  var l = et(r, 2);
  me(l, () => z(e).length > 0, (c) => {
    var d = Y1(), u = R(d), h = R(u);
    ke(h, 21, () => z(e), be, (g, f) => {
      var p = K1(), b = R(p, !0);
      D(p), mt(() => Zt(b, z(f))), U(g, p);
    }), D(h), D(u), D(d), U(c, d);
  }), nl(a, t), U(o, i), Fe();
}
Vn(["input", "keyup"]);
customElements.define("mv-elegant-search", ae(
  xb,
  {
    searchtext: {},
    searchloadresults: {},
    searchsubmit: {}
  },
  [],
  [],
  !0
));
var J1 = /* @__PURE__ */ W('<img class="hero_image svelte-pm9u4t" alt="logo">'), X1 = /* @__PURE__ */ W('<div class="hero svelte-pm9u4t"><div class="hero_logo svelte-pm9u4t"><!> <div class="hero_logo_text svelte-pm9u4t"> </div></div> <div class="hero_search svelte-pm9u4t"><!></div></div>');
const ty = {
  hash: "svelte-pm9u4t",
  code: '.hero.svelte-pm9u4t {width:100%;display:flex;justify-content:center;flex-flow:row wrap;}.hero_logo.svelte-pm9u4t {display:flex;margin-top:150px;width:100%;justify-content:center;align-items:center;font-family:"Nunito Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-weight:560;color:#333;font-size:20px;}.hero_image.svelte-pm9u4t {width:50px;height:50px;}.hero_logo_text.svelte-pm9u4t {padding-left:12px;}.hero_search.svelte-pm9u4t {width:400px;}'
};
function Eb(o, n) {
  fe(o, ty);
  let t = $(n, "height", 3, "80px"), e = $(n, "title", 3, ""), i = $(n, "titleImageUrl", 3, ""), r = $(n, "searchtext", 15);
  var s = X1(), a = R(s), l = R(a);
  me(l, i, (g) => {
    var f = J1();
    mt(() => {
      At(f, "height", `${t()}`), At(f, "src", i());
    }), U(g, f);
  });
  var c = et(l, 2), d = R(c, !0);
  D(c), D(a);
  var u = et(a, 2), h = R(u);
  xb(h, {
    get searchtext() {
      return r();
    },
    set searchtext(g) {
      r(g);
    },
    get searchloadresults() {
      return n.searchloadresults;
    },
    get searchsubmit() {
      return n.searchsubmit;
    }
  }), D(u), D(s), mt(() => {
    At(a, "style", `height: ${t()};`), Zt(d, e());
  }), U(o, s);
}
customElements.define("mv-elegant-hero-search", ae(
  Eb,
  {
    text: { reflect: !0 },
    height: {},
    title: {},
    titleImageUrl: {},
    searchtext: {},
    searchloadresults: {},
    searchsubmit: {}
  },
  [],
  [],
  !0
));
function ey(o, n, t) {
  o.srcElement && n(o.srcElement.value), t.onInput && t.onInput(n());
}
var ny = /* @__PURE__ */ W('<option class="svelte-1im86kb"> </option>'), iy = /* @__PURE__ */ W('<div class="select svelte-1im86kb"><select name="source" id="source" class="svelte-1im86kb"></select></div>');
const oy = {
  hash: "svelte-1im86kb",
  code: `.select.svelte-1im86kb,
.select.svelte-1im86kb :where(.svelte-1im86kb) {margin:0;padding:0;position:relative;box-sizing:border-box;}.select.svelte-1im86kb {position:relative;background-color:#f0f0f0;border-radius:12px;width:200px;height:40px;}.select.svelte-1im86kb select:where(.svelte-1im86kb) {font-size:1rem;font-weight:normal;width:100%;padding:10px 24px 8px 10px;border:none;background-color:transparent;appearance:none;}.select.svelte-1im86kb select:where(.svelte-1im86kb):active, .select.svelte-1im86kb select:where(.svelte-1im86kb):focus {outline:none;box-shadow:none;}.select.svelte-1im86kb:after {content:"";position:absolute;top:50%;right:8px;width:0;height:0;margin-top:-2px;border-top:5px solid #aaa;border-right:5px solid transparent;border-left:5px solid transparent;}`
};
function Tb(o, n) {
  Ve(n, !0), fe(o, oy);
  let t = $(n, "input", 15), e = $(n, "options", 19, () => []);
  var i = iy(), r = R(i);
  r.__input = [ey, t, n], ke(r, 21, e, be, (s, a) => {
    var l = ny(), c = {}, d = R(l, !0);
    D(l), mt(() => {
      c !== (c = z(a)) && (l.value = (l.__value = z(a)) == null ? "" : z(a)), Zt(d, z(a));
    }), U(s, l);
  }), D(r), D(i), Y0(r, t), U(o, i), Fe();
}
Vn(["input"]);
customElements.define("mv-elegant-select", ae(Tb, { input: {}, onInput: {}, options: {} }, [], [], !0));
function ry(o, n, t) {
  n() === "CARD" ? n("TABLE") : n("CARD"), t.viewselect && t.viewselect(n());
}
var sy = (o, n, t) => n(z(t).name), ay = /* @__PURE__ */ W('<div class="icon svelte-lvweti"></div>'), ly = /* @__PURE__ */ W('<div class="icon svelte-lvweti"> </div>'), cy = /* @__PURE__ */ W('<div class="filterbar_option svelte-lvweti"><!> <div class="name svelte-lvweti"> </div></div>'), dy = /* @__PURE__ */ W('<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"><path d="M3 9.5H21M3 14.5H21M8 4.5V19.5M6.2 19.5H17.8C18.9201 19.5 19.4802 19.5 19.908 19.282C20.2843 19.0903 20.5903 18.7843 20.782 18.408C21 17.9802 21 17.4201 21 16.3V7.7C21 6.5799 21 6.01984 20.782 5.59202C20.5903 5.21569 20.2843 4.90973 19.908 4.71799C19.4802 4.5 18.9201 4.5 17.8 4.5H6.2C5.0799 4.5 4.51984 4.5 4.09202 4.71799C3.71569 4.90973 3.40973 5.21569 3.21799 5.59202C3 6.01984 3 6.57989 3 7.7V16.3C3 17.4201 3 17.9802 3.21799 18.408C3.40973 18.7843 3.71569 19.0903 4.09202 19.282C4.51984 19.5 5.07989 19.5 6.2 19.5Z" stroke="#d8d8d8" stroke-width="2"></path></g></svg>'), uy = /* @__PURE__ */ W('<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="#d8d8d8"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"><title></title><g id="Complete"><g id="grid"><g><rect fill="none" height="7" stroke="#d8d8d8" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="7" x="14.5" y="2.5"></rect><rect fill="none" height="7" stroke="#d8d8d8" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="7" x="14.5" y="14.5"></rect><rect fill="none" height="7" stroke="#d8d8d8" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="7" x="2.5" y="2.5"></rect><rect fill="none" height="7" stroke="#d8d8d8" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="7" x="2.5" y="14.5"></rect></g></g></g></g></svg>'), hy = /* @__PURE__ */ W('<div class="filterbar_frame svelte-lvweti"><div class="options svelte-lvweti"></div> <div class="filter svelte-lvweti"><button class="view_toggle svelte-lvweti"><!></button> <!></div></div>');
const my = {
  hash: "svelte-lvweti",
  code: `.filterbar_frame.svelte-lvweti {display:flex;max-width:2000px;
    /* margin: 20px 10px 0px 16px; */margin:20px auto 0px auto;}.options.svelte-lvweti {display:flex;justify-content:left;width:100%;margin-left:16px;}.filter.svelte-lvweti {display:flex;margin-right:16px;}.filterbar_option.svelte-lvweti {display:flex;min-width:20px;height:40px;font-size:14px;font-weight:700;color:rgb(51, 103, 214);margin-right:6px;margin-bottom:4px;height:20px;padding:4px 8px 6px;border-radius:44px;border-width:1px;border-style:solid;border-color:lightgray;user-select:none;}.filterbar_option_selected.svelte-lvweti {background-color:rgb(209, 227, 255);}.filterbar_option.svelte-lvweti:hover {cursor:pointer;background-color:rgb(209, 227, 255);}.icon.svelte-lvweti {color:rgb(51, 103, 214);font-size:16px;font-weight:700;display:inline-block;width:18px;margin-right:6px;}.name.svelte-lvweti {float:right;margin-top:2px;font-size:14px;font-weight:700;color:rgb(51, 103, 214);}.view_toggle.svelte-lvweti {margin-right:12px;width:44px;border:0px;background-color:transparent;}.view_toggle.svelte-lvweti:hover {cursor:pointer;}`
};
function Sb(o, n) {
  Ve(n, !0), fe(o, my);
  let t = $(n, "view", 15, "card"), e = $t({});
  function i(h) {
    e[h] ? e[h] = !1 : e[h] = !0, n.typeselect && n.typeselect(e);
  }
  function r(h) {
    n.sortselect && n.sortselect(h);
  }
  var s = hy(), a = R(s);
  ke(a, 21, () => n.types, be, (h, g) => {
    var f = cy();
    f.__click = [sy, i, g];
    var p = R(f);
    me(
      p,
      () => e[z(g).name] === !0,
      (w) => {
        var _ = ay();
        U(w, _);
      },
      (w) => {
        var _ = ly(), y = R(_, !0);
        D(_), mt(() => Zt(y, z(g).icon)), U(w, _);
      }
    );
    var b = et(p, 2), k = R(b, !0);
    D(b), D(f), mt(() => {
      Wo(f, "filterbar_option_selected", e[z(g).name]), Zt(k, z(g).name);
    }), U(h, f);
  }), D(a);
  var l = et(a, 2), c = R(l);
  c.__click = [ry, t, n];
  var d = R(c);
  me(
    d,
    () => t() === "CARD",
    (h) => {
      var g = dy();
      U(h, g);
    },
    (h) => {
      var g = uy();
      U(h, g);
    }
  ), D(c);
  var u = et(c, 2);
  Tb(u, {
    input: "Latest",
    get options() {
      return n.sorts;
    },
    onInput: r
  }), D(l), D(s), U(o, s), Fe();
}
Vn(["click"]);
customElements.define("mv-elegant-filtertypes", ae(
  Sb,
  {
    types: {},
    sorts: {},
    typeselect: {},
    sortselect: {},
    view: {},
    viewselect: {}
  },
  [],
  [],
  !0
));
var gy = /* @__PURE__ */ W('<img alt="type icon" class="svelte-1feueb0">'), fy = /* @__PURE__ */ W('<img alt="type icon" class="svelte-1feueb0">'), py = /* @__PURE__ */ W('<div class="card_frame svelte-1feueb0"><div class="top_left_label svelte-1feueb0"><span class="svelte-1feueb0"> </span> <div class="top_right_icons svelte-1feueb0"></div></div> <img class="header_image svelte-1feueb0" alt="header preview"> <a class="title svelte-1feueb0"> </a> <a class="author svelte-1feueb0" target="_blank"><img alt="profile" class="svelte-1feueb0"> </a> <div class="footer svelte-1feueb0"><div class="description svelte-1feueb0"> </div> <div class="link svelte-1feueb0"><a target="_blank" class="svelte-1feueb0">Open asset </a> <div class="type_box svelte-1feueb0"></div></div></div></div>');
const by = {
  hash: "svelte-1feueb0",
  code: ".card_frame.svelte-1feueb0 {display:flex;flex-wrap:wrap;width:288px;height:428px;border:1px solid var(--gm3-sys-color-surface-variant, #e1e3e1);border-radius:12px;margin:16px 16px 32px 16px;}.top_left_label.svelte-1feueb0 {display:flex;padding:12px 18px;color:#444746;width:100%;height:28px;}.top_left_label.svelte-1feueb0 span:where(.svelte-1feueb0) {white-space:nowrap;}.top_right_icons.svelte-1feueb0 {display:flex;justify-content:right;width:100%;}.top_right_icons.svelte-1feueb0 img:where(.svelte-1feueb0) {object-fit:cover;width:24px;height:24px;margin-left:4px;}.header_image.svelte-1feueb0 {width:calc(100% - 18px);margin:0px 18px;object-fit:cover;height:144px;border-radius:7px;}.title.svelte-1feueb0 {padding:12px 18px 4px;height:48px;color:#1f1f1f;font-weight:600;font-size:18px;overflow:hidden;text-overflow:ellipsis;line-height:1.5rem;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:2;}.title.svelte-1feueb0:hover {color:#7c7c7c;}.author.svelte-1feueb0 {display:flex;align-items:start;padding:0px 18px 4px;height:20px;color:#444746;font-size:.875rem;font-weight:400;line-height:1.25rem;overflow:hidden;text-overflow:ellipsis;}.author.svelte-1feueb0 img:where(.svelte-1feueb0) {border-radius:50%;object-fit:cover;width:18px;height:18px;margin-right:8px;}.author.svelte-1feueb0:hover {color:#757a79;}.footer.svelte-1feueb0 {display:flex;flex-direction:column;justify-content:space-between;min-height:134px;padding-top:9px;padding-bottom:3px;width:100%;}.description.svelte-1feueb0 {padding:3px 18px;height:54px;width:calc(100% - 36px);overflow:hidden;color:#444746;font-size:.875rem;font-weight:400;letter-spacing:0;line-height:1.25rem;outline:none;overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;}.link.svelte-1feueb0 {display:flex;width:calc(100% - 36px);overflow:hidden;padding:0px 16px;padding-bottom:14px;}.link.svelte-1feueb0 a:where(.svelte-1feueb0) {color:#0b57d0;font-weight:600;font-size:.975rem;letter-spacing:0;line-height:1.25rem;white-space:nowrap;}.link.svelte-1feueb0 a:where(.svelte-1feueb0):hover {color:#82aae9;}.type_box.svelte-1feueb0 {display:flex;justify-content:right;flex-wrap:wrap;width:100%;}.type_box.svelte-1feueb0 img:where(.svelte-1feueb0) {object-fit:cover;width:24px;height:24px;margin-left:4px;}"
};
function Ib(o, n) {
  Ve(n, !0), fe(o, by);
  let t = $(n, "item", 19, () => ({
    dateTime: "",
    categories: [],
    imageUrl: "",
    title: "",
    authorImageUrl: "",
    authorName: "",
    authorUrl: "",
    description: "",
    link: "",
    types: []
  }));
  var e = py(), i = R(e), r = R(i), s = R(r, !0);
  D(r);
  var a = et(r, 2);
  ke(a, 21, () => t().categories, be, (y, C) => {
    var x = gy();
    mt(() => {
      At(x, "src", z(C).url), At(x, "title", z(C).title);
    }), U(y, x);
  }), D(a), D(i);
  var l = et(i, 2), c = et(l, 2), d = R(c, !0);
  D(c);
  var u = et(c, 2), h = R(u), g = et(h);
  D(u);
  var f = et(u, 2), p = R(f), b = R(p, !0);
  D(p);
  var k = et(p, 2), w = R(k), _ = et(w, 2);
  ke(_, 21, () => t().types, be, (y, C) => {
    var x = fy();
    mt(() => {
      At(x, "src", z(C).url), At(x, "title", z(C).title);
    }), U(y, x);
  }), D(_), D(k), D(f), D(e), mt(() => {
    Zt(s, t().dateTime), At(l, "src", t().imageUrl), At(c, "href", t().link), Zt(d, t().description), At(u, "href", t().authorUrl), At(h, "src", t().authorImageUrl), Zt(g, ` ${t().authorName ?? ""}`), Zt(b, t().description), At(w, "href", t().link);
  }), U(o, e), Fe();
}
customElements.define("mv-elegant-card", ae(Ib, { item: {} }, [], [], !0));
var ky = /* @__PURE__ */ W('<div class="menu_frame svelte-1dvvvu9"></div>');
const wy = {
  hash: "svelte-1dvvvu9",
  code: `.menu_frame.svelte-1dvvvu9 {max-width:2000px;margin:0px auto;display:flex;
    /* justify-content: center; */flex-wrap:wrap;}`
};
function Mb(o, n) {
  fe(o, wy);
  let t = $(n, "items", 7);
  typeof t() == "string" && t(JSON.parse(t()));
  var e = ky();
  ke(e, 21, t, be, (i, r) => {
    Ib(i, {
      get item() {
        return z(r);
      }
    });
  }), D(e), U(o, e);
}
customElements.define("mv-elegant-cardpage", ae(Mb, { items: {} }, [], [], !0));
var _y = (o, n, t) => n(z(t).name), vy = /* @__PURE__ */ W('<div class="filterbar_option svelte-1d4e3jq"><div class="letter svelte-1d4e3jq"> </div> <div class="name svelte-1d4e3jq"> </div></div>'), yy = /* @__PURE__ */ W('<div class="filterbar_frame svelte-1d4e3jq"></div>');
const Cy = {
  hash: "svelte-1d4e3jq",
  code: `.filterbar_frame.svelte-1d4e3jq {display:flex;justify-content:center;}.filterbar_option.svelte-1d4e3jq {display:flex;flex-flow:row wrap;width:60px;height:100px;margin:8px;user-select:none;
    /* background-color: red; */}.letter.svelte-1d4e3jq {display:flex;align-items:center;justify-content:center;width:100%;height:52px;margin:2px 2px 0px 2px;border-radius:80%;text-align:center;font-size:22px;font-weight:bold;color:#3367d6;border-width:1px;border-style:solid;border-color:transparent;}.letter_selected.svelte-1d4e3jq {background-color:rgb(228, 228, 228);}.letter.svelte-1d4e3jq:hover {cursor:pointer;border-color:lightgray;}.name.svelte-1d4e3jq {width:100%;position:relative;top:-8px;text-align:center;color:gray;font-size:14px;}`
};
function Db(o, n) {
  Ve(n, !0), fe(o, Cy);
  let t = $t({});
  function e(r) {
    t[r] ? t[r] = !1 : t[r] = !0, n.categoryselect && n.categoryselect(t);
  }
  var i = yy();
  ke(i, 21, () => n.categories, be, (r, s) => {
    var a = vy(), l = R(a);
    l.__click = [_y, e, s];
    var c = R(l, !0);
    D(l);
    var d = et(l, 2), u = R(d, !0);
    D(d), D(a), mt(() => {
      Wo(l, "letter_selected", t[z(s).name]), Zt(c, z(s).letter), Zt(u, z(s).name);
    }), U(r, a);
  }), D(i), U(o, i), Fe();
}
Vn(["click"]);
customElements.define("mv-elegant-filtercats", ae(Db, { categories: {}, categoryselect: {} }, [], [], !0));
function Ay(o, n, t, e, i) {
  if (z(n)) {
    let r = [];
    for (let s of t()) {
      let a = !1;
      for (let l of e())
        if (l.searchable && s[l.name] && s[l.name].toString().toLowerCase().includes(z(n).toLowerCase())) {
          a = !0;
          break;
        }
      a && r.push(s);
    }
    Xt(i, $t(r));
  } else
    Xt(i, $t(t()));
}
var xy = /* @__PURE__ */ W('<th class="svelte-1nbcvq9"> </th>'), Ey = /* @__PURE__ */ W('<a class="table_row svelte-1nbcvq9"> </a>'), Ty = /* @__PURE__ */ W('<span class="table_row svelte-1nbcvq9"> </span>'), Sy = /* @__PURE__ */ W('<td class="svelte-1nbcvq9"><!></td>'), Iy = /* @__PURE__ */ W("<td></td>"), My = /* @__PURE__ */ W('<tr class="svelte-1nbcvq9"></tr>'), Dy = /* @__PURE__ */ W('<div class="frame svelte-1nbcvq9" style="container-type: inline-size;"><div class="filter svelte-1nbcvq9"><svg data-icon-name="filterIcon" viewBox="0 0 18 18" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M2 4h14v2H2V4zm2 4h10v2H4V8zm2 4h6v2H6v-2z"></path></svg> <span class="filter_input_box svelte-1nbcvq9">Filter <input class="filter_input svelte-1nbcvq9" placeholder="Value to filter for"></span></div> <table class="svelte-1nbcvq9"><thead class="svelte-1nbcvq9"><tr class="svelte-1nbcvq9"></tr></thead><tbody class="svelte-1nbcvq9"></tbody></table></div>');
const Py = {
  hash: "svelte-1nbcvq9",
  code: `.frame.svelte-1nbcvq9 {
    /* border-color: #eaedf2 !important; */
    /* box-shadow: 0 2px 18px rgba(0, 0, 0, 0.02) !important; */min-width:0;word-wrap:break-word;background-color:#fff;background-clip:border-box;
    /* border: 0.0625rem solid rgba(46, 54, 80, 0.125); */border-radius:0.5rem;padding:22px 32px;font-family:"Nunito Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;}table.svelte-1nbcvq9 {width:100%;margin-bottom:1rem;color:#4a5073;vertical-align:top;border-color:#eaedf2;font-family:"Nunito Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;border-collapse:collapse;}table.svelte-1nbcvq9 thead:where(.svelte-1nbcvq9) tr:where(.svelte-1nbcvq9) th:where(.svelte-1nbcvq9) {vertical-align:center;text-align:left;border-bottom:1px solid #eaedf2 !important;font-size:12px;font-weight:bold;padding-left:14px;padding-bottom:10px;}.table_row.svelte-1nbcvq9 {padding-left:14px;padding-top:14px;padding-bottom:14px;border-bottom:1px solid #eaedf2 !important;display:block;}table.svelte-1nbcvq9 tbody:where(.svelte-1nbcvq9) tr:where(.svelte-1nbcvq9):hover {background-color:#eff0f2;cursor:pointer;border-radius:0.5rem;}.table_row_selected.svelte-1nbcvq9 {background-color:#eff0f2;border-radius:0.5rem;}

  @container (width <= 768px) {.column_sm.svelte-1nbcvq9 {display:none;}
  }a.svelte-1nbcvq9:link {text-decoration:none;color:#4a5073;}a.svelte-1nbcvq9:visited {text-decoration:none;color:#4a5073;}a.svelte-1nbcvq9:hover {text-decoration:none;color:#4a5073;}a.svelte-1nbcvq9:active {text-decoration:none;}td.svelte-1nbcvq9 a:where(.svelte-1nbcvq9) {display:block;}.filter.svelte-1nbcvq9 {margin-top:20px;margin-bottom:8px;margin-left:8px;}.filter_input_box.svelte-1nbcvq9 {position:relative;top:-3px;font-weight:bold;font-size:14px;}.filter_input.svelte-1nbcvq9 {width:50%;margin-left:8px;font-family:Google Sans,
      Roboto,
      Helvetica,
      Arial,
      sans-serif;padding:var(--padding);
    /* border: 2px solid gray; */border:0px;outline:none;border-radius:0px;
    /* background-color: #f1f3f4; */background-color:rgb(255, 255, 255);}`
};
function Pb(o, n) {
  Ve(n, !0), fe(o, Py);
  let t = $(n, "tableHeaders", 23, () => []), e = $(n, "tableRows", 23, () => []), i = $(n, "linkprefix", 3, ""), r = $(n, "linkcolumnname", 3, ""), s = $(n, "tableRowClick", 3, void 0);
  typeof t() == "string" && t(JSON.parse(t())), typeof e() == "string" && e(JSON.parse(e()));
  let a = Zi($t(e())), l = Zi(""), c = Zi(-1);
  const d = (_) => {
    Xt(c, $t(_)), s() && s()({ detail: { rowIndex: _ } }), document.dispatchEvent(new CustomEvent("TableRowClick", { detail: { rowIndex: _ } }));
  };
  var u = Dy(), h = R(u), g = et(R(h), 2), f = et(R(g));
  el(f), f.__keyup = [
    Ay,
    l,
    e,
    t,
    a
  ], D(g), D(h);
  var p = et(h, 2), b = R(p), k = R(b);
  ke(k, 21, t, be, (_, y) => {
    var C = xy(), x = R(C, !0);
    D(C), mt(() => {
      Wo(C, "column_sm", z(y).hideNarrow), Zt(x, z(y).displayName);
    }), U(_, C);
  }), D(k), D(b);
  var w = et(b);
  ke(w, 21, () => z(a), be, (_, y, C) => {
    var x = My();
    x.__click = () => {
      d(C);
    }, ke(x, 21, t, be, (I, P) => {
      var Y = hb(), it = sr(Y);
      me(
        it,
        () => z(y)[z(P).name],
        (te) => {
          var ct = Sy(), ee = R(ct);
          me(
            ee,
            r,
            (Vt) => {
              var ie = Ey(), Le = R(ie, !0);
              D(ie), mt(() => {
                At(ie, "href", i() + z(y)[r()]), Zt(Le, z(y)[z(P).name]);
              }), U(Vt, ie);
            },
            (Vt) => {
              var ie = Ty(), Le = R(ie, !0);
              D(ie), mt(() => Zt(Le, z(y)[z(P).name])), U(Vt, ie);
            }
          ), D(ct), mt(() => Wo(ct, "column_sm", z(P).hideNarrow)), U(te, ct);
        },
        (te) => {
          var ct = Iy();
          U(te, ct);
        }
      ), U(I, Y);
    }), D(x), mt(() => Wo(x, "table_row_selected", C === z(c))), U(_, x);
  }), D(w), D(p), D(u), nl(f, () => z(l), (_) => Xt(l, _)), U(o, u), Fe();
}
Vn(["keyup", "click"]);
customElements.define("mv-elegant-table", ae(
  Pb,
  {
    tableHeaders: {},
    tableRows: {},
    linkprefix: {},
    linkcolumnname: {},
    tableRowClick: {}
  },
  [],
  [],
  !0
));
var Ly = /* @__PURE__ */ W("<!> <!> <!> <!> <!>", 1);
const By = { hash: "svelte-32ttx", code: "" };
function Ny(o, n) {
  fe(o, By);
  let t = $(n, "title", 3, ""), e = $(n, "titleImageUrl", 3, ""), i = $(n, "headerMenus", 19, () => []), r = $(n, "searchtext", 7, ""), s = $(n, "categories", 19, () => []), a = $(n, "types", 19, () => []), l = $(n, "sorts", 19, () => []), c = Zi("CARD"), d = $t([
    {
      name: "dateTime",
      displayName: "Date",
      searchable: !1
    },
    {
      name: "authorName",
      displayName: "Author",
      searchable: !0
    },
    {
      name: "title",
      displayName: "Title",
      searchable: !0
    }
  ]);
  var u = Ly(), h = sr(u);
  Ab(h, {
    get title() {
      return t();
    },
    get titleImageUrl() {
      return e();
    },
    get headerMenus() {
      return i();
    }
  });
  var g = et(h, 2);
  Eb(g, {
    get title() {
      return t();
    },
    get titleImageUrl() {
      return e();
    },
    get searchtext() {
      return r();
    },
    set searchtext(k) {
      r(k);
    },
    get searchloadresults() {
      return n.searchloadresults;
    },
    get searchsubmit() {
      return n.searchsubmit;
    }
  });
  var f = et(g, 2);
  Db(f, {
    get categories() {
      return s();
    },
    get categoryselect() {
      return n.categoryselect;
    }
  });
  var p = et(f, 2);
  Sb(p, {
    get types() {
      return a();
    },
    get sorts() {
      return l();
    },
    get typeselect() {
      return n.typeselect;
    },
    get sortselect() {
      return n.sortselect;
    },
    get view() {
      return z(c);
    },
    set view(k) {
      Xt(c, $t(k));
    }
  });
  var b = et(p, 2);
  me(
    b,
    () => z(c) === "CARD",
    (k) => {
      Mb(k, {
        get items() {
          return n.items;
        }
      });
    },
    (k) => {
      Pb(k, {
        get tableHeaders() {
          return d;
        },
        get tableRows() {
          return n.items;
        },
        linkprefix: "",
        linkcolumnname: "link",
        update: void 0
      });
    }
  ), U(o, u);
}
customElements.define("mv-elegant-buffet", ae(
  Ny,
  {
    title: {},
    titleImageUrl: {},
    headerMenus: {},
    searchtext: {},
    searchloadresults: {},
    searchsubmit: {},
    categories: {},
    categoryselect: {},
    types: {},
    typeselect: {},
    sorts: {},
    sortselect: {},
    items: {}
  },
  [],
  [],
  !0
));
var zy = /* @__PURE__ */ W('<div class="lds-ring svelte-nag87b"><div class="svelte-nag87b"></div><div class="svelte-nag87b"></div><div class="svelte-nag87b"></div><div class="svelte-nag87b"></div></div>');
const Oy = {
  hash: "svelte-nag87b",
  code: `.lds-ring.svelte-nag87b {
  /* display: inline-block;
  position: relative; */display:inline-block;position:absolute;width:99%;text-align:center;height:80px;}.lds-ring.svelte-nag87b div:where(.svelte-nag87b) {box-sizing:border-box;position:absolute;left:48%;top:42%;width:32px;height:32px;margin:8px;border:4px solid #3367d6;border-radius:50%;
  animation: svelte-nag87b-lds-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;border-color:#3367d6 transparent transparent transparent;}.lds-ring.svelte-nag87b div:where(.svelte-nag87b):nth-child(1) {animation-delay:-0.45s;}.lds-ring.svelte-nag87b div:where(.svelte-nag87b):nth-child(2) {animation-delay:-0.3s;}.lds-ring.svelte-nag87b div:where(.svelte-nag87b):nth-child(3) {animation-delay:-0.15s;}
@keyframes svelte-nag87b-lds-ring {
  0% {
      transform: rotate(0deg);
  }
  100% {
      transform: rotate(360deg);
  }
}`
};
function Ry(o, n) {
  fe(o, Oy);
  var t = zy();
  U(o, t);
}
customElements.define("mv-elegant-spinner", ae(Ry, {}, [], [], !0));
const Vy = `(function (t) {
  const e = (t["en"] = t["en"] || {});
  e.dictionary = Object.assign(e.dictionary || {}, {
    "%0 of %1": "%0 of %1",
    "Align center": "Align center",
    "Align left": "Align left",
    "Align right": "Align right",
    "Align table to the left": "Align table to the left",
    "Align table to the right": "Align table to the right",
    Alignment: "Alignment",
    "Almost equal to": "Almost equal to",
    Angle: "Angle",
    "Approximately equal to": "Approximately equal to",
    Aquamarine: "Aquamarine",
    "Asterisk operator": "Asterisk operator",
    "Austral sign": "Austral sign",
    "back with leftwards arrow above": "back with leftwards arrow above",
    Background: "Background",
    Big: "Big",
    "Bitcoin sign": "Bitcoin sign",
    Black: "Black",
    "Block quote": "Block quote",
    Blue: "Blue",
    "Blue marker": "Blue marker",
    Bold: "Bold",
    Border: "Border",
    "Break text": "Break text",
    "Bulleted List": "Bulleted List",
    Cancel: "Cancel",
    "Caption for image: %0": "Caption for image: %0",
    "Caption for the image": "Caption for the image",
    "Cedi sign": "Cedi sign",
    "Cent sign": "Cent sign",
    "Center table": "Center table",
    "Centered image": "Centered image",
    "Change image text alternative": "Change image text alternative",
    "Character categories": "Character categories",
    "Characters: %0": "Characters: %0",
    "Choose heading": "Choose heading",
    Code: "Code",
    "Colon sign": "Colon sign",
    Color: "Color",
    "Color picker": "Color picker",
    Column: "Column",
    "Contains as member": "Contains as member",
    "Copyright sign": "Copyright sign",
    "Cruzeiro sign": "Cruzeiro sign",
    "Currency sign": "Currency sign",
    Dashed: "Dashed",
    "Decrease indent": "Decrease indent",
    Default: "Default",
    "Degree sign": "Degree sign",
    "Delete column": "Delete column",
    "Delete row": "Delete row",
    "Dim grey": "Dim grey",
    Dimensions: "Dimensions",
    "Division sign": "Division sign",
    "Document colors": "Document colors",
    "Dollar sign": "Dollar sign",
    "Dong sign": "Dong sign",
    Dotted: "Dotted",
    Double: "Double",
    "Double dagger": "Double dagger",
    "Double exclamation mark": "Double exclamation mark",
    "Double low-9 quotation mark": "Double low-9 quotation mark",
    "Double question mark": "Double question mark",
    Downloadable: "Downloadable",
    "downwards arrow to bar": "downwards arrow to bar",
    "downwards dashed arrow": "downwards dashed arrow",
    "downwards double arrow": "downwards double arrow",
    "downwards simple arrow": "downwards simple arrow",
    "Drachma sign": "Drachma sign",
    "Dropdown toolbar": "Dropdown toolbar",
    "Edit block": "Edit block",
    "Edit link": "Edit link",
    "Edit source": "Edit source",
    "Editor block content toolbar": "Editor block content toolbar",
    "Editor contextual toolbar": "Editor contextual toolbar",
    "Editor editing area: %0": "Editor editing area: %0",
    "Editor toolbar": "Editor toolbar",
    "Element of": "Element of",
    "Em dash": "Em dash",
    "Empty set": "Empty set",
    "Empty snippet content": "Empty snippet content",
    "En dash": "En dash",
    "end with leftwards arrow above": "end with leftwards arrow above",
    "Enter image caption": "Enter image caption",
    "Euro sign": "Euro sign",
    "Euro-currency sign": "Euro-currency sign",
    "Exclamation question mark": "Exclamation question mark",
    "Font Background Color": "Font Background Color",
    "Font Color": "Font Color",
    "Font Family": "Font Family",
    "Font Size": "Font Size",
    "For all": "For all",
    "Fraction slash": "Fraction slash",
    "French franc sign": "French franc sign",
    "Full size image": "Full size image",
    "German penny sign": "German penny sign",
    "Greater-than or equal to": "Greater-than or equal to",
    "Greater-than sign": "Greater-than sign",
    Green: "Green",
    "Green marker": "Green marker",
    "Green pen": "Green pen",
    Grey: "Grey",
    Groove: "Groove",
    "Guarani sign": "Guarani sign",
    "Header column": "Header column",
    "Header row": "Header row",
    Heading: "Heading",
    "Heading 1": "Heading 1",
    "Heading 2": "Heading 2",
    "Heading 3": "Heading 3",
    "Heading 4": "Heading 4",
    "Heading 5": "Heading 5",
    "Heading 6": "Heading 6",
    Height: "Height",
    Highlight: "Highlight",
    "Horizontal ellipsis": "Horizontal ellipsis",
    "Horizontal line": "Horizontal line",
    "Hryvnia sign": "Hryvnia sign",
    "HTML object": "HTML object",
    "HTML snippet": "HTML snippet",
    Huge: "Huge",
    "Identical to": "Identical to",
    "Image resize list": "Image resize list",
    "Image toolbar": "Image toolbar",
    "image widget": "image widget",
    "In line": "In line",
    "Increase indent": "Increase indent",
    "Indian rupee sign": "Indian rupee sign",
    Infinity: "Infinity",
    Insert: "Insert",
    "Insert code block": "Insert code block",
    "Insert column left": "Insert column left",
    "Insert column right": "Insert column right",
    "Insert HTML": "Insert HTML",
    "Insert image": "Insert image",
    "Insert image via URL": "Insert image via URL",
    "Insert media": "Insert media",
    "Insert paragraph after block": "Insert paragraph after block",
    "Insert paragraph before block": "Insert paragraph before block",
    "Insert row above": "Insert row above",
    "Insert row below": "Insert row below",
    "Insert table": "Insert table",
    Inset: "Inset",
    Integral: "Integral",
    Intersection: "Intersection",
    "Inverted exclamation mark": "Inverted exclamation mark",
    "Inverted question mark": "Inverted question mark",
    Italic: "Italic",
    Justify: "Justify",
    "Kip sign": "Kip sign",
    "Latin capital letter a with breve": "Latin capital letter a with breve",
    "Latin capital letter a with macron": "Latin capital letter a with macron",
    "Latin capital letter a with ogonek": "Latin capital letter a with ogonek",
    "Latin capital letter c with acute": "Latin capital letter c with acute",
    "Latin capital letter c with caron": "Latin capital letter c with caron",
    "Latin capital letter c with circumflex":
      "Latin capital letter c with circumflex",
    "Latin capital letter c with dot above":
      "Latin capital letter c with dot above",
    "Latin capital letter d with caron": "Latin capital letter d with caron",
    "Latin capital letter d with stroke": "Latin capital letter d with stroke",
    "Latin capital letter e with breve": "Latin capital letter e with breve",
    "Latin capital letter e with caron": "Latin capital letter e with caron",
    "Latin capital letter e with dot above":
      "Latin capital letter e with dot above",
    "Latin capital letter e with macron": "Latin capital letter e with macron",
    "Latin capital letter e with ogonek": "Latin capital letter e with ogonek",
    "Latin capital letter eng": "Latin capital letter eng",
    "Latin capital letter g with breve": "Latin capital letter g with breve",
    "Latin capital letter g with cedilla":
      "Latin capital letter g with cedilla",
    "Latin capital letter g with circumflex":
      "Latin capital letter g with circumflex",
    "Latin capital letter g with dot above":
      "Latin capital letter g with dot above",
    "Latin capital letter h with circumflex":
      "Latin capital letter h with circumflex",
    "Latin capital letter h with stroke": "Latin capital letter h with stroke",
    "Latin capital letter i with breve": "Latin capital letter i with breve",
    "Latin capital letter i with dot above":
      "Latin capital letter i with dot above",
    "Latin capital letter i with macron": "Latin capital letter i with macron",
    "Latin capital letter i with ogonek": "Latin capital letter i with ogonek",
    "Latin capital letter i with tilde": "Latin capital letter i with tilde",
    "Latin capital letter j with circumflex":
      "Latin capital letter j with circumflex",
    "Latin capital letter k with cedilla":
      "Latin capital letter k with cedilla",
    "Latin capital letter l with acute": "Latin capital letter l with acute",
    "Latin capital letter l with caron": "Latin capital letter l with caron",
    "Latin capital letter l with cedilla":
      "Latin capital letter l with cedilla",
    "Latin capital letter l with middle dot":
      "Latin capital letter l with middle dot",
    "Latin capital letter l with stroke": "Latin capital letter l with stroke",
    "Latin capital letter n with acute": "Latin capital letter n with acute",
    "Latin capital letter n with caron": "Latin capital letter n with caron",
    "Latin capital letter n with cedilla":
      "Latin capital letter n with cedilla",
    "Latin capital letter o with breve": "Latin capital letter o with breve",
    "Latin capital letter o with double acute":
      "Latin capital letter o with double acute",
    "Latin capital letter o with macron": "Latin capital letter o with macron",
    "Latin capital letter r with acute": "Latin capital letter r with acute",
    "Latin capital letter r with caron": "Latin capital letter r with caron",
    "Latin capital letter r with cedilla":
      "Latin capital letter r with cedilla",
    "Latin capital letter s with acute": "Latin capital letter s with acute",
    "Latin capital letter s with caron": "Latin capital letter s with caron",
    "Latin capital letter s with cedilla":
      "Latin capital letter s with cedilla",
    "Latin capital letter s with circumflex":
      "Latin capital letter s with circumflex",
    "Latin capital letter t with caron": "Latin capital letter t with caron",
    "Latin capital letter t with cedilla":
      "Latin capital letter t with cedilla",
    "Latin capital letter t with stroke": "Latin capital letter t with stroke",
    "Latin capital letter u with breve": "Latin capital letter u with breve",
    "Latin capital letter u with double acute":
      "Latin capital letter u with double acute",
    "Latin capital letter u with macron": "Latin capital letter u with macron",
    "Latin capital letter u with ogonek": "Latin capital letter u with ogonek",
    "Latin capital letter u with ring above":
      "Latin capital letter u with ring above",
    "Latin capital letter u with tilde": "Latin capital letter u with tilde",
    "Latin capital letter w with circumflex":
      "Latin capital letter w with circumflex",
    "Latin capital letter y with circumflex":
      "Latin capital letter y with circumflex",
    "Latin capital letter y with diaeresis":
      "Latin capital letter y with diaeresis",
    "Latin capital letter z with acute": "Latin capital letter z with acute",
    "Latin capital letter z with caron": "Latin capital letter z with caron",
    "Latin capital letter z with dot above":
      "Latin capital letter z with dot above",
    "Latin capital ligature ij": "Latin capital ligature ij",
    "Latin capital ligature oe": "Latin capital ligature oe",
    "Latin small letter a with breve": "Latin small letter a with breve",
    "Latin small letter a with macron": "Latin small letter a with macron",
    "Latin small letter a with ogonek": "Latin small letter a with ogonek",
    "Latin small letter c with acute": "Latin small letter c with acute",
    "Latin small letter c with caron": "Latin small letter c with caron",
    "Latin small letter c with circumflex":
      "Latin small letter c with circumflex",
    "Latin small letter c with dot above":
      "Latin small letter c with dot above",
    "Latin small letter d with caron": "Latin small letter d with caron",
    "Latin small letter d with stroke": "Latin small letter d with stroke",
    "Latin small letter dotless i": "Latin small letter dotless i",
    "Latin small letter e with breve": "Latin small letter e with breve",
    "Latin small letter e with caron": "Latin small letter e with caron",
    "Latin small letter e with dot above":
      "Latin small letter e with dot above",
    "Latin small letter e with macron": "Latin small letter e with macron",
    "Latin small letter e with ogonek": "Latin small letter e with ogonek",
    "Latin small letter eng": "Latin small letter eng",
    "Latin small letter f with hook": "Latin small letter f with hook",
    "Latin small letter g with breve": "Latin small letter g with breve",
    "Latin small letter g with cedilla": "Latin small letter g with cedilla",
    "Latin small letter g with circumflex":
      "Latin small letter g with circumflex",
    "Latin small letter g with dot above":
      "Latin small letter g with dot above",
    "Latin small letter h with circumflex":
      "Latin small letter h with circumflex",
    "Latin small letter h with stroke": "Latin small letter h with stroke",
    "Latin small letter i with breve": "Latin small letter i with breve",
    "Latin small letter i with macron": "Latin small letter i with macron",
    "Latin small letter i with ogonek": "Latin small letter i with ogonek",
    "Latin small letter i with tilde": "Latin small letter i with tilde",
    "Latin small letter j with circumflex":
      "Latin small letter j with circumflex",
    "Latin small letter k with cedilla": "Latin small letter k with cedilla",
    "Latin small letter kra": "Latin small letter kra",
    "Latin small letter l with acute": "Latin small letter l with acute",
    "Latin small letter l with caron": "Latin small letter l with caron",
    "Latin small letter l with cedilla": "Latin small letter l with cedilla",
    "Latin small letter l with middle dot":
      "Latin small letter l with middle dot",
    "Latin small letter l with stroke": "Latin small letter l with stroke",
    "Latin small letter long s": "Latin small letter long s",
    "Latin small letter n preceded by apostrophe":
      "Latin small letter n preceded by apostrophe",
    "Latin small letter n with acute": "Latin small letter n with acute",
    "Latin small letter n with caron": "Latin small letter n with caron",
    "Latin small letter n with cedilla": "Latin small letter n with cedilla",
    "Latin small letter o with breve": "Latin small letter o with breve",
    "Latin small letter o with double acute":
      "Latin small letter o with double acute",
    "Latin small letter o with macron": "Latin small letter o with macron",
    "Latin small letter r with acute": "Latin small letter r with acute",
    "Latin small letter r with caron": "Latin small letter r with caron",
    "Latin small letter r with cedilla": "Latin small letter r with cedilla",
    "Latin small letter s with acute": "Latin small letter s with acute",
    "Latin small letter s with caron": "Latin small letter s with caron",
    "Latin small letter s with cedilla": "Latin small letter s with cedilla",
    "Latin small letter s with circumflex":
      "Latin small letter s with circumflex",
    "Latin small letter t with caron": "Latin small letter t with caron",
    "Latin small letter t with cedilla": "Latin small letter t with cedilla",
    "Latin small letter t with stroke": "Latin small letter t with stroke",
    "Latin small letter u with breve": "Latin small letter u with breve",
    "Latin small letter u with double acute":
      "Latin small letter u with double acute",
    "Latin small letter u with macron": "Latin small letter u with macron",
    "Latin small letter u with ogonek": "Latin small letter u with ogonek",
    "Latin small letter u with ring above":
      "Latin small letter u with ring above",
    "Latin small letter u with tilde": "Latin small letter u with tilde",
    "Latin small letter w with circumflex":
      "Latin small letter w with circumflex",
    "Latin small letter y with circumflex":
      "Latin small letter y with circumflex",
    "Latin small letter z with acute": "Latin small letter z with acute",
    "Latin small letter z with caron": "Latin small letter z with caron",
    "Latin small letter z with dot above":
      "Latin small letter z with dot above",
    "Latin small ligature ij": "Latin small ligature ij",
    "Latin small ligature oe": "Latin small ligature oe",
    "Left aligned image": "Left aligned image",
    "Left double quotation mark": "Left double quotation mark",
    "Left single quotation mark": "Left single quotation mark",
    "Left-pointing double angle quotation mark":
      "Left-pointing double angle quotation mark",
    "leftwards arrow to bar": "leftwards arrow to bar",
    "leftwards dashed arrow": "leftwards dashed arrow",
    "leftwards double arrow": "leftwards double arrow",
    "leftwards simple arrow": "leftwards simple arrow",
    "Less-than or equal to": "Less-than or equal to",
    "Less-than sign": "Less-than sign",
    "Light blue": "Light blue",
    "Light green": "Light green",
    "Light grey": "Light grey",
    Link: "Link",
    "Link image": "Link image",
    "Link URL": "Link URL",
    "Lira sign": "Lira sign",
    "Livre tournois sign": "Livre tournois sign",
    "Logical and": "Logical and",
    "Logical or": "Logical or",
    Macron: "Macron",
    "Manat sign": "Manat sign",
    "Media toolbar": "Media toolbar",
    "Media URL": "Media URL",
    "media widget": "media widget",
    "Merge cell down": "Merge cell down",
    "Merge cell left": "Merge cell left",
    "Merge cell right": "Merge cell right",
    "Merge cell up": "Merge cell up",
    "Merge cells": "Merge cells",
    "Mill sign": "Mill sign",
    "Minus sign": "Minus sign",
    "Multiplication sign": "Multiplication sign",
    "N-ary product": "N-ary product",
    "N-ary summation": "N-ary summation",
    Nabla: "Nabla",
    "Naira sign": "Naira sign",
    "New sheqel sign": "New sheqel sign",
    Next: "Next",
    "No preview available": "No preview available",
    None: "None",
    "Nordic mark sign": "Nordic mark sign",
    "Not an element of": "Not an element of",
    "Not equal to": "Not equal to",
    "Not sign": "Not sign",
    "Numbered List": "Numbered List",
    "on with exclamation mark with left right arrow above":
      "on with exclamation mark with left right arrow above",
    "Open in a new tab": "Open in a new tab",
    "Open link in new tab": "Open link in new tab",
    "Open media in new tab": "Open media in new tab",
    Orange: "Orange",
    Original: "Original",
    Outset: "Outset",
    Overline: "Overline",
    Paragraph: "Paragraph",
    "Paragraph sign": "Paragraph sign",
    "Partial differential": "Partial differential",
    "Paste raw HTML here...": "Paste raw HTML here...",
    "Paste the media URL in the input.": "Paste the media URL in the input.",
    "Per mille sign": "Per mille sign",
    "Per ten thousand sign": "Per ten thousand sign",
    "Peseta sign": "Peseta sign",
    "Peso sign": "Peso sign",
    "Pink marker": "Pink marker",
    "Plain text": "Plain text",
    "Plus-minus sign": "Plus-minus sign",
    "Pound sign": "Pound sign",
    "Press Enter to type after or press Shift + Enter to type before the widget":
      "Press Enter to type after or press Shift + Enter to type before the widget",
    Previous: "Previous",
    "Proportional to": "Proportional to",
    Purple: "Purple",
    "Question exclamation mark": "Question exclamation mark",
    Red: "Red",
    "Red pen": "Red pen",
    Redo: "Redo",
    "Registered sign": "Registered sign",
    "Remove color": "Remove color",
    "Remove Format": "Remove Format",
    "Remove highlight": "Remove highlight",
    "Resize image": "Resize image",
    "Resize image to %0": "Resize image to %0",
    "Resize image to the original size": "Resize image to the original size",
    "Restore default": "Restore default",
    "Reversed paragraph sign": "Reversed paragraph sign",
    "Rich Text Editor": "Rich Text Editor",
    "Rich Text Editor. Editing area: %0": "Rich Text Editor. Editing area: %0",
    Ridge: "Ridge",
    "Right aligned image": "Right aligned image",
    "Right double quotation mark": "Right double quotation mark",
    "Right single quotation mark": "Right single quotation mark",
    "Right-pointing double angle quotation mark":
      "Right-pointing double angle quotation mark",
    "rightwards arrow to bar": "rightwards arrow to bar",
    "rightwards dashed arrow": "rightwards dashed arrow",
    "rightwards double arrow": "rightwards double arrow",
    "rightwards simple arrow": "rightwards simple arrow",
    Row: "Row",
    "Ruble sign": "Ruble sign",
    "Rupee sign": "Rupee sign",
    Save: "Save",
    "Save changes": "Save changes",
    "Section sign": "Section sign",
    "Select all": "Select all",
    "Select column": "Select column",
    "Select row": "Select row",
    "Show more items": "Show more items",
    "Side image": "Side image",
    "Single left-pointing angle quotation mark":
      "Single left-pointing angle quotation mark",
    "Single low-9 quotation mark": "Single low-9 quotation mark",
    "Single right-pointing angle quotation mark":
      "Single right-pointing angle quotation mark",
    Small: "Small",
    Solid: "Solid",
    "soon with rightwards arrow above": "soon with rightwards arrow above",
    Source: "Source",
    "Special characters": "Special characters",
    "Spesmilo sign": "Spesmilo sign",
    "Split cell horizontally": "Split cell horizontally",
    "Split cell vertically": "Split cell vertically",
    "Square root": "Square root",
    Strikethrough: "Strikethrough",
    Style: "Style",
    Subscript: "Subscript",
    Superscript: "Superscript",
    "Table alignment toolbar": "Table alignment toolbar",
    "Table properties": "Table properties",
    "Table toolbar": "Table toolbar",
    "Tenge sign": "Tenge sign",
    "Text alignment": "Text alignment",
    "Text alignment toolbar": "Text alignment toolbar",
    "Text alternative": "Text alternative",
    "Text highlight toolbar": "Text highlight toolbar",
    'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".':
      'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".',
    "The URL must not be empty.": "The URL must not be empty.",
    'The value is invalid. Try "10px" or "2em" or simply "2".':
      'The value is invalid. Try "10px" or "2em" or simply "2".',
    "There exists": "There exists",
    "This link has no URL": "This link has no URL",
    "This media URL is not supported.": "This media URL is not supported.",
    "Tilde operator": "Tilde operator",
    Tiny: "Tiny",
    "Tip: Paste the URL into the content to embed faster.":
      "Tip: Paste the URL into the content to embed faster.",
    "To-do List": "To-do List",
    "Toggle caption off": "Toggle caption off",
    "Toggle caption on": "Toggle caption on",
    "top with upwards arrow above": "top with upwards arrow above",
    "Trade mark sign": "Trade mark sign",
    "Tugrik sign": "Tugrik sign",
    "Turkish lira sign": "Turkish lira sign",
    Turquoise: "Turquoise",
    "Two dot leader": "Two dot leader",
    Underline: "Underline",
    Undo: "Undo",
    Union: "Union",
    Unlink: "Unlink",
    "up down arrow with base": "up down arrow with base",
    Update: "Update",
    "Update image URL": "Update image URL",
    "Upload failed": "Upload failed",
    "Upload in progress": "Upload in progress",
    "upwards arrow to bar": "upwards arrow to bar",
    "upwards dashed arrow": "upwards dashed arrow",
    "upwards double arrow": "upwards double arrow",
    "upwards simple arrow": "upwards simple arrow",
    "Vulgar fraction one half": "Vulgar fraction one half",
    "Vulgar fraction one quarter": "Vulgar fraction one quarter",
    "Vulgar fraction three quarters": "Vulgar fraction three quarters",
    White: "White",
    "Widget toolbar": "Widget toolbar",
    Width: "Width",
    "Won sign": "Won sign",
    "Words: %0": "Words: %0",
    "Wrap text": "Wrap text",
    Yellow: "Yellow",
    "Yellow marker": "Yellow marker",
    "Yen sign": "Yen sign",
  });
})(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {}));
/*!
 * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */ (function t(e, n) {
  if (typeof exports === "object" && typeof module === "object")
    module.exports = n();
  else if (typeof define === "function" && define.amd) define([], n);
  else if (typeof exports === "object") exports["BalloonBlockEditor"] = n();
  else e["BalloonBlockEditor"] = n();
})(self, () =>
  (() => {
    "use strict";
    var t = {
      8180: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck-content code{background-color:hsla(0,0%,78%,.3);border-radius:2px;padding:.15em}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-basic-styles/theme/code.css",
            ],
            names: [],
            mappings:
              "AAKA,iBACC,kCAAuC,CAEvC,iBAAkB,CADlB,aAED,CAEA,0CACC,kCACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck-content code {\\n\\tbackground-color: hsla(0, 0%, 78%, 0.3);\\n\\tpadding: .15em;\\n\\tborder-radius: 2px;\\n}\\n\\n.ck.ck-editor__editable .ck-code_selected  {\\n\\tbackground-color: hsla(0, 0%, 78%, 0.5);\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      636: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-block-quote/theme/blockquote.css",
            ],
            names: [],
            mappings:
              "AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck-content blockquote {\\n\\t/* See #12 */\\n\\toverflow: hidden;\\n\\n\\t/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\\n\\tpadding-right: 1.5em;\\n\\tpadding-left: 1.5em;\\n\\n\\tmargin-left: 0;\\n\\tmargin-right: 0;\\n\\tfont-style: italic;\\n\\tborder-left: solid 5px hsl(0, 0%, 80%);\\n}\\n\\n.ck-content[dir="rtl"] blockquote {\\n\\tborder-left: 0;\\n\\tborder-right: solid 5px hsl(0, 0%, 80%);\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      390: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css",
            ],
            names: [],
            mappings:
              "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CCzBF,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CA2DF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-editor__editable {\\n\\t/*\\n\\t * Vertical drop target (in text).\\n\\t */\\n\\t& .ck.ck-clipboard-drop-target-position {\\n\\t\\tdisplay: inline;\\n\\t\\tposition: relative;\\n\\t\\tpointer-events: none;\\n\\n\\t\\t& span {\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\twidth: 0;\\n\\t\\t}\\n\\t}\\n\\n\\t/*\\n\\t * Styles of the widget being dragged (its preview).\\n\\t */\\n\\t& .ck-widget:-webkit-drag {\\n\\t\\t& > .ck-widget__selection-handle {\\n\\t\\t\\tdisplay: none;\\n\\t\\t}\\n\\n\\t\\t& > .ck-widget__type-around {\\n\\t\\t\\tdisplay: none;\\n\\t\\t}\\n\\t}\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-clipboard-drop-target-dot-width: 12px;\\n\\t--ck-clipboard-drop-target-dot-height: 8px;\\n\\t--ck-clipboard-drop-target-color: var(--ck-color-focus-border)\\n}\\n\\n.ck.ck-editor__editable {\\n\\t/*\\n\\t * Vertical drop target (in text).\\n\\t */\\n\\t& .ck.ck-clipboard-drop-target-position {\\n\\t\\t& span {\\n\\t\\t\\tbottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\\n\\t\\t\\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\\n\\t\\t\\tborder: 1px solid var(--ck-clipboard-drop-target-color);\\n\\t\\t\\tbackground: var(--ck-clipboard-drop-target-color);\\n\\t\\t\\tmargin-left: -1px;\\n\\n\\t\\t\\t/* The triangle above the marker */\\n\\t\\t\\t&::after {\\n\\t\\t\\t\\tcontent: "";\\n\\t\\t\\t\\twidth: 0;\\n\\t\\t\\t\\theight: 0;\\n\\n\\t\\t\\t\\tdisplay: block;\\n\\t\\t\\t\\tposition: absolute;\\n\\t\\t\\t\\tleft: 50%;\\n\\t\\t\\t\\ttop: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);\\n\\n\\t\\t\\t\\ttransform: translateX(-50%);\\n\\t\\t\\t\\tborder-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\\n\\t\\t\\t\\tborder-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\\n\\t\\t\\t\\tborder-style: solid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/*\\n\\t// Horizontal drop target (between blocks).\\n\\t& .ck.ck-clipboard-drop-target-position {\\n\\t\\tdisplay: block;\\n\\t\\tposition: relative;\\n\\t\\twidth: 100%;\\n\\t\\theight: 0;\\n\\t\\tmargin: 0;\\n\\t\\ttext-align: initial;\\n\\n\\t\\t& .ck-clipboard-drop-target__line {\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\twidth: 100%;\\n\\t\\t\\theight: 0;\\n\\t\\t\\tborder: 1px solid var(--ck-clipboard-drop-target-color);\\n\\t\\t\\tmargin-top: -1px;\\n\\n\\t\\t\\t&::before {\\n\\t\\t\\t\\tcontent: "";\\n\\t\\t\\t\\twidth: 0;\\n\\t\\t\\t\\theight: 0;\\n\\n\\t\\t\\t\\tdisplay: block;\\n\\t\\t\\t\\tposition: absolute;\\n\\t\\t\\t\\tleft: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\\n\\t\\t\\t\\ttop: 0;\\n\\n\\t\\t\\t\\ttransform: translateY(-50%);\\n\\t\\t\\t\\tborder-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);\\n\\t\\t\\t\\tborder-width: var(--ck-clipboard-drop-target-dot-size) 0 var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size));\\n\\t\\t\\t\\tborder-style: solid;\\n\\t\\t\\t}\\n\\n\\t\\t\\t&::after {\\n\\t\\t\\t\\tcontent: "";\\n\\t\\t\\t\\twidth: 0;\\n\\t\\t\\t\\theight: 0;\\n\\n\\t\\t\\t\\tdisplay: block;\\n\\t\\t\\t\\tposition: absolute;\\n\\t\\t\\t\\tright: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\\n\\t\\t\\t\\ttop: 0;\\n\\n\\t\\t\\t\\ttransform: translateY(-50%);\\n\\t\\t\\t\\tborder-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;\\n\\t\\t\\t\\tborder-width: var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size)) var(--ck-clipboard-drop-target-dot-size) 0;\\n\\t\\t\\t\\tborder-style: solid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t*/\\n\\n\\t/*\\n\\t * Styles of the widget that it a drop target.\\n\\t */\\n\\t& .ck-widget.ck-clipboard-drop-target-range {\\n\\t\\toutline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\\n\\t}\\n\\n\\t/*\\n\\t * Styles of the widget being dragged (its preview).\\n\\t */\\n\\t& .ck-widget:-webkit-drag {\\n\\t\\tzoom: 0.6;\\n\\t\\toutline: none !important;\\n\\t}\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      9085: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck-content pre{background:hsla(0,0%,78%,.3);border:1px solid #c4c4c4;border-radius:2px;color:#353535;direction:ltr;font-style:normal;min-width:200px;padding:1em;tab-size:4;text-align:left;white-space:pre-wrap}.ck-content pre code{background:unset;border-radius:0;padding:0}.ck.ck-editor__editable pre{position:relative}.ck.ck-editor__editable pre[data-language]:after{content:attr(data-language);position:absolute}:root{--ck-color-code-block-label-background:#757575}.ck.ck-editor__editable pre[data-language]:after{background:var(--ck-color-code-block-label-background);color:#fff;font-family:var(--ck-font-face);font-size:10px;line-height:16px;padding:var(--ck-spacing-tiny) var(--ck-spacing-medium);right:10px;top:-1px;white-space:nowrap}.ck.ck-code-block-dropdown .ck-dropdown__panel{max-height:250px;overflow-x:hidden;overflow-y:auto}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-code-block/theme/codeblock.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-code-block/codeblock.css",
            ],
            names: [],
            mappings:
              "AAKA,gBAGC,4BAAiC,CACjC,wBAAiC,CACjC,iBAAkB,CAHlB,aAAwB,CAOxB,aAAc,CAMd,iBAAkB,CAGlB,eAAgB,CAjBhB,WAAY,CAUZ,UAAW,CAHX,eAAgB,CAIhB,oBAaD,CALC,qBACC,gBAAiB,CAEjB,eAAgB,CADhB,SAED,CAGD,4BACC,iBAMD,CAJC,iDACC,2BAA4B,CAC5B,iBACD,CCjCD,MACC,8CACD,CAEA,iDAGC,sDAAuD,CAMvD,UAAuB,CAHvB,+BAAgC,CADhC,cAAe,CAEf,gBAAiB,CACjB,uDAAwD,CANxD,UAAW,CADX,QAAS,CAST,kBACD,CAEA,+CAEC,gBAAiB,CAEjB,iBAAkB,CADlB,eAED",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck-content pre {\\n\\tpadding: 1em;\\n\\tcolor: hsl(0, 0%, 20.8%);\\n\\tbackground: hsla(0, 0%, 78%, 0.3);\\n\\tborder: 1px solid hsl(0, 0%, 77%);\\n\\tborder-radius: 2px;\\n\\n\\t/* Code block are language directionagnostic. */\\n\\ttext-align: left;\\n\\tdirection: ltr;\\n\\n\\ttab-size: 4;\\n\\twhite-space: pre-wrap;\\n\\n\\t/* Don't inherit the style, e.g. when in a block quote. */\\n\\tfont-style: normal;\\n\\n\\t/* Don't let the code be squashed e.g. when in a table cell. */\\n\\tmin-width: 200px;\\n\\n\\t& code {\\n\\t\\tbackground: unset;\\n\\t\\tpadding: 0;\\n\\t\\tborder-radius: 0;\\n\\t}\\n}\\n\\n.ck.ck-editor__editable pre {\\n\\tposition: relative;\\n\\n\\t&[data-language]::after {\\n\\t\\tcontent: attr(data-language);\\n\\t\\tposition: absolute;\\n\\t}\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-color-code-block-label-background: hsl(0, 0%, 46%);\\n}\\n\\n.ck.ck-editor__editable pre[data-language]::after {\\n\\ttop: -1px;\\n\\tright: 10px;\\n\\tbackground: var(--ck-color-code-block-label-background);\\n\\n\\tfont-size: 10px;\\n\\tfont-family: var(--ck-font-face);\\n\\tline-height: 16px;\\n\\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-medium);\\n\\tcolor: hsl(0, 0%, 100%);\\n\\twhite-space: nowrap;\\n}\\n\\n.ck.ck-code-block-dropdown .ck-dropdown__panel {\\n\\t/* There could be dozens of languages available. Use scroll to prevent a 10e6px dropdown. */\\n\\tmax-height: 250px;\\n\\toverflow-y: auto;\\n\\toverflow-x: hidden;\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      8894: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css",
            ],
            names: [],
            mappings:
              "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/* See ckeditor/ckeditor5#936. */\\n.ck.ck-placeholder,\\n.ck .ck-placeholder {\\n\\tposition: relative;\\n\\n\\t&::before {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0;\\n\\t\\tright: 0;\\n\\t\\tcontent: attr(data-placeholder);\\n\\n\\t\\t/* See ckeditor/ckeditor5#469. */\\n\\t\\tpointer-events: none;\\n\\t}\\n}\\n\\n/* See ckeditor/ckeditor5#1987. */\\n.ck.ck-read-only .ck-placeholder {\\n\\t&::before {\\n\\t\\tdisplay: none;\\n\\t}\\n}\\n\\n/*\\n * Rules for the \`ck-placeholder\` are loaded before the rules for \`ck-reset_all\` in the base CKEditor 5 DLL build.\\n * This fix overwrites the incorrectly set \`position: static\` from \`ck-reset_all\`.\\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\\n */\\n.ck.ck-reset_all .ck-placeholder {\\n\\tposition: relative;\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/* See ckeditor/ckeditor5#936. */\\n.ck.ck-placeholder, .ck .ck-placeholder {\\n\\t&::before {\\n\\t\\tcursor: text;\\n\\t\\tcolor: var(--ck-color-engine-placeholder-text);\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      4401: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/renderer.css",
            ],
            names: [],
            mappings: "AAMA,qDACC,YACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\\n\\tdisplay: none;\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      2585: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck .ck-button.ck-color-table__remove-color{align-items:center;display:flex;width:100%}label.ck.ck-color-grid__label{font-weight:unset}.ck .ck-button.ck-color-table__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard)}.ck .ck-button.ck-color-table__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-base-border)}[dir=ltr] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-font/theme/fontcolor.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-font/fontcolor.css",
            ],
            names: [],
            mappings:
              "AAKA,4CAEC,kBAAmB,CADnB,YAAa,CAEb,UACD,CAEA,8BACC,iBACD,CCNA,4CAEC,2BAA4B,CAC5B,4BAA6B,CAF7B,qEAiBD,CAbC,wDACC,mDACD,CAEA,kEAEE,uCAMF,CARA,kEAME,sCAEF",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck .ck-button.ck-color-table__remove-color {\\n\\tdisplay: flex;\\n\\talign-items: center;\\n\\twidth: 100%;\\n}\\n\\nlabel.ck.ck-color-grid__label {\\n\\tfont-weight: unset;\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\\n\\n.ck .ck-button.ck-color-table__remove-color {\\n\\tpadding: calc(var(--ck-spacing-standard) / 2 ) var(--ck-spacing-standard);\\n\\tborder-bottom-left-radius: 0;\\n\\tborder-bottom-right-radius: 0;\\n\\n\\t&:not(:focus) {\\n\\t\\tborder-bottom: 1px solid var(--ck-color-base-border);\\n\\t}\\n\\n\\t& .ck.ck-icon {\\n\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\tmargin-right: var(--ck-spacing-standard);\\n\\t\\t}\\n\\n\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\tmargin-left: var(--ck-spacing-standard);\\n\\t\\t}\\n\\t}\\n}\\n\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      6203: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck-content .text-tiny{font-size:.7em}.ck-content .text-small{font-size:.85em}.ck-content .text-big{font-size:1.4em}.ck-content .text-huge{font-size:1.8em}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-font/theme/fontsize.css",
            ],
            names: [],
            mappings:
              "AAUC,uBACC,cACD,CAEA,wBACC,eACD,CAEA,sBACC,eACD,CAEA,uBACC,eACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/* The values should be synchronized with the "FONT_SIZE_PRESET_UNITS" object in the "/src/fontsize/utils.js" file. */\\n\\n/* Styles should be prefixed with the \`.ck-content\` class.\\nSee https://github.com/ckeditor/ckeditor5/issues/6636 */\\n.ck-content {\\n\\t& .text-tiny {\\n\\t\\tfont-size: .7em;\\n\\t}\\n\\n\\t& .text-small {\\n\\t\\tfont-size: .85em;\\n\\t}\\n\\n\\t& .text-big {\\n\\t\\tfont-size: 1.4em;\\n\\t}\\n\\n\\t& .text-huge {\\n\\t\\tfont-size: 1.8em;\\n\\t}\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      3230: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-heading/theme/heading.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css",
            ],
            names: [],
            mappings:
              "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-heading_heading1 {\\n\\tfont-size: 20px;\\n}\\n\\n.ck.ck-heading_heading2 {\\n\\tfont-size: 17px;\\n}\\n\\n.ck.ck-heading_heading3 {\\n\\tfont-size: 14px;\\n}\\n\\n.ck[class*="ck-heading_heading"] {\\n\\tfont-weight: bold;\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/* Resize dropdown's button label. */\\n.ck.ck-dropdown.ck-heading-dropdown {\\n\\t& .ck-dropdown__button .ck-button__label {\\n\\t\\twidth: 8em;\\n\\t}\\n\\n\\t& .ck-dropdown__panel .ck-list__item {\\n\\t\\tmin-width: 18em;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      713: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ":root{--ck-highlight-marker-yellow:#fdfd77;--ck-highlight-marker-green:#62f962;--ck-highlight-marker-pink:#fc7899;--ck-highlight-marker-blue:#72ccfd;--ck-highlight-pen-red:#e71313;--ck-highlight-pen-green:#128a00}.ck-content .marker-yellow{background-color:var(--ck-highlight-marker-yellow)}.ck-content .marker-green{background-color:var(--ck-highlight-marker-green)}.ck-content .marker-pink{background-color:var(--ck-highlight-marker-pink)}.ck-content .marker-blue{background-color:var(--ck-highlight-marker-blue)}.ck-content .pen-red{background-color:transparent;color:var(--ck-highlight-pen-red)}.ck-content .pen-green{background-color:transparent;color:var(--ck-highlight-pen-green)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-highlight/theme/highlight.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,oCAA+C,CAC/C,mCAA+C,CAC/C,kCAA8C,CAC9C,kCAA8C,CAC9C,8BAAwC,CACxC,gCACD,CAGC,2BACC,kDACD,CAFA,0BACC,iDACD,CAFA,yBACC,gDACD,CAFA,yBACC,gDACD,CAIA,qBAIC,4BAA6B,CAH7B,iCAID,CALA,uBAIC,4BAA6B,CAH7B,mCAID",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-highlight-marker-yellow: hsl(60, 97%, 73%);\\n\\t--ck-highlight-marker-green: hsl(120, 93%, 68%);\\n\\t--ck-highlight-marker-pink: hsl(345, 96%, 73%);\\n\\t--ck-highlight-marker-blue: hsl(201, 97%, 72%);\\n\\t--ck-highlight-pen-red: hsl(0, 85%, 49%);\\n\\t--ck-highlight-pen-green: hsl(112, 100%, 27%);\\n}\\n\\n@define-mixin highlight-marker-color $color {\\n\\t.ck-content .marker-$color {\\n\\t\\tbackground-color: var(--ck-highlight-marker-$color);\\n\\t}\\n}\\n\\n@define-mixin highlight-pen-color $color {\\n\\t.ck-content .pen-$color {\\n\\t\\tcolor: var(--ck-highlight-pen-$color);\\n\\n\\t\\t/* Override default yellow background of \`<mark>\` from user agent stylesheet */\\n\\t\\tbackground-color: transparent;\\n\\t}\\n}\\n\\n@mixin highlight-marker-color yellow;\\n@mixin highlight-marker-color green;\\n@mixin highlight-marker-color pink;\\n@mixin highlight-marker-color blue;\\n\\n@mixin highlight-pen-color red;\\n@mixin highlight-pen-color green;\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      2536: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck-editor__editable .ck-horizontal-line{display:flow-root}.ck-content hr{background:#dedede;border:0;height:4px;margin:15px 0}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-horizontal-line/theme/horizontalline.css",
            ],
            names: [],
            mappings:
              "AAMA,yCAEC,iBACD,CAEA,eAGC,kBAA2B,CAC3B,QAAS,CAFT,UAAW,CADX,aAID",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n\\n.ck-editor__editable .ck-horizontal-line {\\n\\t/* Necessary to render properly next to floated objects, e.g. side image case. */\\n\\tdisplay: flow-root;\\n}\\n\\n.ck-content hr {\\n\\tmargin: 15px 0;\\n\\theight: 4px;\\n\\tbackground: hsl(0, 0%, 87%);\\n\\tborder: 0;\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      3403: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck-widget.raw-html-embed{display:flow-root;font-style:normal;margin:.9em auto;min-width:15em;position:relative}.ck-widget.raw-html-embed:before{position:absolute;z-index:1}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper{display:flex;flex-direction:column;position:absolute}.ck-widget.raw-html-embed .raw-html-embed__preview{display:flex;overflow:hidden;position:relative}.ck-widget.raw-html-embed .raw-html-embed__preview-content{border-collapse:separate;border-spacing:7px;display:table;margin:auto;position:relative;width:100%}.ck-widget.raw-html-embed .raw-html-embed__preview-placeholder{align-items:center;bottom:0;display:flex;justify-content:center;left:0;position:absolute;right:0;top:0}:root{--ck-html-embed-content-width:calc(100% - var(--ck-icon-size)*1.5);--ck-html-embed-source-height:10em;--ck-html-embed-unfocused-outline-width:1px;--ck-html-embed-content-min-height:calc(var(--ck-icon-size) + var(--ck-spacing-standard));--ck-html-embed-source-disabled-background:var(--ck-color-base-foreground);--ck-html-embed-source-disabled-color:#737373}.ck-widget.raw-html-embed{background-color:var(--ck-color-base-foreground);font-size:var(--ck-font-size-base)}.ck-widget.raw-html-embed:not(.ck-widget_selected):not(:hover){outline:var(--ck-html-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border)}.ck-widget.raw-html-embed[dir=ltr]{text-align:left}.ck-widget.raw-html-embed[dir=rtl]{text-align:right}.ck-widget.raw-html-embed:before{background:#999;border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius);color:var(--ck-color-base-background);content:attr(data-html-embed-label);font-family:var(--ck-font-face);font-size:var(--ck-font-size-tiny);left:var(--ck-spacing-standard);padding:calc(var(--ck-spacing-tiny) + var(--ck-html-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);top:calc(var(--ck-html-embed-unfocused-outline-width)*-1);transition:background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck-widget.raw-html-embed[dir=rtl]:before{left:auto;right:var(--ck-spacing-standard)}.ck-widget.raw-html-embed[dir=ltr] .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before{margin-left:50px}.ck.ck-editor__editable.ck-blurred .ck-widget.raw-html-embed.ck-widget_selected:before{padding:var(--ck-spacing-tiny) var(--ck-spacing-small);top:0}.ck.ck-editor__editable:not(.ck-blurred) .ck-widget.raw-html-embed.ck-widget_selected:before{background:var(--ck-color-focus-border);padding:var(--ck-spacing-tiny) var(--ck-spacing-small);top:0}.ck.ck-editor__editable .ck-widget.raw-html-embed:not(.ck-widget_selected):hover:before{padding:var(--ck-spacing-tiny) var(--ck-spacing-small);top:0}.ck-widget.raw-html-embed .raw-html-embed__content-wrapper{padding:var(--ck-spacing-standard)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper{right:var(--ck-spacing-standard);top:var(--ck-spacing-standard)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper .ck-button.raw-html-embed__save-button{color:var(--ck-color-button-save)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper .ck-button.raw-html-embed__cancel-button{color:var(--ck-color-button-cancel)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper .ck-button:not(:first-child){margin-top:var(--ck-spacing-small)}.ck-widget.raw-html-embed[dir=rtl] .raw-html-embed__buttons-wrapper{left:var(--ck-spacing-standard);right:auto}.ck-widget.raw-html-embed .raw-html-embed__source{box-sizing:border-box;direction:ltr;font-family:monospace;font-size:var(--ck-font-size-base);height:var(--ck-html-embed-source-height);min-width:0;padding:var(--ck-spacing-standard);resize:none;tab-size:4;text-align:left;white-space:pre-wrap;width:var(--ck-html-embed-content-width)}.ck-widget.raw-html-embed .raw-html-embed__source[disabled]{-webkit-text-fill-color:var(--ck-html-embed-source-disabled-color);background:var(--ck-html-embed-source-disabled-background);color:var(--ck-html-embed-source-disabled-color);opacity:1}.ck-widget.raw-html-embed .raw-html-embed__preview{min-height:var(--ck-html-embed-content-min-height);width:var(--ck-html-embed-content-width)}.ck-editor__editable:not(.ck-read-only) .ck-widget.raw-html-embed .raw-html-embed__preview{pointer-events:none}.ck-widget.raw-html-embed .raw-html-embed__preview-content{background-color:var(--ck-color-base-foreground);box-sizing:border-box}.ck-widget.raw-html-embed .raw-html-embed__preview-content>*{margin-left:auto;margin-right:auto}.ck-widget.raw-html-embed .raw-html-embed__preview-placeholder{color:var(--ck-html-embed-source-disabled-color)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-html-embed/theme/htmlembed.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-html-embed/htmlembed.css",
            ],
            names: [],
            mappings:
              "AAMA,0BAMC,iBAAkB,CAOlB,iBAAkB,CATlB,gBAAkB,CAMlB,cAAe,CALf,iBAwDD,CA5CC,iCACC,iBAAkB,CAGlB,SACD,CAKA,2DAEC,YAAa,CACb,qBAAsB,CAFtB,iBAGD,CAEA,mDAGC,YAAa,CADb,eAAgB,CADhB,iBAGD,CAEA,2DAOC,wBAAyB,CACzB,kBAAmB,CAFnB,aAAc,CAHd,WAAY,CADZ,iBAAkB,CADlB,UAQD,CAEA,+DAQC,kBAAmB,CAHnB,QAAS,CAET,YAAa,CAEb,sBAAuB,CAPvB,MAAO,CADP,iBAAkB,CAGlB,OAAQ,CADR,KAOD,CC7DD,MACC,kEAAqE,CACrE,kCAAmC,CACnC,2CAA4C,CAC5C,yFAA0F,CAE1F,0EAA2E,CAC3E,6CACD,CAGA,0BAEC,gDAAiD,CADjD,kCA0ID,CAvIC,+DACC,iGACD,CAGA,mCACC,eACD,CAEA,mCACC,gBACD,CAIA,iCAIC,eAA4B,CAG5B,iEAAkE,CAClE,qCAAsC,CAPtC,mCAAoC,CASpC,+BAAgC,CADhC,kCAAmC,CANnC,+BAAgC,CAGhC,kIAAmI,CAJnI,yDAA4D,CAG5D,0GAMD,CAEA,0CACC,SAAU,CACV,gCACD,CAGA,iIACC,gBACD,CAxCD,uFA4CE,sDAAuD,CADvD,KAgGF,CA3IA,6FAkDE,uCAAwC,CADxC,sDAAuD,CADvD,KA2FF,CA3IA,wFAuDE,sDAAuD,CADvD,KAqFF,CA/EC,2DACC,kCACD,CAGA,2DAEC,gCAAiC,CADjC,8BAcD,CAXC,kGACC,iCACD,CAEA,oGACC,mCACD,CAEA,wFACC,kCACD,CAGD,oEACC,+BAAgC,CAChC,UACD,CAGA,kDACC,qBAAsB,CActB,aAAc,CAPd,qBAAsB,CAGtB,kCAAmC,CATnC,yCAA0C,CAG1C,WAAY,CACZ,kCAAmC,CAFnC,WAAY,CAKZ,UAAW,CAKX,eAAgB,CAJhB,oBAAqB,CAPrB,wCAsBD,CARC,4DAKC,kEAAmE,CAJnE,0DAA2D,CAC3D,gDAAiD,CAIjD,SACD,CAID,mDACC,kDAAmD,CACnD,wCAMD,CARA,2FAME,mBAEF,CAEA,2DAEC,gDAAiD,CADjD,qBAOD,CAJC,6DACC,gBAAiB,CACjB,iBACD,CAGD,+DACC,gDACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/* The feature container. */\\n.ck-widget.raw-html-embed {\\n\\t/* Give the embed some air. */\\n\\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\\n\\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\\n\\tmargin: 0.9em auto;\\n\\tposition: relative;\\n\\tdisplay: flow-root;\\n\\n\\t/* Give the html embed some minimal width in the content to prevent them\\n\\tfrom being "squashed" in tight spaces, e.g. in table cells (https://github.com/ckeditor/ckeditor5/issues/8331) */\\n\\tmin-width: 15em;\\n\\n\\t/* Don\\'t inherit the style, e.g. when in a block quote. */\\n\\tfont-style: normal;\\n\\n\\t/* ----- Emebed label in the upper left corner ----------------------------------------------- */\\n\\n\\t&::before {\\n\\t\\tposition: absolute;\\n\\n\\t\\t/* Make sure the content does not cover the label. */\\n\\t\\tz-index: 1;\\n\\t}\\n\\n\\t/* ----- Emebed internals --------------------------------------------------------------------- */\\n\\n\\t/* The switch mode button wrapper. */\\n\\t& .raw-html-embed__buttons-wrapper {\\n\\t\\tposition: absolute;\\n\\t\\tdisplay: flex;\\n\\t\\tflex-direction: column;\\n\\t}\\n\\n\\t& .raw-html-embed__preview {\\n\\t\\tposition: relative;\\n\\t\\toverflow: hidden;\\n\\t\\tdisplay: flex;\\n\\t}\\n\\n\\t& .raw-html-embed__preview-content {\\n\\t\\twidth: 100%;\\n\\t\\tposition: relative;\\n\\t\\tmargin: auto;\\n\\n\\t\\t/* Gives spacing to the small renderable elements, so they always cover the placeholder. */\\n\\t\\tdisplay: table;\\n\\t\\tborder-collapse: separate;\\n\\t\\tborder-spacing: 7px;\\n\\t}\\n\\n\\t& .raw-html-embed__preview-placeholder {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0;\\n\\t\\ttop: 0;\\n\\t\\tright: 0;\\n\\t\\tbottom: 0;\\n\\n\\t\\tdisplay: flex;\\n\\t\\talign-items: center;\\n\\t\\tjustify-content: center;\\n\\t}\\n}\\n',
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-html-embed-content-width: calc(100% - 1.5 * var(--ck-icon-size));\\n\\t--ck-html-embed-source-height: 10em;\\n\\t--ck-html-embed-unfocused-outline-width: 1px;\\n\\t--ck-html-embed-content-min-height: calc(var(--ck-icon-size) + var(--ck-spacing-standard));\\n\\n\\t--ck-html-embed-source-disabled-background: var(--ck-color-base-foreground);\\n\\t--ck-html-embed-source-disabled-color: hsl(0deg 0% 45%);\\n}\\n\\n/* The feature container. */\\n.ck-widget.raw-html-embed {\\n\\tfont-size: var(--ck-font-size-base);\\n\\tbackground-color: var(--ck-color-base-foreground);\\n\\n\\t&:not(.ck-widget_selected):not(:hover) {\\n\\t\\toutline: var(--ck-html-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border);\\n\\t}\\n\\n\\t/* HTML embed widget itself should respect UI language direction */\\n\\t&[dir="ltr"] {\\n\\t\\ttext-align: left;\\n\\t}\\n\\n\\t&[dir="rtl"] {\\n\\t\\ttext-align: right;\\n\\t}\\n\\n\\t/* ----- Embed label in the upper left corner ----------------------------------------------- */\\n\\n\\t&::before {\\n\\t\\tcontent: attr(data-html-embed-label);\\n\\t\\ttop: calc(-1 * var(--ck-html-embed-unfocused-outline-width));\\n\\t\\tleft: var(--ck-spacing-standard);\\n\\t\\tbackground: hsl(0deg 0% 60%);\\n\\t\\ttransition: background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\\n\\t\\tpadding: calc(var(--ck-spacing-tiny) + var(--ck-html-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);\\n\\t\\tborder-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);\\n\\t\\tcolor: var(--ck-color-base-background);\\n\\t\\tfont-size: var(--ck-font-size-tiny);\\n\\t\\tfont-family: var(--ck-font-face);\\n\\t}\\n\\n\\t&[dir="rtl"]::before {\\n\\t\\tleft: auto;\\n\\t\\tright: var(--ck-spacing-standard);\\n\\t}\\n\\n\\t/* Make space for label but it only collides in LTR languages */\\n\\t&[dir="ltr"] .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before {\\n\\t\\tmargin-left: 50px;\\n\\t}\\n\\n\\t@nest .ck.ck-editor__editable.ck-blurred &.ck-widget_selected::before {\\n\\t\\ttop: 0px;\\n\\t\\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-small);\\n\\t}\\n\\n\\t@nest .ck.ck-editor__editable:not(.ck-blurred) &.ck-widget_selected::before {\\n\\t\\ttop: 0;\\n\\t\\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-small);\\n\\t\\tbackground: var(--ck-color-focus-border);\\n\\t}\\n\\n\\t@nest .ck.ck-editor__editable &:not(.ck-widget_selected):hover::before {\\n\\t\\ttop: 0px;\\n\\t\\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-small);\\n\\t}\\n\\n\\t/* ----- Emebed internals --------------------------------------------------------------------- */\\n\\n\\t& .raw-html-embed__content-wrapper {\\n\\t\\tpadding: var(--ck-spacing-standard);\\n\\t}\\n\\n\\t/* The switch mode button wrapper. */\\n\\t& .raw-html-embed__buttons-wrapper {\\n\\t\\ttop: var(--ck-spacing-standard);\\n\\t\\tright: var(--ck-spacing-standard);\\n\\n\\t\\t& .ck-button.raw-html-embed__save-button {\\n\\t\\t\\tcolor: var(--ck-color-button-save);\\n\\t\\t}\\n\\n\\t\\t& .ck-button.raw-html-embed__cancel-button {\\n\\t\\t\\tcolor: var(--ck-color-button-cancel);\\n\\t\\t}\\n\\n\\t\\t& .ck-button:not(:first-child) {\\n\\t\\t\\tmargin-top: var(--ck-spacing-small);\\n\\t\\t}\\n\\t}\\n\\n\\t&[dir="rtl"] .raw-html-embed__buttons-wrapper {\\n\\t\\tleft: var(--ck-spacing-standard);\\n\\t\\tright: auto;\\n\\t}\\n\\n\\t/* The edit source element. */\\n\\t& .raw-html-embed__source {\\n\\t\\tbox-sizing: border-box;\\n\\t\\theight: var(--ck-html-embed-source-height);\\n\\t\\twidth: var(--ck-html-embed-content-width);\\n\\t\\tresize: none;\\n\\t\\tmin-width: 0;\\n\\t\\tpadding: var(--ck-spacing-standard);\\n\\n\\t\\tfont-family: monospace;\\n\\t\\ttab-size: 4;\\n\\t\\twhite-space: pre-wrap;\\n\\t\\tfont-size: var(--ck-font-size-base); /* Safari needs this. */\\n\\n\\t\\t/* HTML code is directionagnostic. */\\n\\t\\ttext-align: left;\\n\\t\\tdirection: ltr;\\n\\n\\t\\t&[disabled] {\\n\\t\\t\\tbackground: var(--ck-html-embed-source-disabled-background);\\n\\t\\t\\tcolor: var(--ck-html-embed-source-disabled-color);\\n\\n\\t\\t\\t/* Safari needs this for the proper text color in disabled input (https://github.com/ckeditor/ckeditor5/issues/8320). */\\n\\t\\t\\t-webkit-text-fill-color: var(--ck-html-embed-source-disabled-color);\\n\\t\\t\\topacity: 1;\\n\\t\\t}\\n\\t}\\n\\n\\t/* The preview data container. */\\n\\t& .raw-html-embed__preview {\\n\\t\\tmin-height: var(--ck-html-embed-content-min-height);\\n\\t\\twidth: var(--ck-html-embed-content-width);\\n\\n\\t\\t/* Disable all mouse interaction as long as the editor is not readonly. */\\n\\t\\t@nest .ck-editor__editable:not(.ck-read-only) & {\\n\\t\\t\\tpointer-events: none;\\n\\t\\t}\\n\\t}\\n\\n\\t& .raw-html-embed__preview-content {\\n\\t\\tbox-sizing: border-box;\\n\\t\\tbackground-color: var(--ck-color-base-foreground);\\n\\n\\t\\t& > * {\\n\\t\\t\\tmargin-left: auto;\\n\\t\\t\\tmargin-right: auto;\\n\\t\\t}\\n\\t}\\n\\n\\t& .raw-html-embed__preview-placeholder {\\n\\t\\tcolor: var(--ck-html-embed-source-disabled-color)\\n\\t}\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      8468: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ":root{--ck-html-object-embed-unfocused-outline-width:1px}.ck-widget.html-object-embed{background-color:var(--ck-color-base-foreground);font-size:var(--ck-font-size-base);min-width:calc(76px + var(--ck-spacing-standard));padding:var(--ck-spacing-small);padding-top:calc(var(--ck-font-size-tiny) + var(--ck-spacing-large))}.ck-widget.html-object-embed:not(.ck-widget_selected):not(:hover){outline:var(--ck-html-object-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border)}.ck-widget.html-object-embed:before{background:#999;border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius);color:var(--ck-color-base-background);content:attr(data-html-object-embed-label);font-family:var(--ck-font-face);font-size:var(--ck-font-size-tiny);font-style:normal;font-weight:400;left:var(--ck-spacing-standard);padding:calc(var(--ck-spacing-tiny) + var(--ck-html-object-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);position:absolute;top:0;transition:background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck-widget.html-object-embed .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before{margin-left:50px}.ck-widget.html-object-embed .html-object-embed__content{pointer-events:none}div.ck-widget.html-object-embed{margin:1em auto}span.ck-widget.html-object-embed{display:inline-block}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-html-support/theme/datafilter.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,kDACD,CAEA,6BAEC,gDAAiD,CADjD,kCAAmC,CAKnC,iDAAkD,CAHlD,+BAAgC,CAEhC,oEAgCD,CA7BC,kEACC,wGACD,CAEA,oCAOC,eAA4B,CAG5B,iEAAkE,CAClE,qCAAsC,CAPtC,0CAA2C,CAS3C,+BAAgC,CADhC,kCAAmC,CAVnC,iBAAkB,CADlB,eAAmB,CAKnB,+BAAgC,CAGhC,yIAA0I,CAN1I,iBAAkB,CAElB,KAAM,CAGN,0GAMD,CAGA,2HACC,gBACD,CAEA,yDAEC,mBACD,CAGD,gCACC,eACD,CAEA,iCACC,oBACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-html-object-embed-unfocused-outline-width: 1px;\\n}\\n\\n.ck-widget.html-object-embed {\\n\\tfont-size: var(--ck-font-size-base);\\n\\tbackground-color: var(--ck-color-base-foreground);\\n\\tpadding: var(--ck-spacing-small);\\n\\t/* Leave space for label */\\n\\tpadding-top: calc(var(--ck-font-size-tiny) + var(--ck-spacing-large));\\n\\tmin-width: calc(76px + var(--ck-spacing-standard));\\n\\n\\t&:not(.ck-widget_selected):not(:hover) {\\n\\t\\toutline: var(--ck-html-object-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border);\\n\\t}\\n\\n\\t&::before {\\n\\t\\tfont-weight: normal;\\n\\t\\tfont-style: normal;\\n\\t\\tposition: absolute;\\n\\t\\tcontent: attr(data-html-object-embed-label);\\n\\t\\ttop: 0;\\n\\t\\tleft: var(--ck-spacing-standard);\\n\\t\\tbackground: hsl(0deg 0% 60%);\\n\\t\\ttransition: background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\\n\\t\\tpadding: calc(var(--ck-spacing-tiny) + var(--ck-html-object-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);\\n\\t\\tborder-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);\\n\\t\\tcolor: var(--ck-color-base-background);\\n\\t\\tfont-size: var(--ck-font-size-tiny);\\n\\t\\tfont-family: var(--ck-font-face);\\n\\t}\\n\\n\\t/* Make space for label. */\\n\\t& .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before {\\n\\t\\tmargin-left: 50px;\\n\\t}\\n\\n\\t& .html-object-embed__content {\\n\\t\\t/* Disable user interaction with embed content */\\n\\t\\tpointer-events: none;\\n\\t}\\n}\\n\\ndiv.ck-widget.html-object-embed {\\n\\tmargin: 1em auto;\\n}\\n\\nspan.ck-widget.html-object-embed {\\n\\tdisplay: inline-block;\\n}\\n\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      9048: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/image.css",
            ],
            names: [],
            mappings:
              "AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBAuBD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAWA,2GACC,SAUD,CAHC,qEACC,YACD,CAOA,0FACC,cACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck-content {\\n\\t& .image {\\n\\t\\tdisplay: table;\\n\\t\\tclear: both;\\n\\t\\ttext-align: center;\\n\\n\\t\\t/* Make sure there is some space between the content and the image. Center image by default. */\\n\\t\\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\\n\\t \\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\\n\\t\\tmargin: 0.9em auto;\\n\\n\\t\\t/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\\n\\t\\tmin-width: 50px;\\n\\n\\t\\t& img {\\n\\t\\t\\t/* Prevent unnecessary margins caused by line-height (see #44). */\\n\\t\\t\\tdisplay: block;\\n\\n\\t\\t\\t/* Center the image if its width is smaller than the content\\'s width. */\\n\\t\\t\\tmargin: 0 auto;\\n\\n\\t\\t\\t/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\\n\\t\\t\\tmax-width: 100%;\\n\\n\\t\\t\\t/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */\\n\\t\\t\\tmin-width: 100%\\n\\t\\t}\\n\\t}\\n\\n\\t& .image-inline {\\n\\t\\t/*\\n\\t\\t * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).\\n\\t\\t * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.\\n\\t\\t * This strange behavior does not happen with inline-flex.\\n\\t\\t */\\n\\t\\tdisplay: inline-flex;\\n\\n\\t\\t/* While being resized, don\\'t allow the image to exceed the width of the editing root. */\\n\\t\\tmax-width: 100%;\\n\\n\\t\\t/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */\\n\\t\\talign-items: flex-start;\\n\\n\\t\\t/* When the picture is present it must act as a flex container to let the img resize properly */\\n\\t\\t& picture {\\n\\t\\t\\tdisplay: flex;\\n\\t\\t}\\n\\n\\t\\t/* When the picture is present, it must act like a resizable img. */\\n\\t\\t& picture,\\n\\t\\t& img {\\n\\t\\t\\t/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */\\n\\t\\t\\tflex-grow: 1;\\n\\t\\t\\tflex-shrink: 1;\\n\\n\\t\\t\\t/* Prevents overflowing the editing root boundaries when an inline image is very wide. */\\n\\t\\t\\tmax-width: 100%;\\n\\t\\t}\\n\\t}\\n}\\n\\n.ck.ck-editor__editable {\\n\\t/*\\n\\t * Inhertit the content styles padding of the <figcaption> in case the integration overrides \`text-align: center\`\\n\\t * of \`.image\` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native\\n\\t * caret does, and not at the edge of <figcaption>.\\n\\t */\\n\\t& .image > figcaption.ck-placeholder::before {\\n\\t\\tpadding-left: inherit;\\n\\t\\tpadding-right: inherit;\\n\\n\\t\\t/*\\n\\t\\t * Make sure the image caption placeholder doesn\\'t overflow the placeholder area.\\n\\t\\t * See https://github.com/ckeditor/ckeditor5/issues/9162.\\n\\t\\t */\\n\\t\\twhite-space: nowrap;\\n\\t\\toverflow: hidden;\\n\\t\\ttext-overflow: ellipsis;\\n\\t}\\n\\n\\n\\t/*\\n\\t * Make sure the selected inline image always stays on top of its siblings.\\n\\t * See https://github.com/ckeditor/ckeditor5/issues/9108.\\n\\t */\\n\\t& .image.ck-widget_selected {\\n\\t\\tz-index: 1;\\n\\t}\\n\\n\\t& .image-inline.ck-widget_selected {\\n\\t\\tz-index: 1;\\n\\n\\t\\t/*\\n\\t\\t * Make sure the native browser selection style is not displayed.\\n\\t\\t * Inline image widgets have their own styles for the selected state and\\n\\t\\t * leaving this up to the browser is asking for a visual collision.\\n\\t\\t */\\n\\t\\t& ::selection {\\n\\t\\t\\tdisplay: none;\\n\\t\\t}\\n\\t}\\n\\n\\t/* The inline image nested in the table should have its original size if not resized.\\n\\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\\n\\t& td,\\n\\t& th {\\n\\t\\t& .image-inline img {\\n\\t\\t\\tmax-width: none;\\n\\t\\t}\\n\\t}\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      8662: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagecaption.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BAKC,yDAA0D,CAH1D,mBAAoB,CAEpB,wCAAyC,CAHzC,qBAAsB,CAMtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,qBAMD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-color-image-caption-background: hsl(0, 0%, 97%);\\n\\t--ck-color-image-caption-text: hsl(0, 0%, 20%);\\n\\t--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);\\n}\\n\\n/* Content styles */\\n.ck-content .image > figcaption {\\n\\tdisplay: table-caption;\\n\\tcaption-side: bottom;\\n\\tword-break: break-word;\\n\\tcolor: var(--ck-color-image-caption-text);\\n\\tbackground-color: var(--ck-color-image-caption-background);\\n\\tpadding: .6em;\\n\\tfont-size: .75em;\\n\\toutline-offset: -1px;\\n}\\n\\n/* Editing styles */\\n.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {\\n\\tanimation: ck-image-caption-highlight .6s ease-out;\\n}\\n\\n@keyframes ck-image-caption-highlight {\\n\\t0% {\\n\\t\\tbackground-color: var(--ck-color-image-caption-highligted-background);\\n\\t}\\n\\n\\t100% {\\n\\t\\tbackground-color: var(--ck-color-image-caption-background);\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      9292: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-image-insert__panel{padding:var(--ck-spacing-large)}.ck.ck-image-insert__ck-finder-button{border:1px solid #ccc;border-radius:var(--ck-border-radius);display:block;margin:var(--ck-spacing-standard) auto;width:100%}.ck.ck-splitbutton>.ck-file-dialog-button.ck-button{border:none;margin:0;padding:0}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageinsert.css",
            ],
            names: [],
            mappings:
              "AAKA,2BACC,+BACD,CAEA,sCAIC,qBAAiC,CACjC,qCAAsC,CAJtC,aAAc,CAEd,sCAAuC,CADvC,UAID,CAGA,oDAGC,WAAY,CADZ,QAAS,CADT,SAGD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-image-insert__panel {\\n\\tpadding: var(--ck-spacing-large);\\n}\\n\\n.ck.ck-image-insert__ck-finder-button {\\n\\tdisplay: block;\\n\\twidth: 100%;\\n\\tmargin: var(--ck-spacing-standard) auto;\\n\\tborder: 1px solid hsl(0, 0%, 80%);\\n\\tborder-radius: var(--ck-border-radius);\\n}\\n\\n/* https://github.com/ckeditor/ckeditor5/issues/7986 */\\n.ck.ck-splitbutton > .ck-file-dialog-button.ck-button {\\n\\tpadding: 0;\\n\\tmargin: 0;\\n\\tborder: none;\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      5150: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-image-insert-form:focus{outline:none}.ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-image-insert-form__action-row{margin-top:var(--ck-spacing-standard)}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageinsertformrowview.css",
            ],
            names: [],
            mappings:
              "AAMC,+BAEC,YACD,CAGD,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAmBD,CAhBC,iCACC,WACD,CAEA,kDACC,qCAUD,CARC,sIAEC,sBACD,CAEA,+EACC,0BACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-image-insert-form {\\n\\t&:focus {\\n\\t\\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\\n\\t\\toutline: none;\\n\\t}\\n}\\n\\n.ck.ck-form__row {\\n\\tdisplay: flex;\\n\\tflex-direction: row;\\n\\tflex-wrap: nowrap;\\n\\tjustify-content: space-between;\\n\\n\\t/* Ignore labels that work as fieldset legends */\\n\\t& > *:not(.ck-label) {\\n\\t\\tflex-grow: 1;\\n\\t}\\n\\n\\t&.ck-image-insert-form__action-row {\\n\\t\\tmargin-top: var(--ck-spacing-standard);\\n\\n\\t\\t& .ck-button-save,\\n\\t\\t& .ck-button-cancel {\\n\\t\\t\\tjustify-content: center;\\n\\t\\t}\\n\\n\\t\\t& .ck-button .ck-button__label {\\n\\t\\t\\tcolor: var(--ck-color-text);\\n\\t\\t}\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      1043: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck-content .image.image_resized{box-sizing:border-box;display:block;max-width:100%}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}.ck.ck-editor__editable td .image-inline.image_resized img,.ck.ck-editor__editable th .image-inline.image_resized img{max-width:100%}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageresize.css",
            ],
            names: [],
            mappings:
              "AAKA,iCAQC,qBAAsB,CADtB,aAAc,CANd,cAkBD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAQC,sHACC,cACD,CAIF,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck-content .image.image_resized {\\n\\tmax-width: 100%;\\n\\t/*\\n\\tThe \`<figure>\` element for resized images must not use \`display:table\` as browsers do not support \`max-width\` for it well.\\n\\tSee https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.\\n\\tFortunately, since we control the width, there is no risk that the image will look bad.\\n\\t*/\\n\\tdisplay: block;\\n\\tbox-sizing: border-box;\\n\\n\\t& img {\\n\\t\\t/* For resized images it is the \`<figure>\` element that determines the image width. */\\n\\t\\twidth: 100%;\\n\\t}\\n\\n\\t& > figcaption {\\n\\t\\t/* The \`<figure>\` element uses \`display:block\`, so \`<figcaption>\` also has to. */\\n\\t\\tdisplay: block;\\n\\t}\\n}\\n\\n.ck.ck-editor__editable {\\n\\t/* The resized inline image nested in the table should respect its parent size.\\n\\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\\n\\t& td,\\n\\t& th {\\n\\t\\t& .image-inline.image_resized img {\\n\\t\\t\\tmax-width: 100%;\\n\\t\\t}\\n\\t}\\n}\\n\\n[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\\n\\tmargin-right: var(--ck-spacing-standard);\\n}\\n\\n[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\\n\\tmargin-left: var(--ck-spacing-standard);\\n}\\n\\n.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {\\n\\twidth: 4em;\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      4622: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagestyle.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-image-style-spacing: 1.5em;\\n\\t--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);\\n}\\n\\n.ck-content {\\n\\t/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback\\n\\tconfirming successful application of the style if image width exceeds the editor's size.\\n\\tSee https://github.com/ckeditor/ckeditor5/issues/9342 */\\n\\t& .image-style-block-align-left,\\n\\t& .image-style-block-align-right {\\n\\t\\tmax-width: calc(100% - var(--ck-image-style-spacing));\\n\\t}\\n\\n\\t/* Allows displaying multiple floating images in the same line.\\n\\tSee https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */\\n\\t& .image-style-align-left,\\n\\t& .image-style-align-right {\\n\\t\\tclear: none;\\n\\t}\\n\\n\\t& .image-style-side {\\n\\t\\tfloat: right;\\n\\t\\tmargin-left: var(--ck-image-style-spacing);\\n\\t\\tmax-width: 50%;\\n\\t}\\n\\n\\t& .image-style-align-left {\\n\\t\\tfloat: left;\\n\\t\\tmargin-right: var(--ck-image-style-spacing);\\n\\t}\\n\\n\\t& .image-style-align-center {\\n\\t\\tmargin-left: auto;\\n\\t\\tmargin-right: auto;\\n\\t}\\n\\n\\t& .image-style-align-right {\\n\\t\\tfloat: right;\\n\\t\\tmargin-left: var(--ck-image-style-spacing);\\n\\t}\\n\\n\\t& .image-style-block-align-right {\\n\\t\\tmargin-right: 0;\\n\\t\\tmargin-left: auto;\\n\\t}\\n\\n\\t& .image-style-block-align-left {\\n\\t\\tmargin-left: 0;\\n\\t\\tmargin-right: auto;\\n\\t}\\n\\n\\t/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */\\n\\t& p + .image-style-align-left,\\n\\t& p + .image-style-align-right,\\n\\t& p + .image-style-side {\\n\\t\\tmargin-top: 0;\\n\\t}\\n\\n\\t& .image-inline {\\n\\t\\t&.image-style-align-left,\\n\\t\\t&.image-style-align-right {\\n\\t\\t\\tmargin-top: var(--ck-inline-image-style-spacing);\\n\\t\\t\\tmargin-bottom: var(--ck-inline-image-style-spacing);\\n\\t\\t}\\n\\n\\t\\t&.image-style-align-left {\\n\\t\\t\\tmargin-right: var(--ck-inline-image-style-spacing);\\n\\t\\t}\\n\\n\\t\\t&.image-style-align-right {\\n\\t\\t\\tmargin-left: var(--ck-inline-image-style-spacing);\\n\\t\\t}\\n\\t}\\n}\\n\\n.ck.ck-splitbutton {\\n\\t/* The button should display as a regular drop-down if the action button\\n\\tis forced to fire the same action as the arrow button. */\\n\\t&.ck-splitbutton_flatten {\\n\\t\\t&:hover,\\n\\t\\t&.ck-splitbutton_open {\\n\\t\\t\\t& > .ck-splitbutton__action:not(.ck-disabled),\\n\\t\\t\\t& > .ck-splitbutton__arrow:not(.ck-disabled),\\n\\t\\t\\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\\n\\t\\t\\t\\tbackground-color: var(--ck-color-button-on-background);\\n\\n\\t\\t\\t\\t&::after {\\n\\t\\t\\t\\t\\tdisplay: none;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t&.ck-splitbutton_open:hover {\\n\\t\\t\\t& > .ck-splitbutton__action:not(.ck-disabled),\\n\\t\\t\\t& > .ck-splitbutton__arrow:not(.ck-disabled),\\n\\t\\t\\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\\n\\t\\t\\t\\tbackground-color: var(--ck-color-button-on-hover-background);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      9899: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadicon.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css",
            ],
            names: [],
            mappings:
              "AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck-image-upload-complete-icon {\\n\\tdisplay: block;\\n\\tposition: absolute;\\n\\n\\t/*\\n\\t * Smaller images should have the icon closer to the border.\\n\\t * Match the icon position with the linked image indicator brought by the link image feature.\\n\\t */\\n\\ttop: min(var(--ck-spacing-medium), 6%);\\n\\tright: min(var(--ck-spacing-medium), 6%);\\n\\tborder-radius: 50%;\\n\\tz-index: 1;\\n\\n\\t&::after {\\n\\t\\tcontent: "";\\n\\t\\tposition: absolute;\\n\\t}\\n}\\n',
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-color-image-upload-icon: hsl(0, 0%, 100%);\\n\\t--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\\n\\n\\t/* Match the icon size with the linked image indicator brought by the link image feature. */\\n\\t--ck-image-upload-icon-size: 20;\\n\\t--ck-image-upload-icon-width: 2px;\\n\\t--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);\\n}\\n\\n.ck-image-upload-complete-icon {\\n\\topacity: 0;\\n\\tbackground: var(--ck-color-image-upload-icon-background);\\n\\tanimation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\\n\\tanimation-fill-mode: forwards, forwards;\\n\\tanimation-duration: 500ms, 500ms;\\n\\n\\t/* To make animation scalable. */\\n\\tfont-size: calc(1px * var(--ck-image-upload-icon-size));\\n\\n\\t/* Hide completed upload icon after 3 seconds. */\\n\\tanimation-delay: 0ms, 3000ms;\\n\\n\\t/*\\n\\t * Use CSS math to simulate container queries.\\n\\t * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\\n\\t */\\n\\toverflow: hidden;\\n\\twidth: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\\n\\theight: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\\n\\n\\t/* This is check icon element made from border-width mixed with animations. */\\n\\t&::after {\\n\\t\\t/* Because of border transformation we need to "hard code" left position. */\\n\\t\\tleft: 25%;\\n\\n\\t\\ttop: 50%;\\n\\t\\topacity: 0;\\n\\t\\theight: 0;\\n\\t\\twidth: 0;\\n\\n\\t\\ttransform: scaleX(-1) rotate(135deg);\\n\\t\\ttransform-origin: left top;\\n\\t\\tborder-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\\n\\t\\tborder-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\\n\\n\\t\\tanimation-name: ck-upload-complete-icon-check;\\n\\t\\tanimation-duration: 500ms;\\n\\t\\tanimation-delay: 500ms;\\n\\t\\tanimation-fill-mode: forwards;\\n\\n\\t\\t/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\\n\\t\\tbox-sizing: border-box;\\n\\t}\\n}\\n\\n@keyframes ck-upload-complete-icon-show {\\n\\tfrom {\\n\\t\\topacity: 0;\\n\\t}\\n\\n\\tto {\\n\\t\\topacity: 1;\\n\\t}\\n}\\n\\n@keyframes ck-upload-complete-icon-hide {\\n\\tfrom {\\n\\t\\topacity: 1;\\n\\t}\\n\\n\\tto {\\n\\t\\topacity: 0;\\n\\t}\\n}\\n\\n@keyframes ck-upload-complete-icon-check {\\n\\t0% {\\n\\t\\topacity: 1;\\n\\t\\twidth: 0;\\n\\t\\theight: 0;\\n\\t}\\n\\t33% {\\n\\t\\twidth: 0.3em;\\n\\t\\theight: 0;\\n\\t}\\n\\t100% {\\n\\t\\topacity: 1;\\n\\t\\twidth: 0.3em;\\n\\t\\theight: 0.45em;\\n\\t}\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      9825: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadloader.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css",
            ],
            names: [],
            mappings:
              "AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck .ck-upload-placeholder-loader {\\n\\tposition: absolute;\\n\\tdisplay: flex;\\n\\talign-items: center;\\n\\tjustify-content: center;\\n\\ttop: 0;\\n\\tleft: 0;\\n\\n\\t&::before {\\n\\t\\tcontent: '';\\n\\t\\tposition: relative;\\n\\t}\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\\n\\t--ck-upload-placeholder-loader-size: 32px;\\n\\t--ck-upload-placeholder-image-aspect-ratio: 2.8;\\n}\\n\\n.ck .ck-image-upload-placeholder {\\n\\t/* We need to control the full width of the SVG gray background. */\\n\\twidth: 100%;\\n\\tmargin: 0;\\n\\n\\t&.image-inline {\\n\\t\\twidth: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );\\n\\t}\\n\\n\\t& img {\\n\\t\\t/*\\n\\t\\t * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.\\n\\t\\t * There's nothing special about this number except that it should make the image placeholder look like\\n\\t\\t * a real image during this short period after the upload started and before the image was read from the\\n\\t\\t * file system (and a rich preview was loaded).\\n\\t\\t */\\n\\t\\taspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);\\n\\t}\\n}\\n\\n.ck .ck-upload-placeholder-loader {\\n\\twidth: 100%;\\n\\theight: 100%;\\n\\n\\t&::before {\\n\\t\\twidth: var(--ck-upload-placeholder-loader-size);\\n\\t\\theight: var(--ck-upload-placeholder-loader-size);\\n\\t\\tborder-radius: 50%;\\n\\t\\tborder-top: 3px solid var(--ck-color-upload-placeholder-loader);\\n\\t\\tborder-right: 2px solid transparent;\\n\\t\\tanimation: ck-upload-placeholder-loader 1s linear infinite;\\n\\t}\\n}\\n\\n@keyframes ck-upload-placeholder-loader {\\n\\tto {\\n\\t\\ttransform: rotate( 360deg );\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      5870: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadprogress.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css",
            ],
            names: [],
            mappings:
              "AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-editor__editable {\\n\\t& .image,\\n\\t& .image-inline {\\n\\t\\tposition: relative;\\n\\t}\\n\\n\\t/* Upload progress bar. */\\n\\t& .image .ck-progress-bar,\\n\\t& .image-inline .ck-progress-bar {\\n\\t\\tposition: absolute;\\n\\t\\ttop: 0;\\n\\t\\tleft: 0;\\n\\t}\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-editor__editable {\\n\\t& .image,\\n\\t& .image-inline {\\n\\t\\t/* Showing animation. */\\n\\t\\t&.ck-appear {\\n\\t\\t\\tanimation: fadeIn 700ms;\\n\\t\\t}\\n\\t}\\n\\n\\t/* Upload progress bar. */\\n\\t& .image .ck-progress-bar,\\n\\t& .image-inline .ck-progress-bar {\\n\\t\\theight: 2px;\\n\\t\\twidth: 0;\\n\\t\\tbackground: var(--ck-color-upload-bar-background);\\n\\t\\ttransition: width 100ms;\\n\\t}\\n}\\n\\n@keyframes fadeIn {\\n\\tfrom { opacity: 0; }\\n\\tto   { opacity: 1; }\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      6831: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/textalternativeform.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
            ],
            names: [],
            mappings:
              "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\\n\\n.ck.ck-text-alternative-form {\\n\\tdisplay: flex;\\n\\tflex-direction: row;\\n\\tflex-wrap: nowrap;\\n\\n\\t& .ck-labeled-field-view {\\n\\t\\tdisplay: inline-block;\\n\\t}\\n\\n\\t& .ck-label {\\n\\t\\tdisplay: none;\\n\\t}\\n\\n\\t@mixin ck-media-phone {\\n\\t\\tflex-wrap: wrap;\\n\\n\\t\\t& .ck-labeled-field-view {\\n\\t\\t\\tflex-basis: 100%;\\n\\t\\t}\\n\\n\\t\\t& .ck-button {\\n\\t\\t\\tflex-basis: 50%;\\n\\t\\t}\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@define-mixin ck-media-phone {\\n\\t@media screen and (max-width: 600px) {\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      399: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/link.css",
            ],
            names: [],
            mappings:
              "AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/* Class added to span element surrounding currently selected link. */\\n.ck .ck-link_selected {\\n\\tbackground: var(--ck-color-link-selected-background);\\n\\n\\t/* Give linked inline images some outline to let the user know they are also part of the link. */\\n\\t& span.image-inline {\\n\\t\\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);\\n\\t}\\n}\\n\\n/*\\n * Classes used by the "fake visual selection" displayed in the content when an input\\n * in the link UI has focus (the browser does not render the native selection in this state).\\n */\\n.ck .ck-fake-link-selection {\\n\\tbackground: var(--ck-color-link-fake-selection);\\n}\\n\\n/* A collapsed fake visual selection. */\\n.ck .ck-fake-link-selection_collapsed {\\n\\theight: 100%;\\n\\tborder-right: 1px solid var(--ck-color-base-text);\\n\\tmargin-right: -1px;\\n\\toutline: solid 1px hsla(0, 0%, 100%, .5);\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      9465: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css",
            ],
            names: [],
            mappings:
              "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\\n\\n.ck.ck-link-actions {\\n\\tdisplay: flex;\\n\\tflex-direction: row;\\n\\tflex-wrap: nowrap;\\n\\n\\t& .ck-link-actions__preview {\\n\\t\\tdisplay: inline-block;\\n\\n\\t\\t& .ck-button__label {\\n\\t\\t\\toverflow: hidden;\\n\\t\\t}\\n\\t}\\n\\n\\t@mixin ck-media-phone {\\n\\t\\tflex-wrap: wrap;\\n\\n\\t\\t& .ck-link-actions__preview {\\n\\t\\t\\tflex-basis: 100%;\\n\\t\\t}\\n\\n\\t\\t& .ck-button:not(.ck-link-actions__preview) {\\n\\t\\t\\tflex-basis: 50%;\\n\\t\\t}\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@define-mixin ck-media-phone {\\n\\t@media screen and (max-width: 600px) {\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\\n@import "../mixins/_focus.css";\\n@import "../mixins/_shadow.css";\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\\n\\n.ck.ck-link-actions {\\n\\t& .ck-button.ck-link-actions__preview {\\n\\t\\tpadding-left: 0;\\n\\t\\tpadding-right: 0;\\n\\n\\t\\t& .ck-button__label {\\n\\t\\t\\tpadding: 0 var(--ck-spacing-medium);\\n\\t\\t\\tcolor: var(--ck-color-link-default);\\n\\t\\t\\ttext-overflow: ellipsis;\\n\\t\\t\\tcursor: pointer;\\n\\n\\t\\t\\t/* Match the box model of the link editor form\\'s input so the balloon\\n\\t\\t\\tdoes not change width when moving between actions and the form. */\\n\\t\\t\\tmax-width: var(--ck-input-width);\\n\\t\\t\\tmin-width: 3em;\\n\\t\\t\\ttext-align: center;\\n\\n\\t\\t\\t&:hover {\\n\\t\\t\\t\\ttext-decoration: underline;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t&,\\n\\t\\t&:hover,\\n\\t\\t&:focus,\\n\\t\\t&:active {\\n\\t\\t\\tbackground: none;\\n\\t\\t}\\n\\n\\t\\t&:active {\\n\\t\\t\\tbox-shadow: none;\\n\\t\\t}\\n\\n\\t\\t&:focus {\\n\\t\\t\\t& .ck-button__label {\\n\\t\\t\\t\\ttext-decoration: underline;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t@mixin ck-dir ltr {\\n\\t\\t& .ck-button:not(:first-child) {\\n\\t\\t\\tmargin-left: var(--ck-spacing-standard);\\n\\t\\t}\\n\\t}\\n\\n\\t@mixin ck-dir rtl {\\n\\t\\t& .ck-button:not(:last-child) {\\n\\t\\t\\tmargin-left: var(--ck-spacing-standard);\\n\\t\\t}\\n\\t}\\n\\n\\t@mixin ck-media-phone {\\n\\t\\t& .ck-button.ck-link-actions__preview {\\n\\t\\t\\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\\n\\n\\t\\t\\t& .ck-button__label {\\n\\t\\t\\t\\tmin-width: 0;\\n\\t\\t\\t\\tmax-width: 100%;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t& .ck-button:not(.ck-link-actions__preview) {\\n\\t\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\t\\tmargin-left: 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\t\\tmargin-left: 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      4827: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkform.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css",
            ],
            names: [],
            mappings:
              "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\\n\\n.ck.ck-link-form {\\n\\tdisplay: flex;\\n\\n\\t& .ck-label {\\n\\t\\tdisplay: none;\\n\\t}\\n\\n\\t@mixin ck-media-phone {\\n\\t\\tflex-wrap: wrap;\\n\\n\\t\\t& .ck-labeled-field-view {\\n\\t\\t\\tflex-basis: 100%;\\n\\t\\t}\\n\\n\\t\\t& .ck-button {\\n\\t\\t\\tflex-basis: 50%;\\n\\t\\t}\\n\\t}\\n}\\n\\n/*\\n * Style link form differently when manual decorators are available.\\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\\n */\\n.ck.ck-link-form_layout-vertical {\\n\\tdisplay: block;\\n\\n\\t/*\\n\\t * Whether the form is in the responsive mode or not, if there are decorator buttons\\n\\t * keep the top margin of action buttons medium.\\n\\t */\\n\\t& .ck-button {\\n\\t\\t&.ck-button-save,\\n\\t\\t&.ck-button-cancel {\\n\\t\\t\\tmargin-top: var(--ck-spacing-medium);\\n\\t\\t}\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@define-mixin ck-media-phone {\\n\\t@media screen and (max-width: 600px) {\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\\n\\n/*\\n * Style link form differently when manual decorators are available.\\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\\n */\\n.ck.ck-link-form_layout-vertical {\\n\\tpadding: 0;\\n\\tmin-width: var(--ck-input-width);\\n\\n\\t& .ck-labeled-field-view {\\n\\t\\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\\n\\n\\t\\t& .ck-input-text {\\n\\t\\t\\tmin-width: 0;\\n\\t\\t\\twidth: 100%;\\n\\t\\t}\\n\\t}\\n\\n\\t& > .ck-button {\\n\\t\\tpadding: var(--ck-spacing-standard);\\n\\t\\tmargin: 0;\\n\\t\\twidth: 50%;\\n\\t\\tborder-radius: 0;\\n\\n\\t\\t&:not(:focus) {\\n\\t\\t\\tborder-top: 1px solid var(--ck-color-base-border);\\n\\t\\t}\\n\\n\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\tmargin-left: 0;\\n\\t\\t}\\n\\n\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\tmargin-left: 0;\\n\\n\\t\\t\\t&:last-of-type {\\n\\t\\t\\t\\tborder-right: 1px solid var(--ck-color-base-border);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/* Using additional \`.ck\` class for stronger CSS specificity than \`.ck.ck-link-form > :not(:first-child)\`. */\\n\\t& .ck.ck-list {\\n\\t\\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\\n\\n\\t\\t& .ck-button.ck-switchbutton {\\n\\t\\t\\tpadding: 0;\\n\\t\\t\\twidth: 100%;\\n\\n\\t\\t\\t&:hover {\\n\\t\\t\\t\\tbackground: none;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      3858: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{display:block;position:absolute}:root{--ck-link-image-indicator-icon-size:20;--ck-link-image-indicator-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{background-color:rgba(0,0,0,.4);background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");background-position:50%;background-repeat:no-repeat;background-size:14px;border-radius:100%;content:"";height:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size));overflow:hidden;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);width:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size))}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkimage.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkimage.css",
            ],
            names: [],
            mappings:
              "AASE,+FACC,aAAc,CACd,iBACD,CCPF,MAEC,sCAAuC,CACvC,oEACD,CAME,+FAUC,+BAAqC,CACrC,83BAA+3B,CAG/3B,uBAA2B,CAD3B,2BAA4B,CAD5B,oBAAqB,CAGrB,kBAAmB,CAdnB,UAAW,CAsBX,oGAAuG,CAFvG,eAAgB,CAbhB,sCAAwC,CADxC,oCAAsC,CAetC,mGAED",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-editor__editable {\\n\\t/* Linked image indicator */\\n\\t& figure.image > a,\\n\\t& a span.image-inline {\\n\\t\\t&::after {\\n\\t\\t\\tdisplay: block;\\n\\t\\t\\tposition: absolute;\\n\\t\\t}\\n\\t}\\n}\\n\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t/* Match the icon size with the upload indicator brought by the image upload feature. */\\n\\t--ck-link-image-indicator-icon-size: 20;\\n\\t--ck-link-image-indicator-icon-is-visible: clamp(0px, 100% - 50px, 1px);\\n}\\n\\n.ck.ck-editor__editable {\\n\\t/* Linked image indicator */\\n\\t& figure.image > a,\\n\\t& a span.image-inline {\\n\\t\\t&::after {\\n\\t\\t\\tcontent: "";\\n\\n\\t\\t\\t/*\\n\\t\\t\\t * Smaller images should have the icon closer to the border.\\n\\t\\t\\t * Match the icon position with the upload indicator brought by the image upload feature.\\n\\t\\t\\t */\\n\\t\\t\\ttop: min(var(--ck-spacing-medium), 6%);\\n\\t\\t\\tright: min(var(--ck-spacing-medium), 6%);\\n\\n\\t\\t\\tbackground-color: hsla(0, 0%, 0%, .4);\\n\\t\\t\\tbackground-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");\\n\\t\\t\\tbackground-size: 14px;\\n\\t\\t\\tbackground-repeat: no-repeat;\\n\\t\\t\\tbackground-position: center;\\n\\t\\t\\tborder-radius: 100%;\\n\\n\\t\\t\\t/*\\n\\t\\t\\t* Use CSS math to simulate container queries.\\n\\t\\t\\t* https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\\n\\t\\t\\t*/\\n\\t\\t\\toverflow: hidden;\\n\\t\\t\\twidth: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));\\n\\t\\t\\theight: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));\\n\\t\\t}\\n\\t}\\n}\\n\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      1588: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ':root{--ck-todo-list-checkmark-size:16px}.ck-content .todo-list{list-style:none}.ck-content .todo-list li{margin-bottom:5px}.ck-content .todo-list li .todo-list{margin-top:5px}.ck-content .todo-list .todo-list__label>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-content .todo-list .todo-list__label>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out,background .25s ease-in-out,border .25s ease-in-out;width:100%}.ck-content .todo-list .todo-list__label>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-content .todo-list .todo-list__label>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-content .todo-list .todo-list__label>input[checked]:after{border-color:#fff}.ck-content .todo-list .todo-list__label .todo-list__label__description{vertical-align:middle}[dir=rtl] .todo-list .todo-list__label>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-editor__editable .todo-list .todo-list__label>input{cursor:pointer}.ck-editor__editable .todo-list .todo-list__label>input:hover:before{box-shadow:0 0 0 5px rgba(0,0,0,.1)}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-list/theme/todolist.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,kCACD,CAEA,uBACC,eA0ED,CAxEC,0BACC,iBAKD,CAHC,qCACC,cACD,CAIA,+CACC,uBAAwB,CAQxB,QAAS,CAPT,oBAAqB,CAGrB,yCAA0C,CAO1C,UAAW,CAGX,aAAc,CAFd,kBAAmB,CAVnB,iBAAkB,CAWlB,OAAQ,CARR,qBAAsB,CAFtB,wCAqDD,CAxCC,sDAOC,qBAAiC,CACjC,iBAAkB,CALlB,qBAAsB,CACtB,UAAW,CAHX,aAAc,CAKd,WAAY,CAJZ,iBAAkB,CAOlB,0FAAgG,CAJhG,UAKD,CAEA,qDAaC,wBAAyB,CADzB,kBAAmB,CAEnB,sGAA+G,CAX/G,sBAAuB,CAEvB,UAAW,CAJX,aAAc,CAUd,mDAAwD,CAHxD,+CAAoD,CAJpD,mBAAoB,CAFpB,iBAAkB,CAOlB,gDAAqD,CAMrD,uBAAwB,CALxB,kDAMD,CAGC,+DACC,kBAA8B,CAC9B,oBACD,CAEA,8DACC,iBACD,CAIF,wEACC,qBACD,CAKF,6CACC,MAAO,CAGP,iBAAkB,CAFlB,cAAe,CACf,WAED,CAMA,wDACC,cAKD,CAHC,qEACC,mCACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-todo-list-checkmark-size: 16px;\\n}\\n\\n.ck-content .todo-list {\\n\\tlist-style: none;\\n\\n\\t& li {\\n\\t\\tmargin-bottom: 5px;\\n\\n\\t\\t& .todo-list {\\n\\t\\t\\tmargin-top: 5px;\\n\\t\\t}\\n\\t}\\n\\n\\t& .todo-list__label {\\n\\t\\t& > input {\\n\\t\\t\\t-webkit-appearance: none;\\n\\t\\t\\tdisplay: inline-block;\\n\\t\\t\\tposition: relative;\\n\\t\\t\\twidth: var(--ck-todo-list-checkmark-size);\\n\\t\\t\\theight: var(--ck-todo-list-checkmark-size);\\n\\t\\t\\tvertical-align: middle;\\n\\n\\t\\t\\t/* Needed on iOS */\\n\\t\\t\\tborder: 0;\\n\\n\\t\\t\\t/* LTR styles */\\n\\t\\t\\tleft: -25px;\\n\\t\\t\\tmargin-right: -15px;\\n\\t\\t\\tright: 0;\\n\\t\\t\\tmargin-left: 0;\\n\\n\\t\\t\\t&::before {\\n\\t\\t\\t\\tdisplay: block;\\n\\t\\t\\t\\tposition: absolute;\\n\\t\\t\\t\\tbox-sizing: border-box;\\n\\t\\t\\t\\tcontent: '';\\n\\t\\t\\t\\twidth: 100%;\\n\\t\\t\\t\\theight: 100%;\\n\\t\\t\\t\\tborder: 1px solid hsl(0, 0%, 20%);\\n\\t\\t\\t\\tborder-radius: 2px;\\n\\t\\t\\t\\ttransition: 250ms ease-in-out box-shadow, 250ms ease-in-out background, 250ms ease-in-out border;\\n\\t\\t\\t}\\n\\n\\t\\t\\t&::after {\\n\\t\\t\\t\\tdisplay: block;\\n\\t\\t\\t\\tposition: absolute;\\n\\t\\t\\t\\tbox-sizing: content-box;\\n\\t\\t\\t\\tpointer-events: none;\\n\\t\\t\\t\\tcontent: '';\\n\\n\\t\\t\\t\\t/* Calculate tick position, size and border-width proportional to the checkmark size. */\\n\\t\\t\\t\\tleft: calc( var(--ck-todo-list-checkmark-size) / 3 );\\n\\t\\t\\t\\ttop: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\\n\\t\\t\\t\\twidth: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\\n\\t\\t\\t\\theight: calc( var(--ck-todo-list-checkmark-size) / 2.6 );\\n\\t\\t\\t\\tborder-style: solid;\\n\\t\\t\\t\\tborder-color: transparent;\\n\\t\\t\\t\\tborder-width: 0 calc( var(--ck-todo-list-checkmark-size) / 8 ) calc( var(--ck-todo-list-checkmark-size) / 8 ) 0;\\n\\t\\t\\t\\ttransform: rotate(45deg);\\n\\t\\t\\t}\\n\\n\\t\\t\\t&[checked] {\\n\\t\\t\\t\\t&::before {\\n\\t\\t\\t\\t\\tbackground: hsl(126, 64%, 41%);\\n\\t\\t\\t\\t\\tborder-color: hsl(126, 64%, 41%);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t&::after {\\n\\t\\t\\t\\t\\tborder-color: hsl(0, 0%, 100%);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t& .todo-list__label__description {\\n\\t\\t\\tvertical-align: middle;\\n\\t\\t}\\n\\t}\\n}\\n\\n/* RTL styles */\\n[dir=\\"rtl\\"] .todo-list .todo-list__label > input {\\n\\tleft: 0;\\n\\tmargin-right: 0;\\n\\tright: -25px;\\n\\tmargin-left: -15px;\\n}\\n\\n/*\\n * To-do list should be interactive only during the editing\\n * (https://github.com/ckeditor/ckeditor5/issues/2090).\\n */\\n.ck-editor__editable .todo-list .todo-list__label > input {\\n\\tcursor: pointer;\\n\\n\\t&:hover::before {\\n\\t\\tbox-shadow: 0 0 0 5px hsla(0, 0%, 0%, 0.1);\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      5777: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck-content .media{clear:both;display:block;margin:.9em 0;min-width:15em}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembed.css",
            ],
            names: [],
            mappings: "AAKA,mBAGC,UAAW,CASX,aAAc,CAJd,aAAe,CAQf,cACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck-content .media {\\n\\t/* Don\\'t allow floated content overlap the media.\\n\\thttps://github.com/ckeditor/ckeditor5-media-embed/issues/53 */\\n\\tclear: both;\\n\\n\\t/* Make sure there is some space between the content and the media. */\\n\\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\\n\\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\\n\\tmargin: 0.9em 0;\\n\\n\\t/* Make sure media is not overriden with Bootstrap default \`flex\` value.\\n\\tSee: https://github.com/ckeditor/ckeditor5/issues/1373. */\\n\\tdisplay: block;\\n\\n\\t/* Give the media some minimal width in the content to prevent them\\n\\tfrom being "squashed" in tight spaces, e.g. in table cells (#44) */\\n\\tmin-width: 15em;\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      952: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck-media__wrapper .ck-media__placeholder{align-items:center;display:flex;flex-direction:column}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{display:block;overflow:hidden}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{background:var(--ck-color-base-foreground);padding:calc(var(--ck-spacing-standard)*3)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{background-position:50%;background-size:cover;height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);min-width:var(--ck-media-embed-placeholder-icon-size)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{height:100%;width:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);font-style:italic;text-align:center;text-overflow:ellipsis;white-space:nowrap}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-height:380px;max-width:300px}.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Im0yMDYuNDc3IDI2MC45LTI4Ljk4NyAyOC45ODdhNS4yMTggNS4yMTggMCAwIDAgMy43OCAxLjYxaDQ5LjYyMWMxLjY5NCAwIDMuMTktLjc5OCA0LjE0Ni0yLjAzN3oiIGZpbGw9IiM1Yzg4YzUiLz48cGF0aCBkPSJNMjI2Ljc0MiAyMjIuOTg4Yy05LjI2NiAwLTE2Ljc3NyA3LjE3LTE2Ljc3NyAxNi4wMTQuMDA3IDIuNzYyLjY2MyA1LjQ3NCAyLjA5MyA3Ljg3NS40My43MDMuODMgMS40MDggMS4xOSAyLjEwNy4zMzMuNTAyLjY1IDEuMDA1Ljk1IDEuNTA4LjM0My40NzcuNjczLjk1Ny45ODggMS40NCAxLjMxIDEuNzY5IDIuNSAzLjUwMiAzLjYzNyA1LjE2OC43OTMgMS4yNzUgMS42ODMgMi42NCAyLjQ2NiAzLjk5IDIuMzYzIDQuMDk0IDQuMDA3IDguMDkyIDQuNiAxMy45MTR2LjAxMmMuMTgyLjQxMi41MTYuNjY2Ljg3OS42NjcuNDAzLS4wMDEuNzY4LS4zMTQuOTMtLjc5OS42MDMtNS43NTYgMi4yMzgtOS43MjkgNC41ODUtMTMuNzk0Ljc4Mi0xLjM1IDEuNjczLTIuNzE1IDIuNDY1LTMuOTkgMS4xMzctMS42NjYgMi4zMjgtMy40IDMuNjM4LTUuMTY5LjMxNS0uNDgyLjY0NS0uOTYyLjk4OC0xLjQzOS4zLS41MDMuNjE3LTEuMDA2Ljk1LTEuNTA4LjM1OS0uNy43Ni0xLjQwNCAxLjE5LTIuMTA3IDEuNDI2LTIuNDAyIDItNS4xMTQgMi4wMDQtNy44NzUgMC04Ljg0NC03LjUxMS0xNi4wMTQtMTYuNzc2LTE2LjAxNHoiIGZpbGw9IiNkZDRiM2UiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PGVsbGlwc2Ugcnk9IjUuNTY0IiByeD0iNS44MjgiIGN5PSIyMzkuMDAyIiBjeD0iMjI2Ljc0MiIgZmlsbD0iIzgwMmQyNyIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMTkwLjMwMSAyMzcuMjgzYy00LjY3IDAtOC40NTcgMy44NTMtOC40NTcgOC42MDZzMy43ODYgOC42MDcgOC40NTcgOC42MDdjMy4wNDMgMCA0LjgwNi0uOTU4IDYuMzM3LTIuNTE2IDEuNTMtMS41NTcgMi4wODctMy45MTMgMi4wODctNi4yOSAwLS4zNjItLjAyMy0uNzIyLS4wNjQtMS4wNzloLTguMjU3djMuMDQzaDQuODVjLS4xOTcuNzU5LS41MzEgMS40NS0xLjA1OCAxLjk4Ni0uOTQyLjk1OC0yLjAyOCAxLjU0OC0zLjkwMSAxLjU0OC0yLjg3NiAwLTUuMjA4LTIuMzcyLTUuMjA4LTUuMjk5IDAtMi45MjYgMi4zMzItNS4yOTkgNS4yMDgtNS4yOTkgMS4zOTkgMCAyLjYxOC40MDcgMy41ODQgMS4yOTNsMi4zODEtMi4zOGMwLS4wMDItLjAwMy0uMDA0LS4wMDQtLjAwNS0xLjU4OC0xLjUyNC0zLjYyLTIuMjE1LTUuOTU1LTIuMjE1em00LjQzIDUuNjYuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0ibTIxNS4xODQgMjUxLjkyOS03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVhNS4yMzMgNS4yMzMgMCAwIDAgLjQ0OS0yLjEyM3YtMzEuMTY1Yy0uNDY5LjY3NS0uOTM0IDEuMzQ5LTEuMzgyIDIuMDA1LS43OTIgMS4yNzUtMS42ODIgMi42NC0yLjQ2NSAzLjk5LTIuMzQ3IDQuMDY1LTMuOTgyIDguMDM4LTQuNTg1IDEzLjc5NC0uMTYyLjQ4NS0uNTI3Ljc5OC0uOTMuNzk5LS4zNjMtLjAwMS0uNjk3LS4yNTUtLjg3OS0uNjY3di0uMDEyYy0uNTkzLTUuODIyLTIuMjM3LTkuODItNC42LTEzLjkxNC0uNzgzLTEuMzUtMS42NzMtMi43MTUtMi40NjYtMy45OS0xLjEzNy0xLjY2Ni0yLjMyNy0zLjQtMy42MzctNS4xNjlsLS4wMDItLjAwM3oiIGZpbGw9IiNjM2MzYzMiLz48cGF0aCBkPSJtMjEyLjk4MyAyNDguNDk1LTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOCA1LjIzOGgxLjAxNWwzNS42NjYtMzUuNjY2YTEzNi4yNzUgMTM2LjI3NSAwIDAgMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAgMC0uOTg5LTEuNDQgMzUuMTI3IDM1LjEyNyAwIDAgMC0uOTUtMS41MDhjLS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJtMjExLjk5OCAyNjEuMDgzLTYuMTUyIDYuMTUxIDI0LjI2NCAyNC4yNjRoLjc4MWE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OVptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OVoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzNabTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1Wk00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MDAgNDAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIHN0eWxlPSJmaWxsOiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembedediting.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-media-embed/mediaembedediting.css",
            ],
            names: [],
            mappings:
              "AAMC,0CAGC,kBAAmB,CAFnB,YAAa,CACb,qBAcD,CAXC,sEAEC,cAAe,CAEf,iBAMD,CAJC,wGAEC,aAAc,CADd,eAED,CAWD,6kBACC,YACD,CAYF,2LACC,mBACD,CC1CA,MACC,0CAA2C,CAE3C,mDAA4D,CAC5D,2EACD,CAEA,mBACC,aA+FD,CA7FC,0CAEC,0CAA2C,CAD3C,0CA6BD,CA1BC,uEAIC,uBAA2B,CAC3B,qBAAsB,CAHtB,kDAAmD,CACnD,qCAAsC,CAFtC,qDAUD,CAJC,gFAEC,WAAY,CADZ,UAED,CAGD,4EACC,sDAAuD,CAGvD,iBAAkB,CADlB,iBAAkB,CAElB,sBAAuB,CAHvB,kBAUD,CALC,kFACC,4DAA6D,CAC7D,cAAe,CACf,yBACD,CAIF,wDAEC,gBAAiB,CADjB,eAED,CAEA,4UAIC,wvGACD,CAEA,2EACC,kBAaD,CAXC,wGACC,orBACD,CAEA,6GACC,UAKD,CAHC,mHACC,UACD,CAIF,4EACC,2DAcD,CAZC,yGACC,4jHACD,CAGA,8GACC,aAKD,CAHC,oHACC,UACD,CAIF,6EAEC,iDAaD,CAXC,0GACC,wiCACD,CAEA,+GACC,aAKD,CAHC,qHACC,UACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck-media__wrapper {\\n\\t& .ck-media__placeholder {\\n\\t\\tdisplay: flex;\\n\\t\\tflex-direction: column;\\n\\t\\talign-items: center;\\n\\n\\t\\t& .ck-media__placeholder__url {\\n\\t\\t\\t/* Otherwise the URL will overflow when the content is very narrow. */\\n\\t\\t\\tmax-width: 100%;\\n\\n\\t\\t\\tposition: relative;\\n\\n\\t\\t\\t& .ck-media__placeholder__url__text {\\n\\t\\t\\t\\toverflow: hidden;\\n\\t\\t\\t\\tdisplay: block;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t&[data-oembed-url*="twitter.com"],\\n\\t&[data-oembed-url*="google.com/maps"],\\n\\t&[data-oembed-url*="goo.gl/maps"],\\n\\t&[data-oembed-url*="maps.google.com"],\\n\\t&[data-oembed-url*="maps.app.goo.gl"],\\n\\t&[data-oembed-url*="facebook.com"],\\n\\t&[data-oembed-url*="instagram.com"] {\\n\\t\\t& .ck-media__placeholder__icon * {\\n\\t\\t\\tdisplay: none;\\n\\t\\t}\\n\\t}\\n}\\n\\n/* Disable all mouse interaction as long as the editor is not readonly.\\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/58 */\\n.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper > *:not(.ck-media__placeholder) {\\n\\tpointer-events: none;\\n}\\n\\n/* Disable all mouse interaction when the widget is not selected (e.g. to avoid opening links by accident).\\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/18 */\\n.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder {\\n\\tpointer-events: none;\\n}\\n',
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-media-embed-placeholder-icon-size: 3em;\\n\\n\\t--ck-color-media-embed-placeholder-url-text: hsl(0, 0%, 46%);\\n\\t--ck-color-media-embed-placeholder-url-text-hover: var(--ck-color-base-text);\\n}\\n\\n.ck-media__wrapper {\\n\\tmargin: 0 auto;\\n\\n\\t& .ck-media__placeholder {\\n\\t\\tpadding: calc( 3 * var(--ck-spacing-standard) );\\n\\t\\tbackground: var(--ck-color-base-foreground);\\n\\n\\t\\t& .ck-media__placeholder__icon {\\n\\t\\t\\tmin-width: var(--ck-media-embed-placeholder-icon-size);\\n\\t\\t\\theight: var(--ck-media-embed-placeholder-icon-size);\\n\\t\\t\\tmargin-bottom: var(--ck-spacing-large);\\n\\t\\t\\tbackground-position: center;\\n\\t\\t\\tbackground-size: cover;\\n\\n\\t\\t\\t& .ck-icon {\\n\\t\\t\\t\\twidth: 100%;\\n\\t\\t\\t\\theight: 100%;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t& .ck-media__placeholder__url__text {\\n\\t\\t\\tcolor: var(--ck-color-media-embed-placeholder-url-text);\\n\\t\\t\\twhite-space: nowrap;\\n\\t\\t\\ttext-align: center;\\n\\t\\t\\tfont-style: italic;\\n\\t\\t\\ttext-overflow: ellipsis;\\n\\n\\t\\t\\t&:hover {\\n\\t\\t\\t\\tcolor: var(--ck-color-media-embed-placeholder-url-text-hover);\\n\\t\\t\\t\\tcursor: pointer;\\n\\t\\t\\t\\ttext-decoration: underline;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t&[data-oembed-url*="open.spotify.com"] {\\n\\t\\tmax-width: 300px;\\n\\t\\tmax-height: 380px;\\n\\t}\\n\\n\\t&[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,\\n\\t&[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,\\n\\t&[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon,\\n\\t&[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon {\\n\\t\\tbackground-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMCAwIDMuNzggMS42MWg0OS42MjFjMS42OTQgMCAzLjE5LS43OTggNC4xNDYtMi4wMzd6IiBmaWxsPSIjNWM4OGM1Ii8+PHBhdGggZD0iTTIyNi43NDIgMjIyLjk4OGMtOS4yNjYgMC0xNi43NzcgNy4xNy0xNi43NzcgMTYuMDE0LjAwNyAyLjc2Mi42NjMgNS40NzQgMi4wOTMgNy44NzUuNDMuNzAzLjgzIDEuNDA4IDEuMTkgMi4xMDcuMzMzLjUwMi42NSAxLjAwNS45NSAxLjUwOC4zNDMuNDc3LjY3My45NTcuOTg4IDEuNDQgMS4zMSAxLjc2OSAyLjUgMy41MDIgMy42MzcgNS4xNjguNzkzIDEuMjc1IDEuNjgzIDIuNjQgMi40NjYgMy45OSAyLjM2MyA0LjA5NCA0LjAwNyA4LjA5MiA0LjYgMTMuOTE0di4wMTJjLjE4Mi40MTIuNTE2LjY2Ni44NzkuNjY3LjQwMy0uMDAxLjc2OC0uMzE0LjkzLS43OTkuNjAzLTUuNzU2IDIuMjM4LTkuNzI5IDQuNTg1LTEzLjc5NC43ODItMS4zNSAxLjY3My0yLjcxNSAyLjQ2NS0zLjk5IDEuMTM3LTEuNjY2IDIuMzI4LTMuNCAzLjYzOC01LjE2OS4zMTUtLjQ4Mi42NDUtLjk2Mi45ODgtMS40MzkuMy0uNTAzLjYxNy0xLjAwNi45NS0xLjUwOC4zNTktLjcuNzYtMS40MDQgMS4xOS0yLjEwNyAxLjQyNi0yLjQwMiAyLTUuMTE0IDIuMDA0LTcuODc1IDAtOC44NDQtNy41MTEtMTYuMDE0LTE2Ljc3Ni0xNi4wMTR6IiBmaWxsPSIjZGQ0YjNlIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxlbGxpcHNlIHJ5PSI1LjU2NCIgcng9IjUuODI4IiBjeT0iMjM5LjAwMiIgY3g9IjIyNi43NDIiIGZpbGw9IiM4MDJkMjciIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTE5MC4zMDEgMjM3LjI4M2MtNC42NyAwLTguNDU3IDMuODUzLTguNDU3IDguNjA2czMuNzg2IDguNjA3IDguNDU3IDguNjA3YzMuMDQzIDAgNC44MDYtLjk1OCA2LjMzNy0yLjUxNiAxLjUzLTEuNTU3IDIuMDg3LTMuOTEzIDIuMDg3LTYuMjkgMC0uMzYyLS4wMjMtLjcyMi0uMDY0LTEuMDc5aC04LjI1N3YzLjA0M2g0Ljg1Yy0uMTk3Ljc1OS0uNTMxIDEuNDUtMS4wNTggMS45ODYtLjk0Mi45NTgtMi4wMjggMS41NDgtMy45MDEgMS41NDgtMi44NzYgMC01LjIwOC0yLjM3Mi01LjIwOC01LjI5OSAwLTIuOTI2IDIuMzMyLTUuMjk5IDUuMjA4LTUuMjk5IDEuMzk5IDAgMi42MTguNDA3IDMuNTg0IDEuMjkzbDIuMzgxLTIuMzhjMC0uMDAyLS4wMDMtLjAwNC0uMDA0LS4wMDUtMS41ODgtMS41MjQtMy42Mi0yLjIxNS01Ljk1NS0yLjIxNXptNC40MyA1LjY2bC4wMDMuMDA2di0uMDAzeiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjE1LjE4NCAyNTEuOTI5bC03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVjLjI4Ny0uNjQ5LjQ0OS0xLjM2Ni40NDktMi4xMjN2LTMxLjE2NWMtLjQ2OS42NzUtLjkzNCAxLjM0OS0xLjM4MiAyLjAwNS0uNzkyIDEuMjc1LTEuNjgyIDIuNjQtMi40NjUgMy45OS0yLjM0NyA0LjA2NS0zLjk4MiA4LjAzOC00LjU4NSAxMy43OTQtLjE2Mi40ODUtLjUyNy43OTgtLjkzLjc5OS0uMzYzLS4wMDEtLjY5Ny0uMjU1LS44NzktLjY2N3YtLjAxMmMtLjU5My01LjgyMi0yLjIzNy05LjgyLTQuNi0xMy45MTQtLjc4My0xLjM1LTEuNjczLTIuNzE1LTIuNDY2LTMuOTktMS4xMzctMS42NjYtMi4zMjctMy40LTMuNjM3LTUuMTY5bC0uMDAyLS4wMDN6IiBmaWxsPSIjYzNjM2MzIi8+PHBhdGggZD0iTTIxMi45ODMgMjQ4LjQ5NWwtMzYuOTUyIDM2Ljk1M3YuODEyYTUuMjI3IDUuMjI3IDAgMCAwIDUuMjM4IDUuMjM4aDEuMDE1bDM1LjY2Ni0zNS42NjZhMTM2LjI3NSAxMzYuMjc1IDAgMCAwLTIuNzY0LTMuOSAzNy41NzUgMzcuNTc1IDAgMCAwLS45ODktMS40NGMtLjI5OS0uNTAzLS42MTYtMS4wMDYtLjk1LTEuNTA4LS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjExLjk5OCAyNjEuMDgzbC02LjE1MiA2LjE1MSAyNC4yNjQgMjQuMjY0aC43ODFhNS4yMjcgNS4yMjcgMCAwIDAgNS4yMzktNS4yMzh2LTEuMDQ1eiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48L2c+PC9zdmc+);\\n\\t}\\n\\n\\t&[data-oembed-url*="facebook.com"] .ck-media__placeholder {\\n\\t\\tbackground: hsl(220, 46%, 48%);\\n\\n\\t\\t& .ck-media__placeholder__icon {\\n\\t\\t\\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIxMDI0cHgiIGhlaWdodD0iMTAyNHB4IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPiAgICAgICAgPHRpdGxlPkZpbGwgMTwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgICAgICAgPGcgaWQ9ImZMb2dvX1doaXRlIiBmaWxsPSIjRkZGRkZFIj4gICAgICAgICAgICA8cGF0aCBkPSJNOTY3LjQ4NCwwIEw1Ni41MTcsMCBDMjUuMzA0LDAgMCwyNS4zMDQgMCw1Ni41MTcgTDAsOTY3LjQ4MyBDMCw5OTguNjk0IDI1LjI5NywxMDI0IDU2LjUyMiwxMDI0IEw1NDcsMTAyNCBMNTQ3LDYyOCBMNDE0LDYyOCBMNDE0LDQ3MyBMNTQ3LDQ3MyBMNTQ3LDM1OS4wMjkgQzU0NywyMjYuNzY3IDYyNy43NzMsMTU0Ljc0NyA3NDUuNzU2LDE1NC43NDcgQzgwMi4yNjksMTU0Ljc0NyA4NTAuODQyLDE1OC45NTUgODY1LDE2MC44MzYgTDg2NSwyOTkgTDc4My4zODQsMjk5LjAzNyBDNzE5LjM5MSwyOTkuMDM3IDcwNywzMjkuNTI5IDcwNywzNzQuMjczIEw3MDcsNDczIEw4NjAuNDg3LDQ3MyBMODQwLjUwMSw2MjggTDcwNyw2MjggTDcwNywxMDI0IEw5NjcuNDg0LDEwMjQgQzk5OC42OTcsMTAyNCAxMDI0LDk5OC42OTcgMTAyNCw5NjcuNDg0IEwxMDI0LDU2LjUxNSBDMTAyNCwyNS4zMDMgOTk4LjY5NywwIDk2Ny40ODQsMCIgaWQ9IkZpbGwtMSI+PC9wYXRoPiAgICAgICAgPC9nPiAgICA8L2c+PC9zdmc+);\\n\\t\\t}\\n\\n\\t\\t& .ck-media__placeholder__url__text {\\n\\t\\t\\tcolor: hsl(220, 100%, 90%);\\n\\n\\t\\t\\t&:hover {\\n\\t\\t\\t\\tcolor: hsl(0, 0%, 100%);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t&[data-oembed-url*="instagram.com"] .ck-media__placeholder {\\n\\t\\tbackground: linear-gradient(-135deg,hsl(246, 100%, 39%),hsl(302, 100%, 36%),hsl(0, 100%, 48%));\\n\\n\\t\\t& .ck-media__placeholder__icon {\\n\\t\\t\\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSI1MDRweCIgaGVpZ2h0PSI1MDRweCIgdmlld0JveD0iMCAwIDUwNCA1MDQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+ICAgICAgICA8dGl0bGU+Z2x5cGgtbG9nb19NYXkyMDE2PC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMSIgcG9pbnRzPSIwIDAuMTU5IDUwMy44NDEgMC4xNTkgNTAzLjg0MSA1MDMuOTQgMCA1MDMuOTQiPjwvcG9seWdvbj4gICAgPC9kZWZzPiAgICA8ZyBpZD0iZ2x5cGgtbG9nb19NYXkyMDE2IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4gICAgICAgIDxnIGlkPSJHcm91cC0zIj4gICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+ICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+ICAgICAgICAgICAgPC9tYXNrPiAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4gICAgICAgICAgICA8cGF0aCBkPSJNMjUxLjkyMSwwLjE1OSBDMTgzLjUwMywwLjE1OSAxNzQuOTI0LDAuNDQ5IDE0OC4wNTQsMS42NzUgQzEyMS4yNCwyLjg5OCAxMDIuOTI3LDcuMTU3IDg2LjkwMywxMy4zODUgQzcwLjMzNywxOS44MjIgNTYuMjg4LDI4LjQzNiA0Mi4yODIsNDIuNDQxIEMyOC4yNzcsNTYuNDQ3IDE5LjY2Myw3MC40OTYgMTMuMjI2LDg3LjA2MiBDNi45OTgsMTAzLjA4NiAyLjczOSwxMjEuMzk5IDEuNTE2LDE0OC4yMTMgQzAuMjksMTc1LjA4MyAwLDE4My42NjIgMCwyNTIuMDggQzAsMzIwLjQ5NyAwLjI5LDMyOS4wNzYgMS41MTYsMzU1Ljk0NiBDMi43MzksMzgyLjc2IDYuOTk4LDQwMS4wNzMgMTMuMjI2LDQxNy4wOTcgQzE5LjY2Myw0MzMuNjYzIDI4LjI3Nyw0NDcuNzEyIDQyLjI4Miw0NjEuNzE4IEM1Ni4yODgsNDc1LjcyMyA3MC4zMzcsNDg0LjMzNyA4Ni45MDMsNDkwLjc3NSBDMTAyLjkyNyw0OTcuMDAyIDEyMS4yNCw1MDEuMjYxIDE0OC4wNTQsNTAyLjQ4NCBDMTc0LjkyNCw1MDMuNzEgMTgzLjUwMyw1MDQgMjUxLjkyMSw1MDQgQzMyMC4zMzgsNTA0IDMyOC45MTcsNTAzLjcxIDM1NS43ODcsNTAyLjQ4NCBDMzgyLjYwMSw1MDEuMjYxIDQwMC45MTQsNDk3LjAwMiA0MTYuOTM4LDQ5MC43NzUgQzQzMy41MDQsNDg0LjMzNyA0NDcuNTUzLDQ3NS43MjMgNDYxLjU1OSw0NjEuNzE4IEM0NzUuNTY0LDQ0Ny43MTIgNDg0LjE3OCw0MzMuNjYzIDQ5MC42MTYsNDE3LjA5NyBDNDk2Ljg0Myw0MDEuMDczIDUwMS4xMDIsMzgyLjc2IDUwMi4zMjUsMzU1Ljk0NiBDNTAzLjU1MSwzMjkuMDc2IDUwMy44NDEsMzIwLjQ5NyA1MDMuODQxLDI1Mi4wOCBDNTAzLjg0MSwxODMuNjYyIDUwMy41NTEsMTc1LjA4MyA1MDIuMzI1LDE0OC4yMTMgQzUwMS4xMDIsMTIxLjM5OSA0OTYuODQzLDEwMy4wODYgNDkwLjYxNiw4Ny4wNjIgQzQ4NC4xNzgsNzAuNDk2IDQ3NS41NjQsNTYuNDQ3IDQ2MS41NTksNDIuNDQxIEM0NDcuNTUzLDI4LjQzNiA0MzMuNTA0LDE5LjgyMiA0MTYuOTM4LDEzLjM4NSBDNDAwLjkxNCw3LjE1NyAzODIuNjAxLDIuODk4IDM1NS43ODcsMS42NzUgQzMyOC45MTcsMC40NDkgMzIwLjMzOCwwLjE1OSAyNTEuOTIxLDAuMTU5IFogTTI1MS45MjEsNDUuNTUgQzMxOS4xODYsNDUuNTUgMzI3LjE1NCw0NS44MDcgMzUzLjcxOCw0Ny4wMTkgQzM3OC4yOCw0OC4xMzkgMzkxLjYxOSw1Mi4yNDMgNDAwLjQ5Niw1NS42OTMgQzQxMi4yNTUsNjAuMjYzIDQyMC42NDcsNjUuNzIyIDQyOS40NjIsNzQuNTM4IEM0MzguMjc4LDgzLjM1MyA0NDMuNzM3LDkxLjc0NSA0NDguMzA3LDEwMy41MDQgQzQ1MS43NTcsMTEyLjM4MSA0NTUuODYxLDEyNS43MiA0NTYuOTgxLDE1MC4yODIgQzQ1OC4xOTMsMTc2Ljg0NiA0NTguNDUsMTg0LjgxNCA0NTguNDUsMjUyLjA4IEM0NTguNDUsMzE5LjM0NSA0NTguMTkzLDMyNy4zMTMgNDU2Ljk4MSwzNTMuODc3IEM0NTUuODYxLDM3OC40MzkgNDUxLjc1NywzOTEuNzc4IDQ0OC4zMDcsNDAwLjY1NSBDNDQzLjczNyw0MTIuNDE0IDQzOC4yNzgsNDIwLjgwNiA0MjkuNDYyLDQyOS42MjEgQzQyMC42NDcsNDM4LjQzNyA0MTIuMjU1LDQ0My44OTYgNDAwLjQ5Niw0NDguNDY2IEMzOTEuNjE5LDQ1MS45MTYgMzc4LjI4LDQ1Ni4wMiAzNTMuNzE4LDQ1Ny4xNCBDMzI3LjE1OCw0NTguMzUyIDMxOS4xOTEsNDU4LjYwOSAyNTEuOTIxLDQ1OC42MDkgQzE4NC42NSw0NTguNjA5IDE3Ni42ODQsNDU4LjM1MiAxNTAuMTIzLDQ1Ny4xNCBDMTI1LjU2MSw0NTYuMDIgMTEyLjIyMiw0NTEuOTE2IDEwMy4zNDUsNDQ4LjQ2NiBDOTEuNTg2LDQ0My44OTYgODMuMTk0LDQzOC40MzcgNzQuMzc5LDQyOS42MjEgQzY1LjU2NCw0MjAuODA2IDYwLjEwNCw0MTIuNDE0IDU1LjUzNCw0MDAuNjU1IEM1Mi4wODQsMzkxLjc3OCA0Ny45OCwzNzguNDM5IDQ2Ljg2LDM1My44NzcgQzQ1LjY0OCwzMjcuMzEzIDQ1LjM5MSwzMTkuMzQ1IDQ1LjM5MSwyNTIuMDggQzQ1LjM5MSwxODQuODE0IDQ1LjY0OCwxNzYuODQ2IDQ2Ljg2LDE1MC4yODIgQzQ3Ljk4LDEyNS43MiA1Mi4wODQsMTEyLjM4MSA1NS41MzQsMTAzLjUwNCBDNjAuMTA0LDkxLjc0NSA2NS41NjMsODMuMzUzIDc0LjM3OSw3NC41MzggQzgzLjE5NCw2NS43MjIgOTEuNTg2LDYwLjI2MyAxMDMuMzQ1LDU1LjY5MyBDMTEyLjIyMiw1Mi4yNDMgMTI1LjU2MSw0OC4xMzkgMTUwLjEyMyw0Ny4wMTkgQzE3Ni42ODcsNDUuODA3IDE4NC42NTUsNDUuNTUgMjUxLjkyMSw0NS41NSBaIiBpZD0iRmlsbC0xIiBmaWxsPSIjRkZGRkZGIiBtYXNrPSJ1cmwoI21hc2stMikiPjwvcGF0aD4gICAgICAgIDwvZz4gICAgICAgIDxwYXRoIGQ9Ik0yNTEuOTIxLDMzNi4wNTMgQzIwNS41NDMsMzM2LjA1MyAxNjcuOTQ3LDI5OC40NTcgMTY3Ljk0NywyNTIuMDggQzE2Ny45NDcsMjA1LjcwMiAyMDUuNTQzLDE2OC4xMDYgMjUxLjkyMSwxNjguMTA2IEMyOTguMjk4LDE2OC4xMDYgMzM1Ljg5NCwyMDUuNzAyIDMzNS44OTQsMjUyLjA4IEMzMzUuODk0LDI5OC40NTcgMjk4LjI5OCwzMzYuMDUzIDI1MS45MjEsMzM2LjA1MyBaIE0yNTEuOTIxLDEyMi43MTUgQzE4MC40NzQsMTIyLjcxNSAxMjIuNTU2LDE4MC42MzMgMTIyLjU1NiwyNTIuMDggQzEyMi41NTYsMzIzLjUyNiAxODAuNDc0LDM4MS40NDQgMjUxLjkyMSwzODEuNDQ0IEMzMjMuMzY3LDM4MS40NDQgMzgxLjI4NSwzMjMuNTI2IDM4MS4yODUsMjUyLjA4IEMzODEuMjg1LDE4MC42MzMgMzIzLjM2NywxMjIuNzE1IDI1MS45MjEsMTIyLjcxNSBaIiBpZD0iRmlsbC00IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgICAgICA8cGF0aCBkPSJNNDE2LjYyNywxMTcuNjA0IEM0MTYuNjI3LDEzNC4zIDQwMy4wOTIsMTQ3LjgzNCAzODYuMzk2LDE0Ny44MzQgQzM2OS43MDEsMTQ3LjgzNCAzNTYuMTY2LDEzNC4zIDM1Ni4xNjYsMTE3LjYwNCBDMzU2LjE2NiwxMDAuOTA4IDM2OS43MDEsODcuMzczIDM4Ni4zOTYsODcuMzczIEM0MDMuMDkyLDg3LjM3MyA0MTYuNjI3LDEwMC45MDggNDE2LjYyNywxMTcuNjA0IiBpZD0iRmlsbC01IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgIDwvZz48L3N2Zz4=);\\n\\t\\t}\\n\\n\\t\\t/* stylelint-disable-next-line no-descending-specificity */\\n\\t\\t& .ck-media__placeholder__url__text {\\n\\t\\t\\tcolor: hsl(302, 100%, 94%);\\n\\n\\t\\t\\t&:hover {\\n\\t\\t\\t\\tcolor: hsl(0, 0%, 100%);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t&[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder {\\n\\t\\t/* Use gradient to contrast with focused widget (ckeditor/ckeditor5-media-embed#22). */\\n\\t\\tbackground: linear-gradient( to right, hsl(201, 85%, 70%), hsl(201, 85%, 35%) );\\n\\n\\t\\t& .ck-media__placeholder__icon {\\n\\t\\t\\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IldoaXRlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQwMCA0MDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7ZmlsbDojRkZGRkZGO308L3N0eWxlPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMjAwYzAsMTEwLjUtODkuNSwyMDAtMjAwLDIwMFMwLDMxMC41LDAsMjAwUzg5LjUsMCwyMDAsMFM0MDAsODkuNSw0MDAsMjAweiBNMTYzLjQsMzA1LjVjODguNywwLDEzNy4yLTczLjUsMTM3LjItMTM3LjJjMC0yLjEsMC00LjItMC4xLTYuMmM5LjQtNi44LDE3LjYtMTUuMywyNC4xLTI1Yy04LjYsMy44LTE3LjksNi40LTI3LjcsNy42YzEwLTYsMTcuNi0xNS40LDIxLjItMjYuN2MtOS4zLDUuNS0xOS42LDkuNS0zMC42LDExLjdjLTguOC05LjQtMjEuMy0xNS4yLTM1LjItMTUuMmMtMjYuNiwwLTQ4LjIsMjEuNi00OC4yLDQ4LjJjMCwzLjgsMC40LDcuNSwxLjMsMTFjLTQwLjEtMi03NS42LTIxLjItOTkuNC01MC40Yy00LjEsNy4xLTYuNSwxNS40LTYuNSwyNC4yYzAsMTYuNyw4LjUsMzEuNSwyMS41LDQwLjFjLTcuOS0wLjItMTUuMy0yLjQtMjEuOC02YzAsMC4yLDAsMC40LDAsMC42YzAsMjMuNCwxNi42LDQyLjgsMzguNyw0Ny4zYy00LDEuMS04LjMsMS43LTEyLjcsMS43Yy0zLjEsMC02LjEtMC4zLTkuMS0wLjljNi4xLDE5LjIsMjMuOSwzMy4xLDQ1LDMzLjVjLTE2LjUsMTIuOS0zNy4zLDIwLjYtNTkuOSwyMC42Yy0zLjksMC03LjctMC4yLTExLjUtMC43QzExMC44LDI5Ny41LDEzNi4yLDMwNS41LDE2My40LDMwNS41Ii8+PC9zdmc+);\\n\\t\\t}\\n\\n\\t\\t& .ck-media__placeholder__url__text {\\n\\t\\t\\tcolor: hsl(201, 100%, 86%);\\n\\n\\t\\t\\t&:hover {\\n\\t\\t\\t\\tcolor: hsl(0, 0%, 100%);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      3525: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-media-form{align-items:flex-start;display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaform.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
            ],
            names: [],
            mappings:
              "AAOA,kBAEC,sBAAuB,CADvB,YAAa,CAEb,kBAAmB,CACnB,gBAqBD,CAnBC,yCACC,oBACD,CAEA,4BACC,YACD,CCbA,oCDCD,kBAeE,cAUF,CARE,yCACC,eACD,CAEA,6BACC,cACD,CCtBD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\\n\\n.ck.ck-media-form {\\n\\tdisplay: flex;\\n\\talign-items: flex-start;\\n\\tflex-direction: row;\\n\\tflex-wrap: nowrap;\\n\\n\\t& .ck-labeled-field-view {\\n\\t\\tdisplay: inline-block;\\n\\t}\\n\\n\\t& .ck-label {\\n\\t\\tdisplay: none;\\n\\t}\\n\\n\\t@mixin ck-media-phone {\\n\\t\\tflex-wrap: wrap;\\n\\n\\t\\t& .ck-labeled-field-view {\\n\\t\\t\\tflex-basis: 100%;\\n\\t\\t}\\n\\n\\t\\t& .ck-button {\\n\\t\\t\\tflex-basis: 50%;\\n\\t\\t}\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@define-mixin ck-media-phone {\\n\\t@media screen and (max-width: 600px) {\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      7583: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ":root{--ck-color-mention-background:rgba(153,0,48,.1);--ck-color-mention-text:#990030}.ck-content .mention{background:var(--ck-color-mention-background);color:var(--ck-color-mention-text)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-mention/mention.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,+CAAwD,CACxD,+BACD,CAEA,qBACC,6CAA8C,CAC9C,kCACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-color-mention-background: hsla(341, 100%, 30%, 0.1);\\n\\t--ck-color-mention-text: hsl(341, 100%, 30%);\\n}\\n\\n.ck-content .mention {\\n\\tbackground: var(--ck-color-mention-background);\\n\\tcolor: var(--ck-color-mention-text);\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      6391: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ":root{--ck-mention-list-max-height:300px}.ck.ck-mentions{max-height:var(--ck-mention-list-max-height);overflow-x:hidden;overflow-y:auto;overscroll-behavior:contain}.ck.ck-mentions>.ck-list__item{flex-shrink:0;overflow:hidden}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-mention/theme/mentionui.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,kCACD,CAEA,gBACC,4CAA6C,CAM7C,iBAAkB,CAJlB,eAAgB,CAMhB,2BAQD,CAJC,+BAEC,aAAc,CADd,eAED",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-mention-list-max-height: 300px;\\n}\\n\\n.ck.ck-mentions {\\n\\tmax-height: var(--ck-mention-list-max-height);\\n\\n\\toverflow-y: auto;\\n\\n\\t/* Prevent unnecessary horizontal scrollbar in Safari\\n\\thttps://github.com/ckeditor/ckeditor5-mention/issues/41 */\\n\\toverflow-x: hidden;\\n\\n\\toverscroll-behavior: contain;\\n\\n\\t/* Prevent unnecessary vertical scrollbar in Safari\\n\\thttps://github.com/ckeditor/ckeditor5-mention/issues/41 */\\n\\t& > .ck-list__item {\\n\\t\\toverflow: hidden;\\n\\t\\tflex-shrink: 0;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      671: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck-source-editing-area{overflow:hidden;position:relative}.ck-source-editing-area textarea,.ck-source-editing-area:after{border:1px solid transparent;font-family:monospace;font-size:var(--ck-font-size-normal);line-height:var(--ck-line-height-base);margin:0;padding:var(--ck-spacing-large);white-space:pre-wrap}.ck-source-editing-area:after{content:attr(data-value) " ";display:block;visibility:hidden}.ck-source-editing-area textarea{border-color:var(--ck-color-base-border);border-radius:0;box-sizing:border-box;height:100%;outline:none;overflow:hidden;position:absolute;resize:none;width:100%}.ck-rounded-corners .ck-source-editing-area textarea,.ck-source-editing-area textarea.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck-source-editing-area textarea:not([readonly]):focus{border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-source-editing/theme/sourceediting.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AASA,wBAEC,eAAgB,CADhB,iBAED,CAEA,+DAIC,4BAA6B,CAG7B,qBAAsB,CADtB,oCAAqC,CADrC,sCAAuC,CAFvC,QAAS,CADT,+BAAgC,CAMhC,oBACD,CAEA,8BACC,4BAA6B,CAE7B,aAAc,CADd,iBAED,CAEA,iCASC,wCAAyC,CC7BzC,eAAgB,CD2BhB,qBAAsB,CAJtB,WAAY,CAEZ,YAAa,CACb,eAAgB,CALhB,iBAAkB,CAGlB,WAAY,CAFZ,UAkBD,CApBA,yGChBE,qCAAsC,CD4BtC,wBAAyB,CACzB,yBAOF,CAJC,uDEpCA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFwCA",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css";\\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css";\\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css";\\n\\n.ck-source-editing-area {\\n\\tposition: relative;\\n\\toverflow: hidden;\\n}\\n\\n.ck-source-editing-area::after,\\n.ck-source-editing-area textarea {\\n\\tpadding: var(--ck-spacing-large);\\n\\tmargin: 0;\\n\\tborder: 1px solid transparent;\\n\\tline-height: var(--ck-line-height-base);\\n\\tfont-size: var(--ck-font-size-normal);\\n\\tfont-family: monospace;\\n\\twhite-space: pre-wrap;\\n}\\n\\n.ck-source-editing-area::after {\\n\\tcontent: attr(data-value) " ";\\n\\tvisibility: hidden;\\n\\tdisplay: block;\\n}\\n\\n.ck-source-editing-area textarea {\\n\\tposition: absolute;\\n\\twidth: 100%;\\n\\theight: 100%;\\n\\tresize: none;\\n\\toutline: none;\\n\\toverflow: hidden;\\n\\tbox-sizing: border-box;\\n\\n\\tborder-color: var(--ck-color-base-border);\\n\\n\\t@mixin ck-rounded-corners {\\n\\t\\tborder-top-left-radius: 0;\\n\\t\\tborder-top-right-radius: 0;\\n\\t}\\n\\n\\t&:not([readonly]):focus {\\n\\t\\t@mixin ck-focus-ring;\\n\\t\\t@mixin ck-box-shadow var(--ck-inner-shadow);\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Implements rounded corner interface for .ck-rounded-corners class.\\n *\\n * @see $ck-border-radius\\n */\\n@define-mixin ck-rounded-corners {\\n\\tborder-radius: 0;\\n\\n\\t@nest .ck-rounded-corners &,\\n\\t&.ck-rounded-corners {\\n\\t\\tborder-radius: var(--ck-border-radius);\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A visual style of focused element's border.\\n */\\n@define-mixin ck-focus-ring {\\n\\t/* Disable native outline. */\\n\\toutline: none;\\n\\tborder: var(--ck-focus-ring)\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A helper to combine multiple shadows.\\n */\\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\\n\\tbox-shadow: $shadowA, $shadowB;\\n}\\n\\n/**\\n * Gives an element a drop shadow so it looks like a floating panel.\\n */\\n@define-mixin ck-drop-shadow {\\n\\t@mixin ck-box-shadow var(--ck-drop-shadow);\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      4046: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-character-grid{max-width:100%}.ck.ck-character-grid .ck-character-grid__tiles{display:grid}:root{--ck-character-grid-tile-size:24px}.ck.ck-character-grid{max-height:200px;overflow-x:hidden;overflow-y:auto;width:350px}@media screen and (max-width:600px){.ck.ck-character-grid{width:190px}}.ck.ck-character-grid .ck-character-grid__tiles{grid-gap:var(--ck-spacing-standard);grid-template-columns:repeat(10,1fr);margin:var(--ck-spacing-standard) var(--ck-spacing-large)}@media screen and (max-width:600px){.ck.ck-character-grid .ck-character-grid__tiles{grid-template-columns:repeat(5,1fr)}}.ck.ck-character-grid .ck-character-grid__tile{border:0;font-size:1.2em;height:var(--ck-character-grid-tile-size);min-height:var(--ck-character-grid-tile-size);min-width:var(--ck-character-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-character-grid-tile-size)}.ck.ck-character-grid .ck-character-grid__tile:focus:not(.ck-disabled),.ck.ck-character-grid .ck-character-grid__tile:hover:not(.ck-disabled){border:0;box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-character-grid .ck-character-grid__tile .ck-button__label{line-height:var(--ck-character-grid-tile-size);text-align:center;width:100%}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-special-characters/theme/charactergrid.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/charactergrid.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
            ],
            names: [],
            mappings:
              "AAKA,sBACC,cAKD,CAHC,gDACC,YACD,CCFD,MACC,kCACD,CAEA,sBAIC,gBAAiB,CAFjB,iBAAkB,CADlB,eAAgB,CAEhB,WAyCD,CClDC,oCDMD,sBAOE,WAqCF,CChDC,CDcA,gDAGC,mCAAoC,CAFpC,oCAAsC,CACtC,yDAMD,CCxBA,oCDgBA,gDAME,mCAEF,CCtBA,CDwBA,+CAQC,QAAS,CAHT,eAAgB,CAHhB,yCAA0C,CAE1C,6CAA8C,CAD9C,4CAA6C,CAG7C,SAAU,CACV,8BAA+B,CAN/B,wCAsBD,CAbC,8IAGC,QAAS,CACT,iGACD,CAGA,iEACC,8CAA+C,CAE/C,iBAAkB,CADlB,UAED",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-character-grid {\\n\\tmax-width: 100%;\\n\\t\\n\\t& .ck-character-grid__tiles {\\n\\t\\tdisplay: grid;\\n\\t}\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\\n@import "../mixins/_rounded.css";\\n\\n:root {\\n\\t--ck-character-grid-tile-size: 24px;\\n}\\n\\n.ck.ck-character-grid {\\n\\toverflow-y: auto;\\n\\toverflow-x: hidden;\\n\\twidth: 350px;\\n\\tmax-height: 200px;\\n\\n\\t@mixin ck-media-phone {\\n\\t\\twidth: 190px;\\n\\t}\\n\\n\\t& .ck-character-grid__tiles {\\n\\t\\tgrid-template-columns: repeat(10, 1fr);\\n\\t\\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\\n\\t\\tgrid-gap: var(--ck-spacing-standard);\\n\\n\\t\\t@mixin ck-media-phone {\\n\\t\\t\\tgrid-template-columns: repeat(5, 1fr);\\n\\t\\t}\\n\\t}\\n\\n\\t& .ck-character-grid__tile {\\n\\t\\twidth: var(--ck-character-grid-tile-size);\\n\\t\\theight: var(--ck-character-grid-tile-size);\\n\\t\\tmin-width: var(--ck-character-grid-tile-size);\\n\\t\\tmin-height: var(--ck-character-grid-tile-size);\\n\\t\\tfont-size: 1.2em;\\n\\t\\tpadding: 0;\\n\\t\\ttransition: .2s ease box-shadow;\\n\\t\\tborder: 0;\\n\\n\\t\\t&:focus:not( .ck-disabled ),\\n\\t\\t&:hover:not( .ck-disabled ) {\\n\\t\\t\\t/* Disable the default .ck-button\\'s border ring. */\\n\\t\\t\\tborder: 0;\\n\\t\\t\\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\\n\\t\\t}\\n\\n\\t\\t/* Make sure the glyph is rendered in the center of the button */\\n\\t\\t& .ck-button__label {\\n\\t\\t\\tline-height: var(--ck-character-grid-tile-size);\\n\\t\\t\\twidth: 100%;\\n\\t\\t\\ttext-align: center;\\n\\t\\t}\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@define-mixin ck-media-phone {\\n\\t@media screen and (max-width: 600px) {\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      4779: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-character-info{border-top:1px solid var(--ck-color-base-border);display:flex;justify-content:space-between;padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-character-info>*{font-size:var(--ck-font-size-small);text-transform:uppercase}.ck.ck-character-info .ck-character-info__name{max-width:280px;overflow:hidden;text-overflow:ellipsis}.ck.ck-character-info .ck-character-info__code{opacity:.6}@media screen and (max-width:600px){.ck.ck-character-info{max-width:190px}}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-special-characters/theme/characterinfo.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/characterinfo.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
            ],
            names: [],
            mappings:
              "AAKA,sBCIC,gDAAiD,CDHjD,YAAa,CACb,6BAA8B,CCC9B,uDDAD,CCGC,wBAEC,mCAAoC,CADpC,wBAED,CAEA,+CACC,eAAgB,CAEhB,eAAgB,CADhB,sBAED,CAEA,+CACC,UACD,CClBA,oCDCD,sBAoBE,eAEF,CCrBC",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-character-info {\\n\\tdisplay: flex;\\n\\tjustify-content: space-between;\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\\n\\n.ck.ck-character-info {\\n\\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\\n\\tborder-top: 1px solid var(--ck-color-base-border);\\n\\n\\t& > * {\\n\\t\\ttext-transform: uppercase;\\n\\t\\tfont-size: var(--ck-font-size-small);\\n\\t}\\n\\n\\t& .ck-character-info__name {\\n\\t\\tmax-width: 280px;\\n\\t\\ttext-overflow: ellipsis;\\n\\t\\toverflow: hidden;\\n\\t}\\n\\n\\t& .ck-character-info__code {\\n\\t\\topacity: .6;\\n\\t}\\n\\n\\t@mixin ck-media-phone {\\n\\t\\tmax-width: 190px;\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@define-mixin ck-media-phone {\\n\\t@media screen and (max-width: 600px) {\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      8170: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-special-characters-navigation>.ck-label{max-width:160px;overflow:hidden;text-overflow:ellipsis}.ck.ck-special-characters-navigation>.ck-dropdown .ck-dropdown__panel{max-height:250px;overflow-x:hidden;overflow-y:auto}@media screen and (max-width:600px){.ck.ck-special-characters-navigation{max-width:190px}.ck.ck-special-characters-navigation>.ck-form__header__label{overflow:hidden;text-overflow:ellipsis}}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/specialcharacters.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
            ],
            names: [],
            mappings:
              "AAUC,+CACC,eAAgB,CAEhB,eAAgB,CADhB,sBAED,CAEA,sEAEC,gBAAiB,CAEjB,iBAAkB,CADlB,eAED,CCfA,oCDED,qCAgBE,eAOF,CALE,6DAEC,eAAgB,CADhB,sBAED,CCrBD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\\n\\n.ck.ck-special-characters-navigation {\\n\\n\\t& > .ck-label {\\n\\t\\tmax-width: 160px;\\n\\t\\ttext-overflow: ellipsis;\\n\\t\\toverflow: hidden;\\n\\t}\\n\\n\\t& > .ck-dropdown .ck-dropdown__panel {\\n\\t\\t/* There could be dozens of categories available. Use scroll to prevent a 10e6px dropdown. */\\n\\t\\tmax-height: 250px;\\n\\t\\toverflow-y: auto;\\n\\t\\toverflow-x: hidden;\\n\\t}\\n\\n\\t@mixin ck-media-phone {\\n\\t\\tmax-width: 190px;\\n\\n\\t\\t& > .ck-form__header__label {\\n\\t\\t\\ttext-overflow: ellipsis;\\n\\t\\t\\toverflow: hidden;\\n\\t\\t}\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@define-mixin ck-media-phone {\\n\\t@media screen and (max-width: 600px) {\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      4082: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-input-color{display:flex;flex-direction:row-reverse;width:100%}.ck.ck-input-color>input.ck.ck-input-text{flex-grow:1;min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button{display:flex}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{overflow:hidden;position:relative}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{display:block;position:absolute}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-input-color>.ck.ck-input-text:focus{z-index:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-left-radius:0;border-top-left-radius:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-left:1px solid transparent}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-right:1px solid transparent}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border-radius:0}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border:1px solid var(--ck-color-input-border);height:20px;width:20px}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{background:red;border-radius:2px;height:150%;left:50%;top:-30%;transform:rotate(45deg);transform-origin:50%;width:8%}.ck.ck-input-color .ck.ck-input-color__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);width:100%}.ck.ck-input-color .ck.ck-input-color__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-input-border)}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard);margin-right:0}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-table/theme/colorinput.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/colorinput.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAKA,mBAEC,YAAa,CACb,0BAA2B,CAF3B,UAgCD,CA5BC,0CAEC,WAAY,CADZ,cAED,CAEA,sCACC,cAMD,CAHC,kFACC,YACD,CAGD,8CAEC,YAWD,CATC,kFAEC,eAAgB,CADhB,iBAOD,CAJC,0IAEC,aAAc,CADd,iBAED,CC1BF,+CAGE,4BAA6B,CAD7B,yBAcF,CAhBA,+CAQE,2BAA4B,CAD5B,wBASF,CAHC,2CACC,SACD,CAIA,wEACC,SA0CD,CA3CA,kFAKE,2BAA4B,CAD5B,wBAuCF,CApCE,8FACC,iCACD,CATF,kFAcE,4BAA6B,CAD7B,yBA8BF,CA3BE,8FACC,kCACD,CAGD,oFACC,oDACD,CAEA,4GC1CF,eD2DE,CAjBA,+PCtCD,qCDuDC,CAjBA,4GAKC,6CAA8C,CAD9C,WAAY,CADZ,UAcD,CAVC,oKAKC,cAA6B,CAC7B,iBAAkB,CAHlB,WAAY,CADZ,QAAS,CADT,QAAS,CAMT,uBAAwB,CACxB,oBAAqB,CAJrB,QAKD,CAKH,oDAIC,2BAA4B,CAC5B,4BAA6B,CAH7B,qEAAwE,CADxE,UA0BD,CApBC,gEACC,oDACD,CATD,8DAYE,yBAeF,CA3BA,8DAgBE,wBAWF,CARC,gEACC,uCAMD,CAPA,0EAKE,sCAAuC,CADvC,cAGF",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-input-color {\\n\\twidth: 100%;\\n\\tdisplay: flex;\\n\\tflex-direction: row-reverse;\\n\\n\\t& > input.ck.ck-input-text {\\n\\t\\tmin-width: auto;\\n\\t\\tflex-grow: 1;\\n\\t}\\n\\n\\t& > div.ck.ck-dropdown {\\n\\t\\tmin-width: auto;\\n\\n\\t\\t/* This dropdown has no arrow but a color preview instead. */\\n\\t\\t& > .ck-input-color__button .ck-dropdown__arrow {\\n\\t\\t\\tdisplay: none;\\n\\t\\t}\\n\\t}\\n\\n\\t& .ck.ck-input-color__button {\\n\\t\\t/* Resolving issue with misaligned buttons on Safari (see #10589) */\\n\\t\\tdisplay: flex;\\n\\n\\t\\t& .ck.ck-input-color__button__preview {\\n\\t\\t\\tposition: relative;\\n\\t\\t\\toverflow: hidden;\\n\\n\\t\\t\\t& > .ck.ck-input-color__button__preview__no-color-indicator {\\n\\t\\t\\t\\tposition: absolute;\\n\\t\\t\\t\\tdisplay: block;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\\n@import "../mixins/_rounded.css";\\n\\n.ck.ck-input-color {\\n\\t& > .ck.ck-input-text {\\n\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\tborder-top-right-radius: 0;\\n\\t\\t\\tborder-bottom-right-radius: 0;\\n\\t\\t}\\n\\n\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\tborder-top-left-radius: 0;\\n\\t\\t\\tborder-bottom-left-radius: 0;\\n\\t\\t}\\n\\n\\t\\t/* Make sure the focused input is always on top of the dropdown button so its\\n\\t\\t   outline and border are never cropped (also when the input is read-only). */\\n\\t\\t&:focus {\\n\\t\\t\\tz-index: 0;\\n\\t\\t}\\n\\t}\\n\\n\\t& > .ck.ck-dropdown {\\n\\t\\t& > .ck.ck-button.ck-input-color__button {\\n\\t\\t\\tpadding: 0;\\n\\n\\t\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\t\\tborder-top-left-radius: 0;\\n\\t\\t\\t\\tborder-bottom-left-radius: 0;\\n\\n\\t\\t\\t\\t&:not(:focus) {\\n\\t\\t\\t\\t\\tborder-left: 1px solid transparent;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\t\\tborder-top-right-radius: 0;\\n\\t\\t\\t\\tborder-bottom-right-radius: 0;\\n\\n\\t\\t\\t\\t&:not(:focus) {\\n\\t\\t\\t\\t\\tborder-right: 1px solid transparent;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t&.ck-disabled {\\n\\t\\t\\t\\tbackground: var(--ck-color-input-disabled-background);\\n\\t\\t\\t}\\n\\n\\t\\t\\t& > .ck.ck-input-color__button__preview {\\n\\t\\t\\t\\t@mixin ck-rounded-corners;\\n\\n\\t\\t\\t\\twidth: 20px;\\n\\t\\t\\t\\theight: 20px;\\n\\t\\t\\t\\tborder: 1px solid var(--ck-color-input-border);\\n\\n\\t\\t\\t\\t& > .ck.ck-input-color__button__preview__no-color-indicator {\\n\\t\\t\\t\\t\\ttop: -30%;\\n\\t\\t\\t\\t\\tleft: 50%;\\n\\t\\t\\t\\t\\theight: 150%;\\n\\t\\t\\t\\t\\twidth: 8%;\\n\\t\\t\\t\\t\\tbackground: hsl(0, 100%, 50%);\\n\\t\\t\\t\\t\\tborder-radius: 2px;\\n\\t\\t\\t\\t\\ttransform: rotate(45deg);\\n\\t\\t\\t\\t\\ttransform-origin: 50%;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t& .ck.ck-input-color__remove-color {\\n\\t\\twidth: 100%;\\n\\t\\tpadding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);\\n\\n\\t\\tborder-bottom-left-radius: 0;\\n\\t\\tborder-bottom-right-radius: 0;\\n\\n\\t\\t&:not(:focus) {\\n\\t\\t\\tborder-bottom: 1px solid var(--ck-color-input-border);\\n\\t\\t}\\n\\n\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\tborder-top-right-radius: 0;\\n\\t\\t}\\n\\n\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\tborder-top-left-radius: 0;\\n\\t\\t}\\n\\n\\t\\t& .ck.ck-icon {\\n\\t\\t\\tmargin-right: var(--ck-spacing-standard);\\n\\n\\t\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\t\\tmargin-right: 0;\\n\\t\\t\\t\\tmargin-left: var(--ck-spacing-standard);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Implements rounded corner interface for .ck-rounded-corners class.\\n *\\n * @see $ck-border-radius\\n */\\n@define-mixin ck-rounded-corners {\\n\\tborder-radius: 0;\\n\\n\\t@nest .ck-rounded-corners &,\\n\\t&.ck-rounded-corners {\\n\\t\\tborder-radius: var(--ck-border-radius);\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      4880: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/form.css",
            ],
            names: [],
            mappings:
              "AAKA,YACC,mCAyBD,CAvBC,kBAEC,YACD,CAEA,8BACC,cAAe,CACf,OACD,CAEA,4BACC,cAWD,CARE,6DACC,4CACD,CAEA,mEACC,UACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-form {\\n\\tpadding: 0 0 var(--ck-spacing-large);\\n\\n\\t&:focus {\\n\\t\\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\\n\\t\\toutline: none;\\n\\t}\\n\\n\\t& .ck.ck-input-text {\\n\\t\\tmin-width: 100%;\\n\\t\\twidth: 0;\\n\\t}\\n\\n\\t& .ck.ck-dropdown {\\n\\t\\tmin-width: 100%;\\n\\n\\t\\t& .ck-dropdown__button {\\n\\t\\t\\t&:not(:focus) {\\n\\t\\t\\t\\tborder: 1px solid var(--ck-color-base-border);\\n\\t\\t\\t}\\n\\n\\t\\t\\t& .ck-button__label {\\n\\t\\t\\t\\twidth: 100%;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      9865: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row{padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}[dir=ltr] .ck.ck-form__row>:not(.ck-label)+*{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-form__row>:not(.ck-label)+*{margin-right:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{min-width:100%;width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-table/theme/formrow.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/formrow.css",
            ],
            names: [],
            mappings:
              "AAKA,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAaD,CAVC,iCACC,WACD,CAGC,wHAEC,sBACD,CCbF,iBACC,4DA2BD,CAvBE,6CAEE,mCAMF,CARA,6CAME,oCAEF,CAGD,2BAEC,cAAe,CADf,UAED,CAEA,2CACC,kCAKD,CAHC,wEACC,0BACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-form__row {\\n\\tdisplay: flex;\\n\\tflex-direction: row;\\n\\tflex-wrap: nowrap;\\n\\tjustify-content: space-between;\\n\\n\\t/* Ignore labels that work as fieldset legends */\\n\\t& > *:not(.ck-label) {\\n\\t\\tflex-grow: 1;\\n\\t}\\n\\n\\t&.ck-table-form__action-row {\\n\\t\\t& .ck-button-save,\\n\\t\\t& .ck-button-cancel {\\n\\t\\t\\tjustify-content: center;\\n\\t\\t}\\n\\t}\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\\n\\n.ck.ck-form__row {\\n\\tpadding: var(--ck-spacing-standard) var(--ck-spacing-large) 0;\\n\\n\\t/* Ignore labels that work as fieldset legends */\\n\\t& > *:not(.ck-label) {\\n\\t\\t& + * {\\n\\t\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\t\\tmargin-left: var(--ck-spacing-large);\\n\\t\\t\\t}\\n\\n\\t\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\t\\tmargin-right: var(--ck-spacing-large);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t& > .ck-label {\\n\\t\\twidth: 100%;\\n\\t\\tmin-width: 100%;\\n\\t}\\n\\n\\t&.ck-table-form__action-row {\\n\\t\\tmargin-top: var(--ck-spacing-large);\\n\\n\\t\\t& .ck-button .ck-button__label {\\n\\t\\t\\tcolor: var(--ck-color-text);\\n\\t\\t}\\n\\t}\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      8085: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label,.ck[dir=rtl] .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;margin:var(--ck-insert-table-dropdown-box-margin);min-height:var(--ck-insert-table-dropdown-box-height);min-width:var(--ck-insert-table-dropdown-box-width);outline:none;transition:none}.ck .ck-insert-table-dropdown-grid-box:focus{box-shadow:none}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-table/theme/inserttable.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css",
            ],
            names: [],
            mappings:
              "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAGC,yFAA0F,CAD1F,oJAED,CAEA,mFAEC,iBACD,CAEA,uCAIC,4CAA6C,CAC7C,iBAAkB,CAFlB,iDAAkD,CADlD,qDAAsD,CADtD,mDAAoD,CAKpD,YAAa,CACb,eAUD,CARC,6CACC,eACD,CAEA,6CAEC,6CAA8C,CAD9C,yCAED",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck .ck-insert-table-dropdown__grid {\\n\\tdisplay: flex;\\n\\tflex-direction: row;\\n\\tflex-wrap: wrap;\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-insert-table-dropdown-padding: 10px;\\n\\t--ck-insert-table-dropdown-box-height: 11px;\\n\\t--ck-insert-table-dropdown-box-width: 12px;\\n\\t--ck-insert-table-dropdown-box-margin: 1px;\\n}\\n\\n.ck .ck-insert-table-dropdown__grid {\\n\\t/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */\\n\\twidth: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);\\n\\tpadding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;\\n}\\n\\n.ck .ck-insert-table-dropdown__label,\\n.ck[dir=rtl] .ck-insert-table-dropdown__label {\\n\\ttext-align: center;\\n}\\n\\n.ck .ck-insert-table-dropdown-grid-box {\\n\\tmin-width: var(--ck-insert-table-dropdown-box-width);\\n\\tmin-height: var(--ck-insert-table-dropdown-box-height);\\n\\tmargin: var(--ck-insert-table-dropdown-box-margin);\\n\\tborder: 1px solid var(--ck-color-base-border);\\n\\tborder-radius: 1px;\\n\\toutline: none;\\n\\ttransition: none;\\n\\n\\t&:focus {\\n\\t\\tbox-shadow: none;\\n\\t}\\n\\n\\t&.ck-on {\\n\\t\\tborder-color: var(--ck-color-focus-border);\\n\\t\\tbackground: var(--ck-color-focus-outer-shadow);\\n\\t}\\n}\\n\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      4104: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck-content .table{display:table;margin:.9em auto}.ck-content .table table{border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0;height:100%;width:100%}.ck-content .table table td,.ck-content .table table th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}.ck-content .table table th{background:rgba(0,0,0,.05);font-weight:700}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-table/theme/table.css",
            ],
            names: [],
            mappings:
              "AAKA,mBAKC,aAAc,CADd,gBAiCD,CA9BC,yBAYC,yBAAkC,CAVlC,wBAAyB,CACzB,gBAAiB,CAKjB,WAAY,CADZ,UAsBD,CAfC,wDAQC,wBAAiC,CANjC,aAAc,CACd,YAMD,CAEA,4BAEC,0BAA+B,CAD/B,eAED,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck-content .table {\\n\\t/* Give the table widget some air and center it horizontally */\\n\\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\\n\\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\\n\\tmargin: 0.9em auto;\\n\\tdisplay: table;\\n\\n\\t& table {\\n\\t\\t/* The table cells should have slight borders */\\n\\t\\tborder-collapse: collapse;\\n\\t\\tborder-spacing: 0;\\n\\n\\t\\t/* Table width and height are set on the parent <figure>. Make sure the table inside stretches\\n\\t\\tto the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */\\n\\t\\twidth: 100%;\\n\\t\\theight: 100%;\\n\\n\\t\\t/* The outer border of the table should be slightly darker than the inner lines.\\n\\t\\tAlso see https://github.com/ckeditor/ckeditor5-table/issues/50. */\\n\\t\\tborder: 1px double hsl(0, 0%, 70%);\\n\\n\\t\\t& td,\\n\\t\\t& th {\\n\\t\\t\\tmin-width: 2em;\\n\\t\\t\\tpadding: .4em;\\n\\n\\t\\t\\t/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it\\'s not necessary here.\\n\\t\\t\\tHowever, the border is a content style, so it should use .ck-content (so it works outside the editor).\\n\\t\\t\\tHence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */\\n\\t\\t\\tborder: 1px solid hsl(0, 0%, 75%);\\n\\t\\t}\\n\\n\\t\\t& th {\\n\\t\\t\\tfont-weight: bold;\\n\\t\\t\\tbackground: hsla(0, 0%, 0%, 5%);\\n\\t\\t}\\n\\t}\\n}\\n\\n/* Text alignment of the table header should match the editor settings and override the native browser styling,\\nwhen content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */\\n.ck-content[dir="rtl"] .table th {\\n\\ttext-align: right;\\n}\\n\\n.ck-content[dir="ltr"] .table th {\\n\\ttext-align: left;\\n}\\n\\n.ck-editor__editable .ck-table-bogus-paragraph {\\n\\t/*\\n\\t * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.\\n\\t * See https://github.com/ckeditor/ckeditor5/issues/6062.\\n\\t */\\n\\tdisplay: inline-block;\\n\\n\\t/*\\n\\t * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.\\n\\t * See https://github.com/ckeditor/ckeditor5/issues/9117.\\n\\t */\\n\\twidth: 100%;\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      728: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ":root{--ck-color-table-column-resizer-hover:var(--ck-color-base-active);--ck-table-column-resizer-width:7px;--ck-table-column-resizer-position-offset:calc(var(--ck-table-column-resizer-width)*-0.5 - 0.5px)}.ck-content .table .ck-table-resized{table-layout:fixed}.ck-content .table table{overflow:hidden}.ck-content .table td,.ck-content .table th{position:relative}.ck.ck-editor__editable .table .ck-table-column-resizer{bottom:-999999px;cursor:col-resize;position:absolute;right:var(--ck-table-column-resizer-position-offset);top:-999999px;user-select:none;width:var(--ck-table-column-resizer-width);z-index:var(--ck-z-default)}.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer,.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer{display:none}.ck.ck-editor__editable .table .ck-table-column-resizer:hover,.ck.ck-editor__editable .table .ck-table-column-resizer__active{background-color:var(--ck-color-table-column-resizer-hover);opacity:.25}.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer{left:var(--ck-table-column-resizer-position-offset);right:unset}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tablecolumnresize.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,iEAAkE,CAClE,mCAAoC,CAIpC,iGACD,CAEA,qCACC,kBACD,CAEA,yBACC,eACD,CAEA,4CAEC,iBACD,CAEA,wDAOC,gBAAiB,CAGjB,iBAAkB,CATlB,iBAAkB,CAOlB,oDAAqD,CAFrD,aAAc,CAKd,gBAAiB,CAFjB,0CAA2C,CAG3C,2BACD,CAQA,qJACC,YACD,CAEA,8HAEC,2DAA4D,CAC5D,WACD,CAEA,iEACC,mDAAoD,CACpD,WACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-color-table-column-resizer-hover: var(--ck-color-base-active);\\n\\t--ck-table-column-resizer-width: 7px;\\n\\n\\t/* The offset used for absolute positioning of the resizer element, so that it is placed exactly above the cell border.\\n\\t   The value is: minus half the width of the resizer decreased additionaly by the half the width of the border (0.5px). */\\n\\t--ck-table-column-resizer-position-offset: calc(var(--ck-table-column-resizer-width) * -0.5 - 0.5px);\\n}\\n\\n.ck-content .table .ck-table-resized {\\n\\ttable-layout: fixed;\\n}\\n\\n.ck-content .table table {\\n\\toverflow: hidden;\\n}\\n\\n.ck-content .table td,\\n.ck-content .table th {\\n\\tposition: relative;\\n}\\n\\n.ck.ck-editor__editable .table .ck-table-column-resizer {\\n\\tposition: absolute;\\n\\t/* The resizer element resides in each cell so to occupy the entire height of the table, which is unknown from a CSS point of view,\\n\\t   it is extended to an extremely high height. Even for screens with a very high pixel density, the resizer will fulfill its role as\\n\\t   it should, i.e. for a screen of 476 ppi the total height of the resizer will take over 350 sheets of A4 format, which is totally\\n\\t   unrealistic height for a single table. */\\n\\ttop: -999999px;\\n\\tbottom: -999999px;\\n\\tright: var(--ck-table-column-resizer-position-offset);\\n\\twidth: var(--ck-table-column-resizer-width);\\n\\tcursor: col-resize;\\n\\tuser-select: none;\\n\\tz-index: var(--ck-z-default);\\n}\\n\\n.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer {\\n\\tdisplay: none;\\n}\\n\\n/* The resizer elements, which are extended to an extremely high height, break the drag & drop feature in Chrome. To make it work again,\\n   all resizers must be hidden while the table is dragged. */\\n.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer {\\n\\tdisplay: none;\\n}\\n\\n.ck.ck-editor__editable .table .ck-table-column-resizer:hover,\\n.ck.ck-editor__editable .table .ck-table-column-resizer__active {\\n\\tbackground-color: var(--ck-color-table-column-resizer-hover);\\n\\topacity: 0.25;\\n}\\n\\n.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer {\\n\\tleft: var(--ck-table-column-resizer-position-offset);\\n\\tright: unset;\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      4777: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ":root{--ck-color-table-focused-cell-background:rgba(158,201,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,6DACD,CAKE,8QAGC,wDAAyD,CAKzD,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-color-table-focused-cell-background: hsla(212, 90%, 80%, .3);\\n}\\n\\n.ck-widget.table {\\n\\t& td,\\n\\t& th {\\n\\t\\t&.ck-editor__nested-editable.ck-editor__nested-editable_focused,\\n\\t\\t&.ck-editor__nested-editable:focus {\\n\\t\\t\\t/* A very slight background to highlight the focused cell */\\n\\t\\t\\tbackground: var(--ck-color-table-focused-cell-background);\\n\\n\\t\\t\\t/* Fixes the problem where surrounding cells cover the focused cell's border.\\n\\t\\t\\tIt does not fix the problem in all places but the UX is improved.\\n\\t\\t\\tSee https://github.com/ckeditor/ckeditor5-table/issues/29. */\\n\\t\\t\\tborder-style: none;\\n\\t\\t\\toutline: 1px solid var(--ck-color-focus-border);\\n\\t\\t\\toutline-offset: -1px; /* progressive enhancement - no IE support */\\n\\t\\t}\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      198: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-table-form .ck-form__row.ck-table-form__background-row,.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{align-items:center;flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view{align-items:center;display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck.ck-labeled-field-view{position:relative}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{bottom:calc(var(--ck-table-properties-error-arrow-size)*-1);left:50%;position:absolute;transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{content:"";left:50%;position:absolute;top:calc(var(--ck-table-properties-error-arrow-size)*-1);transform:translateX(-50%)}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{max-width:80px;min-width:80px;width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:flex-end;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-field-view{padding-top:var(--ck-spacing-standard)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{border-radius:0}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status,.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{background:var(--ck-color-base-error);color:var(--ck-color-base-background);min-width:var(--ck-table-properties-min-error-width);padding:var(--ck-spacing-small) var(--ck-spacing-medium);text-align:center}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-color:transparent transparent var(--ck-color-base-error) transparent;border-style:solid;border-width:0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both}.ck.ck-table-form .ck.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tableform.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableform.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAWE,wHACC,cACD,CAEA,8DAEC,kBAAmB,CADnB,cAgBD,CAbC,qFAGC,kBAAmB,CAFnB,YAAa,CACb,6BAMD,CAEA,sMACC,WACD,CAIF,4CAEC,iBAoBD,CAlBC,8EAGC,2DAAgE,CADhE,QAAS,CADT,iBAAkB,CAGlB,8BAA+B,CAG/B,SAUD,CAPC,oFACC,UAAW,CAGX,QAAS,CAFT,iBAAkB,CAClB,wDAA6D,CAE7D,0BACD,CChDH,MACC,0CAA2C,CAC3C,2CACD,CAMI,2FACC,kCAAmC,CACnC,iBACD,CAGD,8KAIC,cAAe,CADf,cAAe,CADf,UAGD,CAGD,8DACC,SAcD,CAZC,yMAEC,QACD,CAEA,iGACC,mBAAoB,CACpB,oBAAqB,CACrB,wCAAyC,CACzC,6CAA8C,CAC9C,gCACD,CAIF,4CACC,sCAyBD,CAvBC,8ECxCD,eDyDC,CAjBA,mMCpCA,qCDqDA,CAjBA,8EAGC,qCAAsC,CACtC,qCAAsC,CAEtC,oDAAqD,CADrD,wDAAyD,CAEzD,iBAUD,CAPC,oFACC,2EAA4E,CAE5E,kBAAmB,CADnB,kJAED,CAdD,8EAgBC,iEACD,CAGA,6GACC,YACD,CAIF,oDACC,GACC,SACD,CAEA,GACC,SACD,CACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-table-form {\\n\\t& .ck-form__row {\\n\\t\\t&.ck-table-form__border-row {\\n\\t\\t\\tflex-wrap: wrap;\\n\\t\\t}\\n\\n\\t\\t&.ck-table-form__background-row {\\n\\t\\t\\tflex-wrap: wrap;\\n\\t\\t}\\n\\n\\t\\t&.ck-table-form__dimensions-row {\\n\\t\\t\\tflex-wrap: wrap;\\n\\t\\t\\talign-items: center;\\n\\n\\t\\t\\t& .ck-labeled-field-view {\\n\\t\\t\\t\\tdisplay: flex;\\n\\t\\t\\t\\tflex-direction: column-reverse;\\n\\t\\t\\t\\talign-items: center;\\n\\n\\t\\t\\t\\t& .ck.ck-dropdown {\\n\\t\\t\\t\\t\\tflex-grow: 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t& .ck-table-form__dimension-operator {\\n\\t\\t\\t\\tflex-grow: 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t& .ck.ck-labeled-field-view {\\n\\t\\t/* Allow absolute positioning of the status (error) balloons. */\\n\\t\\tposition: relative;\\n\\n\\t\\t& .ck.ck-labeled-field-view__status {\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\tleft: 50%;\\n\\t\\t\\tbottom: calc( -1 * var(--ck-table-properties-error-arrow-size) );\\n\\t\\t\\ttransform: translate(-50%,100%);\\n\\n\\t\\t\\t/* Make sure the balloon status stays on top of other form elements. */\\n\\t\\t\\tz-index: 1;\\n\\n\\t\\t\\t/* The arrow pointing towards the field. */\\n\\t\\t\\t&::after {\\n\\t\\t\\t\\tcontent: "";\\n\\t\\t\\t\\tposition: absolute;\\n\\t\\t\\t\\ttop: calc( -1 * var(--ck-table-properties-error-arrow-size) );\\n\\t\\t\\t\\tleft: 50%;\\n\\t\\t\\t\\ttransform: translateX( -50% );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n',
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../mixins/_rounded.css";\\n\\n:root {\\n\\t--ck-table-properties-error-arrow-size: 6px;\\n\\t--ck-table-properties-min-error-width: 150px;\\n}\\n\\n.ck.ck-table-form {\\n\\t& .ck-form__row {\\n\\t\\t&.ck-table-form__border-row {\\n\\t\\t\\t& .ck-labeled-field-view {\\n\\t\\t\\t\\t& > .ck-label {\\n\\t\\t\\t\\t\\tfont-size: var(--ck-font-size-tiny);\\n\\t\\t\\t\\t\\ttext-align: center;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t& .ck-table-form__border-style,\\n\\t\\t\\t& .ck-table-form__border-width {\\n\\t\\t\\t\\twidth: 80px;\\n\\t\\t\\t\\tmin-width: 80px;\\n\\t\\t\\t\\tmax-width: 80px;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t&.ck-table-form__dimensions-row {\\n\\t\\t\\tpadding: 0;\\n\\n\\t\\t\\t& .ck-table-form__dimensions-row__width,\\n\\t\\t\\t& .ck-table-form__dimensions-row__height {\\n\\t\\t\\t\\tmargin: 0\\n\\t\\t\\t}\\n\\n\\t\\t\\t& .ck-table-form__dimension-operator {\\n\\t\\t\\t\\talign-self: flex-end;\\n\\t\\t\\t\\tdisplay: inline-block;\\n\\t\\t\\t\\theight: var(--ck-ui-component-min-height);\\n\\t\\t\\t\\tline-height: var(--ck-ui-component-min-height);\\n\\t\\t\\t\\tmargin: 0 var(--ck-spacing-small);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t& .ck.ck-labeled-field-view {\\n\\t\\tpadding-top: var(--ck-spacing-standard);\\n\\n\\t\\t& .ck.ck-labeled-field-view__status {\\n\\t\\t\\t@mixin ck-rounded-corners;\\n\\n\\t\\t\\tbackground: var(--ck-color-base-error);\\n\\t\\t\\tcolor: var(--ck-color-base-background);\\n\\t\\t\\tpadding: var(--ck-spacing-small) var(--ck-spacing-medium);\\n\\t\\t\\tmin-width: var(--ck-table-properties-min-error-width);\\n\\t\\t\\ttext-align: center;\\n\\n\\t\\t\\t/* The arrow pointing towards the field. */\\n\\t\\t\\t&::after {\\n\\t\\t\\t\\tborder-color: transparent transparent var(--ck-color-base-error) transparent;\\n\\t\\t\\t\\tborder-width: 0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size);\\n\\t\\t\\t\\tborder-style: solid;\\n\\t\\t\\t}\\n\\n\\t\\t\\tanimation: ck-table-form-labeled-view-status-appear .15s ease both;\\n\\t\\t}\\n\\n\\t\\t/* Hide the error balloon when the field is blurred. Makes the experience much more clear. */\\n\\t\\t& .ck-input.ck-error:not(:focus) + .ck.ck-labeled-field-view__status {\\n\\t\\t\\tdisplay: none;\\n\\t\\t}\\n\\t}\\n}\\n\\n@keyframes ck-table-form-labeled-view-status-appear {\\n\\t0% {\\n\\t\\topacity: 0;\\n\\t}\\n\\n\\t100% {\\n\\t\\topacity: 1;\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Implements rounded corner interface for .ck-rounded-corners class.\\n *\\n * @see $ck-border-radius\\n */\\n@define-mixin ck-rounded-corners {\\n\\tborder-radius: 0;\\n\\n\\t@nest .ck-rounded-corners &,\\n\\t&.ck-rounded-corners {\\n\\t\\tborder-radius: var(--ck-border-radius);\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      9221: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-content:baseline;flex-basis:0;flex-wrap:wrap}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-self:flex-end;padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tableproperties.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableproperties.css",
            ],
            names: [],
            mappings:
              "AAOE,mFAGC,sBAAuB,CADvB,YAAa,CADb,cAOD,CAHC,qHACC,gBACD,CCTH,6BACC,WAmBD,CAhBE,mFACC,mBAAoB,CACpB,SAYD,CAVC,kGACC,eAAgB,CAGhB,qCAKD,CAHC,uHACC,UACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-table-properties-form {\\n\\t& .ck-form__row {\\n\\t\\t&.ck-table-properties-form__alignment-row {\\n\\t\\t\\tflex-wrap: wrap;\\n\\t\\t\\tflex-basis: 0;\\n\\t\\t\\talign-content: baseline;\\n\\n\\t\\t\\t& .ck.ck-toolbar .ck-toolbar__items {\\n\\t\\t\\t\\tflex-wrap: nowrap;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-table-properties-form {\\n\\twidth: 320px;\\n\\n\\t& .ck-form__row {\\n\\t\\t&.ck-table-properties-form__alignment-row {\\n\\t\\t\\talign-self: flex-end;\\n\\t\\t\\tpadding: 0;\\n\\n\\t\\t\\t& .ck.ck-toolbar {\\n\\t\\t\\t\\tbackground: none;\\n\\n\\t\\t\\t\\t/* Compensate for missing input label that would push the margin (toolbar has no inputs). */\\n\\t\\t\\t\\tmargin-top: var(--ck-spacing-standard);\\n\\n\\t\\t\\t\\t& .ck-toolbar__items > * {\\n\\t\\t\\t\\t\\twidth: 40px;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      5593: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ':root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,wDACD,CAGC,0IAKC,gBAAiB,CAFjB,uBAAwB,CACxB,aAAc,CAFd,iBAiCD,CA3BC,sJAGC,yDAA0D,CAK1D,QAAS,CAPT,UAAW,CAKX,MAAO,CAJP,mBAAoB,CAEpB,iBAAkB,CAGlB,OAAQ,CAFR,KAID,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);\\n}\\n\\n.ck.ck-editor__editable .table table {\\n\\t& td.ck-editor__editable_selected,\\n\\t& th.ck-editor__editable_selected {\\n\\t\\tposition: relative;\\n\\t\\tcaret-color: transparent;\\n\\t\\toutline: unset;\\n\\t\\tbox-shadow: unset;\\n\\n\\t\\t/* https://github.com/ckeditor/ckeditor5/issues/6446 */\\n\\t\\t&:after {\\n\\t\\t\\tcontent: '';\\n\\t\\t\\tpointer-events: none;\\n\\t\\t\\tbackground-color: var(--ck-table-selected-cell-background);\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\ttop: 0;\\n\\t\\t\\tleft: 0;\\n\\t\\t\\tright: 0;\\n\\t\\t\\tbottom: 0;\\n\\t\\t}\\n\\n\\t\\t& ::selection,\\n\\t\\t&:focus {\\n\\t\\t\\tbackground-color: transparent;\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.\\n\\t\\t * See https://github.com/ckeditor/ckeditor5/issues/9491.\\n\\t\\t */\\n\\t\\t& .ck-widget {\\n\\t\\t\\toutline: unset;\\n\\n\\t\\t\\t& > .ck-widget__selection-handle {\\n\\t\\t\\t\\tdisplay: none;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      4499: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
            ],
            names: [],
            mappings:
              "AAOA,6BAMC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAAkB,CCFlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDkBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../mixins/_unselectable.css";\\n\\n.ck.ck-button,\\na.ck.ck-button {\\n\\t@mixin ck-unselectable;\\n\\n\\tposition: relative;\\n\\tdisplay: inline-flex;\\n\\talign-items: center;\\n\\tjustify-content: left;\\n\\n\\t& .ck-button__label {\\n\\t\\tdisplay: none;\\n\\t}\\n\\n\\t&.ck-button_with-text {\\n\\t\\t& .ck-button__label {\\n\\t\\t\\tdisplay: inline-block;\\n\\t\\t}\\n\\t}\\n\\n\\t/* Center the icon horizontally in a button without text. */\\n\\t&:not(.ck-button_with-text)  {\\n\\t\\tjustify-content: center;\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Makes element unselectable.\\n */\\n@define-mixin ck-unselectable {\\n\\t-moz-user-select: none;\\n\\t-webkit-user-select: none;\\n\\t-ms-user-select: none;\\n\\tuser-select: none\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../../mixins/_focus.css";\\n@import "../../../mixins/_shadow.css";\\n@import "../../../mixins/_disabled.css";\\n@import "../../../mixins/_rounded.css";\\n@import "../../mixins/_button.css";\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\\n\\n.ck.ck-button,\\na.ck.ck-button {\\n\\t@mixin ck-button-colors --ck-color-button-default;\\n\\t@mixin ck-rounded-corners;\\n\\n\\twhite-space: nowrap;\\n\\tcursor: default;\\n\\tvertical-align: middle;\\n\\tpadding: var(--ck-spacing-tiny);\\n\\ttext-align: center;\\n\\n\\t/* A very important piece of styling. Go to variable declaration to learn more. */\\n\\tmin-width: var(--ck-ui-component-min-height);\\n\\tmin-height: var(--ck-ui-component-min-height);\\n\\n\\t/* Normalize the height of the line. Removing this will break consistent height\\n\\tamong text and text-less buttons (with icons). */\\n\\tline-height: 1;\\n\\n\\t/* Enable font size inheritance, which allows fluid UI scaling. */\\n\\tfont-size: inherit;\\n\\n\\t/* Avoid flickering when the foucs border shows up. */\\n\\tborder: 1px solid transparent;\\n\\n\\t/* Apply some smooth transition to the box-shadow and border. */\\n\\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\\n\\n\\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\\n\\t-webkit-appearance: none;\\n\\n\\t&:active,\\n\\t&:focus {\\n\\t\\t@mixin ck-focus-ring;\\n\\t\\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\\n\\t}\\n\\n\\t/* Allow icon coloring using the text "color" property. */\\n\\t& .ck-button__icon {\\n\\t\\t& use,\\n\\t\\t& use * {\\n\\t\\t\\tcolor: inherit;\\n\\t\\t}\\n\\t}\\n\\n\\t& .ck-button__label {\\n\\t\\t/* Enable font size inheritance, which allows fluid UI scaling. */\\n\\t\\tfont-size: inherit;\\n\\t\\tfont-weight: inherit;\\n\\t\\tcolor: inherit;\\n\\t\\tcursor: inherit;\\n\\n\\t\\t/* Must be consistent with .ck-icon\\'s vertical align. Otherwise, buttons with and\\n\\t\\twithout labels (but with icons) have different sizes in Chrome */\\n\\t\\tvertical-align: middle;\\n\\n\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\ttext-align: left;\\n\\t\\t}\\n\\n\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\ttext-align: right;\\n\\t\\t}\\n\\t}\\n\\n\\t& .ck-button__keystroke {\\n\\t\\tcolor: inherit;\\n\\n\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\tmargin-left: var(--ck-spacing-large);\\n\\t\\t}\\n\\n\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\tmargin-right: var(--ck-spacing-large);\\n\\t\\t}\\n\\n\\t\\tfont-weight: bold;\\n\\t\\topacity: .7;\\n\\t}\\n\\n\\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\\n\\t&.ck-disabled {\\n\\t\\t&:active,\\n\\t\\t&:focus {\\n\\t\\t\\t/* The disabled button should have a slightly less visible shadow when focused. */\\n\\t\\t\\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\\n\\t\\t}\\n\\n\\t\\t& .ck-button__icon {\\n\\t\\t\\t@mixin ck-disabled;\\n\\t\\t}\\n\\n\\t\\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\\n\\t\\t& .ck-button__label {\\n\\t\\t\\t@mixin ck-disabled;\\n\\t\\t}\\n\\n\\t\\t& .ck-button__keystroke {\\n\\t\\t\\topacity: .3;\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-button_with-text {\\n\\t\\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\\n\\n\\t\\t/* stylelint-disable-next-line no-descending-specificity */\\n\\t\\t& .ck-button__icon {\\n\\t\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\t\\tmargin-left: calc(-1 * var(--ck-spacing-small));\\n\\t\\t\\t\\tmargin-right: var(--ck-spacing-small);\\n\\t\\t\\t}\\n\\n\\t\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\t\\tmargin-right: calc(-1 * var(--ck-spacing-small));\\n\\t\\t\\t\\tmargin-left: var(--ck-spacing-small);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-button_with-keystroke {\\n\\t\\t/* stylelint-disable-next-line no-descending-specificity */\\n\\t\\t& .ck-button__label {\\n\\t\\t\\tflex-grow: 1;\\n\\t\\t}\\n\\t}\\n\\n\\t/* A style of the button which is currently on, e.g. its feature is active. */\\n\\t&.ck-on {\\n\\t\\t@mixin ck-button-colors --ck-color-button-on;\\n\\n\\t\\tcolor: var(--ck-color-button-on-color);\\n\\t}\\n\\n\\t&.ck-button-save {\\n\\t\\tcolor: var(--ck-color-button-save);\\n\\t}\\n\\n\\t&.ck-button-cancel {\\n\\t\\tcolor: var(--ck-color-button-cancel);\\n\\t}\\n}\\n\\n/* A style of the button which handles the primary action. */\\n.ck.ck-button-action,\\na.ck.ck-button-action {\\n\\t@mixin ck-button-colors --ck-color-button-action;\\n\\n\\tcolor: var(--ck-color-button-action-text);\\n}\\n\\n.ck.ck-button-bold,\\na.ck.ck-button-bold {\\n\\tfont-weight: bold;\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Implements a button of given background color.\\n *\\n * @param {String} $background - Background color of the button.\\n * @param {String} $border - Border color of the button.\\n */\\n@define-mixin ck-button-colors $prefix {\\n\\tbackground: var($(prefix)-background);\\n\\n\\t&:not(.ck-disabled) {\\n\\t\\t&:hover {\\n\\t\\t\\tbackground: var($(prefix)-hover-background);\\n\\t\\t}\\n\\n\\t\\t&:active {\\n\\t\\t\\tbackground: var($(prefix)-active-background);\\n\\t\\t}\\n\\t}\\n\\n\\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\\n\\t&.ck-disabled {\\n\\t\\tbackground: var($(prefix)-disabled-background);\\n\\t}\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Implements rounded corner interface for .ck-rounded-corners class.\\n *\\n * @see $ck-border-radius\\n */\\n@define-mixin ck-rounded-corners {\\n\\tborder-radius: 0;\\n\\n\\t@nest .ck-rounded-corners &,\\n\\t&.ck-rounded-corners {\\n\\t\\tborder-radius: var(--ck-border-radius);\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A visual style of focused element's border.\\n */\\n@define-mixin ck-focus-ring {\\n\\t/* Disable native outline. */\\n\\toutline: none;\\n\\tborder: var(--ck-focus-ring)\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A helper to combine multiple shadows.\\n */\\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\\n\\tbox-shadow: $shadowA, $shadowB;\\n}\\n\\n/**\\n * Gives an element a drop shadow so it looks like a floating panel.\\n */\\n@define-mixin ck-drop-shadow {\\n\\t@mixin ck-box-shadow var(--ck-drop-shadow);\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A class which indicates that an element holding it is disabled.\\n */\\n@define-mixin ck-disabled {\\n\\topacity: var(--ck-disabled-opacity);\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      9681: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
            ],
            names: [],
            mappings:
              "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-button.ck-switchbutton {\\n\\t& .ck-button__toggle {\\n\\t\\tdisplay: block;\\n\\n\\t\\t& .ck-button__toggle__inner {\\n\\t\\t\\tdisplay: block;\\n\\t\\t}\\n\\t}\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../../mixins/_rounded.css";\\n@import "../../../mixins/_disabled.css";\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\\n\\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\\nof the component, floatingpoint numbers have been used which, for the default font size\\n(see: --ck-font-size-base), will generate simple integers. */\\n:root {\\n\\t/* 34px at 13px font-size */\\n\\t--ck-switch-button-toggle-width: 2.6153846154em;\\n\\t/* 14px at 13px font-size */\\n\\t--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);\\n\\t--ck-switch-button-translation: calc(\\n\\t\\tvar(--ck-switch-button-toggle-width) -\\n\\t\\tvar(--ck-switch-button-toggle-inner-size) -\\n\\t\\t2px /* Border */\\n\\t);\\n\\t--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\\n}\\n\\n.ck.ck-button.ck-switchbutton {\\n\\t/* Unlike a regular button, the switch button text color and background should never change.\\n\\t * Changing toggle switch (background, outline) is enough to carry the information about the\\n\\t * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)\\n\\t */\\n\\t&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {\\n\\t\\tcolor: inherit;\\n\\t\\tbackground: transparent;\\n\\t}\\n\\n\\t& .ck-button__label {\\n\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\t/* Separate the label from the switch */\\n\\t\\t\\tmargin-right: calc(2 * var(--ck-spacing-large));\\n\\t\\t}\\n\\n\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\t/* Separate the label from the switch */\\n\\t\\t\\tmargin-left: calc(2 * var(--ck-spacing-large));\\n\\t\\t}\\n\\t}\\n\\n\\t& .ck-button__toggle {\\n\\t\\t@mixin ck-rounded-corners;\\n\\n\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\t/* Make sure the toggle is always to the right as far as possible. */\\n\\t\\t\\tmargin-left: auto;\\n\\t\\t}\\n\\n\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\t/* Make sure the toggle is always to the left as far as possible. */\\n\\t\\t\\tmargin-right: auto;\\n\\t\\t}\\n\\n\\t\\t/* Apply some smooth transition to the box-shadow and border. */\\n\\t\\t/* Gently animate the background color of the toggle switch */\\n\\t\\ttransition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;\\n\\t\\tborder: 1px solid transparent;\\n\\t\\twidth: var(--ck-switch-button-toggle-width);\\n\\t\\tbackground: var(--ck-color-switch-button-off-background);\\n\\n\\t\\t& .ck-button__toggle__inner {\\n\\t\\t\\t@mixin ck-rounded-corners {\\n\\t\\t\\t\\tborder-radius: calc(.5 * var(--ck-border-radius));\\n\\t\\t\\t}\\n\\n\\t\\t\\twidth: var(--ck-switch-button-toggle-inner-size);\\n\\t\\t\\theight: var(--ck-switch-button-toggle-inner-size);\\n\\t\\t\\tbackground: var(--ck-color-switch-button-inner-background);\\n\\n\\t\\t\\t/* Gently animate the inner part of the toggle switch */\\n\\t\\t\\ttransition: all 300ms ease;\\n\\t\\t}\\n\\n\\t\\t&:hover {\\n\\t\\t\\tbackground: var(--ck-color-switch-button-off-hover-background);\\n\\n\\t\\t\\t& .ck-button__toggle__inner {\\n\\t\\t\\t\\tbox-shadow: var(--ck-switch-button-inner-hover-shadow);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-disabled .ck-button__toggle {\\n\\t\\t@mixin ck-disabled;\\n\\t}\\n\\n\\t/* Overriding default .ck-button:focus styles + an outline around the toogle */\\n\\t&:focus {\\n\\t\\tborder-color: transparent;\\n\\t\\toutline: none;\\n\\t\\tbox-shadow: none;\\n\\n\\t\\t& .ck-button__toggle {\\n\\t\\t\\tbox-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);\\n\\t\\t\\toutline-offset: 1px;\\n\\t\\t\\toutline: var(--ck-focus-ring);\\n\\t\\t}\\n\\t}\\n\\n\\t/* stylelint-disable-next-line no-descending-specificity */\\n\\t&.ck-on {\\n\\t\\t& .ck-button__toggle {\\n\\t\\t\\tbackground: var(--ck-color-switch-button-on-background);\\n\\n\\t\\t\\t&:hover {\\n\\t\\t\\t\\tbackground: var(--ck-color-switch-button-on-hover-background);\\n\\t\\t\\t}\\n\\n\\t\\t\\t& .ck-button__toggle__inner {\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t* Move the toggle switch to the right. It will be animated.\\n\\t\\t\\t\\t*/\\n\\t\\t\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\t\\t\\ttransform: translateX( var( --ck-switch-button-translation ) );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\t\\t\\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Implements rounded corner interface for .ck-rounded-corners class.\\n *\\n * @see $ck-border-radius\\n */\\n@define-mixin ck-rounded-corners {\\n\\tborder-radius: 0;\\n\\n\\t@nest .ck-rounded-corners &,\\n\\t&.ck-rounded-corners {\\n\\t\\tborder-radius: var(--ck-border-radius);\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A class which indicates that an element holding it is disabled.\\n */\\n@define-mixin ck-disabled {\\n\\topacity: var(--ck-disabled-opacity);\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      4923: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css",
            ],
            names: [],
            mappings:
              "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-color-grid {\\n\\tdisplay: grid;\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../../mixins/_rounded.css";\\n\\n:root {\\n\\t--ck-color-grid-tile-size: 24px;\\n\\n\\t/* Not using global colors here because these may change but some colors in a pallette\\n\\t * require special treatment. For instance, this ensures no matter what the UI text color is,\\n\\t * the check icon will look good on the black color tile. */\\n\\t--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);\\n}\\n\\n.ck.ck-color-grid {\\n\\tgrid-gap: 5px;\\n\\tpadding: 8px;\\n}\\n\\n.ck.ck-color-grid__tile {\\n\\twidth: var(--ck-color-grid-tile-size);\\n\\theight: var(--ck-color-grid-tile-size);\\n\\tmin-width: var(--ck-color-grid-tile-size);\\n\\tmin-height: var(--ck-color-grid-tile-size);\\n\\tpadding: 0;\\n\\ttransition: .2s ease box-shadow;\\n\\tborder: 0;\\n\\n\\t&.ck-disabled {\\n\\t\\tcursor: unset;\\n\\t\\ttransition: unset;\\n\\t}\\n\\n\\t&.ck-color-table__color-tile_bordered {\\n\\t\\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\\n\\t}\\n\\n\\t& .ck.ck-icon {\\n\\t\\tdisplay: none;\\n\\t\\tcolor: var(--ck-color-color-grid-check-icon);\\n\\t}\\n\\n\\t&.ck-on {\\n\\t\\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\\n\\n\\t\\t& .ck.ck-icon {\\n\\t\\t\\tdisplay: block;\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-on,\\n\\t&:focus:not( .ck-disabled ),\\n\\t&:hover:not( .ck-disabled ) {\\n\\t\\t/* Disable the default .ck-button\\'s border ring. */\\n\\t\\tborder: 0;\\n\\t}\\n\\n\\t&:focus:not( .ck-disabled ),\\n\\t&:hover:not( .ck-disabled ) {\\n\\t\\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\\n\\t}\\n}\\n\\n.ck.ck-color-grid__label {\\n\\tpadding: 0 var(--ck-spacing-standard);\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      3488: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-dropdown-max-width: 75vw;\\n}\\n\\n.ck.ck-dropdown {\\n\\tdisplay: inline-block;\\n\\tposition: relative;\\n\\n\\t& .ck-dropdown__arrow {\\n\\t\\tpointer-events: none;\\n\\t\\tz-index: var(--ck-z-default);\\n\\t}\\n\\n\\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\\n\\t& .ck-button.ck-dropdown__button {\\n\\t\\twidth: 100%;\\n\\t}\\n\\n\\t& .ck-dropdown__panel {\\n\\t\\tdisplay: none;\\n\\t\\tz-index: var(--ck-z-modal);\\n\\t\\tmax-width: var(--ck-dropdown-max-width);\\n\\n\\t\\tposition: absolute;\\n\\n\\t\\t&.ck-dropdown__panel-visible {\\n\\t\\t\\tdisplay: inline-block;\\n\\t\\t}\\n\\n\\t\\t&.ck-dropdown__panel_ne,\\n\\t\\t&.ck-dropdown__panel_nw,\\n\\t\\t&.ck-dropdown__panel_n,\\n\\t\\t&.ck-dropdown__panel_nmw,\\n\\t\\t&.ck-dropdown__panel_nme {\\n\\t\\t\\tbottom: 100%;\\n\\t\\t}\\n\\n\\t\\t&.ck-dropdown__panel_se,\\n\\t\\t&.ck-dropdown__panel_sw,\\n\\t\\t&.ck-dropdown__panel_smw,\\n\\t\\t&.ck-dropdown__panel_sme,\\n\\t\\t&.ck-dropdown__panel_s {\\n\\t\\t\\t/*\\n\\t\\t\\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\\n\\t\\t\\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\\n\\t\\t\\t */\\n\\t\\t\\ttop: 100%;\\n\\t\\t\\tbottom: auto;\\n\\t\\t}\\n\\n\\t\\t&.ck-dropdown__panel_ne,\\n\\t\\t&.ck-dropdown__panel_se {\\n\\t\\t\\tleft: 0px;\\n\\t\\t}\\n\\n\\t\\t&.ck-dropdown__panel_nw,\\n\\t\\t&.ck-dropdown__panel_sw {\\n\\t\\t\\tright: 0px;\\n\\t\\t}\\n\\n\\t\\t&.ck-dropdown__panel_s,\\n\\t\\t&.ck-dropdown__panel_n {\\n\\t\\t\\t/* Positioning panels relative to the center of the button */\\n\\t\\t\\tleft: 50%;\\n\\t\\t\\ttransform: translateX(-50%);\\n\\t\\t}\\n\\n\\t\\t&.ck-dropdown__panel_nmw,\\n\\t\\t&.ck-dropdown__panel_smw {\\n\\t\\t\\t/* Positioning panels relative to the middle-west of the button */\\n\\t\\t\\tleft: 75%;\\n\\t\\t\\ttransform: translateX(-75%);\\n\\t\\t}\\n\\n\\t\\t&.ck-dropdown__panel_nme,\\n\\t\\t&.ck-dropdown__panel_sme {\\n\\t\\t\\t/* Positioning panels relative to the middle-east of the button */\\n\\t\\t\\tleft: 25%;\\n\\t\\t\\ttransform: translateX(-25%);\\n\\t\\t}\\n\\t}\\n}\\n\\n/*\\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\\n * See https://github.com/ckeditor/ckeditor5/issues/7874\\n */\\n.ck.ck-toolbar .ck-dropdown__panel {\\n\\tz-index: calc( var(--ck-z-modal) + 1 );\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../../mixins/_rounded.css";\\n@import "../../../mixins/_disabled.css";\\n@import "../../../mixins/_shadow.css";\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\\n\\n:root {\\n\\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\\n}\\n\\n.ck.ck-dropdown {\\n\\t/* Enable font size inheritance, which allows fluid UI scaling. */\\n\\tfont-size: inherit;\\n\\n\\t& .ck-dropdown__arrow {\\n\\t\\twidth: var(--ck-dropdown-arrow-size);\\n\\t}\\n\\n\\t@mixin ck-dir ltr {\\n\\t\\t& .ck-dropdown__arrow {\\n\\t\\t\\tright: var(--ck-spacing-standard);\\n\\n\\t\\t\\t/* A space to accommodate the triangle. */\\n\\t\\t\\tmargin-left: var(--ck-spacing-standard);\\n\\t\\t}\\n\\t}\\n\\n\\t@mixin ck-dir rtl {\\n\\t\\t& .ck-dropdown__arrow {\\n\\t\\t\\tleft: var(--ck-spacing-standard);\\n\\n\\t\\t\\t/* A space to accommodate the triangle. */\\n\\t\\t\\tmargin-right: var(--ck-spacing-small);\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-disabled .ck-dropdown__arrow {\\n\\t\\t@mixin ck-disabled;\\n\\t}\\n\\n\\t& .ck-button.ck-dropdown__button {\\n\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\t&:not(.ck-button_with-text) {\\n\\t\\t\\t\\t/* Make sure dropdowns with just an icon have the right inner spacing */\\n\\t\\t\\t\\tpadding-left: var(--ck-spacing-small);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\t&:not(.ck-button_with-text) {\\n\\t\\t\\t\\t/* Make sure dropdowns with just an icon have the right inner spacing */\\n\\t\\t\\t\\tpadding-right: var(--ck-spacing-small);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t/* #23 */\\n\\t\\t& .ck-button__label {\\n\\t\\t\\twidth: 7em;\\n\\t\\t\\toverflow: hidden;\\n\\t\\t\\ttext-overflow: ellipsis;\\n\\t\\t}\\n\\n\\t\\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\\n\\t\\t&.ck-disabled .ck-button__label {\\n\\t\\t\\t@mixin ck-disabled;\\n\\t\\t}\\n\\n\\t\\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\\n\\t\\t&.ck-on {\\n\\t\\t\\tborder-bottom-left-radius: 0;\\n\\t\\t\\tborder-bottom-right-radius: 0;\\n\\t\\t}\\n\\n\\t\\t&.ck-dropdown__button_label-width_auto .ck-button__label {\\n\\t\\t\\twidth: auto;\\n\\t\\t}\\n\\n\\t\\t/* https://github.com/ckeditor/ckeditor5/issues/8699 */\\n\\t\\t&.ck-off:active,\\n\\t\\t&.ck-on:active {\\n\\t\\t\\tbox-shadow: none;\\n\\t\\t\\t\\n\\t\\t\\t&:focus {\\n\\t\\t\\t\\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n.ck.ck-dropdown__panel {\\n\\t@mixin ck-rounded-corners;\\n\\t@mixin ck-drop-shadow;\\n\\n\\tbackground: var(--ck-color-dropdown-panel-background);\\n\\tborder: 1px solid var(--ck-color-dropdown-panel-border);\\n\\tbottom: 0;\\n\\n\\t/* Make sure the panel is at least as wide as the drop-down\\'s button. */\\n\\tmin-width: 100%;\\n\\n\\t/* Disabled corner border radius to be consistent with the .dropdown__button\\n\\thttps://github.com/ckeditor/ckeditor5/issues/816 */\\n\\t&.ck-dropdown__panel_se {\\n\\t\\tborder-top-left-radius: 0;\\n\\t}\\n\\n\\t&.ck-dropdown__panel_sw {\\n\\t\\tborder-top-right-radius: 0;\\n\\t}\\n\\n\\t&.ck-dropdown__panel_ne {\\n\\t\\tborder-bottom-left-radius: 0;\\n\\t}\\n\\n\\t&.ck-dropdown__panel_nw {\\n\\t\\tborder-bottom-right-radius: 0;\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A class which indicates that an element holding it is disabled.\\n */\\n@define-mixin ck-disabled {\\n\\topacity: var(--ck-disabled-opacity);\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A helper to combine multiple shadows.\\n */\\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\\n\\tbox-shadow: $shadowA, $shadowB;\\n}\\n\\n/**\\n * Gives an element a drop shadow so it looks like a floating panel.\\n */\\n@define-mixin ck-drop-shadow {\\n\\t@mixin ck-box-shadow var(--ck-drop-shadow);\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Implements rounded corner interface for .ck-rounded-corners class.\\n *\\n * @see $ck-border-radius\\n */\\n@define-mixin ck-rounded-corners {\\n\\tborder-radius: 0;\\n\\n\\t@nest .ck-rounded-corners &,\\n\\t&.ck-rounded-corners {\\n\\t\\tborder-radius: var(--ck-border-radius);\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      6875: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../../mixins/_rounded.css";\\n\\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\\n\\t/* Disabled radius of top-left border to be consistent with .dropdown__button\\n\\thttps://github.com/ckeditor/ckeditor5/issues/816 */\\n\\t@mixin ck-rounded-corners {\\n\\t\\tborder-top-left-radius: 0;\\n\\t}\\n\\n\\t/* Make sure the button belonging to the first/last child of the list goes well with the\\n\\tborder radius of the entire panel. */\\n\\t& .ck-list__item {\\n\\t\\t&:first-child .ck-button {\\n\\t\\t\\t@mixin ck-rounded-corners {\\n\\t\\t\\t\\tborder-top-left-radius: 0;\\n\\t\\t\\t\\tborder-bottom-left-radius: 0;\\n\\t\\t\\t\\tborder-bottom-right-radius: 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t&:last-child .ck-button {\\n\\t\\t\\t@mixin ck-rounded-corners {\\n\\t\\t\\t\\tborder-top-left-radius: 0;\\n\\t\\t\\t\\tborder-top-right-radius: 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Implements rounded corner interface for .ck-rounded-corners class.\\n *\\n * @see $ck-border-radius\\n */\\n@define-mixin ck-rounded-corners {\\n\\tborder-radius: 0;\\n\\n\\t@nest .ck-rounded-corners &,\\n\\t&.ck-rounded-corners {\\n\\t\\tborder-radius: var(--ck-border-radius);\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      66: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-splitbutton {\\n\\t/* Enable font size inheritance, which allows fluid UI scaling. */\\n\\tfont-size: inherit;\\n\\n\\t& .ck-splitbutton__action:focus {\\n\\t\\tz-index: calc(var(--ck-z-default) + 1);\\n\\t}\\n}\\n\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../../mixins/_rounded.css";\\n\\n:root {\\n\\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\\n\\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\\n}\\n\\n.ck.ck-splitbutton {\\n\\t/*\\n\\t * Note: ck-rounded and ck-dir mixins don\\'t go together (because they both use @nest).\\n\\t */\\n\\t&:hover > .ck-splitbutton__action,\\n\\t&.ck-splitbutton_open > .ck-splitbutton__action {\\n\\t\\t@nest [dir="ltr"] & {\\n\\t\\t\\t/* Don\\'t round the action button on the right side */\\n\\t\\t\\tborder-top-right-radius: unset;\\n\\t\\t\\tborder-bottom-right-radius: unset;\\n\\t\\t}\\n\\n\\t\\t@nest [dir="rtl"] & {\\n\\t\\t\\t/* Don\\'t round the action button on the left side */\\n\\t\\t\\tborder-top-left-radius: unset;\\n\\t\\t\\tborder-bottom-left-radius: unset;\\n\\t\\t}\\n\\t}\\n\\n\\t& > .ck-splitbutton__arrow {\\n\\t\\t/* It\\'s a text-less button and since the icon is positioned absolutely in such situation,\\n\\t\\tit must get some arbitrary min-width. */\\n\\t\\tmin-width: unset;\\n\\n\\t\\t@nest [dir="ltr"] & {\\n\\t\\t\\t/* Don\\'t round the arrow button on the left side */\\n\\t\\t\\tborder-top-left-radius: unset;\\n\\t\\t\\tborder-bottom-left-radius: unset;\\n\\t\\t}\\n\\n\\t\\t@nest [dir="rtl"] & {\\n\\t\\t\\t/* Don\\'t round the arrow button on the right side */\\n\\t\\t\\tborder-top-right-radius: unset;\\n\\t\\t\\tborder-bottom-right-radius: unset;\\n\\t\\t}\\n\\n\\t\\t& svg {\\n\\t\\t\\twidth: var(--ck-dropdown-arrow-size);\\n\\t\\t}\\n\\t}\\n\\n\\t/* Make sure the divider stretches 100% height of the button\\n\\thttps://github.com/ckeditor/ckeditor5/issues/10936 */\\n\\t& > .ck-splitbutton__arrow:not(:focus) {\\n\\t\\tborder-top-width: 0px;\\n\\t\\tborder-bottom-width: 0px;\\n\\t}\\n\\n\\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\\n\\tas a whole. The background of both buttons should stand out and there should be a visual\\n\\tseparation between both buttons. */\\n\\t&.ck-splitbutton_open,\\n\\t&:hover {\\n\\t\\t/* When the split button hovered as a whole, not as individual buttons. */\\n\\t\\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\\n\\t\\t\\tbackground: var(--ck-color-split-button-hover-background);\\n\\t\\t}\\n\\n\\t\\t/* Splitbutton separator needs to be set with the ::after pseudoselector\\n\\t\\tto display properly the borders on focus */\\n\\t\\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\\n\\t\\t\\tcontent: \\'\\';\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\twidth: 1px;\\n\\t\\t\\theight: 100%;\\n\\t\\t\\tbackground-color: var(--ck-color-split-button-hover-border);\\n\\t\\t}\\n\\n\\t\\t/* Make sure the divider between the buttons looks fine when the button is focused */\\n\\t\\t& > .ck-splitbutton__arrow:focus::after {\\n\\t\\t\\t--ck-color-split-button-hover-border: var(--ck-color-focus-border);\\n\\t\\t}\\n\\n\\t\\t@nest [dir="ltr"] & {\\n\\t\\t\\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\\n\\t\\t\\t\\tleft: -1px;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t@nest [dir="rtl"] & {\\n\\t\\t\\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\\n\\t\\t\\t\\tright: -1px;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/* Don\\'t round the bottom left and right corners of the buttons when "open"\\n\\thttps://github.com/ckeditor/ckeditor5/issues/816 */\\n\\t&.ck-splitbutton_open {\\n\\t\\t@mixin ck-rounded-corners {\\n\\t\\t\\t& > .ck-splitbutton__action {\\n\\t\\t\\t\\tborder-bottom-left-radius: 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\t& > .ck-splitbutton__arrow {\\n\\t\\t\\t\\tborder-bottom-right-radius: 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Implements rounded corner interface for .ck-rounded-corners class.\\n *\\n * @see $ck-border-radius\\n */\\n@define-mixin ck-rounded-corners {\\n\\tborder-radius: 0;\\n\\n\\t@nest .ck-rounded-corners &,\\n\\t&.ck-rounded-corners {\\n\\t\\tborder-radius: var(--ck-border-radius);\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      5075: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-toolbar-dropdown-max-width: 60vw;\\n}\\n\\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\\n\\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\\n\\twidth: max-content;\\n\\tmax-width: var(--ck-toolbar-dropdown-max-width);\\n\\n\\t& .ck-button {\\n\\t\\t&:focus {\\n\\t\\t\\tz-index: calc(var(--ck-z-default) + 1);\\n\\t\\t}\\n\\t}\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-toolbar-dropdown .ck-toolbar {\\n\\tborder: 0;\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      4547: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../../mixins/_rounded.css";\\n@import "../../../mixins/_disabled.css";\\n@import "../../../mixins/_shadow.css";\\n@import "../../../mixins/_focus.css";\\n@import "../../mixins/_button.css";\\n\\n:root {\\n\\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\\n}\\n\\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\\n\\t@mixin ck-rounded-corners;\\n\\n\\t&.ck-focused {\\n\\t\\t@mixin ck-focus-ring;\\n\\t\\t@mixin ck-box-shadow var(--ck-inner-shadow);\\n\\t}\\n}\\n\\n.ck.ck-editor__editable_inline {\\n\\toverflow: auto;\\n\\tpadding: 0 var(--ck-spacing-standard);\\n\\tborder: 1px solid transparent;\\n\\n\\t&[dir="ltr"] {\\n\\t\\ttext-align: left;\\n\\t}\\n\\n\\t&[dir="rtl"] {\\n\\t\\ttext-align: right;\\n\\t}\\n\\n\\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\\n\\t& > *:first-child {\\n\\t\\tmargin-top: var(--ck-spacing-large);\\n\\t}\\n\\n\\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\\n\\t& > *:last-child {\\n\\t\\t/*\\n\\t\\t * This value should match with the default margins of the block elements (like .media or .image)\\n\\t\\t * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\\n\\t\\t */\\n\\t\\tmargin-bottom: var(--ck-spacing-large);\\n\\t}\\n\\n\\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\\n\\t&.ck-blurred ::selection {\\n\\t\\tbackground: var(--ck-color-editable-blur-selection);\\n\\t}\\n}\\n\\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\\n\\t&::after {\\n\\t\\tborder-bottom-color: var(--ck-color-base-foreground);\\n\\t}\\n}\\n\\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\\n\\t&::after {\\n\\t\\tborder-top-color: var(--ck-color-base-foreground);\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Implements rounded corner interface for .ck-rounded-corners class.\\n *\\n * @see $ck-border-radius\\n */\\n@define-mixin ck-rounded-corners {\\n\\tborder-radius: 0;\\n\\n\\t@nest .ck-rounded-corners &,\\n\\t&.ck-rounded-corners {\\n\\t\\tborder-radius: var(--ck-border-radius);\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A visual style of focused element's border.\\n */\\n@define-mixin ck-focus-ring {\\n\\t/* Disable native outline. */\\n\\toutline: none;\\n\\tborder: var(--ck-focus-ring)\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A helper to combine multiple shadows.\\n */\\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\\n\\tbox-shadow: $shadowA, $shadowB;\\n}\\n\\n/**\\n * Gives an element a drop shadow so it looks like a floating panel.\\n */\\n@define-mixin ck-drop-shadow {\\n\\t@mixin ck-box-shadow var(--ck-drop-shadow);\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      5523: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css",
            ],
            names: [],
            mappings:
              "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BACD,CCNA,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-form__header {\\n\\tdisplay: flex;\\n\\tflex-direction: row;\\n\\tflex-wrap: nowrap;\\n\\talign-items: center;\\n\\tjustify-content: space-between;\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-form-header-height: 38px;\\n}\\n\\n.ck.ck-form__header {\\n\\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\\n\\theight: var(--ck-form-header-height);\\n\\tline-height: var(--ck-form-header-height);\\n\\tborder-bottom: 1px solid var(--ck-color-base-border);\\n\\n\\t& .ck-form__header__label {\\n\\t\\tfont-weight: bold;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      1174: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css",
            ],
            names: [],
            mappings:
              "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-icon {\\n\\tvertical-align: middle;\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\\n}\\n\\n.ck.ck-icon {\\n\\twidth: var(--ck-icon-size);\\n\\theight: var(--ck-icon-size);\\n\\n\\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\\n\\tfont-size: .8333350694em;\\n\\n\\t/* Inherit cursor style (#5). */\\n\\tcursor: inherit;\\n\\n\\t/* This will prevent blurry icons on Firefox. See #340. */\\n\\twill-change: transform;\\n\\n\\t& * {\\n\\t\\t/* Inherit cursor style (#5). */\\n\\t\\tcursor: inherit;\\n\\t}\\n\\n\\t/* Allows dynamic coloring of an icon by inheriting its color from the parent. */\\n\\t&.ck-icon_inherit-color {\\n\\t\\tcolor: inherit;\\n\\n\\t\\t& * {\\n\\t\\t\\tcolor: inherit;\\n\\n\\t\\t\\t&:not([fill]) {\\n\\t\\t\\t\\t/* Needed by FF. */\\n\\t\\t\\t\\tfill: currentColor;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      6985: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../../mixins/_rounded.css";\\n@import "../../../mixins/_focus.css";\\n@import "../../../mixins/_shadow.css";\\n\\n:root {\\n\\t--ck-input-width: 18em;\\n\\n\\t/* Backward compatibility. */\\n\\t--ck-input-text-width: var(--ck-input-width);\\n}\\n\\n.ck.ck-input {\\n\\t@mixin ck-rounded-corners;\\n\\n\\tbackground: var(--ck-color-input-background);\\n\\tborder: 1px solid var(--ck-color-input-border);\\n\\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\\n\\tmin-width: var(--ck-input-width);\\n\\n\\t/* This is important to stay of the same height as surrounding buttons */\\n\\tmin-height: var(--ck-ui-component-min-height);\\n\\n\\t/* Apply some smooth transition to the box-shadow and border. */\\n\\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\\n\\n\\t&:focus {\\n\\t\\t@mixin ck-focus-ring;\\n\\t\\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\\n\\t}\\n\\n\\t&[readonly] {\\n\\t\\tborder: 1px solid var(--ck-color-input-disabled-border);\\n\\t\\tbackground: var(--ck-color-input-disabled-background);\\n\\t\\tcolor: var(--ck-color-input-disabled-text);\\n\\n\\t\\t&:focus {\\n\\t\\t\\t/* The read-only input should have a slightly less visible shadow when focused. */\\n\\t\\t\\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-error {\\n\\t\\tborder-color: var(--ck-color-input-error-border);\\n\\t\\tanimation: ck-input-shake .3s ease both;\\n\\n\\t\\t&:focus {\\n\\t\\t\\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\\n\\t\\t}\\n\\t}\\n}\\n\\n@keyframes ck-input-shake {\\n\\t20% {\\n\\t\\ttransform: translateX(-2px);\\n\\t}\\n\\n\\t40% {\\n\\t\\ttransform: translateX(2px);\\n\\t}\\n\\n\\t60% {\\n\\t\\ttransform: translateX(-1px);\\n\\t}\\n\\n\\t80% {\\n\\t\\ttransform: translateX(1px);\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Implements rounded corner interface for .ck-rounded-corners class.\\n *\\n * @see $ck-border-radius\\n */\\n@define-mixin ck-rounded-corners {\\n\\tborder-radius: 0;\\n\\n\\t@nest .ck-rounded-corners &,\\n\\t&.ck-rounded-corners {\\n\\t\\tborder-radius: var(--ck-border-radius);\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A visual style of focused element's border.\\n */\\n@define-mixin ck-focus-ring {\\n\\t/* Disable native outline. */\\n\\toutline: none;\\n\\tborder: var(--ck-focus-ring)\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A helper to combine multiple shadows.\\n */\\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\\n\\tbox-shadow: $shadowA, $shadowB;\\n}\\n\\n/**\\n * Gives an element a drop shadow so it looks like a floating panel.\\n */\\n@define-mixin ck-drop-shadow {\\n\\t@mixin ck-box-shadow var(--ck-drop-shadow);\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      2751: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css",
            ],
            names: [],
            mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-label {\\n\\tdisplay: block;\\n}\\n\\n.ck.ck-voice-label {\\n\\tdisplay: none;\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-label {\\n\\tfont-weight: bold;\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      8111: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD8GD,CAzGA,2FCDE,qCD0GF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-labeled-field-view {\\n\\t& > .ck.ck-labeled-field-view__input-wrapper {\\n\\t\\tdisplay: flex;\\n\\t\\tposition: relative;\\n\\t}\\n\\n\\t& .ck.ck-label {\\n\\t\\tdisplay: block;\\n\\t\\tposition: absolute;\\n\\t}\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\\n@import "../../../mixins/_rounded.css";\\n\\n:root {\\n\\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\\n\\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\\n\\t--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);\\n\\t--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));\\n\\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\\n}\\n\\n.ck.ck-labeled-field-view {\\n\\t@mixin ck-rounded-corners;\\n\\n\\t& > .ck.ck-labeled-field-view__input-wrapper {\\n\\t\\twidth: 100%;\\n\\n\\t\\t& > .ck.ck-label {\\n\\t\\t\\ttop: 0px;\\n\\n\\t\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\t\\tleft: 0px;\\n\\t\\t\\t}\\n\\n\\t\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\t\\tright: 0px;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpointer-events: none;\\n\\t\\t\\ttransform-origin: 0 0;\\n\\n\\t\\t\\t/* By default, display the label scaled down above the field. */\\n\\t\\t\\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\\n\\n\\t\\t\\tbackground: var(--ck-color-labeled-field-label-background);\\n\\t\\t\\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\\n\\t\\t\\tline-height: initial;\\n\\t\\t\\tfont-weight: normal;\\n\\n\\t\\t\\t/* Prevent overflow when the label is longer than the input */\\n\\t\\t\\ttext-overflow: ellipsis;\\n\\t\\t\\toverflow: hidden;\\n\\n\\t\\t\\tmax-width: 100%;\\n\\n\\t\\t\\ttransition:\\n\\t\\t\\t\\ttransform var(--ck-labeled-field-view-transition),\\n\\t\\t\\t\\tpadding var(--ck-labeled-field-view-transition),\\n\\t\\t\\t\\tbackground var(--ck-labeled-field-view-transition);\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-error {\\n\\t\\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\\n\\t\\t\\tcolor: var(--ck-color-base-error);\\n\\t\\t}\\n\\n\\t\\t& .ck-input:not([readonly]) + .ck.ck-label {\\n\\t\\t\\tcolor: var(--ck-color-base-error);\\n\\t\\t}\\n\\t}\\n\\n\\t& .ck-labeled-field-view__status {\\n\\t\\tfont-size: var(--ck-font-size-small);\\n\\t\\tmargin-top: var(--ck-spacing-small);\\n\\n\\t\\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\\n\\t\\tThe status could be very long. */\\n\\t\\twhite-space: normal;\\n\\n\\t\\t&.ck-labeled-field-view__status_error {\\n\\t\\t\\tcolor: var(--ck-color-base-error);\\n\\t\\t}\\n\\t}\\n\\n\\t/* Disabled fields and fields that have no focus should fade out. */\\n\\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\\n\\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\\n\\t\\tcolor: var(--ck-color-input-disabled-text);\\n\\t}\\n\\n\\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\\n\\t/* stylelint-disable-next-line no-descending-specificity */\\n\\t&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\\n\\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\\n\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\ttransform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);\\n\\t\\t}\\n\\n\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\ttransform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);\\n\\t\\t}\\n\\n\\t\\t/* Compensate for the default translate position. */\\n\\t\\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\\n\\n\\t\\tbackground: transparent;\\n\\t\\tpadding: 0;\\n\\t}\\n\\n\\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\\n\\n\\t/* Make sure dropdown\\' background color in any of dropdown\\'s state does not collide with labeled field. */\\n\\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\\n\\t\\tbackground: transparent;\\n\\t}\\n\\n\\t/* When the dropdown is "empty", the labeled field label replaces its label. */\\n\\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\\n\\t\\topacity: 0;\\n\\t}\\n\\n\\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\\n\\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\\n\\t\\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Implements rounded corner interface for .ck-rounded-corners class.\\n *\\n * @see $ck-border-radius\\n */\\n@define-mixin ck-rounded-corners {\\n\\tborder-radius: 0;\\n\\n\\t@nest .ck-rounded-corners &,\\n\\t&.ck-rounded-corners {\\n\\t\\tborder-radius: var(--ck-border-radius);\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      1162: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../mixins/_unselectable.css";\\n\\n.ck.ck-list {\\n\\t@mixin ck-unselectable;\\n\\n\\tdisplay: flex;\\n\\tflex-direction: column;\\n\\n\\t& .ck-list__item,\\n\\t& .ck-list__separator {\\n\\t\\tdisplay: block;\\n\\t}\\n\\n\\t/* Make sure that whatever child of the list item gets focus, it remains on the\\n\\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\\n\\tadjacent list items. */\\n\\t& .ck-list__item > *:focus {\\n\\t\\tposition: relative;\\n\\t\\tz-index: var(--ck-z-default);\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Makes element unselectable.\\n */\\n@define-mixin ck-unselectable {\\n\\t-moz-user-select: none;\\n\\t-webkit-user-select: none;\\n\\t-ms-user-select: none;\\n\\tuser-select: none\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../../mixins/_disabled.css";\\n@import "../../../mixins/_rounded.css";\\n@import "../../../mixins/_shadow.css";\\n\\n.ck.ck-list {\\n\\t@mixin ck-rounded-corners;\\n\\n\\tlist-style-type: none;\\n\\tbackground: var(--ck-color-list-background);\\n}\\n\\n.ck.ck-list__item {\\n\\tcursor: default;\\n\\tmin-width: 12em;\\n\\n\\t& .ck-button {\\n\\t\\tmin-height: unset;\\n\\t\\twidth: 100%;\\n\\t\\ttext-align: left;\\n\\t\\tborder-radius: 0;\\n\\n\\t\\t/* List items should have the same height. Use absolute units to make sure it is so\\n\\t\\t   because e.g. different heading styles may have different height\\n\\t\\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\\n\\t\\tpadding:\\n\\t\\t\\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\\n\\t\\t\\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\\n\\n\\t\\t& .ck-button__label {\\n\\t\\t\\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\\n\\t\\t\\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\\n\\t\\t}\\n\\n\\t\\t&:active {\\n\\t\\t\\tbox-shadow: none;\\n\\t\\t}\\n\\n\\t\\t&.ck-on {\\n\\t\\t\\tbackground: var(--ck-color-list-button-on-background);\\n\\t\\t\\tcolor: var(--ck-color-list-button-on-text);\\n\\n\\t\\t\\t&:active {\\n\\t\\t\\t\\tbox-shadow: none;\\n\\t\\t\\t}\\n\\n\\t\\t\\t&:hover:not(.ck-disabled) {\\n\\t\\t\\t\\tbackground: var(--ck-color-list-button-on-background-focus);\\n\\t\\t\\t}\\n\\n\\t\\t\\t&:focus:not(.ck-switchbutton):not(.ck-disabled) {\\n\\t\\t\\t\\tborder-color: var(--ck-color-base-background);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t&:hover:not(.ck-disabled) {\\n\\t\\t\\tbackground: var(--ck-color-list-button-hover-background);\\n\\t\\t}\\n\\t}\\n\\n\\t/* It\\'s unnecessary to change the background/text of a switch toggle; it has different ways\\n\\tof conveying its state (like the switcher) */\\n\\t& .ck-switchbutton {\\n\\t\\t&.ck-on {\\n\\t\\t\\tbackground: var(--ck-color-list-background);\\n\\t\\t\\tcolor: inherit;\\n\\n\\t\\t\\t&:hover:not(.ck-disabled) {\\n\\t\\t\\t\\tbackground: var(--ck-color-list-button-hover-background);\\n\\t\\t\\t\\tcolor: inherit;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n.ck.ck-list__separator {\\n\\theight: 1px;\\n\\twidth: 100%;\\n\\tbackground: var(--ck-color-base-border);\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Implements rounded corner interface for .ck-rounded-corners class.\\n *\\n * @see $ck-border-radius\\n */\\n@define-mixin ck-rounded-corners {\\n\\tborder-radius: 0;\\n\\n\\t@nest .ck-rounded-corners &,\\n\\t&.ck-rounded-corners {\\n\\t\\tborder-radius: var(--ck-border-radius);\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      8245: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t/* Make sure the balloon arrow does not float over its children. */\\n\\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\\n}\\n\\n.ck.ck-balloon-panel {\\n\\tdisplay: none;\\n\\tposition: absolute;\\n\\n\\tz-index: var(--ck-z-modal);\\n\\n\\t&.ck-balloon-panel_with-arrow {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tcontent: "";\\n\\t\\t\\tposition: absolute;\\n\\t\\t}\\n\\n\\t\\t&::before {\\n\\t\\t\\tz-index: var(--ck-balloon-panel-arrow-z-index);\\n\\t\\t}\\n\\n\\t\\t&::after {\\n\\t\\t\\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\\n\\t\\t}\\n\\t}\\n\\n\\t&[class*="arrow_n"] {\\n\\t\\t&::before {\\n\\t\\t\\tz-index: var(--ck-balloon-panel-arrow-z-index);\\n\\t\\t}\\n\\n\\t\\t&::after {\\n\\t\\t\\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\\n\\t\\t}\\n\\t}\\n\\n\\t&[class*="arrow_s"] {\\n\\t\\t&::before {\\n\\t\\t\\tz-index: var(--ck-balloon-panel-arrow-z-index);\\n\\t\\t}\\n\\n\\t\\t&::after {\\n\\t\\t\\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-balloon-panel_visible {\\n\\t\\tdisplay: block;\\n\\t}\\n}\\n',
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../../mixins/_rounded.css";\\n@import "../../../mixins/_shadow.css";\\n\\n:root {\\n\\t--ck-balloon-border-width: 1px;\\n\\t--ck-balloon-arrow-offset: 2px;\\n\\t--ck-balloon-arrow-height: 10px;\\n\\t--ck-balloon-arrow-half-width: 8px;\\n\\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\\n}\\n\\n.ck.ck-balloon-panel {\\n\\t@mixin ck-rounded-corners;\\n\\t@mixin ck-drop-shadow;\\n\\n\\tmin-height: 15px;\\n\\n\\tbackground: var(--ck-color-panel-background);\\n\\tborder: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);\\n\\n\\t&.ck-balloon-panel_with-arrow {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\twidth: 0;\\n\\t\\t\\theight: 0;\\n\\t\\t\\tborder-style: solid;\\n\\t\\t}\\n\\t}\\n\\n\\t&[class*="arrow_n"] {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\\n\\t\\t}\\n\\n\\t\\t&::before {\\n\\t\\t\\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\\n\\t\\t\\tmargin-top: calc( -1 * var(--ck-balloon-border-width) );\\n\\t\\t}\\n\\n\\t\\t&::after {\\n\\t\\t\\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\\n\\t\\t\\tmargin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\\n\\t\\t}\\n\\t}\\n\\n\\t&[class*="arrow_s"] {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\\n\\t\\t}\\n\\n\\t\\t&::before {\\n\\t\\t\\tborder-color: var(--ck-color-panel-border) transparent transparent;\\n\\t\\t\\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\\n\\t\\t\\tmargin-bottom: calc( -1 * var(--ck-balloon-border-width) );\\n\\t\\t}\\n\\n\\t\\t&::after {\\n\\t\\t\\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\\n\\t\\t\\tmargin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\\n\\t\\t}\\n\\t}\\n\\n\\t&[class*="arrow_e"] {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tborder-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);\\n\\t\\t}\\n\\n\\t\\t&::before {\\n\\t\\t\\tborder-color: transparent transparent transparent var(--ck-color-panel-border);\\n\\t\\t\\tmargin-right: calc( -1 * var(--ck-balloon-border-width) );\\n\\t\\t}\\n\\n\\t\\t&::after {\\n\\t\\t\\tborder-color: transparent transparent transparent var(--ck-color-panel-background);\\n\\t\\t\\tmargin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\\n\\t\\t}\\n\\t}\\n\\n\\t&[class*="arrow_w"] {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tborder-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;\\n\\t\\t}\\n\\n\\t\\t&::before {\\n\\t\\t\\tborder-color: transparent var(--ck-color-panel-border) transparent transparent;\\n\\t\\t\\tmargin-left: calc( -1 * var(--ck-balloon-border-width) );\\n\\t\\t}\\n\\n\\t\\t&::after {\\n\\t\\t\\tborder-color: transparent var(--ck-color-panel-background) transparent transparent;\\n\\t\\t\\tmargin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-balloon-panel_arrow_n {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tleft: 50%;\\n\\t\\t\\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\\n\\t\\t\\ttop: calc(-1 * var(--ck-balloon-arrow-height));\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-balloon-panel_arrow_nw {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\\n\\t\\t\\ttop: calc(-1 * var(--ck-balloon-arrow-height));\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-balloon-panel_arrow_ne {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tright: calc(2 * var(--ck-balloon-arrow-half-width));\\n\\t\\t\\ttop: calc(-1 * var(--ck-balloon-arrow-height));\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-balloon-panel_arrow_s {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tleft: 50%;\\n\\t\\t\\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\\n\\t\\t\\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-balloon-panel_arrow_sw {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\\n\\t\\t\\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-balloon-panel_arrow_se {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tright: calc(2 * var(--ck-balloon-arrow-half-width));\\n\\t\\t\\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-balloon-panel_arrow_sme {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tright: 25%;\\n\\t\\t\\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\\n\\t\\t\\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-balloon-panel_arrow_smw {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tleft: 25%;\\n\\t\\t\\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\\n\\t\\t\\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-balloon-panel_arrow_nme {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tright: 25%;\\n\\t\\t\\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\\n\\t\\t\\ttop: calc(-1 * var(--ck-balloon-arrow-height));\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-balloon-panel_arrow_nmw {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tleft: 25%;\\n\\t\\t\\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\\n\\t\\t\\ttop: calc(-1 * var(--ck-balloon-arrow-height));\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-balloon-panel_arrow_e {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tright: calc(-1 * var(--ck-balloon-arrow-height));\\n\\t\\t\\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\\n\\t\\t\\ttop: 50%;\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-balloon-panel_arrow_w {\\n\\t\\t&::before,\\n\\t\\t&::after {\\n\\t\\t\\tleft: calc(-1 * var(--ck-balloon-arrow-height));\\n\\t\\t\\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\\n\\t\\t\\ttop: 50%;\\n\\t\\t}\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Implements rounded corner interface for .ck-rounded-corners class.\\n *\\n * @see $ck-border-radius\\n */\\n@define-mixin ck-rounded-corners {\\n\\tborder-radius: 0;\\n\\n\\t@nest .ck-rounded-corners &,\\n\\t&.ck-rounded-corners {\\n\\t\\tborder-radius: var(--ck-border-radius);\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A helper to combine multiple shadows.\\n */\\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\\n\\tbox-shadow: $shadowA, $shadowB;\\n}\\n\\n/**\\n * Gives an element a drop shadow so it looks like a floating panel.\\n */\\n@define-mixin ck-drop-shadow {\\n\\t@mixin ck-box-shadow var(--ck-drop-shadow);\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      1757: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css",
            ],
            names: [],
            mappings:
              "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck .ck-balloon-rotator__navigation {\\n\\tdisplay: flex;\\n\\talign-items: center;\\n\\tjustify-content: center;\\n}\\n\\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\\n */\\n.ck .ck-balloon-rotator__content .ck-toolbar {\\n\\tjustify-content: center;\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck .ck-balloon-rotator__navigation {\\n\\tbackground: var(--ck-color-toolbar-background);\\n\\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\\n\\tpadding: 0 var(--ck-spacing-small);\\n\\n\\t/* Let's keep similar appearance to \`ck-toolbar\`. */\\n\\t& > * {\\n\\t\\tmargin-right: var(--ck-spacing-small);\\n\\t\\tmargin-top: var(--ck-spacing-small);\\n\\t\\tmargin-bottom: var(--ck-spacing-small);\\n\\t}\\n\\n\\t/* Gives counter more breath than buttons. */\\n\\t& .ck-balloon-rotator__counter {\\n\\t\\tmargin-right: var(--ck-spacing-standard);\\n\\n\\t\\t/* We need to use smaller margin because of previous button's right margin. */\\n\\t\\tmargin-left: var(--ck-spacing-small);\\n\\t}\\n}\\n\\n.ck .ck-balloon-rotator__content {\\n\\n\\t/* Disable default annotation shadow inside rotator with fake panels. */\\n\\t& .ck.ck-annotation-wrapper {\\n\\t\\tbox-shadow: none;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      3553: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck .ck-fake-panel {\\n\\tposition: absolute;\\n\\n\\t/* Fake panels should be placed under main balloon content. */\\n\\tz-index: calc(var(--ck-z-modal) - 1);\\n}\\n\\n.ck .ck-fake-panel div {\\n\\tposition: absolute;\\n}\\n\\n.ck .ck-fake-panel div:nth-child( 1 ) {\\n\\tz-index: 2;\\n}\\n\\n.ck .ck-fake-panel div:nth-child( 2 ) {\\n\\tz-index: 1;\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../../mixins/_shadow.css";\\n\\n:root {\\n\\t--ck-balloon-fake-panel-offset-horizontal: 6px;\\n\\t--ck-balloon-fake-panel-offset-vertical: 6px;\\n}\\n\\n/* Let\\'s use \`.ck-balloon-panel\` appearance. See: balloonpanel.css. */\\n.ck .ck-fake-panel div {\\n\\t@mixin ck-drop-shadow;\\n\\n\\tmin-height: 15px;\\n\\n\\tbackground: var(--ck-color-panel-background);\\n\\tborder: 1px solid var(--ck-color-panel-border);\\n\\tborder-radius: var(--ck-border-radius);\\n\\n\\twidth: 100%;\\n\\theight: 100%;\\n}\\n\\n.ck .ck-fake-panel div:nth-child( 1 ) {\\n\\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\\n\\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\\n}\\n\\n.ck .ck-fake-panel div:nth-child( 2 ) {\\n\\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\\n\\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\\n}\\n.ck .ck-fake-panel div:nth-child( 3 ) {\\n\\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\\n\\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\\n}\\n\\n/* If balloon is positioned above element, we need to move fake panel to the top. */\\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\\n\\t--ck-balloon-fake-panel-offset-vertical: -6px;\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A helper to combine multiple shadows.\\n */\\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\\n\\tbox-shadow: $shadowA, $shadowB;\\n}\\n\\n/**\\n * Gives an element a drop shadow so it looks like a floating panel.\\n */\\n@define-mixin ck-drop-shadow {\\n\\t@mixin ck-box-shadow var(--ck-drop-shadow);\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      3609: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-sticky-panel {\\n\\t& .ck-sticky-panel__content_sticky {\\n\\t\\tz-index: var(--ck-z-modal); /* #315 */\\n\\t\\tposition: fixed;\\n\\t\\ttop: 0;\\n\\t}\\n\\n\\t& .ck-sticky-panel__content_sticky_bottom-limit {\\n\\t\\ttop: auto;\\n\\t\\tposition: absolute;\\n\\t}\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../../mixins/_shadow.css";\\n\\n.ck.ck-sticky-panel {\\n\\t& .ck-sticky-panel__content_sticky {\\n\\t\\t@mixin ck-drop-shadow;\\n\\n\\t\\tborder-width: 0 1px 1px;\\n\\t\\tborder-top-left-radius: 0;\\n\\t\\tborder-top-right-radius: 0;\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A helper to combine multiple shadows.\\n */\\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\\n\\tbox-shadow: $shadowA, $shadowB;\\n}\\n\\n/**\\n * Gives an element a drop shadow so it looks like a floating panel.\\n */\\n@define-mixin ck-drop-shadow {\\n\\t@mixin ck-box-shadow var(--ck-drop-shadow);\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      1590: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css",
            ],
            names: [],
            mappings:
              "AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\\n\\n.ck-vertical-form .ck-button {\\n\\t&::after {\\n\\t\\tcontent: "";\\n\\t\\twidth: 0;\\n\\t\\tposition: absolute;\\n\\t\\tright: -1px;\\n\\t\\ttop: -1px;\\n\\t\\tbottom: -1px;\\n\\t\\tz-index: 1;\\n\\t}\\n\\n\\t&:focus::after {\\n\\t\\tdisplay: none;\\n\\t}\\n}\\n\\n.ck.ck-responsive-form {\\n\\t@mixin ck-media-phone {\\n\\t\\t& .ck-button {\\n\\t\\t\\t&::after {\\n\\t\\t\\t\\tcontent: "";\\n\\t\\t\\t\\twidth: 0;\\n\\t\\t\\t\\tposition: absolute;\\n\\t\\t\\t\\tright: -1px;\\n\\t\\t\\t\\ttop: -1px;\\n\\t\\t\\t\\tbottom: -1px;\\n\\t\\t\\t\\tz-index: 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t&:focus::after {\\n\\t\\t\\t\\tdisplay: none;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@define-mixin ck-media-phone {\\n\\t@media screen and (max-width: 600px) {\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\\n\\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\\n\\tborder-right: 1px solid var(--ck-color-base-border);\\n}\\n\\n.ck.ck-responsive-form {\\n\\tpadding: var(--ck-spacing-large);\\n\\n\\t&:focus {\\n\\t\\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\\n\\t\\toutline: none;\\n\\t}\\n\\n\\t@mixin ck-dir ltr {\\n\\t\\t& > :not(:first-child) {\\n\\t\\t\\tmargin-left: var(--ck-spacing-standard);\\n\\t\\t}\\n\\t}\\n\\n\\t@mixin ck-dir rtl {\\n\\t\\t& > :not(:last-child) {\\n\\t\\t\\tmargin-left: var(--ck-spacing-standard);\\n\\t\\t}\\n\\t}\\n\\n\\t@mixin ck-media-phone {\\n\\t\\tpadding: 0;\\n\\t\\twidth: calc(.8 * var(--ck-input-width));\\n\\n\\t\\t& .ck-labeled-field-view {\\n\\t\\t\\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\\n\\n\\t\\t\\t& .ck-input-text {\\n\\t\\t\\t\\tmin-width: 0;\\n\\t\\t\\t\\twidth: 100%;\\n\\t\\t\\t}\\n\\n\\t\\t\\t/* Let the long error messages wrap in the narrow form. */\\n\\t\\t\\t& .ck-labeled-field-view__error {\\n\\t\\t\\t\\twhite-space: normal;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\\n\\t\\t& > .ck-button:nth-last-child(2) {\\n\\t\\t\\t&::after {\\n\\t\\t\\t\\tborder-right: 1px solid var(--ck-color-base-border);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t& > .ck-button:nth-last-child(1),\\n\\t\\t& > .ck-button:nth-last-child(2) {\\n\\t\\t\\tpadding: var(--ck-spacing-standard);\\n\\t\\t\\tmargin-top: var(--ck-spacing-large);\\n\\t\\t\\tborder-radius: 0;\\n\\n\\t\\t\\t&:not(:focus) {\\n\\t\\t\\t\\tborder-top: 1px solid var(--ck-color-base-border);\\n\\t\\t\\t}\\n\\n\\t\\t\\t@mixin ck-dir ltr {\\n\\t\\t\\t\\tmargin-left: 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\t@mixin ck-dir rtl {\\n\\t\\t\\t\\tmargin-left: 0;\\n\\n\\t\\t\\t\\t&:last-of-type {\\n\\t\\t\\t\\t\\tborder-right: 1px solid var(--ck-color-base-border);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      6706: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css",
            ],
            names: [],
            mappings:
              "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-block-toolbar-button {\\n\\tposition: absolute;\\n\\tz-index: var(--ck-z-default);\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-color-block-toolbar-button: var(--ck-color-text);\\n\\t--ck-block-toolbar-button-size: var(--ck-font-size-normal);\\n}\\n\\n.ck.ck-block-toolbar-button {\\n\\tcolor: var(--ck-color-block-toolbar-button);\\n\\tfont-size: var(--ck-block-toolbar-size);\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      5571: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDoGD,CAvGA,qECOE,qCDgGF,CAvGA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAmGD,CAhGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAjGF,qCAqGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../mixins/_unselectable.css";\\n\\n.ck.ck-toolbar {\\n\\t@mixin ck-unselectable;\\n\\n\\tdisplay: flex;\\n\\tflex-flow: row nowrap;\\n\\talign-items: center;\\n\\n\\t& > .ck-toolbar__items {\\n\\t\\tdisplay: flex;\\n\\t\\tflex-flow: row wrap;\\n\\t\\talign-items: center;\\n\\t\\tflex-grow: 1;\\n\\n\\t}\\n\\n\\t& .ck.ck-toolbar__separator {\\n\\t\\tdisplay: inline-block;\\n\\n\\t\\t/*\\n\\t\\t * A leading or trailing separator makes no sense (separates from nothing on one side).\\n\\t\\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\\n\\t\\t * moved to another toolbar in the dropdown.\\n\\t\\t */\\n\\t\\t&:first-child,\\n\\t\\t&:last-child {\\n\\t\\t\\tdisplay: none;\\n\\t\\t}\\n\\t}\\n\\n\\t& .ck-toolbar__line-break {\\n\\t\\tflex-basis: 100%;\\n\\t}\\n\\n\\t&.ck-toolbar_grouping > .ck-toolbar__items {\\n\\t\\tflex-wrap: nowrap;\\n\\t}\\n\\n\\t&.ck-toolbar_vertical > .ck-toolbar__items {\\n\\t\\tflex-direction: column;\\n\\t}\\n\\n\\t&.ck-toolbar_floating > .ck-toolbar__items {\\n\\t\\tflex-wrap: nowrap;\\n\\t}\\n\\n\\t& > .ck.ck-toolbar__grouped-dropdown {\\n\\t\\t& > .ck-dropdown__button .ck-dropdown__arrow {\\n\\t\\t\\tdisplay: none;\\n\\t\\t}\\n\\t}\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Makes element unselectable.\\n */\\n@define-mixin ck-unselectable {\\n\\t-moz-user-select: none;\\n\\t-webkit-user-select: none;\\n\\t-ms-user-select: none;\\n\\tuser-select: none\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../../mixins/_rounded.css";\\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\\n\\n.ck.ck-toolbar {\\n\\t@mixin ck-rounded-corners;\\n\\n\\tbackground: var(--ck-color-toolbar-background);\\n\\tpadding: 0 var(--ck-spacing-small);\\n\\tborder: 1px solid var(--ck-color-toolbar-border);\\n\\n\\t& .ck.ck-toolbar__separator {\\n\\t\\talign-self: stretch;\\n\\t\\twidth: 1px;\\n\\t\\tmin-width: 1px;\\n\\t\\tbackground: var(--ck-color-toolbar-border);\\n\\n\\t\\t/*\\n\\t\\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\\n\\t\\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\\n\\t\\t */\\n\\t\\tmargin-top: var(--ck-spacing-small);\\n\\t\\tmargin-bottom: var(--ck-spacing-small);\\n\\t}\\n\\n\\t& .ck-toolbar__line-break {\\n\\t\\theight: 0;\\n\\t}\\n\\n\\t& > .ck-toolbar__items {\\n\\t\\t& > *:not(.ck-toolbar__line-break) {\\n\\t\\t\\t/* (#11) Separate toolbar items. */\\n\\t\\t\\tmargin-right: var(--ck-spacing-small);\\n\\t\\t}\\n\\n\\t\\t/* Don\\'t display a separator after an empty items container, for instance,\\n\\t\\twhen all items were grouped */\\n\\t\\t&:empty + .ck.ck-toolbar__separator {\\n\\t\\t\\tdisplay: none;\\n\\t\\t}\\n\\t}\\n\\n\\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\\n\\t& > .ck.ck-toolbar__grouped-dropdown {\\n\\t\\t/* Make sure items wrapped to the next line have v-spacing */\\n\\t\\tmargin-top: var(--ck-spacing-small);\\n\\t\\tmargin-bottom: var(--ck-spacing-small);\\n\\t}\\n\\n\\t&.ck-toolbar_vertical {\\n\\t\\t/* Items in a vertical toolbar span the entire width. */\\n\\t\\tpadding: 0;\\n\\n\\t\\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\\n\\t\\t& > .ck-toolbar__items > .ck {\\n\\t\\t\\t/* Items in a vertical toolbar should span the horizontal space. */\\n\\t\\t\\twidth: 100%;\\n\\n\\t\\t\\t/* Items in a vertical toolbar should have no margin. */\\n\\t\\t\\tmargin: 0;\\n\\n\\t\\t\\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\\n\\t\\t\\tborder-radius: 0;\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-toolbar_compact {\\n\\t\\t/* No spacing around items. */\\n\\t\\tpadding: 0;\\n\\n\\t\\t& > .ck-toolbar__items > * {\\n\\t\\t\\t/* Compact toolbar items have no spacing between them. */\\n\\t\\t\\tmargin: 0;\\n\\n\\t\\t\\t/* "Middle" children should have no rounded corners. */\\n\\t\\t\\t&:not(:first-child):not(:last-child) {\\n\\t\\t\\t\\tborder-radius: 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t& > .ck.ck-toolbar__grouped-dropdown {\\n\\t\\t/*\\n\\t\\t * Dropdown button has asymmetric padding to fit the arrow.\\n\\t\\t * This button has no arrow so let\\'s revert that padding back to normal.\\n\\t\\t */\\n\\t\\t& > .ck.ck-button.ck-dropdown__button {\\n\\t\\t\\tpadding-left: var(--ck-spacing-tiny);\\n\\t\\t}\\n\\t}\\n\\n\\t/* A drop-down containing the nested toolbar with configured items. */\\n\\t& .ck-toolbar__nested-toolbar-dropdown {\\n\\t\\t/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */\\n\\t\\t& > .ck-dropdown__panel {\\n\\t\\t\\tmin-width: auto;\\n\\t\\t}\\n\\n\\t\\t& > .ck-button > .ck-button__label {\\n\\t\\t\\tmax-width: 7em;\\n\\t\\t\\twidth: auto;\\n\\t\\t}\\n\\t}\\n\\n\\t@nest .ck-toolbar-container & {\\n\\t\\tborder: 0;\\n\\t}\\n}\\n\\n/* stylelint-disable */\\n\\n/*\\n * Styles for RTL toolbars.\\n *\\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\\n * because its parent is not controlled by the editor framework.\\n */\\n[dir="rtl"] .ck.ck-toolbar,\\n.ck.ck-toolbar[dir="rtl"] {\\n\\t& > .ck-toolbar__items > .ck {\\n\\t\\tmargin-right: 0;\\n\\t}\\n\\n\\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\\n\\t\\t/* (#11) Separate toolbar items. */\\n\\t\\tmargin-left: var(--ck-spacing-small);\\n\\t}\\n\\n\\t& > .ck-toolbar__items > .ck:last-child {\\n\\t\\tmargin-left: 0;\\n\\t}\\n\\n\\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\\n\\t\\t/* No rounded corners on the right side of the first child. */\\n\\t\\t&:first-child {\\n\\t\\t\\tborder-top-left-radius: 0;\\n\\t\\t\\tborder-bottom-left-radius: 0;\\n\\t\\t}\\n\\n\\t\\t/* No rounded corners on the left side of the last child. */\\n\\t\\t&:last-child {\\n\\t\\t\\tborder-top-right-radius: 0;\\n\\t\\t\\tborder-bottom-right-radius: 0;\\n\\t\\t}\\n\\t}\\n\\n\\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\\n\\t& > .ck.ck-toolbar__separator {\\n\\t\\tmargin-left: var(--ck-spacing-small);\\n\\t}\\n\\n\\t/* Some spacing between the items and the separator before the grouped items dropdown. */\\n\\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\\n\\t\\tmargin-left: var(--ck-spacing-small);\\n\\t}\\n}\\n\\n/*\\n * Styles for LTR toolbars.\\n *\\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\\n * because its parent is not controlled by the editor framework.\\n */\\n[dir="ltr"] .ck.ck-toolbar,\\n.ck.ck-toolbar[dir="ltr"] {\\n\\t& > .ck-toolbar__items > .ck:last-child {\\n\\t\\tmargin-right: 0;\\n\\t}\\n\\n\\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\\n\\t\\t/* No rounded corners on the right side of the first child. */\\n\\t\\t&:first-child {\\n\\t\\t\\tborder-top-right-radius: 0;\\n\\t\\t\\tborder-bottom-right-radius: 0;\\n\\t\\t}\\n\\n\\t\\t/* No rounded corners on the left side of the last child. */\\n\\t\\t&:last-child {\\n\\t\\t\\tborder-top-left-radius: 0;\\n\\t\\t\\tborder-bottom-left-radius: 0;\\n\\t\\t}\\n\\t}\\n\\n\\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\\n\\t& > .ck.ck-toolbar__separator {\\n\\t\\tmargin-right: var(--ck-spacing-small);\\n\\t}\\n\\n\\t/* Some spacing between the items and the separator before the grouped items dropdown. */\\n\\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\\n\\t\\tmargin-right: var(--ck-spacing-small);\\n\\t}\\n}\\n\\n/* stylelint-enable */\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Implements rounded corner interface for .ck-rounded-corners class.\\n *\\n * @see $ck-border-radius\\n */\\n@define-mixin ck-rounded-corners {\\n\\tborder-radius: 0;\\n\\n\\t@nest .ck-rounded-corners &,\\n\\t&.ck-rounded-corners {\\n\\t\\tborder-radius: var(--ck-border-radius);\\n\\t\\t@mixin-content;\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      9948: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css",
            ],
            names: [],
            mappings:
              "AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDPnC,mBAAoB,CAEpB,qCACD,CCMC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAbD,gCAgBC,eAMD,CAHC,uCACC,YACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-balloon-panel.ck-tooltip {\\n\\t/* Keep tooltips transparent for any interactions. */\\n\\tpointer-events: none;\\n\\n\\tz-index: calc( var(--ck-z-modal) + 100 );\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../../../mixins/_rounded.css";\\n\\n.ck.ck-balloon-panel.ck-tooltip {\\n\\t--ck-balloon-border-width: 0px;\\n\\t--ck-balloon-arrow-offset: 0px;\\n\\t--ck-balloon-arrow-half-width: 4px;\\n\\t--ck-balloon-arrow-height: 4px;\\n\\t--ck-color-panel-background: var(--ck-color-tooltip-background);\\n\\n\\tpadding: 0 var(--ck-spacing-medium);\\n\\n\\t& .ck-tooltip__text {\\n\\t\\tfont-size: .9em;\\n\\t\\tline-height: 1.5;\\n\\t\\tcolor: var(--ck-color-tooltip-text);\\n\\t}\\n\\n\\t/* Reset balloon panel styles */\\n\\tbox-shadow: none;\\n\\n\\t/* Hide the default shadow of the .ck-balloon-panel tip */\\n\\t&::before {\\n\\t\\tdisplay: none;\\n\\t}\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      6150: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_transition.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css",
            ],
            names: [],
            mappings:
              "AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAwD,CCvGxD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJuGD,CIjGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A class which hides an element in DOM.\\n */\\n.ck-hidden {\\n\\t/* Override selector specificity. Otherwise, all elements with some display\\n\\tstyle defined will override this one, which is not a desired result. */\\n\\tdisplay: none !important;\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck.ck-reset,\\n.ck.ck-reset_all,\\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\\n\\tbox-sizing: border-box;\\n\\twidth: auto;\\n\\theight: auto;\\n\\tposition: static;\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-z-default: 1;\\n\\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A class that disables all transitions of the element and its children.\\n */\\n.ck-transitions-disabled,\\n.ck-transitions-disabled * {\\n\\ttransition: none !important;\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-color-base-foreground: \\t\\t\\t\\t\\t\\t\\t\\thsl(0, 0%, 98%);\\n\\t--ck-color-base-background: \\t\\t\\t\\t\\t\\t\\t\\thsl(0, 0%, 100%);\\n\\t--ck-color-base-border: \\t\\t\\t\\t\\t\\t\\t\\t\\thsl(220, 6%, 81%);\\n\\t--ck-color-base-action: \\t\\t\\t\\t\\t\\t\\t\\t\\thsl(104, 50.2%, 42.5%);\\n\\t--ck-color-base-focus: \\t\\t\\t\\t\\t\\t\\t\\t\\t\\thsl(209, 92%, 70%);\\n\\t--ck-color-base-text: \\t\\t\\t\\t\\t\\t\\t\\t\\t\\thsl(0, 0%, 20%);\\n\\t--ck-color-base-active: \\t\\t\\t\\t\\t\\t\\t\\t\\thsl(218.1, 100%, 58%);\\n\\t--ck-color-base-active-focus:\\t\\t\\t\\t\\t\\t\\t\\thsl(218.2, 100%, 52.5%);\\n\\t--ck-color-base-error:\\t\\t\\t\\t\\t\\t\\t\\t\\t\\thsl(15, 100%, 43%);\\n\\n\\t/* -- Generic colors ------------------------------------------------------------------------ */\\n\\n\\t--ck-color-focus-border-coordinates: \\t\\t\\t\\t\\t\\t218, 81.8%, 56.9%;\\n\\t--ck-color-focus-border: \\t\\t\\t\\t\\t\\t\\t\\t\\thsl(var(--ck-color-focus-border-coordinates));\\n\\t--ck-color-focus-outer-shadow:\\t\\t\\t\\t\\t\\t\\t\\thsl(212.4, 89.3%, 89%);\\n\\t--ck-color-focus-disabled-shadow:\\t\\t\\t\\t\\t\\t\\thsla(209, 90%, 72%,.3);\\n\\t--ck-color-focus-error-shadow:\\t\\t\\t\\t\\t\\t\\t\\thsla(9,100%,56%,.3);\\n\\t--ck-color-text: \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-text);\\n\\t--ck-color-shadow-drop: \\t\\t\\t\\t\\t\\t\\t\\t\\thsla(0, 0%, 0%, 0.15);\\n\\t--ck-color-shadow-drop-active:\\t\\t\\t\\t\\t\\t\\t\\thsla(0, 0%, 0%, 0.2);\\n\\t--ck-color-shadow-inner: \\t\\t\\t\\t\\t\\t\\t\\t\\thsla(0, 0%, 0%, 0.1);\\n\\n\\t/* -- Buttons ------------------------------------------------------------------------------- */\\n\\n\\t--ck-color-button-default-background: \\t\\t\\t\\t\\t\\ttransparent;\\n\\t--ck-color-button-default-hover-background: \\t\\t\\t\\thsl(0, 0%, 94.1%);\\n\\t--ck-color-button-default-active-background: \\t\\t\\t\\thsl(0, 0%, 94.1%);\\n\\t--ck-color-button-default-disabled-background: \\t\\t\\t\\ttransparent;\\n\\n\\t--ck-color-button-on-background: \\t\\t\\t\\t\\t\\t\\thsl(212, 100%, 97.1%);\\n\\t--ck-color-button-on-hover-background: \\t\\t\\t\\t\\t\\thsl(211.7, 100%, 92.9%);\\n\\t--ck-color-button-on-active-background: \\t\\t\\t\\t\\thsl(211.7, 100%, 92.9%);\\n\\t--ck-color-button-on-disabled-background: \\t\\t\\t\\t\\thsl(211, 15%, 95%);\\n\\t--ck-color-button-on-color:\\t\\t\\t\\t\\t\\t\\t\\t\\thsl(218.1, 100%, 58%);\\n\\n\\n\\t--ck-color-button-action-background: \\t\\t\\t\\t\\t\\tvar(--ck-color-base-action);\\n\\t--ck-color-button-action-hover-background: \\t\\t\\t\\t\\thsl(104, 53.2%, 40.2%);\\n\\t--ck-color-button-action-active-background: \\t\\t\\t\\thsl(104, 53.2%, 40.2%);\\n\\t--ck-color-button-action-disabled-background: \\t\\t\\t\\thsl(104, 44%, 58%);\\n\\t--ck-color-button-action-text: \\t\\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-background);\\n\\n\\t--ck-color-button-save: \\t\\t\\t\\t\\t\\t\\t\\t\\thsl(120, 100%, 27%);\\n\\t--ck-color-button-cancel: \\t\\t\\t\\t\\t\\t\\t\\t\\thsl(15, 100%, 43%);\\n\\n\\t--ck-color-switch-button-off-background:\\t\\t\\t\\t\\thsl(0, 0%, 57.6%);\\n\\t--ck-color-switch-button-off-hover-background:\\t\\t\\t\\thsl(0, 0%, 49%);\\n\\t--ck-color-switch-button-on-background:\\t\\t\\t\\t\\t\\tvar(--ck-color-button-action-background);\\n\\t--ck-color-switch-button-on-hover-background:\\t\\t\\t\\thsl(104, 53.2%, 40.2%);\\n\\t--ck-color-switch-button-inner-background:\\t\\t\\t\\t\\tvar(--ck-color-base-background);\\n\\t--ck-color-switch-button-inner-shadow:\\t\\t\\t\\t\\t\\thsla(0, 0%, 0%, 0.1);\\n\\n\\t/* -- Dropdown ------------------------------------------------------------------------------ */\\n\\n\\t--ck-color-dropdown-panel-background: \\t\\t\\t\\t\\t\\tvar(--ck-color-base-background);\\n\\t--ck-color-dropdown-panel-border: \\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-border);\\n\\n\\t/* -- Input --------------------------------------------------------------------------------- */\\n\\n\\t--ck-color-input-background: \\t\\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-background);\\n\\t--ck-color-input-border: \\t\\t\\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-border);\\n\\t--ck-color-input-error-border:\\t\\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-error);\\n\\t--ck-color-input-text: \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-text);\\n\\t--ck-color-input-disabled-background: \\t\\t\\t\\t\\t\\thsl(0, 0%, 95%);\\n\\t--ck-color-input-disabled-border: \\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-border);\\n\\t--ck-color-input-disabled-text: \\t\\t\\t\\t\\t\\t\\thsl(0, 0%, 46%);\\n\\n\\t/* -- List ---------------------------------------------------------------------------------- */\\n\\n\\t--ck-color-list-background: \\t\\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-background);\\n\\t--ck-color-list-button-hover-background: \\t\\t\\t\\t\\tvar(--ck-color-button-default-hover-background);\\n\\t--ck-color-list-button-on-background: \\t\\t\\t\\t\\t\\tvar(--ck-color-button-on-color);\\n\\t--ck-color-list-button-on-background-focus: \\t\\t\\t\\tvar(--ck-color-button-on-color);\\n\\t--ck-color-list-button-on-text:\\t\\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-background);\\n\\n\\t/* -- Panel --------------------------------------------------------------------------------- */\\n\\n\\t--ck-color-panel-background: \\t\\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-background);\\n\\t--ck-color-panel-border: \\t\\t\\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-border);\\n\\n\\t/* -- Toolbar ------------------------------------------------------------------------------- */\\n\\n\\t--ck-color-toolbar-background: \\t\\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-background);\\n\\t--ck-color-toolbar-border: \\t\\t\\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-border);\\n\\n\\t/* -- Tooltip ------------------------------------------------------------------------------- */\\n\\n\\t--ck-color-tooltip-background: \\t\\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-text);\\n\\t--ck-color-tooltip-text: \\t\\t\\t\\t\\t\\t\\t\\t\\tvar(--ck-color-base-background);\\n\\n\\t/* -- Engine -------------------------------------------------------------------------------- */\\n\\n\\t--ck-color-engine-placeholder-text: \\t\\t\\t\\t\\t\\thsl(0, 0%, 44%);\\n\\n\\t/* -- Upload -------------------------------------------------------------------------------- */\\n\\n\\t--ck-color-upload-bar-background:\\t\\t \\t\\t\\t\\t\\thsl(209, 92%, 70%);\\n\\n\\t/* -- Link -------------------------------------------------------------------------------- */\\n\\n\\t--ck-color-link-default:\\t\\t\\t\\t\\t\\t\\t\\t\\thsl(240, 100%, 47%);\\n\\t--ck-color-link-selected-background:\\t\\t\\t\\t\\t\\thsla(201, 100%, 56%, 0.1);\\n\\t--ck-color-link-fake-selection:\\t\\t\\t\\t\\t\\t\\t\\thsla(201, 100%, 56%, 0.3);\\n\\n\\t/* -- Search result highlight ---------------------------------------------------------------- */\\n\\n\\t--ck-color-highlight-background:\\t\\t\\t\\t\\t\\t\\thsl(60, 100%, 50%)\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t/**\\n\\t * An opacity value of disabled UI item.\\n\\t */\\n\\t--ck-disabled-opacity: .5;\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t/**\\n\\t * The geometry of the of focused element's outer shadow.\\n\\t */\\n\\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\\n\\n\\t/**\\n\\t * A visual style of focused element's outer shadow.\\n\\t */\\n\\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\\n\\n\\t/**\\n\\t * A visual style of focused element's outer shadow (when disabled).\\n\\t */\\n\\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\\n\\n\\t/**\\n\\t * A visual style of focused element's outer shadow (when has errors).\\n\\t */\\n\\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\\n\\n\\t/**\\n\\t * A visual style of focused element's border or outline.\\n\\t */\\n\\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-font-size-base: 13px;\\n\\t--ck-line-height-base: 1.84615;\\n\\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\\n\\n\\t--ck-font-size-tiny: 0.7em;\\n\\t--ck-font-size-small: 0.75em;\\n\\t--ck-font-size-normal: 1em;\\n\\t--ck-font-size-big: 1.4em;\\n\\t--ck-font-size-large: 1.8em;\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t/* This is super-important. This is **manually** adjusted so a button without an icon\\n\\tis never smaller than a button with icon, additionally making sure that text-less buttons\\n\\tare perfect squares. The value is also shared by other components which should stay "in-line"\\n\\twith buttons. */\\n\\t--ck-ui-component-min-height: 2.3em;\\n}\\n\\n/**\\n * Resets an element, ignoring its children.\\n */\\n.ck.ck-reset,\\n.ck.ck-reset_all,\\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\\n\\t/* Do not include inheritable rules here. */\\n\\tmargin: 0;\\n\\tpadding: 0;\\n\\tborder: 0;\\n\\tbackground: transparent;\\n\\ttext-decoration: none;\\n\\tvertical-align: middle;\\n\\ttransition: none;\\n\\n\\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\\n\\tword-wrap: break-word;\\n}\\n\\n/**\\n * Resets an element AND its children.\\n */\\n.ck.ck-reset_all,\\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\\n\\t/* These are rule inherited by all children elements. */\\n\\tborder-collapse: collapse;\\n\\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\\n\\tcolor: var(--ck-color-text);\\n\\ttext-align: left;\\n\\twhite-space: nowrap;\\n\\tcursor: auto;\\n\\tfloat: none;\\n}\\n\\n.ck-reset_all {\\n\\t& .ck-rtl *:not(.ck-reset_all-excluded *) {\\n\\t\\ttext-align: right;\\n\\t}\\n\\n\\t& iframe:not(.ck-reset_all-excluded *) {\\n\\t\\t/* For IE */\\n\\t\\tvertical-align: inherit;\\n\\t}\\n\\n\\t& textarea:not(.ck-reset_all-excluded *) {\\n\\t\\twhite-space: pre-wrap;\\n\\t}\\n\\n\\t& textarea:not(.ck-reset_all-excluded *),\\n\\t& input[type="text"]:not(.ck-reset_all-excluded *),\\n\\t& input[type="password"]:not(.ck-reset_all-excluded *) {\\n\\t\\tcursor: text;\\n\\t}\\n\\n\\t& textarea[disabled]:not(.ck-reset_all-excluded *),\\n\\t& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\\n\\t& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\\n\\t\\tcursor: default;\\n\\t}\\n\\n\\t& fieldset:not(.ck-reset_all-excluded *) {\\n\\t\\tpadding: 10px;\\n\\t\\tborder: 2px groove hsl(255, 7%, 88%);\\n\\t}\\n\\n\\t& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\\n\\t\\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\\n\\t\\tpadding: 0;\\n\\t\\tborder: 0\\n\\t}\\n}\\n\\n/**\\n * Default UI rules for RTL languages.\\n */\\n.ck[dir="rtl"],\\n.ck[dir="rtl"] .ck {\\n\\ttext-align: right;\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * Default border-radius value.\\n */\\n:root{\\n\\t--ck-border-radius: 2px;\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t/**\\n\\t * A visual style of element's inner shadow (i.e. input).\\n\\t */\\n\\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\\n\\n\\t/**\\n\\t * A visual style of element's drop shadow (i.e. panel).\\n\\t */\\n\\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\\n\\n\\t/**\\n\\t * A visual style of element's active shadow (i.e. comment or suggestion).\\n\\t */\\n\\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-spacing-unit: \\t\\t\\t\\t\\t\\t0.6em;\\n\\t--ck-spacing-large: \\t\\t\\t\\t\\tcalc(var(--ck-spacing-unit) * 1.5);\\n\\t--ck-spacing-standard: \\t\\t\\t\\t\\tvar(--ck-spacing-unit);\\n\\t--ck-spacing-medium: \\t\\t\\t\\t\\tcalc(var(--ck-spacing-unit) * 0.8);\\n\\t--ck-spacing-small: \\t\\t\\t\\t\\tcalc(var(--ck-spacing-unit) * 0.5);\\n\\t--ck-spacing-tiny: \\t\\t\\t\\t\\t\\tcalc(var(--ck-spacing-unit) * 0.3);\\n\\t--ck-spacing-extra-tiny: \\t\\t\\t\\tcalc(var(--ck-spacing-unit) * 0.16);\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      6507: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widget.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-color-resizer: var(--ck-color-focus-border);\\n\\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\\n\\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\\n\\n\\t--ck-resizer-border-radius: var(--ck-border-radius);\\n\\t--ck-resizer-tooltip-offset: 10px;\\n\\t--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\\n}\\n\\n.ck .ck-widget {\\n\\t/* This is neccessary for type around UI to be positioned properly. */\\n\\tposition: relative;\\n}\\n\\n.ck .ck-widget.ck-widget_with-selection-handle {\\n\\t/* Make the widget wrapper a relative positioning container for the drag handle. */\\n\\tposition: relative;\\n\\n\\t& .ck-widget__selection-handle {\\n\\t\\tposition: absolute;\\n\\n\\t\\t& .ck-icon {\\n\\t\\t\\t/* Make sure the icon in not a subject to font-size or line-height to avoid\\n\\t\\t\\tunnecessary spacing around it. */\\n\\t\\t\\tdisplay: block;\\n\\t\\t}\\n\\t}\\n\\n\\t/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\\n\\t&:hover > .ck-widget__selection-handle {\\n\\t\\tvisibility: visible;\\n\\t}\\n\\n\\t/* Show the selection handle when the widget is selected, but not for nested widgets. */\\n\\t&.ck-widget_selected > .ck-widget__selection-handle {\\n\\t\\tvisibility: visible;\\n\\t}\\n}\\n\\n.ck .ck-size-view {\\n\\tbackground: var(--ck-color-resizer-tooltip-background);\\n\\tcolor: var(--ck-color-resizer-tooltip-text);\\n\\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\\n\\tborder-radius: var(--ck-resizer-border-radius);\\n\\tfont-size: var(--ck-font-size-tiny);\\n\\tdisplay: block;\\n\\tpadding: 0 var(--ck-spacing-small);\\n\\theight: var(--ck-resizer-tooltip-height);\\n\\tline-height: var(--ck-resizer-tooltip-height);\\n\\n\\t&.ck-orientation-top-left,\\n\\t&.ck-orientation-top-right,\\n\\t&.ck-orientation-bottom-right,\\n\\t&.ck-orientation-bottom-left,\\n\\t&.ck-orientation-above-center {\\n\\t\\tposition: absolute;\\n\\t}\\n\\n\\t&.ck-orientation-top-left {\\n\\t\\ttop: var(--ck-resizer-tooltip-offset);\\n\\t\\tleft: var(--ck-resizer-tooltip-offset);\\n\\t}\\n\\n\\t&.ck-orientation-top-right {\\n\\t\\ttop: var(--ck-resizer-tooltip-offset);\\n\\t\\tright: var(--ck-resizer-tooltip-offset);\\n\\t}\\n\\n\\t&.ck-orientation-bottom-right {\\n\\t\\tbottom: var(--ck-resizer-tooltip-offset);\\n\\t\\tright: var(--ck-resizer-tooltip-offset);\\n\\t}\\n\\n\\t&.ck-orientation-bottom-left {\\n\\t\\tbottom: var(--ck-resizer-tooltip-offset);\\n\\t\\tleft: var(--ck-resizer-tooltip-offset);\\n\\t}\\n\\n\\t/* Class applied if the widget is too small to contain the size label */\\n\\t&.ck-orientation-above-center {\\n\\t\\ttop: calc(var(--ck-resizer-tooltip-height) * -1);\\n\\t\\tleft: 50%;\\n\\t\\ttransform: translate(-50%);\\n\\t}\\n}\\n",
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n@import "../mixins/_focus.css";\\n@import "../mixins/_shadow.css";\\n\\n:root {\\n\\t--ck-widget-outline-thickness: 3px;\\n\\t--ck-widget-handler-icon-size: 16px;\\n\\t--ck-widget-handler-animation-duration: 200ms;\\n\\t--ck-widget-handler-animation-curve: ease;\\n\\n\\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\\n\\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\\n\\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\\n\\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\\n}\\n\\n.ck .ck-widget {\\n\\toutline-width: var(--ck-widget-outline-thickness);\\n\\toutline-style: solid;\\n\\toutline-color: transparent;\\n\\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\\n\\n\\t&.ck-widget_selected,\\n\\t&.ck-widget_selected:hover {\\n\\t\\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\\n\\t}\\n\\n\\t&:hover {\\n\\t\\toutline-color: var(--ck-color-widget-hover-border);\\n\\t}\\n}\\n\\n.ck .ck-editor__nested-editable {\\n\\tborder: 1px solid transparent;\\n\\n\\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\\n\\tThese styles show a different border for a blink of an eye, so \`:focus\` need to have same styles applied. */\\n\\t&.ck-editor__nested-editable_focused,\\n\\t&:focus {\\n\\t\\t@mixin ck-focus-ring;\\n\\t\\t@mixin ck-box-shadow var(--ck-inner-shadow);\\n\\n\\t\\tbackground-color: var(--ck-color-widget-editable-focus-background);\\n\\t}\\n}\\n\\n.ck .ck-widget.ck-widget_with-selection-handle {\\n\\t& .ck-widget__selection-handle {\\n\\t\\tpadding: 4px;\\n\\t\\tbox-sizing: border-box;\\n\\n\\t\\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\\n\\t\\tbackground-color: transparent;\\n\\t\\topacity: 0;\\n\\n\\t\\t/* Transition:\\n\\t\\t   * background-color for the .ck-widget_selected state change,\\n\\t\\t   * visibility for hiding the handler,\\n\\t\\t   * opacity for the proper look of the icon when the handler disappears. */\\n\\t\\ttransition:\\n\\t\\t\\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\\n\\t\\t\\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\\n\\t\\t\\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\\n\\n\\t\\t/* Make only top corners round. */\\n\\t\\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\\n\\n\\t\\t/* Place the drag handler outside the widget wrapper. */\\n\\t\\ttransform: translateY(-100%);\\n\\t\\tleft: calc(0px - var(--ck-widget-outline-thickness));\\n\\t\\ttop: 0;\\n\\n\\t\\t& .ck-icon {\\n\\t\\t\\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\\n\\t\\t\\twidth: var(--ck-widget-handler-icon-size);\\n\\t\\t\\theight: var(--ck-widget-handler-icon-size);\\n\\t\\t\\tcolor: var(--ck-color-widget-drag-handler-icon-color);\\n\\n\\t\\t\\t/* The "selected" part of the icon is invisible by default */\\n\\t\\t\\t& .ck-icon__selected-indicator {\\n\\t\\t\\t\\topacity: 0;\\n\\n\\t\\t\\t\\t/* Note: The animation is longer on purpose. Simply feels better. */\\n\\t\\t\\t\\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\\n\\t\\t&:hover .ck-icon .ck-icon__selected-indicator {\\n\\t\\t\\topacity: 1;\\n\\t\\t}\\n\\t}\\n\\n\\t/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\\n\\t&:hover > .ck-widget__selection-handle {\\n\\t\\topacity: 1;\\n\\t\\tbackground-color: var(--ck-color-widget-hover-border);\\n\\t}\\n\\n\\t/* Show the selection handler when the widget is selected, but not for nested widgets. */\\n\\t&.ck-widget_selected,\\n\\t&.ck-widget_selected:hover {\\n\\t\\t& > .ck-widget__selection-handle {\\n\\t\\t\\topacity: 1;\\n\\t\\t\\tbackground-color: var(--ck-color-focus-border);\\n\\n\\t\\t\\t/* When the widget is selected, notify the user using the proper look of the icon. */\\n\\t\\t\\t& .ck-icon .ck-icon__selected-indicator {\\n\\t\\t\\t\\topacity: 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n/* In a RTL environment, align the selection handler to the right side of the widget */\\n/* stylelint-disable-next-line no-descending-specificity */\\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\\n\\tleft: auto;\\n\\tright: calc(0px - var(--ck-widget-outline-thickness));\\n}\\n\\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\\n.ck.ck-editor__editable.ck-read-only .ck-widget {\\n\\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\\n\\ttransition: none;\\n\\n\\t&:not(.ck-widget_selected) {\\n\\t\\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\\n\\t\\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\\n\\t\\t *\\n\\t\\t * Leave the unit because this custom property is used in calc() by other features.\\n\\t\\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\\n\\t\\t */\\n\\t\\t--ck-widget-outline-thickness: 0px;\\n\\t}\\n\\n\\t&.ck-widget_with-selection-handle {\\n\\t\\t& .ck-widget__selection-handle,\\n\\t\\t& .ck-widget__selection-handle:hover {\\n\\t\\t\\tbackground: var(--ck-color-widget-blurred-border);\\n\\t\\t}\\n\\t}\\n}\\n\\n/* Style the widget when it\\'s selected but the editable it belongs to lost focus. */\\n/* stylelint-disable-next-line no-descending-specificity */\\n.ck.ck-editor__editable.ck-blurred .ck-widget {\\n\\t&.ck-widget_selected,\\n\\t&.ck-widget_selected:hover {\\n\\t\\toutline-color: var(--ck-color-widget-blurred-border);\\n\\n\\t\\t&.ck-widget_with-selection-handle {\\n\\t\\t\\t& > .ck-widget__selection-handle,\\n\\t\\t\\t& > .ck-widget__selection-handle:hover {\\n\\t\\t\\t\\tbackground: var(--ck-color-widget-blurred-border);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\\n\\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\\n\\tIn fact, anything with overflow: hidden.\\n\\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\\n\\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\\n\\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\\n\\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\\n}\\n',
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A visual style of focused element's border.\\n */\\n@define-mixin ck-focus-ring {\\n\\t/* Disable native outline. */\\n\\toutline: none;\\n\\tborder: var(--ck-focus-ring)\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n/**\\n * A helper to combine multiple shadows.\\n */\\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\\n\\tbox-shadow: $shadowA, $shadowB;\\n}\\n\\n/**\\n * Gives an element a drop shadow so it looks like a floating panel.\\n */\\n@define-mixin ck-drop-shadow {\\n\\t@mixin ck-box-shadow var(--ck-drop-shadow);\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      2263: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css",
            ],
            names: [],
            mappings:
              "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD",
            sourcesContent: [
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck .ck-widget_with-resizer {\\n\\t/* Make the widget wrapper a relative positioning container for the drag handle. */\\n\\tposition: relative;\\n}\\n\\n.ck .ck-widget__resizer {\\n\\tdisplay: none;\\n\\tposition: absolute;\\n\\n\\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\\n\\tpointer-events: none;\\n\\n\\tleft: 0;\\n\\ttop: 0;\\n}\\n\\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\\n\\t& > .ck-widget__resizer {\\n\\t\\tdisplay: block;\\n\\t}\\n}\\n\\n.ck .ck-widget__resizer__handle {\\n\\tposition: absolute;\\n\\n\\t/* Resizers are the only UI elements that should interfere with a pointer device. */\\n\\tpointer-events: all;\\n\\n\\t&.ck-widget__resizer__handle-top-left,\\n\\t&.ck-widget__resizer__handle-bottom-right {\\n\\t\\tcursor: nwse-resize;\\n\\t}\\n\\n\\t&.ck-widget__resizer__handle-top-right,\\n\\t&.ck-widget__resizer__handle-bottom-left {\\n\\t\\tcursor: nesw-resize;\\n\\t}\\n}\\n",
              "/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-resizer-size: 10px;\\n\\n\\t/* Set the resizer with a 50% offset. */\\n\\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\\n\\t--ck-resizer-border-width: 1px;\\n}\\n\\n.ck .ck-widget__resizer {\\n\\toutline: 1px solid var(--ck-color-resizer);\\n}\\n\\n.ck .ck-widget__resizer__handle {\\n\\twidth: var(--ck-resizer-size);\\n\\theight: var(--ck-resizer-size);\\n\\tbackground: var(--ck-color-focus-border);\\n\\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\\n\\tborder-radius: var(--ck-resizer-border-radius);\\n\\n\\t&.ck-widget__resizer__handle-top-left {\\n\\t\\ttop: var(--ck-resizer-offset);\\n\\t\\tleft: var(--ck-resizer-offset);\\n\\t}\\n\\n\\t&.ck-widget__resizer__handle-top-right {\\n\\t\\ttop: var(--ck-resizer-offset);\\n\\t\\tright: var(--ck-resizer-offset);\\n\\t}\\n\\n\\t&.ck-widget__resizer__handle-bottom-right {\\n\\t\\tbottom: var(--ck-resizer-offset);\\n\\t\\tright: var(--ck-resizer-offset);\\n\\t}\\n\\n\\t&.ck-widget__resizer__handle-bottom-left {\\n\\t\\tbottom: var(--ck-resizer-offset);\\n\\t\\tleft: var(--ck-resizer-offset);\\n\\t}\\n}\\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      5137: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css",
            ],
            names: [],
            mappings:
              "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD",
            sourcesContent: [
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n.ck .ck-widget {\\n\\t/*\\n\\t * Styles of the type around buttons\\n\\t */\\n\\t& .ck-widget__type-around__button {\\n\\t\\tdisplay: block;\\n\\t\\tposition: absolute;\\n\\t\\toverflow: hidden;\\n\\t\\tz-index: var(--ck-z-default);\\n\\n\\t\\t& svg {\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\ttop: 50%;\\n\\t\\t\\tleft: 50%;\\n\\t\\t\\tz-index: calc(var(--ck-z-default) + 2);\\n\\t\\t}\\n\\n\\t\\t&.ck-widget__type-around__button_before {\\n\\t\\t\\t/* Place it in the middle of the outline */\\n\\t\\t\\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\\n\\t\\t\\tleft: min(10%, 30px);\\n\\n\\t\\t\\ttransform: translateY(-50%);\\n\\t\\t}\\n\\n\\t\\t&.ck-widget__type-around__button_after {\\n\\t\\t\\t/* Place it in the middle of the outline */\\n\\t\\t\\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\\n\\t\\t\\tright: min(10%, 30px);\\n\\n\\t\\t\\ttransform: translateY(50%);\\n\\t\\t}\\n\\t}\\n\\n\\t/*\\n\\t * Styles for the buttons when:\\n\\t * - the widget is selected,\\n\\t * - or the button is being hovered (regardless of the widget state).\\n\\t */\\n\\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\\n\\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\\n\\t\\t&::after {\\n\\t\\t\\tcontent: "";\\n\\t\\t\\tdisplay: block;\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\ttop: 1px;\\n\\t\\t\\tleft: 1px;\\n\\t\\t\\tz-index: calc(var(--ck-z-default) + 1);\\n\\t\\t}\\n\\t}\\n\\n\\t/*\\n\\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\\n\\t */\\n\\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\\n\\t\\tdisplay: none;\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0;\\n\\t\\tright: 0;\\n\\t}\\n\\n\\t/*\\n\\t * When the widget is hovered the "fake caret" would normally be narrower than the\\n\\t * extra outline displayed around the widget. Let\\'s extend the "fake caret" to match\\n\\t * the full width of the widget.\\n\\t */\\n\\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\\n\\t\\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\\n\\t\\tright: calc( -1 * var(--ck-widget-outline-thickness) );\\n\\t}\\n\\n\\t/*\\n\\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\\n\\t */\\n\\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\\n\\t\\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\\n\\t\\tdisplay: block;\\n\\t}\\n\\n\\t/*\\n\\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\\n\\t */\\n\\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\\n\\t\\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\\n\\t\\tdisplay: block;\\n\\t}\\n}\\n\\n/*\\n * Integration with the read-only mode of the editor.\\n */\\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\\n\\tdisplay: none;\\n}\\n\\n/*\\n * Integration with the restricted editing mode (feature) of the editor.\\n */\\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\\n\\tdisplay: none;\\n}\\n\\n/*\\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\\n */\\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\\n\\tdisplay: none;\\n}\\n',
              '/*\\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\\n */\\n\\n:root {\\n\\t--ck-widget-type-around-button-size: 20px;\\n\\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\\n\\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\\n\\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\\n\\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\\n\\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\\n\\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\\n}\\n\\n@define-mixin ck-widget-type-around-button-visible {\\n\\topacity: 1;\\n\\tpointer-events: auto;\\n}\\n\\n@define-mixin ck-widget-type-around-button-hidden {\\n\\topacity: 0;\\n\\tpointer-events: none;\\n}\\n\\n.ck .ck-widget {\\n\\t/*\\n\\t * Styles of the type around buttons\\n\\t */\\n\\t& .ck-widget__type-around__button {\\n\\t\\twidth: var(--ck-widget-type-around-button-size);\\n\\t\\theight: var(--ck-widget-type-around-button-size);\\n\\t\\tbackground: var(--ck-color-widget-type-around-button);\\n\\t\\tborder-radius: 100px;\\n\\t\\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\\n\\n\\t\\t@mixin ck-widget-type-around-button-hidden;\\n\\n\\t\\t& svg {\\n\\t\\t\\twidth: 10px;\\n\\t\\t\\theight: 8px;\\n\\t\\t\\ttransform: translate(-50%,-50%);\\n\\t\\t\\ttransition: transform .5s ease;\\n\\t\\t\\tmargin-top: 1px;\\n\\n\\t\\t\\t& * {\\n\\t\\t\\t\\tstroke-dasharray: 10;\\n\\t\\t\\t\\tstroke-dashoffset: 0;\\n\\n\\t\\t\\t\\tfill: none;\\n\\t\\t\\t\\tstroke: var(--ck-color-widget-type-around-button-icon);\\n\\t\\t\\t\\tstroke-width: 1.5px;\\n\\t\\t\\t\\tstroke-linecap: round;\\n\\t\\t\\t\\tstroke-linejoin: round;\\n\\t\\t\\t}\\n\\n\\t\\t\\t& line {\\n\\t\\t\\t\\tstroke-dasharray: 7;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t&:hover {\\n\\t\\t\\t/*\\n\\t\\t\\t * Display the "sonar" around the button when hovered.\\n\\t\\t\\t */\\n\\t\\t\\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\\n\\n\\t\\t\\t/*\\n\\t\\t\\t * Animate active button\\'s icon.\\n\\t\\t\\t */\\n\\t\\t\\t& svg {\\n\\t\\t\\t\\t& polyline {\\n\\t\\t\\t\\t\\tanimation: ck-widget-type-around-arrow-dash 2s linear;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t& line {\\n\\t\\t\\t\\t\\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/*\\n\\t * Show type around buttons when the widget gets selected or being hovered.\\n\\t */\\n\\t&.ck-widget_selected,\\n\\t&:hover {\\n\\t\\t& > .ck-widget__type-around > .ck-widget__type-around__button {\\n\\t\\t\\t@mixin ck-widget-type-around-button-visible;\\n\\t\\t}\\n\\t}\\n\\n\\t/*\\n\\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\\n\\t * and still can be hovered).\\n\\t */\\n\\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\\n\\t\\tbackground: var(--ck-color-widget-type-around-button-hover);\\n\\t}\\n\\n\\t/*\\n\\t * Styles for the buttons when:\\n\\t * - the widget is selected,\\n\\t * - or the button is being hovered (regardless of the widget state).\\n\\t */\\n\\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\\n\\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\\n\\t\\tbackground: var(--ck-color-widget-type-around-button-active);\\n\\n\\t\\t&::after {\\n\\t\\t\\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\\n\\t\\t\\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\\n\\t\\t\\tborder-radius: 100px;\\n\\t\\t\\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\\n\\t\\t}\\n\\t}\\n\\n\\t/*\\n\\t * Styles for the "before" button when the widget has a selection handle. Because some space\\n\\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\\n\\t */\\n\\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\\n\\t\\tmargin-left: 20px;\\n\\t}\\n\\n\\t/*\\n\\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\\n\\t */\\n\\t& .ck-widget__type-around__fake-caret {\\n\\t\\tpointer-events: none;\\n\\t\\theight: 1px;\\n\\t\\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\\n\\n\\t\\t/*\\n\\t\\t * The semi-transparent-outline+background combo improves the contrast\\n\\t\\t * when the background underneath the fake caret is dark.\\n\\t\\t */\\n\\t\\toutline: solid 1px hsla(0, 0%, 100%, .5);\\n\\t\\tbackground: var(--ck-color-base-text);\\n\\t}\\n\\n\\t/*\\n\\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\\n\\t * Despite the widget being physically selected in the model, its outline should disappear.\\n\\t */\\n\\t&.ck-widget_selected {\\n\\t\\t&.ck-widget_type-around_show-fake-caret_before,\\n\\t\\t&.ck-widget_type-around_show-fake-caret_after {\\n\\t\\t\\toutline-color: transparent;\\n\\t\\t}\\n\\t}\\n\\n\\t&.ck-widget_type-around_show-fake-caret_before,\\n\\t&.ck-widget_type-around_show-fake-caret_after {\\n\\t\\t/*\\n\\t\\t * When the "fake caret" is visible we simulate that the widget is not selected\\n\\t\\t * (despite being physically selected), so the outline color should be for the\\n\\t\\t * unselected widget.\\n\\t\\t */\\n\\t\\t&.ck-widget_selected:hover {\\n\\t\\t\\toutline-color: var(--ck-color-widget-hover-border);\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\\n\\t\\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\\n\\t\\t */\\n\\t\\t& > .ck-widget__type-around > .ck-widget__type-around__button {\\n\\t\\t\\t@mixin ck-widget-type-around-button-hidden;\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\\n\\t\\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\\n\\t\\t */\\n\\t\\t&.ck-widget_with-selection-handle {\\n\\t\\t\\t&.ck-widget_selected,\\n\\t\\t\\t&.ck-widget_selected:hover {\\n\\t\\t\\t\\t& > .ck-widget__selection-handle {\\n\\t\\t\\t\\t\\topacity: 0\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\\n\\t\\t * hide the resize UI because it creates too much noise. It can be visible when the user\\n\\t\\t * hovers the widget, though.\\n\\t\\t */\\n\\t\\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\\n\\t\\t\\topacity: 0\\n\\t\\t}\\n\\t}\\n}\\n\\n/*\\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\\n * The selection handler is aligned to the right side of the widget so there is no need to create\\n * additional space for it next to the "before" button.\\n */\\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\\n\\tmargin-left: 0;\\n\\tmargin-right: 20px;\\n}\\n\\n/*\\n * Hide type around buttons when the widget is selected as a child of a selected\\n * nested editable (e.g. mulit-cell table selection).\\n *\\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\\n */\\n.ck-editor__nested-editable.ck-editor__editable_selected {\\n\\t& .ck-widget {\\n\\t\\t&.ck-widget_selected,\\n\\t\\t&:hover {\\n\\t\\t\\t& > .ck-widget__type-around > .ck-widget__type-around__button {\\n\\t\\t\\t\\t@mixin ck-widget-type-around-button-hidden;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n/*\\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\\n */\\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\\n\\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\\n\\n\\t& svg * {\\n\\t\\tstroke: hsl(0,0%,60%);\\n\\t}\\n}\\n\\n@keyframes ck-widget-type-around-arrow-dash {\\n\\t0% {\\n\\t\\tstroke-dashoffset: 10;\\n\\t}\\n\\t20%, 100% {\\n\\t\\tstroke-dashoffset: 0;\\n\\t}\\n}\\n\\n@keyframes ck-widget-type-around-arrow-tip-dash {\\n\\t0%, 20% {\\n\\t\\tstroke-dashoffset: 7;\\n\\t}\\n\\t40%, 100% {\\n\\t\\tstroke-dashoffset: 0;\\n\\t}\\n}\\n\\n@keyframes ck-widget-type-around-button-sonar {\\n\\t0% {\\n\\t\\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\\n\\t}\\n\\t50% {\\n\\t\\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\\n\\t}\\n\\t100% {\\n\\t\\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\\n\\t}\\n}\\n\\n@keyframes ck-widget-type-around-fake-caret-pulse {\\n\\t0% {\\n\\t\\topacity: 1;\\n\\t}\\n\\t49% {\\n\\t\\topacity: 1;\\n\\t}\\n\\t50% {\\n\\t\\topacity: 0;\\n\\t}\\n\\t99% {\\n\\t\\topacity: 0;\\n\\t}\\n\\t100% {\\n\\t\\topacity: 1;\\n\\t}\\n}\\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      3645: (t) => {
        t.exports = function (t) {
          var e = [];
          e.toString = function e() {
            return this.map(function (e) {
              var n = t(e);
              if (e[2]) {
                return "@media ".concat(e[2], " {").concat(n, "}");
              }
              return n;
            }).join("");
          };
          e.i = function (t, n, i) {
            if (typeof t === "string") {
              t = [[null, t, ""]];
            }
            var o = {};
            if (i) {
              for (var r = 0; r < this.length; r++) {
                var s = this[r][0];
                if (s != null) {
                  o[s] = true;
                }
              }
            }
            for (var a = 0; a < t.length; a++) {
              var c = [].concat(t[a]);
              if (i && o[c[0]]) {
                continue;
              }
              if (n) {
                if (!c[2]) {
                  c[2] = n;
                } else {
                  c[2] = "".concat(n, " and ").concat(c[2]);
                }
              }
              e.push(c);
            }
          };
          return e;
        };
      },
      4015: (t) => {
        function e(t, e) {
          return s(t) || r(t, e) || i(t, e) || n();
        }
        function n() {
          throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        }
        function i(t, e) {
          if (!t) return;
          if (typeof t === "string") return o(t, e);
          var n = Object.prototype.toString.call(t).slice(8, -1);
          if (n === "Object" && t.constructor) n = t.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(t);
          if (
            n === "Arguments" ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          )
            return o(t, e);
        }
        function o(t, e) {
          if (e == null || e > t.length) e = t.length;
          for (var n = 0, i = new Array(e); n < e; n++) {
            i[n] = t[n];
          }
          return i;
        }
        function r(t, e) {
          var n =
            t &&
            ((typeof Symbol !== "undefined" && t[Symbol.iterator]) ||
              t["@@iterator"]);
          if (n == null) return;
          var i = [];
          var o = true;
          var r = false;
          var s, a;
          try {
            for (n = n.call(t); !(o = (s = n.next()).done); o = true) {
              i.push(s.value);
              if (e && i.length === e) break;
            }
          } catch (t) {
            r = true;
            a = t;
          } finally {
            try {
              if (!o && n["return"] != null) n["return"]();
            } finally {
              if (r) throw a;
            }
          }
          return i;
        }
        function s(t) {
          if (Array.isArray(t)) return t;
        }
        t.exports = function t(n) {
          var i = e(n, 4),
            o = i[1],
            r = i[3];
          if (!r) {
            return o;
          }
          if (typeof btoa === "function") {
            var s = btoa(unescape(encodeURIComponent(JSON.stringify(r))));
            var a =
              "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(
                s
              );
            var c = "/*# ".concat(a, " */");
            var l = r.sources.map(function (t) {
              return "/*# sourceURL="
                .concat(r.sourceRoot || "")
                .concat(t, " */");
            });
            return [o].concat(l).concat([c]).join("\\n");
          }
          return [o].join("\\n");
        };
      },
      3379: (t, e, n) => {
        var i = (function t() {
          var e;
          return function t() {
            if (typeof e === "undefined") {
              e = Boolean(window && document && document.all && !window.atob);
            }
            return e;
          };
        })();
        var o = (function t() {
          var e = {};
          return function t(n) {
            if (typeof e[n] === "undefined") {
              var i = document.querySelector(n);
              if (
                window.HTMLIFrameElement &&
                i instanceof window.HTMLIFrameElement
              ) {
                try {
                  i = i.contentDocument.head;
                } catch (t) {
                  i = null;
                }
              }
              e[n] = i;
            }
            return e[n];
          };
        })();
        var r = [];
        function s(t) {
          var e = -1;
          for (var n = 0; n < r.length; n++) {
            if (r[n].identifier === t) {
              e = n;
              break;
            }
          }
          return e;
        }
        function a(t, e) {
          var n = {};
          var i = [];
          for (var o = 0; o < t.length; o++) {
            var a = t[o];
            var c = e.base ? a[0] + e.base : a[0];
            var l = n[c] || 0;
            var d = "".concat(c, " ").concat(l);
            n[c] = l + 1;
            var u = s(d);
            var h = { css: a[1], media: a[2], sourceMap: a[3] };
            if (u !== -1) {
              r[u].references++;
              r[u].updater(h);
            } else {
              r.push({ identifier: d, updater: f(h, e), references: 1 });
            }
            i.push(d);
          }
          return i;
        }
        function c(t) {
          var e = document.createElement("style");
          var i = t.attributes || {};
          if (typeof i.nonce === "undefined") {
            var r = true ? n.nc : 0;
            if (r) {
              i.nonce = r;
            }
          }
          Object.keys(i).forEach(function (t) {
            e.setAttribute(t, i[t]);
          });
          if (typeof t.insert === "function") {
            t.insert(e);
          } else {
            var s = o(t.insert || "head");
            if (!s) {
              throw new Error(
                "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
              );
            }
            s.appendChild(e);
          }
          return e;
        }
        function l(t) {
          if (t.parentNode === null) {
            return false;
          }
          t.parentNode.removeChild(t);
        }
        var d = (function t() {
          var e = [];
          return function t(n, i) {
            e[n] = i;
            return e.filter(Boolean).join("\\n");
          };
        })();
        function u(t, e, n, i) {
          var o = n
            ? ""
            : i.media
            ? "@media ".concat(i.media, " {").concat(i.css, "}")
            : i.css;
          if (t.styleSheet) {
            t.styleSheet.cssText = d(e, o);
          } else {
            var r = document.createTextNode(o);
            var s = t.childNodes;
            if (s[e]) {
              t.removeChild(s[e]);
            }
            if (s.length) {
              t.insertBefore(r, s[e]);
            } else {
              t.appendChild(r);
            }
          }
        }
        function h(t, e, n) {
          var i = n.css;
          var o = n.media;
          var r = n.sourceMap;
          if (o) {
            t.setAttribute("media", o);
          } else {
            t.removeAttribute("media");
          }
          if (r && typeof btoa !== "undefined") {
            i += "\\n/*# sourceMappingURL=data:application/json;base64,".concat(
              btoa(unescape(encodeURIComponent(JSON.stringify(r)))),
              " */"
            );
          }
          if (t.styleSheet) {
            t.styleSheet.cssText = i;
          } else {
            while (t.firstChild) {
              t.removeChild(t.firstChild);
            }
            t.appendChild(document.createTextNode(i));
          }
        }
        var m = null;
        var g = 0;
        function f(t, e) {
          var n;
          var i;
          var o;
          if (e.singleton) {
            var r = g++;
            n = m || (m = c(e));
            i = u.bind(null, n, r, false);
            o = u.bind(null, n, r, true);
          } else {
            n = c(e);
            i = h.bind(null, n, e);
            o = function t() {
              l(n);
            };
          }
          i(t);
          return function e(n) {
            if (n) {
              if (
                n.css === t.css &&
                n.media === t.media &&
                n.sourceMap === t.sourceMap
              ) {
                return;
              }
              i((t = n));
            } else {
              o();
            }
          };
        }
        t.exports = function (t, e) {
          e = e || {};
          if (!e.singleton && typeof e.singleton !== "boolean") {
            e.singleton = i();
          }
          t = t || [];
          var n = a(t, e);
          return function t(i) {
            i = i || [];
            if (Object.prototype.toString.call(i) !== "[object Array]") {
              return;
            }
            for (var o = 0; o < n.length; o++) {
              var c = n[o];
              var l = s(c);
              r[l].references--;
            }
            var d = a(i, e);
            for (var u = 0; u < n.length; u++) {
              var h = n[u];
              var m = s(h);
              if (r[m].references === 0) {
                r[m].updater();
                r.splice(m, 1);
              }
            }
            n = d;
          };
        };
      },
    };
    var e = {};
    function n(i) {
      var o = e[i];
      if (o !== undefined) {
        return o.exports;
      }
      var r = (e[i] = { id: i, exports: {} });
      t[i](r, r.exports, n);
      return r.exports;
    }
    (() => {
      n.n = (t) => {
        var e = t && t.__esModule ? () => t["default"] : () => t;
        n.d(e, { a: e });
        return e;
      };
    })();
    (() => {
      n.d = (t, e) => {
        for (var i in e) {
          if (n.o(e, i) && !n.o(t, i)) {
            Object.defineProperty(t, i, { enumerable: true, get: e[i] });
          }
        }
      };
    })();
    (() => {
      n.g = (function () {
        if (typeof globalThis === "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch (t) {
          if (typeof window === "object") return window;
        }
      })();
    })();
    (() => {
      n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
    })();
    (() => {
      n.nc = undefined;
    })();
    var i = {};
    (() => {
      n.d(i, { default: () => iK });
      function t() {
        try {
          return navigator.userAgent.toLowerCase();
        } catch (t) {
          return "";
        }
      }
      const e = t();
      const o = {
        isMac: s(e),
        isWindows: a(e),
        isGecko: c(e),
        isSafari: l(e),
        isiOS: d(e),
        isAndroid: u(e),
        isBlink: h(e),
        features: { isRegExpUnicodePropertySupported: m() },
      };
      const r = o;
      function s(t) {
        return t.indexOf("macintosh") > -1;
      }
      function a(t) {
        return t.indexOf("windows") > -1;
      }
      function c(t) {
        return !!t.match(/gecko\\/\\d+/);
      }
      function l(t) {
        return t.indexOf(" applewebkit/") > -1 && t.indexOf("chrome") === -1;
      }
      function d(t) {
        return (
          !!t.match(/iphone|ipad/i) || (s(t) && navigator.maxTouchPoints > 0)
        );
      }
      function u(t) {
        return t.indexOf("android") > -1;
      }
      function h(t) {
        return t.indexOf("chrome/") > -1 && t.indexOf("edge/") < 0;
      }
      function m() {
        let t = false;
        try {
          t = "".search(new RegExp("[\\\\p{L}]", "u")) === 0;
        } catch (t) {}
        return t;
      }
      function g(t, e, n, i) {
        n =
          n ||
          function (t, e) {
            return t === e;
          };
        const o = Array.isArray(t) ? t : Array.prototype.slice.call(t);
        const r = Array.isArray(e) ? e : Array.prototype.slice.call(e);
        const s = f(o, r, n);
        const a = i ? w(s, r.length) : k(r, s);
        return a;
      }
      function f(t, e, n) {
        const i = p(t, e, n);
        if (i === -1) {
          return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
        }
        const o = b(t, i);
        const r = b(e, i);
        const s = p(o, r, n);
        const a = t.length - s;
        const c = e.length - s;
        return { firstIndex: i, lastIndexOld: a, lastIndexNew: c };
      }
      function p(t, e, n) {
        for (let i = 0; i < Math.max(t.length, e.length); i++) {
          if (t[i] === undefined || e[i] === undefined || !n(t[i], e[i])) {
            return i;
          }
        }
        return -1;
      }
      function b(t, e) {
        return t.slice(e).reverse();
      }
      function k(t, e) {
        const n = [];
        const { firstIndex: i, lastIndexOld: o, lastIndexNew: r } = e;
        if (r - i > 0) {
          n.push({ index: i, type: "insert", values: t.slice(i, r) });
        }
        if (o - i > 0) {
          n.push({ index: i + (r - i), type: "delete", howMany: o - i });
        }
        return n;
      }
      function w(t, e) {
        const { firstIndex: n, lastIndexOld: i, lastIndexNew: o } = t;
        if (n === -1) {
          return Array(e).fill("equal");
        }
        let r = [];
        if (n > 0) {
          r = r.concat(Array(n).fill("equal"));
        }
        if (o - n > 0) {
          r = r.concat(Array(o - n).fill("insert"));
        }
        if (i - n > 0) {
          r = r.concat(Array(i - n).fill("delete"));
        }
        if (o < e) {
          r = r.concat(Array(e - o).fill("equal"));
        }
        return r;
      }
      function A(t, e, n) {
        n =
          n ||
          function (t, e) {
            return t === e;
          };
        const i = t.length;
        const o = e.length;
        if (i > 200 || o > 200 || i + o > 300) {
          return A.fastDiff(t, e, n, true);
        }
        let r, s;
        if (o < i) {
          const n = t;
          t = e;
          e = n;
          r = "delete";
          s = "insert";
        } else {
          r = "insert";
          s = "delete";
        }
        const a = t.length;
        const c = e.length;
        const l = c - a;
        const d = {};
        const u = {};
        function h(i) {
          const o = (u[i - 1] !== undefined ? u[i - 1] : -1) + 1;
          const l = u[i + 1] !== undefined ? u[i + 1] : -1;
          const h = o > l ? -1 : 1;
          if (d[i + h]) {
            d[i] = d[i + h].slice(0);
          }
          if (!d[i]) {
            d[i] = [];
          }
          d[i].push(o > l ? r : s);
          let m = Math.max(o, l);
          let g = m - i;
          while (g < a && m < c && n(t[g], e[m])) {
            g++;
            m++;
            d[i].push("equal");
          }
          return m;
        }
        let m = 0;
        let g;
        do {
          for (g = -m; g < l; g++) {
            u[g] = h(g);
          }
          for (g = l + m; g > l; g--) {
            u[g] = h(g);
          }
          u[l] = h(l);
          m++;
        } while (u[l] !== c);
        return d[l].slice(1);
      }
      A.fastDiff = g;
      function C(t, ...e) {
        e.forEach((e) => {
          const n = Object.getOwnPropertyNames(e);
          const i = Object.getOwnPropertySymbols(e);
          n.concat(i).forEach((n) => {
            if (n in t.prototype) {
              return;
            }
            if (
              typeof e == "function" &&
              (n == "length" || n == "name" || n == "prototype")
            ) {
              return;
            }
            const i = Object.getOwnPropertyDescriptor(e, n);
            i.enumerable = false;
            Object.defineProperty(t.prototype, n, i);
          });
        });
      }
      function _() {
        return function t() {
          t.called = true;
        };
      }
      const v = _;
      class y {
        constructor(t, e) {
          this.source = t;
          this.name = e;
          this.path = [];
          this.stop = v();
          this.off = v();
        }
      }
      const x = new Array(256)
        .fill("")
        .map((t, e) => ("0" + e.toString(16)).slice(-2));
      function E() {
        const t = (Math.random() * 4294967296) >>> 0;
        const e = (Math.random() * 4294967296) >>> 0;
        const n = (Math.random() * 4294967296) >>> 0;
        const i = (Math.random() * 4294967296) >>> 0;
        return (
          "e" +
          x[(t >> 0) & 255] +
          x[(t >> 8) & 255] +
          x[(t >> 16) & 255] +
          x[(t >> 24) & 255] +
          x[(e >> 0) & 255] +
          x[(e >> 8) & 255] +
          x[(e >> 16) & 255] +
          x[(e >> 24) & 255] +
          x[(n >> 0) & 255] +
          x[(n >> 8) & 255] +
          x[(n >> 16) & 255] +
          x[(n >> 24) & 255] +
          x[(i >> 0) & 255] +
          x[(i >> 8) & 255] +
          x[(i >> 16) & 255] +
          x[(i >> 24) & 255]
        );
      }
      const D = {
        get(t = "normal") {
          if (typeof t != "number") {
            return this[t] || this.normal;
          } else {
            return t;
          }
        },
        highest: 1e5,
        high: 1e3,
        normal: 0,
        low: -1e3,
        lowest: -1e5,
      };
      const S = D;
      function T(t, e) {
        const n = S.get(e.priority);
        for (let i = 0; i < t.length; i++) {
          if (S.get(t[i].priority) < n) {
            t.splice(i, 0, e);
            return;
          }
        }
        t.push(e);
      }
      const I =
        "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
      class M extends Error {
        constructor(t, e, n) {
          super(z(t, n));
          this.name = "CKEditorError";
          this.context = e;
          this.data = n;
        }
        is(t) {
          return t === "CKEditorError";
        }
        static rethrowUnexpectedError(t, e) {
          if (t.is && t.is("CKEditorError")) {
            throw t;
          }
          const n = new M(t.message, e);
          n.stack = t.stack;
          throw n;
        }
      }
      function B(t, e) {
        console.warn(...P(t, e));
      }
      function L(t, e) {
        console.error(...P(t, e));
      }
      function N(t) {
        return \`\\nRead more: \${I}#error-\${t}\`;
      }
      function z(t, e) {
        const n = new WeakSet();
        const i = (t, e) => {
          if (typeof e === "object" && e !== null) {
            if (n.has(e)) {
              return \`[object \${e.constructor.name}]\`;
            }
            n.add(e);
          }
          return e;
        };
        const o = e ? \` \${JSON.stringify(e, i)}\` : "";
        const r = N(t);
        return t + o + r;
      }
      function P(t, e) {
        const n = N(t);
        return e ? [t, e, n] : [t, n];
      }
      const R = "35.4.0";
      const O = null && R;
      const j = typeof window === "object" ? window : n.g;
      if (j.CKEDITOR_VERSION) {
        throw new M("ckeditor-duplicated-modules", null);
      } else {
        j.CKEDITOR_VERSION = R;
      }
      const F = Symbol("listeningTo");
      const V = Symbol("emitterId");
      const H = Symbol("delegations");
      const U = q(Object);
      function q(t) {
        if (!t) {
          return U;
        }
        class e extends t {
          on(t, e, n) {
            this.listenTo(this, t, e, n);
          }
          once(t, e, n) {
            let i = false;
            const o = (t, ...n) => {
              if (!i) {
                i = true;
                t.off();
                e.call(this, t, ...n);
              }
            };
            this.listenTo(this, t, o, n);
          }
          off(t, e) {
            this.stopListening(this, t, e);
          }
          listenTo(t, e, n, i = {}) {
            let o, r;
            if (!this[F]) {
              this[F] = {};
            }
            const s = this[F];
            if (!$(t)) {
              G(t);
            }
            const a = $(t);
            if (!(o = s[a])) {
              o = s[a] = { emitter: t, callbacks: {} };
            }
            if (!(r = o.callbacks[e])) {
              r = o.callbacks[e] = [];
            }
            r.push(n);
            tt(this, t, e, n, i);
          }
          stopListening(t, e, n) {
            const i = this[F];
            let o = t && $(t);
            const r = i && o ? i[o] : undefined;
            const s = r && e ? r.callbacks[e] : undefined;
            if (!i || (t && !r) || (e && !s)) {
              return;
            }
            if (n) {
              et(this, t, e, n);
              const i = s.indexOf(n);
              if (i !== -1) {
                if (s.length === 1) {
                  delete r.callbacks[e];
                } else {
                  et(this, t, e, n);
                }
              }
            } else if (s) {
              while ((n = s.pop())) {
                et(this, t, e, n);
              }
              delete r.callbacks[e];
            } else if (r) {
              for (e in r.callbacks) {
                this.stopListening(t, e);
              }
              delete i[o];
            } else {
              for (o in i) {
                this.stopListening(i[o].emitter);
              }
              delete this[F];
            }
          }
          fire(t, ...e) {
            try {
              const n = t instanceof y ? t : new y(this, t);
              const i = n.name;
              let o = J(this, i);
              n.path.push(this);
              if (o) {
                const t = [n, ...e];
                o = Array.from(o);
                for (let e = 0; e < o.length; e++) {
                  o[e].callback.apply(this, t);
                  if (n.off.called) {
                    delete n.off.called;
                    this._removeEventListener(i, o[e].callback);
                  }
                  if (n.stop.called) {
                    break;
                  }
                }
              }
              const r = this[H];
              if (r) {
                const t = r.get(i);
                const o = r.get("*");
                if (t) {
                  X(t, n, e);
                }
                if (o) {
                  X(o, n, e);
                }
              }
              return n.return;
            } catch (t) {
              M.rethrowUnexpectedError(t, this);
            }
          }
          delegate(...t) {
            return {
              to: (e, n) => {
                if (!this[H]) {
                  this[H] = new Map();
                }
                t.forEach((t) => {
                  const i = this[H].get(t);
                  if (!i) {
                    this[H].set(t, new Map([[e, n]]));
                  } else {
                    i.set(e, n);
                  }
                });
              },
            };
          }
          stopDelegating(t, e) {
            if (!this[H]) {
              return;
            }
            if (!t) {
              this[H].clear();
            } else if (!e) {
              this[H].delete(t);
            } else {
              const n = this[H].get(t);
              if (n) {
                n.delete(e);
              }
            }
          }
          _addEventListener(t, e, n) {
            Z(this, t);
            const i = Q(this, t);
            const o = S.get(n.priority);
            const r = { callback: e, priority: o };
            for (const t of i) {
              T(t, r);
            }
          }
          _removeEventListener(t, e) {
            const n = Q(this, t);
            for (const t of n) {
              for (let n = 0; n < t.length; n++) {
                if (t[n].callback == e) {
                  t.splice(n, 1);
                  n--;
                }
              }
            }
          }
        }
        return e;
      }
      [
        "on",
        "once",
        "off",
        "listenTo",
        "stopListening",
        "fire",
        "delegate",
        "stopDelegating",
        "_addEventListener",
        "_removeEventListener",
      ].forEach((t) => {
        q[t] = U.prototype[t];
      });
      function W(t, e) {
        const n = t[F];
        if (n && n[e]) {
          return n[e].emitter;
        }
        return null;
      }
      function G(t, e) {
        if (!t[V]) {
          t[V] = e || E();
        }
      }
      function $(t) {
        return t[V];
      }
      function K(t) {
        if (!t._events) {
          Object.defineProperty(t, "_events", { value: {} });
        }
        return t._events;
      }
      function Y() {
        return { callbacks: [], childEvents: [] };
      }
      function Z(t, e) {
        const n = K(t);
        if (n[e]) {
          return;
        }
        let i = e;
        let o = null;
        const r = [];
        while (i !== "") {
          if (n[i]) {
            break;
          }
          n[i] = Y();
          r.push(n[i]);
          if (o) {
            n[i].childEvents.push(o);
          }
          o = i;
          i = i.substr(0, i.lastIndexOf(":"));
        }
        if (i !== "") {
          for (const t of r) {
            t.callbacks = n[i].callbacks.slice();
          }
          n[i].childEvents.push(o);
        }
      }
      function Q(t, e) {
        const n = K(t)[e];
        if (!n) {
          return [];
        }
        let i = [n.callbacks];
        for (let e = 0; e < n.childEvents.length; e++) {
          const o = Q(t, n.childEvents[e]);
          i = i.concat(o);
        }
        return i;
      }
      function J(t, e) {
        let n;
        if (!t._events || !(n = t._events[e]) || !n.callbacks.length) {
          if (e.indexOf(":") > -1) {
            return J(t, e.substr(0, e.lastIndexOf(":")));
          } else {
            return null;
          }
        }
        return n.callbacks;
      }
      function X(t, e, n) {
        for (let [i, o] of t) {
          if (!o) {
            o = e.name;
          } else if (typeof o == "function") {
            o = o(e.name);
          }
          const t = new y(e.source, o);
          t.path = [...e.path];
          i.fire(t, ...n);
        }
      }
      function tt(t, e, n, i, o) {
        if (e._addEventListener) {
          e._addEventListener(n, i, o);
        } else {
          t._addEventListener.call(e, n, i, o);
        }
      }
      function et(t, e, n, i) {
        if (e._removeEventListener) {
          e._removeEventListener(n, i);
        } else {
          t._removeEventListener.call(e, n, i);
        }
      }
      function nt(t) {
        var e = typeof t;
        return t != null && (e == "object" || e == "function");
      }
      const it = nt;
      const ot = Symbol("observableProperties");
      const rt = Symbol("boundObservables");
      const st = Symbol("boundProperties");
      const at = Symbol("decoratedMethods");
      const ct = Symbol("decoratedOriginal");
      const lt = dt(q());
      function dt(t) {
        if (!t) {
          return lt;
        }
        class e extends t {
          set(t, e) {
            if (it(t)) {
              Object.keys(t).forEach((e) => {
                this.set(e, t[e]);
              }, this);
              return;
            }
            ut(this);
            const n = this[ot];
            if (t in this && !n.has(t)) {
              throw new M("observable-set-cannot-override", this);
            }
            Object.defineProperty(this, t, {
              enumerable: true,
              configurable: true,
              get() {
                return n.get(t);
              },
              set(e) {
                const i = n.get(t);
                let o = this.fire(\`set:\${t}\`, t, e, i);
                if (o === undefined) {
                  o = e;
                }
                if (i !== o || !n.has(t)) {
                  n.set(t, o);
                  this.fire(\`change:\${t}\`, t, o, i);
                }
              },
            });
            this[t] = e;
          }
          bind(...t) {
            if (!t.length || !ft(t)) {
              throw new M("observable-bind-wrong-properties", this);
            }
            if (new Set(t).size !== t.length) {
              throw new M("observable-bind-duplicate-properties", this);
            }
            ut(this);
            const e = this[st];
            t.forEach((t) => {
              if (e.has(t)) {
                throw new M("observable-bind-rebind", this);
              }
            });
            const n = new Map();
            t.forEach((t) => {
              const i = { property: t, to: [] };
              e.set(t, i);
              n.set(t, i);
            });
            return {
              to: ht,
              toMany: mt,
              _observable: this,
              _bindProperties: t,
              _to: [],
              _bindings: n,
            };
          }
          unbind(...t) {
            if (!this[ot]) {
              return;
            }
            const e = this[st];
            const n = this[rt];
            if (t.length) {
              if (!ft(t)) {
                throw new M("observable-unbind-wrong-properties", this);
              }
              t.forEach((t) => {
                const i = e.get(t);
                if (!i) {
                  return;
                }
                i.to.forEach(([t, e]) => {
                  const o = n.get(t);
                  const r = o[e];
                  r.delete(i);
                  if (!r.size) {
                    delete o[e];
                  }
                  if (!Object.keys(o).length) {
                    n.delete(t);
                    this.stopListening(t, "change");
                  }
                });
                e.delete(t);
              });
            } else {
              n.forEach((t, e) => {
                this.stopListening(e, "change");
              });
              n.clear();
              e.clear();
            }
          }
          decorate(t) {
            ut(this);
            const e = this[t];
            if (!e) {
              throw new M("observablemixin-cannot-decorate-undefined", this, {
                object: this,
                methodName: t,
              });
            }
            this.on(t, (t, n) => {
              t.return = e.apply(this, n);
            });
            this[t] = function (...e) {
              return this.fire(t, e);
            };
            this[t][ct] = e;
            if (!this[at]) {
              this[at] = [];
            }
            this[at].push(t);
          }
          stopListening(t, e, n) {
            if (!t && this[at]) {
              for (const t of this[at]) {
                this[t] = this[t][ct];
              }
              delete this[at];
            }
            super.stopListening(t, e, n);
          }
        }
        return e;
      }
      [
        "set",
        "bind",
        "unbind",
        "decorate",
        "on",
        "once",
        "off",
        "listenTo",
        "stopListening",
        "fire",
        "delegate",
        "stopDelegating",
        "_addEventListener",
        "_removeEventListener",
      ].forEach((t) => {
        dt[t] = lt.prototype[t];
      });
      function ut(t) {
        if (t[ot]) {
          return;
        }
        Object.defineProperty(t, ot, { value: new Map() });
        Object.defineProperty(t, rt, { value: new Map() });
        Object.defineProperty(t, st, { value: new Map() });
      }
      function ht(...t) {
        const e = pt(...t);
        const n = Array.from(this._bindings.keys());
        const i = n.length;
        if (!e.callback && e.to.length > 1) {
          throw new M("observable-bind-to-no-callback", this);
        }
        if (i > 1 && e.callback) {
          throw new M("observable-bind-to-extra-callback", this);
        }
        e.to.forEach((t) => {
          if (t.properties.length && t.properties.length !== i) {
            throw new M("observable-bind-to-properties-length", this);
          }
          if (!t.properties.length) {
            t.properties = this._bindProperties;
          }
        });
        this._to = e.to;
        if (e.callback) {
          this._bindings.get(n[0]).callback = e.callback;
        }
        At(this._observable, this._to);
        kt(this);
        this._bindProperties.forEach((t) => {
          wt(this._observable, t);
        });
      }
      function mt(t, e, n) {
        if (this._bindings.size > 1) {
          throw new M("observable-bind-to-many-not-one-binding", this);
        }
        this.to(...gt(t, e), n);
      }
      function gt(t, e) {
        const n = t.map((t) => [t, e]);
        return Array.prototype.concat.apply([], n);
      }
      function ft(t) {
        return t.every((t) => typeof t == "string");
      }
      function pt(...t) {
        if (!t.length) {
          throw new M("observable-bind-to-parse-error", null);
        }
        const e = { to: [] };
        let n;
        if (typeof t[t.length - 1] == "function") {
          e.callback = t.pop();
        }
        t.forEach((t) => {
          if (typeof t == "string") {
            n.properties.push(t);
          } else if (typeof t == "object") {
            n = { observable: t, properties: [] };
            e.to.push(n);
          } else {
            throw new M("observable-bind-to-parse-error", null);
          }
        });
        return e;
      }
      function bt(t, e, n, i) {
        const o = t[rt];
        const r = o.get(n);
        const s = r || {};
        if (!s[i]) {
          s[i] = new Set();
        }
        s[i].add(e);
        if (!r) {
          o.set(n, s);
        }
      }
      function kt(t) {
        let e;
        t._bindings.forEach((n, i) => {
          t._to.forEach((o) => {
            e = o.properties[n.callback ? 0 : t._bindProperties.indexOf(i)];
            n.to.push([o.observable, e]);
            bt(t._observable, n, o.observable, e);
          });
        });
      }
      function wt(t, e) {
        const n = t[st];
        const i = n.get(e);
        let o;
        if (i.callback) {
          o = i.callback.apply(
            t,
            i.to.map((t) => t[0][t[1]])
          );
        } else {
          o = i.to[0];
          o = o[0][o[1]];
        }
        if (Object.prototype.hasOwnProperty.call(t, e)) {
          t[e] = o;
        } else {
          t.set(e, o);
        }
      }
      function At(t, e) {
        e.forEach((e) => {
          const n = t[rt];
          let i;
          if (!n.get(e.observable)) {
            t.listenTo(e.observable, "change", (o, r) => {
              i = n.get(e.observable)[r];
              if (i) {
                i.forEach((e) => {
                  wt(t, e.property);
                });
              }
            });
          }
        });
      }
      class Ct {
        constructor() {
          this._replacedElements = [];
        }
        replace(t, e) {
          this._replacedElements.push({ element: t, newElement: e });
          t.style.display = "none";
          if (e) {
            t.parentNode.insertBefore(e, t.nextSibling);
          }
        }
        restore() {
          this._replacedElements.forEach(({ element: t, newElement: e }) => {
            t.style.display = "";
            if (e) {
              e.remove();
            }
          });
          this._replacedElements = [];
        }
      }
      function _t(t) {
        let e = 0;
        for (const n of t) {
          e++;
        }
        return e;
      }
      function vt(t, e) {
        const n = Math.min(t.length, e.length);
        for (let i = 0; i < n; i++) {
          if (t[i] != e[i]) {
            return i;
          }
        }
        if (t.length == e.length) {
          return "same";
        } else if (t.length < e.length) {
          return "prefix";
        } else {
          return "extension";
        }
      }
      function yt(t) {
        return !!(t && t[Symbol.iterator]);
      }
      var xt =
        typeof global == "object" &&
        global &&
        global.Object === Object &&
        global;
      const Et = xt;
      var Dt =
        typeof self == "object" && self && self.Object === Object && self;
      var St = Et || Dt || Function("return this")();
      const Tt = St;
      var It = Tt.Symbol;
      const Mt = It;
      var Bt = Object.prototype;
      var Lt = Bt.hasOwnProperty;
      var Nt = Bt.toString;
      var zt = Mt ? Mt.toStringTag : undefined;
      function Pt(t) {
        var e = Lt.call(t, zt),
          n = t[zt];
        try {
          t[zt] = undefined;
          var i = true;
        } catch (t) {}
        var o = Nt.call(t);
        if (i) {
          if (e) {
            t[zt] = n;
          } else {
            delete t[zt];
          }
        }
        return o;
      }
      const Rt = Pt;
      var Ot = Object.prototype;
      var jt = Ot.toString;
      function Ft(t) {
        return jt.call(t);
      }
      const Vt = Ft;
      var Ht = "[object Null]",
        Ut = "[object Undefined]";
      var qt = Mt ? Mt.toStringTag : undefined;
      function Wt(t) {
        if (t == null) {
          return t === undefined ? Ut : Ht;
        }
        return qt && qt in Object(t) ? Rt(t) : Vt(t);
      }
      const Gt = Wt;
      var $t = Array.isArray;
      const Kt = $t;
      function Yt(t) {
        return t != null && typeof t == "object";
      }
      const Zt = Yt;
      var Qt = "[object String]";
      function Jt(t) {
        return typeof t == "string" || (!Kt(t) && Zt(t) && Gt(t) == Qt);
      }
      const Xt = Jt;
      function te(t, e, n = {}, i = []) {
        const o = n && n.xmlns;
        const r = o ? t.createElementNS(o, e) : t.createElement(e);
        for (const t in n) {
          r.setAttribute(t, n[t]);
        }
        if (Xt(i) || !yt(i)) {
          i = [i];
        }
        for (let e of i) {
          if (Xt(e)) {
            e = t.createTextNode(e);
          }
          r.appendChild(e);
        }
        return r;
      }
      function ee(t, e) {
        return function (n) {
          return t(e(n));
        };
      }
      const ne = ee;
      var ie = ne(Object.getPrototypeOf, Object);
      const oe = ie;
      var re = "[object Object]";
      var se = Function.prototype,
        ae = Object.prototype;
      var ce = se.toString;
      var le = ae.hasOwnProperty;
      var de = ce.call(Object);
      function ue(t) {
        if (!Zt(t) || Gt(t) != re) {
          return false;
        }
        var e = oe(t);
        if (e === null) {
          return true;
        }
        var n = le.call(e, "constructor") && e.constructor;
        return typeof n == "function" && n instanceof n && ce.call(n) == de;
      }
      const he = ue;
      function me() {
        this.__data__ = [];
        this.size = 0;
      }
      const ge = me;
      function fe(t, e) {
        return t === e || (t !== t && e !== e);
      }
      const pe = fe;
      function be(t, e) {
        var n = t.length;
        while (n--) {
          if (pe(t[n][0], e)) {
            return n;
          }
        }
        return -1;
      }
      const ke = be;
      var we = Array.prototype;
      var Ae = we.splice;
      function Ce(t) {
        var e = this.__data__,
          n = ke(e, t);
        if (n < 0) {
          return false;
        }
        var i = e.length - 1;
        if (n == i) {
          e.pop();
        } else {
          Ae.call(e, n, 1);
        }
        --this.size;
        return true;
      }
      const _e = Ce;
      function ve(t) {
        var e = this.__data__,
          n = ke(e, t);
        return n < 0 ? undefined : e[n][1];
      }
      const ye = ve;
      function xe(t) {
        return ke(this.__data__, t) > -1;
      }
      const Ee = xe;
      function De(t, e) {
        var n = this.__data__,
          i = ke(n, t);
        if (i < 0) {
          ++this.size;
          n.push([t, e]);
        } else {
          n[i][1] = e;
        }
        return this;
      }
      const Se = De;
      function Te(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.clear();
        while (++e < n) {
          var i = t[e];
          this.set(i[0], i[1]);
        }
      }
      Te.prototype.clear = ge;
      Te.prototype["delete"] = _e;
      Te.prototype.get = ye;
      Te.prototype.has = Ee;
      Te.prototype.set = Se;
      const Ie = Te;
      function Me() {
        this.__data__ = new Ie();
        this.size = 0;
      }
      const Be = Me;
      function Le(t) {
        var e = this.__data__,
          n = e["delete"](t);
        this.size = e.size;
        return n;
      }
      const Ne = Le;
      function ze(t) {
        return this.__data__.get(t);
      }
      const Pe = ze;
      function Re(t) {
        return this.__data__.has(t);
      }
      const Oe = Re;
      var je = "[object AsyncFunction]",
        Fe = "[object Function]",
        Ve = "[object GeneratorFunction]",
        He = "[object Proxy]";
      function Ue(t) {
        if (!it(t)) {
          return false;
        }
        var e = Gt(t);
        return e == Fe || e == Ve || e == je || e == He;
      }
      const qe = Ue;
      var We = Tt["__core-js_shared__"];
      const Ge = We;
      var $e = (function () {
        var t = /[^.]+$/.exec((Ge && Ge.keys && Ge.keys.IE_PROTO) || "");
        return t ? "Symbol(src)_1." + t : "";
      })();
      function Ke(t) {
        return !!$e && $e in t;
      }
      const Ye = Ke;
      var Ze = Function.prototype;
      var Qe = Ze.toString;
      function Je(t) {
        if (t != null) {
          try {
            return Qe.call(t);
          } catch (t) {}
          try {
            return t + "";
          } catch (t) {}
        }
        return "";
      }
      const Xe = Je;
      var tn = /[\\\\^$.*+?()[\\]{}|]/g;
      var en = /^\\[object .+?Constructor\\]$/;
      var nn = Function.prototype,
        on = Object.prototype;
      var rn = nn.toString;
      var sn = on.hasOwnProperty;
      var an = RegExp(
        "^" +
          rn
            .call(sn)
            .replace(tn, "\\\\$&")
            .replace(
              /hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,
              "$1.*?"
            ) +
          "$"
      );
      function cn(t) {
        if (!it(t) || Ye(t)) {
          return false;
        }
        var e = qe(t) ? an : en;
        return e.test(Xe(t));
      }
      const ln = cn;
      function dn(t, e) {
        return t == null ? undefined : t[e];
      }
      const un = dn;
      function hn(t, e) {
        var n = un(t, e);
        return ln(n) ? n : undefined;
      }
      const mn = hn;
      var gn = mn(Tt, "Map");
      const fn = gn;
      var pn = mn(Object, "create");
      const bn = pn;
      function kn() {
        this.__data__ = bn ? bn(null) : {};
        this.size = 0;
      }
      const wn = kn;
      function An(t) {
        var e = this.has(t) && delete this.__data__[t];
        this.size -= e ? 1 : 0;
        return e;
      }
      const Cn = An;
      var _n = "__lodash_hash_undefined__";
      var vn = Object.prototype;
      var yn = vn.hasOwnProperty;
      function xn(t) {
        var e = this.__data__;
        if (bn) {
          var n = e[t];
          return n === _n ? undefined : n;
        }
        return yn.call(e, t) ? e[t] : undefined;
      }
      const En = xn;
      var Dn = Object.prototype;
      var Sn = Dn.hasOwnProperty;
      function Tn(t) {
        var e = this.__data__;
        return bn ? e[t] !== undefined : Sn.call(e, t);
      }
      const In = Tn;
      var Mn = "__lodash_hash_undefined__";
      function Bn(t, e) {
        var n = this.__data__;
        this.size += this.has(t) ? 0 : 1;
        n[t] = bn && e === undefined ? Mn : e;
        return this;
      }
      const Ln = Bn;
      function Nn(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.clear();
        while (++e < n) {
          var i = t[e];
          this.set(i[0], i[1]);
        }
      }
      Nn.prototype.clear = wn;
      Nn.prototype["delete"] = Cn;
      Nn.prototype.get = En;
      Nn.prototype.has = In;
      Nn.prototype.set = Ln;
      const zn = Nn;
      function Pn() {
        this.size = 0;
        this.__data__ = {
          hash: new zn(),
          map: new (fn || Ie)(),
          string: new zn(),
        };
      }
      const Rn = Pn;
      function On(t) {
        var e = typeof t;
        return e == "string" || e == "number" || e == "symbol" || e == "boolean"
          ? t !== "__proto__"
          : t === null;
      }
      const jn = On;
      function Fn(t, e) {
        var n = t.__data__;
        return jn(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
      }
      const Vn = Fn;
      function Hn(t) {
        var e = Vn(this, t)["delete"](t);
        this.size -= e ? 1 : 0;
        return e;
      }
      const Un = Hn;
      function qn(t) {
        return Vn(this, t).get(t);
      }
      const Wn = qn;
      function Gn(t) {
        return Vn(this, t).has(t);
      }
      const $n = Gn;
      function Kn(t, e) {
        var n = Vn(this, t),
          i = n.size;
        n.set(t, e);
        this.size += n.size == i ? 0 : 1;
        return this;
      }
      const Yn = Kn;
      function Zn(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.clear();
        while (++e < n) {
          var i = t[e];
          this.set(i[0], i[1]);
        }
      }
      Zn.prototype.clear = Rn;
      Zn.prototype["delete"] = Un;
      Zn.prototype.get = Wn;
      Zn.prototype.has = $n;
      Zn.prototype.set = Yn;
      const Qn = Zn;
      var Jn = 200;
      function Xn(t, e) {
        var n = this.__data__;
        if (n instanceof Ie) {
          var i = n.__data__;
          if (!fn || i.length < Jn - 1) {
            i.push([t, e]);
            this.size = ++n.size;
            return this;
          }
          n = this.__data__ = new Qn(i);
        }
        n.set(t, e);
        this.size = n.size;
        return this;
      }
      const ti = Xn;
      function ei(t) {
        var e = (this.__data__ = new Ie(t));
        this.size = e.size;
      }
      ei.prototype.clear = Be;
      ei.prototype["delete"] = Ne;
      ei.prototype.get = Pe;
      ei.prototype.has = Oe;
      ei.prototype.set = ti;
      const ni = ei;
      function ii(t, e) {
        var n = -1,
          i = t == null ? 0 : t.length;
        while (++n < i) {
          if (e(t[n], n, t) === false) {
            break;
          }
        }
        return t;
      }
      const oi = ii;
      var ri = (function () {
        try {
          var t = mn(Object, "defineProperty");
          t({}, "", {});
          return t;
        } catch (t) {}
      })();
      const si = ri;
      function ai(t, e, n) {
        if (e == "__proto__" && si) {
          si(t, e, {
            configurable: true,
            enumerable: true,
            value: n,
            writable: true,
          });
        } else {
          t[e] = n;
        }
      }
      const ci = ai;
      var li = Object.prototype;
      var di = li.hasOwnProperty;
      function ui(t, e, n) {
        var i = t[e];
        if (!(di.call(t, e) && pe(i, n)) || (n === undefined && !(e in t))) {
          ci(t, e, n);
        }
      }
      const hi = ui;
      function mi(t, e, n, i) {
        var o = !n;
        n || (n = {});
        var r = -1,
          s = e.length;
        while (++r < s) {
          var a = e[r];
          var c = i ? i(n[a], t[a], a, n, t) : undefined;
          if (c === undefined) {
            c = t[a];
          }
          if (o) {
            ci(n, a, c);
          } else {
            hi(n, a, c);
          }
        }
        return n;
      }
      const gi = mi;
      function fi(t, e) {
        var n = -1,
          i = Array(t);
        while (++n < t) {
          i[n] = e(n);
        }
        return i;
      }
      const pi = fi;
      var bi = "[object Arguments]";
      function ki(t) {
        return Zt(t) && Gt(t) == bi;
      }
      const wi = ki;
      var Ai = Object.prototype;
      var Ci = Ai.hasOwnProperty;
      var _i = Ai.propertyIsEnumerable;
      var vi = wi(
        (function () {
          return arguments;
        })()
      )
        ? wi
        : function (t) {
            return Zt(t) && Ci.call(t, "callee") && !_i.call(t, "callee");
          };
      const yi = vi;
      function xi() {
        return false;
      }
      const Ei = xi;
      var Di =
        typeof exports == "object" && exports && !exports.nodeType && exports;
      var Si =
        Di && typeof module == "object" && module && !module.nodeType && module;
      var Ti = Si && Si.exports === Di;
      var Ii = Ti ? Tt.Buffer : undefined;
      var Mi = Ii ? Ii.isBuffer : undefined;
      var Bi = Mi || Ei;
      const Li = Bi;
      var Ni = 9007199254740991;
      var zi = /^(?:0|[1-9]\\d*)$/;
      function Pi(t, e) {
        var n = typeof t;
        e = e == null ? Ni : e;
        return (
          !!e &&
          (n == "number" || (n != "symbol" && zi.test(t))) &&
          t > -1 &&
          t % 1 == 0 &&
          t < e
        );
      }
      const Ri = Pi;
      var Oi = 9007199254740991;
      function ji(t) {
        return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Oi;
      }
      const Fi = ji;
      var Vi = "[object Arguments]",
        Hi = "[object Array]",
        Ui = "[object Boolean]",
        qi = "[object Date]",
        Wi = "[object Error]",
        Gi = "[object Function]",
        $i = "[object Map]",
        Ki = "[object Number]",
        Yi = "[object Object]",
        Zi = "[object RegExp]",
        Qi = "[object Set]",
        Ji = "[object String]",
        Xi = "[object WeakMap]";
      var to = "[object ArrayBuffer]",
        eo = "[object DataView]",
        no = "[object Float32Array]",
        io = "[object Float64Array]",
        oo = "[object Int8Array]",
        ro = "[object Int16Array]",
        so = "[object Int32Array]",
        ao = "[object Uint8Array]",
        co = "[object Uint8ClampedArray]",
        lo = "[object Uint16Array]",
        uo = "[object Uint32Array]";
      var ho = {};
      ho[no] =
        ho[io] =
        ho[oo] =
        ho[ro] =
        ho[so] =
        ho[ao] =
        ho[co] =
        ho[lo] =
        ho[uo] =
          true;
      ho[Vi] =
        ho[Hi] =
        ho[to] =
        ho[Ui] =
        ho[eo] =
        ho[qi] =
        ho[Wi] =
        ho[Gi] =
        ho[$i] =
        ho[Ki] =
        ho[Yi] =
        ho[Zi] =
        ho[Qi] =
        ho[Ji] =
        ho[Xi] =
          false;
      function mo(t) {
        return Zt(t) && Fi(t.length) && !!ho[Gt(t)];
      }
      const go = mo;
      function fo(t) {
        return function (e) {
          return t(e);
        };
      }
      const po = fo;
      var bo =
        typeof exports == "object" && exports && !exports.nodeType && exports;
      var ko =
        bo && typeof module == "object" && module && !module.nodeType && module;
      var wo = ko && ko.exports === bo;
      var Ao = wo && Et.process;
      var Co = (function () {
        try {
          var t = ko && ko.require && ko.require("util").types;
          if (t) {
            return t;
          }
          return Ao && Ao.binding && Ao.binding("util");
        } catch (t) {}
      })();
      const _o = Co;
      var vo = _o && _o.isTypedArray;
      var yo = vo ? po(vo) : go;
      const xo = yo;
      var Eo = Object.prototype;
      var Do = Eo.hasOwnProperty;
      function So(t, e) {
        var n = Kt(t),
          i = !n && yi(t),
          o = !n && !i && Li(t),
          r = !n && !i && !o && xo(t),
          s = n || i || o || r,
          a = s ? pi(t.length, String) : [],
          c = a.length;
        for (var l in t) {
          if (
            (e || Do.call(t, l)) &&
            !(
              s &&
              (l == "length" ||
                (o && (l == "offset" || l == "parent")) ||
                (r &&
                  (l == "buffer" || l == "byteLength" || l == "byteOffset")) ||
                Ri(l, c))
            )
          ) {
            a.push(l);
          }
        }
        return a;
      }
      const To = So;
      var Io = Object.prototype;
      function Mo(t) {
        var e = t && t.constructor,
          n = (typeof e == "function" && e.prototype) || Io;
        return t === n;
      }
      const Bo = Mo;
      var Lo = ne(Object.keys, Object);
      const No = Lo;
      var zo = Object.prototype;
      var Po = zo.hasOwnProperty;
      function Ro(t) {
        if (!Bo(t)) {
          return No(t);
        }
        var e = [];
        for (var n in Object(t)) {
          if (Po.call(t, n) && n != "constructor") {
            e.push(n);
          }
        }
        return e;
      }
      const Oo = Ro;
      function jo(t) {
        return t != null && Fi(t.length) && !qe(t);
      }
      const Fo = jo;
      function Vo(t) {
        return Fo(t) ? To(t) : Oo(t);
      }
      const Ho = Vo;
      function Uo(t, e) {
        return t && gi(e, Ho(e), t);
      }
      const qo = Uo;
      function Wo(t) {
        var e = [];
        if (t != null) {
          for (var n in Object(t)) {
            e.push(n);
          }
        }
        return e;
      }
      const Go = Wo;
      var $o = Object.prototype;
      var Ko = $o.hasOwnProperty;
      function Yo(t) {
        if (!it(t)) {
          return Go(t);
        }
        var e = Bo(t),
          n = [];
        for (var i in t) {
          if (!(i == "constructor" && (e || !Ko.call(t, i)))) {
            n.push(i);
          }
        }
        return n;
      }
      const Zo = Yo;
      function Qo(t) {
        return Fo(t) ? To(t, true) : Zo(t);
      }
      const Jo = Qo;
      function Xo(t, e) {
        return t && gi(e, Jo(e), t);
      }
      const tr = Xo;
      var er =
        typeof exports == "object" && exports && !exports.nodeType && exports;
      var nr =
        er && typeof module == "object" && module && !module.nodeType && module;
      var ir = nr && nr.exports === er;
      var or = ir ? Tt.Buffer : undefined,
        rr = or ? or.allocUnsafe : undefined;
      function sr(t, e) {
        if (e) {
          return t.slice();
        }
        var n = t.length,
          i = rr ? rr(n) : new t.constructor(n);
        t.copy(i);
        return i;
      }
      const ar = sr;
      function cr(t, e) {
        var n = -1,
          i = t.length;
        e || (e = Array(i));
        while (++n < i) {
          e[n] = t[n];
        }
        return e;
      }
      const lr = cr;
      function dr(t, e) {
        var n = -1,
          i = t == null ? 0 : t.length,
          o = 0,
          r = [];
        while (++n < i) {
          var s = t[n];
          if (e(s, n, t)) {
            r[o++] = s;
          }
        }
        return r;
      }
      const ur = dr;
      function hr() {
        return [];
      }
      const mr = hr;
      var gr = Object.prototype;
      var fr = gr.propertyIsEnumerable;
      var pr = Object.getOwnPropertySymbols;
      var br = !pr
        ? mr
        : function (t) {
            if (t == null) {
              return [];
            }
            t = Object(t);
            return ur(pr(t), function (e) {
              return fr.call(t, e);
            });
          };
      const kr = br;
      function wr(t, e) {
        return gi(t, kr(t), e);
      }
      const Ar = wr;
      function Cr(t, e) {
        var n = -1,
          i = e.length,
          o = t.length;
        while (++n < i) {
          t[o + n] = e[n];
        }
        return t;
      }
      const _r = Cr;
      var vr = Object.getOwnPropertySymbols;
      var yr = !vr
        ? mr
        : function (t) {
            var e = [];
            while (t) {
              _r(e, kr(t));
              t = oe(t);
            }
            return e;
          };
      const xr = yr;
      function Er(t, e) {
        return gi(t, xr(t), e);
      }
      const Dr = Er;
      function Sr(t, e, n) {
        var i = e(t);
        return Kt(t) ? i : _r(i, n(t));
      }
      const Tr = Sr;
      function Ir(t) {
        return Tr(t, Ho, kr);
      }
      const Mr = Ir;
      function Br(t) {
        return Tr(t, Jo, xr);
      }
      const Lr = Br;
      var Nr = mn(Tt, "DataView");
      const zr = Nr;
      var Pr = mn(Tt, "Promise");
      const Rr = Pr;
      var Or = mn(Tt, "Set");
      const jr = Or;
      var Fr = mn(Tt, "WeakMap");
      const Vr = Fr;
      var Hr = "[object Map]",
        Ur = "[object Object]",
        qr = "[object Promise]",
        Wr = "[object Set]",
        Gr = "[object WeakMap]";
      var $r = "[object DataView]";
      var Kr = Xe(zr),
        Yr = Xe(fn),
        Zr = Xe(Rr),
        Qr = Xe(jr),
        Jr = Xe(Vr);
      var Xr = Gt;
      if (
        (zr && Xr(new zr(new ArrayBuffer(1))) != $r) ||
        (fn && Xr(new fn()) != Hr) ||
        (Rr && Xr(Rr.resolve()) != qr) ||
        (jr && Xr(new jr()) != Wr) ||
        (Vr && Xr(new Vr()) != Gr)
      ) {
        Xr = function (t) {
          var e = Gt(t),
            n = e == Ur ? t.constructor : undefined,
            i = n ? Xe(n) : "";
          if (i) {
            switch (i) {
              case Kr:
                return $r;
              case Yr:
                return Hr;
              case Zr:
                return qr;
              case Qr:
                return Wr;
              case Jr:
                return Gr;
            }
          }
          return e;
        };
      }
      const ts = Xr;
      var es = Object.prototype;
      var ns = es.hasOwnProperty;
      function is(t) {
        var e = t.length,
          n = new t.constructor(e);
        if (e && typeof t[0] == "string" && ns.call(t, "index")) {
          n.index = t.index;
          n.input = t.input;
        }
        return n;
      }
      const os = is;
      var rs = Tt.Uint8Array;
      const ss = rs;
      function as(t) {
        var e = new t.constructor(t.byteLength);
        new ss(e).set(new ss(t));
        return e;
      }
      const cs = as;
      function ls(t, e) {
        var n = e ? cs(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.byteLength);
      }
      const ds = ls;
      var us = /\\w*$/;
      function hs(t) {
        var e = new t.constructor(t.source, us.exec(t));
        e.lastIndex = t.lastIndex;
        return e;
      }
      const ms = hs;
      var gs = Mt ? Mt.prototype : undefined,
        fs = gs ? gs.valueOf : undefined;
      function ps(t) {
        return fs ? Object(fs.call(t)) : {};
      }
      const bs = ps;
      function ks(t, e) {
        var n = e ? cs(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.length);
      }
      const ws = ks;
      var As = "[object Boolean]",
        Cs = "[object Date]",
        _s = "[object Map]",
        vs = "[object Number]",
        ys = "[object RegExp]",
        xs = "[object Set]",
        Es = "[object String]",
        Ds = "[object Symbol]";
      var Ss = "[object ArrayBuffer]",
        Ts = "[object DataView]",
        Is = "[object Float32Array]",
        Ms = "[object Float64Array]",
        Bs = "[object Int8Array]",
        Ls = "[object Int16Array]",
        Ns = "[object Int32Array]",
        zs = "[object Uint8Array]",
        Ps = "[object Uint8ClampedArray]",
        Rs = "[object Uint16Array]",
        Os = "[object Uint32Array]";
      function js(t, e, n) {
        var i = t.constructor;
        switch (e) {
          case Ss:
            return cs(t);
          case As:
          case Cs:
            return new i(+t);
          case Ts:
            return ds(t, n);
          case Is:
          case Ms:
          case Bs:
          case Ls:
          case Ns:
          case zs:
          case Ps:
          case Rs:
          case Os:
            return ws(t, n);
          case _s:
            return new i();
          case vs:
          case Es:
            return new i(t);
          case ys:
            return ms(t);
          case xs:
            return new i();
          case Ds:
            return bs(t);
        }
      }
      const Fs = js;
      var Vs = Object.create;
      var Hs = (function () {
        function t() {}
        return function (e) {
          if (!it(e)) {
            return {};
          }
          if (Vs) {
            return Vs(e);
          }
          t.prototype = e;
          var n = new t();
          t.prototype = undefined;
          return n;
        };
      })();
      const Us = Hs;
      function qs(t) {
        return typeof t.constructor == "function" && !Bo(t) ? Us(oe(t)) : {};
      }
      const Ws = qs;
      var Gs = "[object Map]";
      function $s(t) {
        return Zt(t) && ts(t) == Gs;
      }
      const Ks = $s;
      var Ys = _o && _o.isMap;
      var Zs = Ys ? po(Ys) : Ks;
      const Qs = Zs;
      var Js = "[object Set]";
      function Xs(t) {
        return Zt(t) && ts(t) == Js;
      }
      const ta = Xs;
      var ea = _o && _o.isSet;
      var na = ea ? po(ea) : ta;
      const ia = na;
      var oa = 1,
        ra = 2,
        sa = 4;
      var aa = "[object Arguments]",
        ca = "[object Array]",
        la = "[object Boolean]",
        da = "[object Date]",
        ua = "[object Error]",
        ha = "[object Function]",
        ma = "[object GeneratorFunction]",
        ga = "[object Map]",
        fa = "[object Number]",
        pa = "[object Object]",
        ba = "[object RegExp]",
        ka = "[object Set]",
        wa = "[object String]",
        Aa = "[object Symbol]",
        Ca = "[object WeakMap]";
      var _a = "[object ArrayBuffer]",
        va = "[object DataView]",
        ya = "[object Float32Array]",
        xa = "[object Float64Array]",
        Ea = "[object Int8Array]",
        Da = "[object Int16Array]",
        Sa = "[object Int32Array]",
        Ta = "[object Uint8Array]",
        Ia = "[object Uint8ClampedArray]",
        Ma = "[object Uint16Array]",
        Ba = "[object Uint32Array]";
      var La = {};
      La[aa] =
        La[ca] =
        La[_a] =
        La[va] =
        La[la] =
        La[da] =
        La[ya] =
        La[xa] =
        La[Ea] =
        La[Da] =
        La[Sa] =
        La[ga] =
        La[fa] =
        La[pa] =
        La[ba] =
        La[ka] =
        La[wa] =
        La[Aa] =
        La[Ta] =
        La[Ia] =
        La[Ma] =
        La[Ba] =
          true;
      La[ua] = La[ha] = La[Ca] = false;
      function Na(t, e, n, i, o, r) {
        var s,
          a = e & oa,
          c = e & ra,
          l = e & sa;
        if (n) {
          s = o ? n(t, i, o, r) : n(t);
        }
        if (s !== undefined) {
          return s;
        }
        if (!it(t)) {
          return t;
        }
        var d = Kt(t);
        if (d) {
          s = os(t);
          if (!a) {
            return lr(t, s);
          }
        } else {
          var u = ts(t),
            h = u == ha || u == ma;
          if (Li(t)) {
            return ar(t, a);
          }
          if (u == pa || u == aa || (h && !o)) {
            s = c || h ? {} : Ws(t);
            if (!a) {
              return c ? Dr(t, tr(s, t)) : Ar(t, qo(s, t));
            }
          } else {
            if (!La[u]) {
              return o ? t : {};
            }
            s = Fs(t, u, a);
          }
        }
        r || (r = new ni());
        var m = r.get(t);
        if (m) {
          return m;
        }
        r.set(t, s);
        if (ia(t)) {
          t.forEach(function (i) {
            s.add(Na(i, e, n, i, t, r));
          });
        } else if (Qs(t)) {
          t.forEach(function (i, o) {
            s.set(o, Na(i, e, n, o, t, r));
          });
        }
        var g = l ? (c ? Lr : Mr) : c ? Jo : Ho;
        var f = d ? undefined : g(t);
        oi(f || t, function (i, o) {
          if (f) {
            o = i;
            i = t[o];
          }
          hi(s, o, Na(i, e, n, o, t, r));
        });
        return s;
      }
      const za = Na;
      var Pa = 1,
        Ra = 4;
      function Oa(t, e) {
        e = typeof e == "function" ? e : undefined;
        return za(t, Pa | Ra, e);
      }
      const ja = Oa;
      function Fa(t) {
        return Zt(t) && t.nodeType === 1 && !he(t);
      }
      const Va = Fa;
      class Ha {
        constructor(t, e) {
          this._config = {};
          if (e) {
            this.define(Ua(e));
          }
          if (t) {
            this._setObjectToTarget(this._config, t);
          }
        }
        set(t, e) {
          this._setToTarget(this._config, t, e);
        }
        define(t, e) {
          const n = true;
          this._setToTarget(this._config, t, e, n);
        }
        get(t) {
          return this._getFromSource(this._config, t);
        }
        *names() {
          for (const t of Object.keys(this._config)) {
            yield t;
          }
        }
        _setToTarget(t, e, n, i = false) {
          if (he(e)) {
            this._setObjectToTarget(t, e, i);
            return;
          }
          const o = e.split(".");
          e = o.pop();
          for (const e of o) {
            if (!he(t[e])) {
              t[e] = {};
            }
            t = t[e];
          }
          if (he(n)) {
            if (!he(t[e])) {
              t[e] = {};
            }
            t = t[e];
            this._setObjectToTarget(t, n, i);
            return;
          }
          if (i && typeof t[e] != "undefined") {
            return;
          }
          t[e] = n;
        }
        _getFromSource(t, e) {
          const n = e.split(".");
          e = n.pop();
          for (const e of n) {
            if (!he(t[e])) {
              t = null;
              break;
            }
            t = t[e];
          }
          return t ? Ua(t[e]) : undefined;
        }
        _setObjectToTarget(t, e, n) {
          Object.keys(e).forEach((i) => {
            this._setToTarget(t, i, e[i], n);
          });
        }
      }
      function Ua(t) {
        return ja(t, qa);
      }
      function qa(t) {
        return Va(t) ? t : undefined;
      }
      function Wa(t) {
        if (t) {
          if (t.defaultView) {
            return t instanceof t.defaultView.Document;
          } else if (t.ownerDocument && t.ownerDocument.defaultView) {
            return t instanceof t.ownerDocument.defaultView.Node;
          }
        }
        return false;
      }
      function Ga(t) {
        const e = Object.prototype.toString.apply(t);
        if (e == "[object Window]") {
          return true;
        }
        if (e == "[object global]") {
          return true;
        }
        return false;
      }
      const $a = Ka(q());
      function Ka(t) {
        if (!t) {
          return $a;
        }
        class e extends t {
          listenTo(t, e, n, i = {}) {
            if (Wa(t) || Ga(t)) {
              const o = { capture: !!i.useCapture, passive: !!i.usePassive };
              const r = this._getProxyEmitter(t, o) || new Ya(t, o);
              this.listenTo(r, e, n, i);
            } else {
              super.listenTo(t, e, n, i);
            }
          }
          stopListening(t, e, n) {
            if (Wa(t) || Ga(t)) {
              const i = this._getAllProxyEmitters(t);
              for (const t of i) {
                this.stopListening(t, e, n);
              }
            } else {
              super.stopListening(t, e, n);
            }
          }
          _getProxyEmitter(t, e) {
            return W(this, Qa(t, e));
          }
          _getAllProxyEmitters(t) {
            return [
              { capture: false, passive: false },
              { capture: false, passive: true },
              { capture: true, passive: false },
              { capture: true, passive: true },
            ]
              .map((e) => this._getProxyEmitter(t, e))
              .filter((t) => !!t);
          }
        }
        return e;
      }
      [
        "_getProxyEmitter",
        "_getAllProxyEmitters",
        "on",
        "once",
        "off",
        "listenTo",
        "stopListening",
        "fire",
        "delegate",
        "stopDelegating",
        "_addEventListener",
        "_removeEventListener",
      ].forEach((t) => {
        Ka[t] = $a.prototype[t];
      });
      class Ya extends q() {
        constructor(t, e) {
          super();
          G(this, Qa(t, e));
          this._domNode = t;
          this._options = e;
        }
        attach(t) {
          if (this._domListeners && this._domListeners[t]) {
            return;
          }
          const e = this._createDomListener(t);
          this._domNode.addEventListener(t, e, this._options);
          if (!this._domListeners) {
            this._domListeners = {};
          }
          this._domListeners[t] = e;
        }
        detach(t) {
          let e;
          if (
            this._domListeners[t] &&
            (!(e = this._events[t]) || !e.callbacks.length)
          ) {
            this._domListeners[t].removeListener();
          }
        }
        _addEventListener(t, e, n) {
          this.attach(t);
          q().prototype._addEventListener.call(this, t, e, n);
        }
        _removeEventListener(t, e) {
          q().prototype._removeEventListener.call(this, t, e);
          this.detach(t);
        }
        _createDomListener(t) {
          const e = (e) => {
            this.fire(t, e);
          };
          e.removeListener = () => {
            this._domNode.removeEventListener(t, e, this._options);
            delete this._domListeners[t];
          };
          return e;
        }
      }
      function Za(t) {
        return t["data-ck-expando"] || (t["data-ck-expando"] = E());
      }
      function Qa(t, e) {
        let n = Za(t);
        for (const t of Object.keys(e).sort()) {
          if (e[t]) {
            n += "-" + t;
          }
        }
        return n;
      }
      let Ja;
      try {
        Ja = { window, document };
      } catch (t) {
        Ja = { window: {}, document: {} };
      }
      const Xa = Ja;
      function tc(t) {
        const e = [];
        let n = t;
        while (n && n.nodeType != Node.DOCUMENT_NODE) {
          e.unshift(n);
          n = n.parentNode;
        }
        return e;
      }
      function ec(t) {
        if (t instanceof HTMLTextAreaElement) {
          return t.value;
        }
        return t.innerHTML;
      }
      function nc(t) {
        return Object.prototype.toString.call(t) == "[object Text]";
      }
      function ic(t) {
        return Object.prototype.toString.apply(t) == "[object Range]";
      }
      function oc(t) {
        const e = t.ownerDocument.defaultView.getComputedStyle(t);
        return {
          top: parseInt(e.borderTopWidth, 10),
          right: parseInt(e.borderRightWidth, 10),
          bottom: parseInt(e.borderBottomWidth, 10),
          left: parseInt(e.borderLeftWidth, 10),
        };
      }
      const rc = ["top", "right", "bottom", "left", "width", "height"];
      class sc {
        constructor(t) {
          const e = ic(t);
          Object.defineProperty(this, "_source", {
            value: t._source || t,
            writable: true,
            enumerable: false,
          });
          if (lc(t) || e) {
            if (e) {
              const e = sc.getDomRangeRects(t);
              ac(this, sc.getBoundingRect(e));
            } else {
              ac(this, t.getBoundingClientRect());
            }
          } else if (Ga(t)) {
            const { innerWidth: e, innerHeight: n } = t;
            ac(this, {
              top: 0,
              right: e,
              bottom: n,
              left: 0,
              width: e,
              height: n,
            });
          } else {
            ac(this, t);
          }
        }
        clone() {
          return new sc(this);
        }
        moveTo(t, e) {
          this.top = e;
          this.right = t + this.width;
          this.bottom = e + this.height;
          this.left = t;
          return this;
        }
        moveBy(t, e) {
          this.top += e;
          this.right += t;
          this.left += t;
          this.bottom += e;
          return this;
        }
        getIntersection(t) {
          const e = {
            top: Math.max(this.top, t.top),
            right: Math.min(this.right, t.right),
            bottom: Math.min(this.bottom, t.bottom),
            left: Math.max(this.left, t.left),
            width: 0,
            height: 0,
          };
          e.width = e.right - e.left;
          e.height = e.bottom - e.top;
          if (e.width < 0 || e.height < 0) {
            return null;
          } else {
            return new sc(e);
          }
        }
        getIntersectionArea(t) {
          const e = this.getIntersection(t);
          if (e) {
            return e.getArea();
          } else {
            return 0;
          }
        }
        getArea() {
          return this.width * this.height;
        }
        getVisible() {
          const t = this._source;
          let e = this.clone();
          if (!cc(t)) {
            let n = t.parentNode || t.commonAncestorContainer;
            while (n && !cc(n)) {
              const t = new sc(n);
              const i = e.getIntersection(t);
              if (i) {
                if (i.getArea() < e.getArea()) {
                  e = i;
                }
              } else {
                return null;
              }
              n = n.parentNode;
            }
          }
          return e;
        }
        isEqual(t) {
          for (const e of rc) {
            if (this[e] !== t[e]) {
              return false;
            }
          }
          return true;
        }
        contains(t) {
          const e = this.getIntersection(t);
          return !!(e && e.isEqual(t));
        }
        excludeScrollbarsAndBorders() {
          const t = this._source;
          let e, n, i;
          if (Ga(t)) {
            e = t.innerWidth - t.document.documentElement.clientWidth;
            n = t.innerHeight - t.document.documentElement.clientHeight;
            i = t.getComputedStyle(t.document.documentElement).direction;
          } else {
            const o = oc(t);
            e = t.offsetWidth - t.clientWidth - o.left - o.right;
            n = t.offsetHeight - t.clientHeight - o.top - o.bottom;
            i = t.ownerDocument.defaultView.getComputedStyle(t).direction;
            this.left += o.left;
            this.top += o.top;
            this.right -= o.right;
            this.bottom -= o.bottom;
            this.width = this.right - this.left;
            this.height = this.bottom - this.top;
          }
          this.width -= e;
          if (i === "ltr") {
            this.right -= e;
          } else {
            this.left += e;
          }
          this.height -= n;
          this.bottom -= n;
          return this;
        }
        static getDomRangeRects(t) {
          const e = [];
          const n = Array.from(t.getClientRects());
          if (n.length) {
            for (const t of n) {
              e.push(new sc(t));
            }
          } else {
            let n = t.startContainer;
            if (nc(n)) {
              n = n.parentNode;
            }
            const i = new sc(n.getBoundingClientRect());
            i.right = i.left;
            i.width = 0;
            e.push(i);
          }
          return e;
        }
        static getBoundingRect(t) {
          const e = {
            left: Number.POSITIVE_INFINITY,
            top: Number.POSITIVE_INFINITY,
            right: Number.NEGATIVE_INFINITY,
            bottom: Number.NEGATIVE_INFINITY,
            width: 0,
            height: 0,
          };
          let n = 0;
          for (const i of t) {
            n++;
            e.left = Math.min(e.left, i.left);
            e.top = Math.min(e.top, i.top);
            e.right = Math.max(e.right, i.right);
            e.bottom = Math.max(e.bottom, i.bottom);
          }
          if (n == 0) {
            return null;
          }
          e.width = e.right - e.left;
          e.height = e.bottom - e.top;
          return new sc(e);
        }
      }
      function ac(t, e) {
        for (const n of rc) {
          t[n] = e[n];
        }
      }
      function cc(t) {
        if (!lc(t)) {
          return false;
        }
        return t === t.ownerDocument.body;
      }
      function lc(t) {
        return (
          t !== null &&
          typeof t === "object" &&
          t.nodeType === 1 &&
          typeof t.getBoundingClientRect === "function"
        );
      }
      class dc {
        constructor(t, e) {
          if (!dc._observerInstance) {
            dc._createObserver();
          }
          this._element = t;
          this._callback = e;
          dc._addElementCallback(t, e);
          dc._observerInstance.observe(t);
        }
        destroy() {
          dc._deleteElementCallback(this._element, this._callback);
        }
        static _addElementCallback(t, e) {
          if (!dc._elementCallbacks) {
            dc._elementCallbacks = new Map();
          }
          let n = dc._elementCallbacks.get(t);
          if (!n) {
            n = new Set();
            dc._elementCallbacks.set(t, n);
          }
          n.add(e);
        }
        static _deleteElementCallback(t, e) {
          const n = dc._getElementCallbacks(t);
          if (n) {
            n.delete(e);
            if (!n.size) {
              dc._elementCallbacks.delete(t);
              dc._observerInstance.unobserve(t);
            }
          }
          if (dc._elementCallbacks && !dc._elementCallbacks.size) {
            dc._observerInstance = null;
            dc._elementCallbacks = null;
          }
        }
        static _getElementCallbacks(t) {
          if (!dc._elementCallbacks) {
            return null;
          }
          return dc._elementCallbacks.get(t);
        }
        static _createObserver() {
          dc._observerInstance = new Xa.window.ResizeObserver((t) => {
            for (const e of t) {
              const t = dc._getElementCallbacks(e.target);
              if (t) {
                for (const n of t) {
                  n(e);
                }
              }
            }
          });
        }
      }
      dc._observerInstance = null;
      dc._elementCallbacks = null;
      function uc(t, e) {
        if (t instanceof HTMLTextAreaElement) {
          t.value = e;
        }
        t.innerHTML = e;
      }
      function hc(t) {
        return (e) => e + t;
      }
      function mc(t) {
        let e = 0;
        while (t.previousSibling) {
          t = t.previousSibling;
          e++;
        }
        return e;
      }
      function gc(t, e, n) {
        t.insertBefore(n, t.childNodes[e] || null);
      }
      function fc(t) {
        return t && t.nodeType === Node.COMMENT_NODE;
      }
      function pc(t) {
        return !!(t && t.getClientRects && t.getClientRects().length);
      }
      function bc(t) {
        if (!t || !t.parentNode) {
          return null;
        }
        if (t.offsetParent === Xa.document.body) {
          return null;
        }
        return t.offsetParent;
      }
      function kc({
        element: t,
        target: e,
        positions: n,
        limiter: i,
        fitInViewport: o,
        viewportOffsetConfig: r,
      }) {
        if (qe(e)) {
          e = e();
        }
        if (qe(i)) {
          i = i();
        }
        const s = bc(t);
        const a = new sc(t);
        const c = new sc(e);
        let l;
        const d = (o && wc(r)) || null;
        const u = {
          targetRect: c,
          elementRect: a,
          positionedElementAncestor: s,
          viewportRect: d,
        };
        if (!i && !o) {
          l = new vc(n[0], u);
        } else {
          const t = i && new sc(i).getVisible();
          Object.assign(u, { limiterRect: t, viewportRect: d });
          l = Ac(n, u) || new vc(n[0], u);
        }
        return l;
      }
      function wc(t) {
        t = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, t);
        const e = new sc(Xa.window);
        e.top += t.top;
        e.height -= t.top;
        e.bottom -= t.bottom;
        e.height -= t.bottom;
        return e;
      }
      function Ac(t, e) {
        const { elementRect: n } = e;
        const i = n.getArea();
        const o = t.map((t) => new vc(t, e)).filter((t) => !!t.name);
        let r = 0;
        let s = null;
        for (const t of o) {
          const { limiterIntersectionArea: e, viewportIntersectionArea: n } = t;
          if (e === i) {
            return t;
          }
          const o = n ** 2 + e ** 2;
          if (o > r) {
            r = o;
            s = t;
          }
        }
        return s;
      }
      function Cc(t, e) {
        const n = _c(new sc(e));
        const i = oc(e);
        let o = 0;
        let r = 0;
        o -= n.left;
        r -= n.top;
        o += e.scrollLeft;
        r += e.scrollTop;
        o -= i.left;
        r -= i.top;
        t.moveBy(o, r);
      }
      function _c(t) {
        const { scrollX: e, scrollY: n } = Xa.window;
        return t.clone().moveBy(e, n);
      }
      class vc {
        constructor(t, e) {
          const n = t(e.targetRect, e.elementRect, e.viewportRect);
          if (!n) {
            return;
          }
          const { left: i, top: o, name: r, config: s } = n;
          this.name = r;
          this.config = s;
          this._positioningFunctionCorrdinates = { left: i, top: o };
          this._options = e;
        }
        get left() {
          return this._absoluteRect.left;
        }
        get top() {
          return this._absoluteRect.top;
        }
        get limiterIntersectionArea() {
          const t = this._options.limiterRect;
          if (t) {
            const e = this._options.viewportRect;
            if (e) {
              const n = t.getIntersection(e);
              if (n) {
                return n.getIntersectionArea(this._rect);
              }
            } else {
              return t.getIntersectionArea(this._rect);
            }
          }
          return 0;
        }
        get viewportIntersectionArea() {
          const t = this._options.viewportRect;
          if (t) {
            return t.getIntersectionArea(this._rect);
          }
          return 0;
        }
        get _rect() {
          if (this._cachedRect) {
            return this._cachedRect;
          }
          this._cachedRect = this._options.elementRect
            .clone()
            .moveTo(
              this._positioningFunctionCorrdinates.left,
              this._positioningFunctionCorrdinates.top
            );
          return this._cachedRect;
        }
        get _absoluteRect() {
          if (this._cachedAbsoluteRect) {
            return this._cachedAbsoluteRect;
          }
          this._cachedAbsoluteRect = _c(this._rect);
          if (this._options.positionedElementAncestor) {
            Cc(
              this._cachedAbsoluteRect,
              this._options.positionedElementAncestor
            );
          }
          return this._cachedAbsoluteRect;
        }
      }
      function yc(t) {
        const e = t.parentNode;
        if (e) {
          e.removeChild(t);
        }
      }
      function xc({ target: t, viewportOffset: e = 0 }) {
        const n = Lc(t);
        let i = n;
        let o = null;
        while (i) {
          let r;
          if (i == n) {
            r = Nc(t);
          } else {
            r = Nc(o);
          }
          Sc(r, () => zc(t, i));
          const s = zc(t, i);
          Dc(i, s, e);
          if (i.parent != i) {
            o = i.frameElement;
            i = i.parent;
            if (!o) {
              return;
            }
          } else {
            i = null;
          }
        }
      }
      function Ec(t) {
        const e = Nc(t);
        Sc(e, () => new Rect(t));
      }
      function Dc(t, e, n) {
        const i = e.clone().moveBy(0, n);
        const o = e.clone().moveBy(0, -n);
        const r = new sc(t).excludeScrollbarsAndBorders();
        const s = [o, i];
        if (!s.every((t) => r.contains(t))) {
          let { scrollX: s, scrollY: a } = t;
          if (Ic(o, r)) {
            a -= r.top - e.top + n;
          } else if (Tc(i, r)) {
            a += e.bottom - r.bottom + n;
          }
          if (Mc(e, r)) {
            s -= r.left - e.left + n;
          } else if (Bc(e, r)) {
            s += e.right - r.right + n;
          }
          t.scrollTo(s, a);
        }
      }
      function Sc(t, e) {
        const n = Lc(t);
        let i, o;
        while (t != n.document.body) {
          o = e();
          i = new sc(t).excludeScrollbarsAndBorders();
          if (!i.contains(o)) {
            if (Ic(o, i)) {
              t.scrollTop -= i.top - o.top;
            } else if (Tc(o, i)) {
              t.scrollTop += o.bottom - i.bottom;
            }
            if (Mc(o, i)) {
              t.scrollLeft -= i.left - o.left;
            } else if (Bc(o, i)) {
              t.scrollLeft += o.right - i.right;
            }
          }
          t = t.parentNode;
        }
      }
      function Tc(t, e) {
        return t.bottom > e.bottom;
      }
      function Ic(t, e) {
        return t.top < e.top;
      }
      function Mc(t, e) {
        return t.left < e.left;
      }
      function Bc(t, e) {
        return t.right > e.right;
      }
      function Lc(t) {
        if (ic(t)) {
          return t.startContainer.ownerDocument.defaultView;
        } else {
          return t.ownerDocument.defaultView;
        }
      }
      function Nc(t) {
        if (ic(t)) {
          let e = t.commonAncestorContainer;
          if (nc(e)) {
            e = e.parentNode;
          }
          return e;
        } else {
          return t.parentNode;
        }
      }
      function zc(t, e) {
        const n = Lc(t);
        const i = new sc(t);
        if (n === e) {
          return i;
        } else {
          let t = n;
          while (t != e) {
            const e = t.frameElement;
            const n = new sc(e).excludeScrollbarsAndBorders();
            i.moveBy(n.left, n.top);
            t = t.parent;
          }
        }
        return i;
      }
      const Pc = { ctrl: "", cmd: "", alt: "", shift: "" };
      const Rc = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" };
      const Oc = $c();
      const jc = Object.fromEntries(
        Object.entries(Oc).map(([t, e]) => [
          e,
          t.charAt(0).toUpperCase() + t.slice(1),
        ])
      );
      function Fc(t) {
        let e;
        if (typeof t == "string") {
          e = Oc[t.toLowerCase()];
          if (!e) {
            throw new M("keyboard-unknown-key", null, { key: t });
          }
        } else {
          e =
            t.keyCode +
            (t.altKey ? Oc.alt : 0) +
            (t.ctrlKey ? Oc.ctrl : 0) +
            (t.shiftKey ? Oc.shift : 0) +
            (t.metaKey ? Oc.cmd : 0);
        }
        return e;
      }
      function Vc(t) {
        if (typeof t == "string") {
          t = Kc(t);
        }
        return t
          .map((t) => (typeof t == "string" ? Wc(t) : t))
          .reduce((t, e) => e + t, 0);
      }
      function Hc(t) {
        let e = Vc(t);
        const n = Object.entries(r.isMac ? Pc : Rc);
        const i = n.reduce((t, [n, i]) => {
          if ((e & Oc[n]) != 0) {
            e &= ~Oc[n];
            t += i;
          }
          return t;
        }, "");
        return i + (e ? jc[e] : "");
      }
      function Uc(t) {
        return (
          t == Oc.arrowright ||
          t == Oc.arrowleft ||
          t == Oc.arrowup ||
          t == Oc.arrowdown
        );
      }
      function qc(t, e) {
        const n = e === "ltr";
        switch (t) {
          case Oc.arrowleft:
            return n ? "left" : "right";
          case Oc.arrowright:
            return n ? "right" : "left";
          case Oc.arrowup:
            return "up";
          case Oc.arrowdown:
            return "down";
        }
      }
      function Wc(t) {
        if (t.endsWith("!")) {
          return Fc(t.slice(0, -1));
        }
        const e = Fc(t);
        return r.isMac && e == Oc.ctrl ? Oc.cmd : e;
      }
      function Gc(t, e) {
        const n = qc(t, e);
        return n === "down" || n === "right";
      }
      function $c() {
        const t = {
          arrowleft: 37,
          arrowup: 38,
          arrowright: 39,
          arrowdown: 40,
          backspace: 8,
          delete: 46,
          enter: 13,
          space: 32,
          esc: 27,
          tab: 9,
          ctrl: 1114112,
          shift: 2228224,
          alt: 4456448,
          cmd: 8912896,
        };
        for (let e = 65; e <= 90; e++) {
          const n = String.fromCharCode(e);
          t[n.toLowerCase()] = e;
        }
        for (let e = 48; e <= 57; e++) {
          t[e - 48] = e;
        }
        for (let e = 112; e <= 123; e++) {
          t["f" + (e - 111)] = e;
        }
        for (const e of "\`-=[];',./\\\\") {
          t[e] = e.charCodeAt(0);
        }
        return t;
      }
      function Kc(t) {
        return t.split("+").map((t) => t.trim());
      }
      function Yc(t) {
        return Array.isArray(t) ? t : [t];
      }
      if (!Xa.window.CKEDITOR_TRANSLATIONS) {
        Xa.window.CKEDITOR_TRANSLATIONS = {};
      }
      function Zc(t, e, n) {
        if (!global.window.CKEDITOR_TRANSLATIONS[t]) {
          global.window.CKEDITOR_TRANSLATIONS[t] = {};
        }
        const i = global.window.CKEDITOR_TRANSLATIONS[t];
        i.dictionary = i.dictionary || {};
        i.getPluralForm = n || i.getPluralForm;
        Object.assign(i.dictionary, e);
      }
      function Qc(t, e, n = 1) {
        if (typeof n !== "number") {
          throw new M("translation-service-quantity-not-a-number", null, {
            quantity: n,
          });
        }
        const i = tl();
        if (i === 1) {
          t = Object.keys(Xa.window.CKEDITOR_TRANSLATIONS)[0];
        }
        const o = e.id || e.string;
        if (i === 0 || !Xc(t, o)) {
          if (n !== 1) {
            return e.plural;
          }
          return e.string;
        }
        const r = Xa.window.CKEDITOR_TRANSLATIONS[t].dictionary;
        const s =
          Xa.window.CKEDITOR_TRANSLATIONS[t].getPluralForm ||
          ((t) => (t === 1 ? 0 : 1));
        const a = r[o];
        if (typeof a === "string") {
          return a;
        }
        const c = Number(s(n));
        return a[c];
      }
      function Jc() {
        global.window.CKEDITOR_TRANSLATIONS = {};
      }
      function Xc(t, e) {
        return (
          !!Xa.window.CKEDITOR_TRANSLATIONS[t] &&
          !!Xa.window.CKEDITOR_TRANSLATIONS[t].dictionary[e]
        );
      }
      function tl() {
        return Object.keys(Xa.window.CKEDITOR_TRANSLATIONS).length;
      }
      const el = [
        "ar",
        "ara",
        "fa",
        "per",
        "fas",
        "he",
        "heb",
        "ku",
        "kur",
        "ug",
        "uig",
      ];
      function nl(t) {
        return el.includes(t) ? "rtl" : "ltr";
      }
      class il {
        constructor({ uiLanguage: t = "en", contentLanguage: e } = {}) {
          this.uiLanguage = t;
          this.contentLanguage = e || this.uiLanguage;
          this.uiLanguageDirection = nl(this.uiLanguage);
          this.contentLanguageDirection = nl(this.contentLanguage);
          this.t = (t, e) => this._t(t, e);
        }
        get language() {
          console.warn(
            "locale-deprecated-language-property: " +
              "The Locale#language property has been deprecated and will be removed in the near future. " +
              "Please use #uiLanguage and #contentLanguage properties instead."
          );
          return this.uiLanguage;
        }
        _t(t, e = []) {
          e = Yc(e);
          if (typeof t === "string") {
            t = { string: t };
          }
          const n = !!t.plural;
          const i = n ? e[0] : 1;
          const o = Qc(this.uiLanguage, t, i);
          return ol(o, e);
        }
      }
      function ol(t, e) {
        return t.replace(/%(\\d+)/g, (t, n) => (n < e.length ? e[n] : t));
      }
      class rl extends q() {
        constructor(t = {}, e = {}) {
          super();
          const n = yt(t);
          if (!n) {
            e = t;
          }
          this._items = [];
          this._itemMap = new Map();
          this._idProperty = e.idProperty || "id";
          this._bindToExternalToInternalMap = new WeakMap();
          this._bindToInternalToExternalMap = new WeakMap();
          this._skippedIndexesFromExternal = [];
          if (n) {
            for (const e of t) {
              this._items.push(e);
              this._itemMap.set(this._getItemIdBeforeAdding(e), e);
            }
          }
        }
        get length() {
          return this._items.length;
        }
        get first() {
          return this._items[0] || null;
        }
        get last() {
          return this._items[this.length - 1] || null;
        }
        add(t, e) {
          return this.addMany([t], e);
        }
        addMany(t, e) {
          if (e === undefined) {
            e = this._items.length;
          } else if (e > this._items.length || e < 0) {
            throw new M("collection-add-item-invalid-index", this);
          }
          let n = 0;
          for (const i of t) {
            const t = this._getItemIdBeforeAdding(i);
            const o = e + n;
            this._items.splice(o, 0, i);
            this._itemMap.set(t, i);
            this.fire("add", i, o);
            n++;
          }
          this.fire("change", { added: t, removed: [], index: e });
          return this;
        }
        get(t) {
          let e;
          if (typeof t == "string") {
            e = this._itemMap.get(t);
          } else if (typeof t == "number") {
            e = this._items[t];
          } else {
            throw new M("collection-get-invalid-arg", this);
          }
          return e || null;
        }
        has(t) {
          if (typeof t == "string") {
            return this._itemMap.has(t);
          } else {
            const e = this._idProperty;
            const n = t[e];
            return n && this._itemMap.has(n);
          }
        }
        getIndex(t) {
          let e;
          if (typeof t == "string") {
            e = this._itemMap.get(t);
          } else {
            e = t;
          }
          return e ? this._items.indexOf(e) : -1;
        }
        remove(t) {
          const [e, n] = this._remove(t);
          this.fire("change", { added: [], removed: [e], index: n });
          return e;
        }
        map(t, e) {
          return this._items.map(t, e);
        }
        find(t, e) {
          return this._items.find(t, e);
        }
        filter(t, e) {
          return this._items.filter(t, e);
        }
        clear() {
          if (this._bindToCollection) {
            this.stopListening(this._bindToCollection);
            this._bindToCollection = null;
          }
          const t = Array.from(this._items);
          while (this.length) {
            this._remove(0);
          }
          this.fire("change", { added: [], removed: t, index: 0 });
        }
        bindTo(t) {
          if (this._bindToCollection) {
            throw new M("collection-bind-to-rebind", this);
          }
          this._bindToCollection = t;
          return {
            as: (t) => {
              this._setUpBindToBinding((e) => new t(e));
            },
            using: (t) => {
              if (typeof t == "function") {
                this._setUpBindToBinding(t);
              } else {
                this._setUpBindToBinding((e) => e[t]);
              }
            },
          };
        }
        _setUpBindToBinding(t) {
          const e = this._bindToCollection;
          const n = (n, i, o) => {
            const r = e._bindToCollection == this;
            const s = e._bindToInternalToExternalMap.get(i);
            if (r && s) {
              this._bindToExternalToInternalMap.set(i, s);
              this._bindToInternalToExternalMap.set(s, i);
            } else {
              const n = t(i);
              if (!n) {
                this._skippedIndexesFromExternal.push(o);
                return;
              }
              let r = o;
              for (const t of this._skippedIndexesFromExternal) {
                if (o > t) {
                  r--;
                }
              }
              for (const t of e._skippedIndexesFromExternal) {
                if (r >= t) {
                  r++;
                }
              }
              this._bindToExternalToInternalMap.set(i, n);
              this._bindToInternalToExternalMap.set(n, i);
              this.add(n, r);
              for (let t = 0; t < e._skippedIndexesFromExternal.length; t++) {
                if (r <= e._skippedIndexesFromExternal[t]) {
                  e._skippedIndexesFromExternal[t]++;
                }
              }
            }
          };
          for (const t of e) {
            n(null, t, e.getIndex(t));
          }
          this.listenTo(e, "add", n);
          this.listenTo(e, "remove", (t, e, n) => {
            const i = this._bindToExternalToInternalMap.get(e);
            if (i) {
              this.remove(i);
            }
            this._skippedIndexesFromExternal =
              this._skippedIndexesFromExternal.reduce((t, e) => {
                if (n < e) {
                  t.push(e - 1);
                }
                if (n > e) {
                  t.push(e);
                }
                return t;
              }, []);
          });
        }
        _getItemIdBeforeAdding(t) {
          const e = this._idProperty;
          let n;
          if (e in t) {
            n = t[e];
            if (typeof n != "string") {
              throw new M("collection-add-invalid-id", this);
            }
            if (this.get(n)) {
              throw new M("collection-add-item-already-exists", this);
            }
          } else {
            t[e] = n = E();
          }
          return n;
        }
        _remove(t) {
          let e, n, i;
          let o = false;
          const r = this._idProperty;
          if (typeof t == "string") {
            n = t;
            i = this._itemMap.get(n);
            o = !i;
            if (i) {
              e = this._items.indexOf(i);
            }
          } else if (typeof t == "number") {
            e = t;
            i = this._items[e];
            o = !i;
            if (i) {
              n = i[r];
            }
          } else {
            i = t;
            n = i[r];
            e = this._items.indexOf(i);
            o = e == -1 || !this._itemMap.get(n);
          }
          if (o) {
            throw new M("collection-remove-404", this);
          }
          this._items.splice(e, 1);
          this._itemMap.delete(n);
          const s = this._bindToInternalToExternalMap.get(i);
          this._bindToInternalToExternalMap.delete(i);
          this._bindToExternalToInternalMap.delete(s);
          this.fire("remove", i, e);
          return [i, e];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
      }
      function sl(t) {
        const e = t.next();
        if (e.done) {
          return null;
        }
        return e.value;
      }
      class al extends Ka(dt()) {
        constructor() {
          super();
          this._elements = new Set();
          this._nextEventLoopTimeout = null;
          this.set("isFocused", false);
          this.set("focusedElement", null);
        }
        add(t) {
          if (this._elements.has(t)) {
            throw new M("focustracker-add-element-already-exist", this);
          }
          this.listenTo(t, "focus", () => this._focus(t), { useCapture: true });
          this.listenTo(t, "blur", () => this._blur(), { useCapture: true });
          this._elements.add(t);
        }
        remove(t) {
          if (t === this.focusedElement) {
            this._blur();
          }
          if (this._elements.has(t)) {
            this.stopListening(t);
            this._elements.delete(t);
          }
        }
        destroy() {
          this.stopListening();
        }
        _focus(t) {
          clearTimeout(this._nextEventLoopTimeout);
          this.focusedElement = t;
          this.isFocused = true;
        }
        _blur() {
          clearTimeout(this._nextEventLoopTimeout);
          this._nextEventLoopTimeout = setTimeout(() => {
            this.focusedElement = null;
            this.isFocused = false;
          }, 0);
        }
      }
      class cl {
        constructor() {
          this._listener = new (Ka())();
        }
        listenTo(t) {
          this._listener.listenTo(t, "keydown", (t, e) => {
            this._listener.fire("_keydown:" + Fc(e), e);
          });
        }
        set(t, e, n = {}) {
          const i = Vc(t);
          const o = n.priority;
          this._listener.listenTo(
            this._listener,
            "_keydown:" + i,
            (t, n) => {
              e(n, () => {
                n.preventDefault();
                n.stopPropagation();
                t.stop();
              });
              t.return = true;
            },
            { priority: o }
          );
        }
        press(t) {
          return !!this._listener.fire("_keydown:" + Fc(t), t);
        }
        destroy() {
          this._listener.stopListening();
        }
      }
      function ll(t) {
        const e = new Map();
        for (const n in t) {
          e.set(n, t[n]);
        }
        return e;
      }
      function dl(t) {
        if (yt(t)) {
          return new Map(t);
        } else {
          return ll(t);
        }
      }
      const ul = 1e4;
      function hl(t, e, n, i) {
        if (Math.max(e.length, t.length) > ul) {
          return t
            .slice(0, n)
            .concat(e)
            .concat(t.slice(n + i, t.length));
        } else {
          const o = Array.from(t);
          o.splice(n, i, ...e);
          return o;
        }
      }
      function ml(t) {
        return (
          !!t &&
          t.length == 1 &&
          /[\\u0300-\\u036f\\u1ab0-\\u1aff\\u1dc0-\\u1dff\\u20d0-\\u20ff\\ufe20-\\ufe2f]/.test(
            t
          )
        );
      }
      function gl(t) {
        return !!t && t.length == 1 && /[\\ud800-\\udbff]/.test(t);
      }
      function fl(t) {
        return !!t && t.length == 1 && /[\\udc00-\\udfff]/.test(t);
      }
      function pl(t, e) {
        return gl(t.charAt(e - 1)) && fl(t.charAt(e));
      }
      function bl(t, e) {
        return ml(t.charAt(e));
      }
      const kl = Al();
      function wl(t, e) {
        const n = String(t).matchAll(kl);
        return Array.from(n).some(
          (t) => t.index < e && e < t.index + t[0].length
        );
      }
      function Al() {
        const t = [
          /\\p{Emoji}[\\u{E0020}-\\u{E007E}]+\\u{E007F}/u,
          /\\p{Emoji}\\u{FE0F}?\\u{20E3}/u,
          /\\p{Emoji}\\u{FE0F}/u,
          /(?=\\p{General_Category=Other_Symbol})\\p{Emoji}\\p{Emoji_Modifier}*/u,
        ];
        const e = /\\p{Regional_Indicator}{2}/u.source;
        const n = "(?:" + t.map((t) => t.source).join("|") + ")";
        const i = \`\${e}|\${n}(?:\${n})*\`;
        return new RegExp(i, "ug");
      }
      class Cl extends dt() {
        constructor(t) {
          super();
          this.editor = t;
          this.set("isEnabled", true);
          this._disableStack = new Set();
        }
        forceDisabled(t) {
          this._disableStack.add(t);
          if (this._disableStack.size == 1) {
            this.on("set:isEnabled", _l, { priority: "highest" });
            this.isEnabled = false;
          }
        }
        clearForceDisabled(t) {
          this._disableStack.delete(t);
          if (this._disableStack.size == 0) {
            this.off("set:isEnabled", _l);
            this.isEnabled = true;
          }
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return false;
        }
      }
      function _l(t) {
        t.return = false;
        t.stop();
      }
      class vl extends dt() {
        constructor(t) {
          super();
          this.editor = t;
          this.set("value", undefined);
          this.set("isEnabled", false);
          this._affectsData = true;
          this._disableStack = new Set();
          this.decorate("execute");
          this.listenTo(this.editor.model.document, "change", () => {
            this.refresh();
          });
          this.on(
            "execute",
            (t) => {
              if (!this.isEnabled) {
                t.stop();
              }
            },
            { priority: "high" }
          );
          this.listenTo(t, "change:isReadOnly", (t, e, n) => {
            if (n && this.affectsData) {
              this.forceDisabled("readOnlyMode");
            } else {
              this.clearForceDisabled("readOnlyMode");
            }
          });
        }
        get affectsData() {
          return this._affectsData;
        }
        set affectsData(t) {
          this._affectsData = t;
        }
        refresh() {
          this.isEnabled = true;
        }
        forceDisabled(t) {
          this._disableStack.add(t);
          if (this._disableStack.size == 1) {
            this.on("set:isEnabled", yl, { priority: "highest" });
            this.isEnabled = false;
          }
        }
        clearForceDisabled(t) {
          this._disableStack.delete(t);
          if (this._disableStack.size == 0) {
            this.off("set:isEnabled", yl);
            this.refresh();
          }
        }
        execute(...t) {
          return undefined;
        }
        destroy() {
          this.stopListening();
        }
      }
      function yl(t) {
        t.return = false;
        t.stop();
      }
      class xl extends vl {
        constructor(t) {
          super(t);
          this._childCommandsDefinitions = [];
        }
        refresh() {}
        execute(...t) {
          const e = this._getFirstEnabledCommand();
          return !!e && e.execute(t);
        }
        registerChildCommand(t, e = {}) {
          T(this._childCommandsDefinitions, {
            command: t,
            priority: e.priority || "normal",
          });
          t.on("change:isEnabled", () => this._checkEnabled());
          this._checkEnabled();
        }
        _checkEnabled() {
          this.isEnabled = !!this._getFirstEnabledCommand();
        }
        _getFirstEnabledCommand() {
          const t = this._childCommandsDefinitions.find(
            ({ command: t }) => t.isEnabled
          );
          return t && t.command;
        }
      }
      class El extends q() {
        constructor(t, e = [], n = []) {
          super();
          this._context = t;
          this._plugins = new Map();
          this._availablePlugins = new Map();
          for (const t of e) {
            if (t.pluginName) {
              this._availablePlugins.set(t.pluginName, t);
            }
          }
          this._contextPlugins = new Map();
          for (const [t, e] of n) {
            this._contextPlugins.set(t, e);
            this._contextPlugins.set(e, t);
            if (t.pluginName) {
              this._availablePlugins.set(t.pluginName, t);
            }
          }
        }
        *[Symbol.iterator]() {
          for (const t of this._plugins) {
            if (typeof t[0] == "function") {
              yield t;
            }
          }
        }
        get(t) {
          const e = this._plugins.get(t);
          if (!e) {
            let e = t;
            if (typeof t == "function") {
              e = t.pluginName || t.name;
            }
            throw new M("plugincollection-plugin-not-loaded", this._context, {
              plugin: e,
            });
          }
          return e;
        }
        has(t) {
          return this._plugins.has(t);
        }
        init(t, e = [], n = []) {
          const i = this;
          const o = this._context;
          h(t);
          g(t);
          const r = t.filter((t) => !d(t, e));
          const s = [...m(r)];
          A(s, n);
          const a = k(s);
          return w(a, "init")
            .then(() => w(a, "afterInit"))
            .then(() => a);
          function c(t) {
            return typeof t === "function";
          }
          function l(t) {
            return c(t) && t.isContextPlugin;
          }
          function d(t, e) {
            return e.some((e) => {
              if (e === t) {
                return true;
              }
              if (u(t) === e) {
                return true;
              }
              if (u(e) === t) {
                return true;
              }
              return false;
            });
          }
          function u(t) {
            return c(t) ? t.pluginName || t.name : t;
          }
          function h(t, e = new Set()) {
            t.forEach((t) => {
              if (!c(t)) {
                return;
              }
              if (e.has(t)) {
                return;
              }
              e.add(t);
              if (t.pluginName && !i._availablePlugins.has(t.pluginName)) {
                i._availablePlugins.set(t.pluginName, t);
              }
              if (t.requires) {
                h(t.requires, e);
              }
            });
          }
          function m(t, e = new Set()) {
            return t
              .map((t) => (c(t) ? t : i._availablePlugins.get(t)))
              .reduce((t, n) => {
                if (e.has(n)) {
                  return t;
                }
                e.add(n);
                if (n.requires) {
                  g(n.requires, n);
                  m(n.requires, e).forEach((e) => t.add(e));
                }
                return t.add(n);
              }, new Set());
          }
          function g(t, e = null) {
            t.map((t) => (c(t) ? t : i._availablePlugins.get(t) || t)).forEach(
              (t) => {
                f(t, e);
                p(t, e);
                b(t, e);
              }
            );
          }
          function f(t, e) {
            if (c(t)) {
              return;
            }
            if (e) {
              throw new M("plugincollection-soft-required", o, {
                missingPlugin: t,
                requiredBy: u(e),
              });
            }
            throw new M("plugincollection-plugin-not-found", o, { plugin: t });
          }
          function p(t, e) {
            if (!l(e)) {
              return;
            }
            if (l(t)) {
              return;
            }
            throw new M("plugincollection-context-required", o, {
              plugin: u(t),
              requiredBy: u(e),
            });
          }
          function b(t, n) {
            if (!n) {
              return;
            }
            if (!d(t, e)) {
              return;
            }
            throw new M("plugincollection-required", o, {
              plugin: u(t),
              requiredBy: u(n),
            });
          }
          function k(t) {
            return t.map((t) => {
              let e = i._contextPlugins.get(t);
              e = e || new t(o);
              i._add(t, e);
              return e;
            });
          }
          function w(t, e) {
            return t.reduce((t, n) => {
              if (!n[e]) {
                return t;
              }
              if (i._contextPlugins.has(n)) {
                return t;
              }
              return t.then(n[e].bind(n));
            }, Promise.resolve());
          }
          function A(t, e) {
            for (const n of e) {
              if (typeof n != "function") {
                throw new M(
                  "plugincollection-replace-plugin-invalid-type",
                  null,
                  { pluginItem: n }
                );
              }
              const e = n.pluginName;
              if (!e) {
                throw new M(
                  "plugincollection-replace-plugin-missing-name",
                  null,
                  { pluginItem: n }
                );
              }
              if (n.requires && n.requires.length) {
                throw new M(
                  "plugincollection-plugin-for-replacing-cannot-have-dependencies",
                  null,
                  { pluginName: e }
                );
              }
              const o = i._availablePlugins.get(e);
              if (!o) {
                throw new M(
                  "plugincollection-plugin-for-replacing-not-exist",
                  null,
                  { pluginName: e }
                );
              }
              const r = t.indexOf(o);
              if (r === -1) {
                if (i._contextPlugins.has(o)) {
                  return;
                }
                throw new M(
                  "plugincollection-plugin-for-replacing-not-loaded",
                  null,
                  { pluginName: e }
                );
              }
              if (o.requires && o.requires.length) {
                throw new M(
                  "plugincollection-replaced-plugin-cannot-have-dependencies",
                  null,
                  { pluginName: e }
                );
              }
              t.splice(r, 1, n);
              i._availablePlugins.set(e, n);
            }
          }
        }
        destroy() {
          const t = [];
          for (const [, e] of this) {
            if (
              typeof e.destroy == "function" &&
              !this._contextPlugins.has(e)
            ) {
              t.push(e.destroy());
            }
          }
          return Promise.all(t);
        }
        _add(t, e) {
          this._plugins.set(t, e);
          const n = t.pluginName;
          if (!n) {
            return;
          }
          if (this._plugins.has(n)) {
            throw new M("plugincollection-plugin-name-conflict", null, {
              pluginName: n,
              plugin1: this._plugins.get(n).constructor,
              plugin2: t,
            });
          }
          this._plugins.set(n, e);
        }
      }
      class Dl {
        constructor(t) {
          this.config = new Ha(t, this.constructor.defaultConfig);
          const e = this.constructor.builtinPlugins;
          this.config.define("plugins", e);
          this.plugins = new El(this, e);
          const n = this.config.get("language") || {};
          this.locale = new il({
            uiLanguage: typeof n === "string" ? n : n.ui,
            contentLanguage: this.config.get("language.content"),
          });
          this.t = this.locale.t;
          this.editors = new rl();
          this._contextOwner = null;
        }
        initPlugins() {
          const t = this.config.get("plugins") || [];
          const e = this.config.get("substitutePlugins") || [];
          for (const n of t.concat(e)) {
            if (typeof n != "function") {
              throw new M("context-initplugins-constructor-only", null, {
                Plugin: n,
              });
            }
            if (n.isContextPlugin !== true) {
              throw new M("context-initplugins-invalid-plugin", null, {
                Plugin: n,
              });
            }
          }
          return this.plugins.init(t, [], e);
        }
        destroy() {
          return Promise.all(Array.from(this.editors, (t) => t.destroy())).then(
            () => this.plugins.destroy()
          );
        }
        _addEditor(t, e) {
          if (this._contextOwner) {
            throw new M("context-addeditor-private-context");
          }
          this.editors.add(t);
          if (e) {
            this._contextOwner = t;
          }
        }
        _removeEditor(t) {
          if (this.editors.has(t)) {
            this.editors.remove(t);
          }
          if (this._contextOwner === t) {
            return this.destroy();
          }
          return Promise.resolve();
        }
        _getEditorConfig() {
          const t = {};
          for (const e of this.config.names()) {
            if (!["plugins", "removePlugins", "extraPlugins"].includes(e)) {
              t[e] = this.config.get(e);
            }
          }
          return t;
        }
        static create(t) {
          return new Promise((e) => {
            const n = new this(t);
            e(n.initPlugins().then(() => n));
          });
        }
      }
      class Sl extends dt() {
        constructor(t) {
          super();
          this.context = t;
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return true;
        }
      }
      var Tl = n(3379);
      var Il = n.n(Tl);
      var Ml = n(8894);
      var Bl = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Bl.insert = "head";
      Bl.singleton = true;
      var Ll = Il()(Ml.Z, Bl);
      const Nl = Ml.Z.locals || {};
      const zl = new WeakMap();
      function Pl(t) {
        const {
          view: e,
          element: n,
          text: i,
          isDirectHost: o = true,
          keepOnFocus: r = false,
        } = t;
        const s = e.document;
        if (!zl.has(s)) {
          zl.set(s, new Map());
          s.registerPostFixer((t) => Vl(s, t));
          s.on(
            "change:isComposing",
            () => {
              e.change((t) => Vl(s, t));
            },
            { priority: "high" }
          );
        }
        zl.get(s).set(n, {
          text: i,
          isDirectHost: o,
          keepOnFocus: r,
          hostElement: o ? n : null,
        });
        e.change((t) => Vl(s, t));
      }
      function Rl(t, e) {
        const n = e.document;
        t.change((t) => {
          if (!zl.has(n)) {
            return;
          }
          const i = zl.get(n);
          const o = i.get(e);
          t.removeAttribute("data-placeholder", o.hostElement);
          jl(t, o.hostElement);
          i.delete(e);
        });
      }
      function Ol(t, e) {
        if (!e.hasClass("ck-placeholder")) {
          t.addClass("ck-placeholder", e);
          return true;
        }
        return false;
      }
      function jl(t, e) {
        if (e.hasClass("ck-placeholder")) {
          t.removeClass("ck-placeholder", e);
          return true;
        }
        return false;
      }
      function Fl(t, e) {
        if (!t.isAttached()) {
          return false;
        }
        const n = Array.from(t.getChildren()).some((t) => !t.is("uiElement"));
        if (n) {
          return false;
        }
        const i = t.document;
        const o = i.selection;
        const r = o.anchor;
        if (i.isComposing && r && r.parent === t) {
          return false;
        }
        if (e) {
          return true;
        }
        if (!i.isFocused) {
          return true;
        }
        return !!r && r.parent !== t;
      }
      function Vl(t, e) {
        const n = zl.get(t);
        const i = [];
        let o = false;
        for (const [t, r] of n) {
          if (r.isDirectHost) {
            i.push(t);
            if (Hl(e, t, r)) {
              o = true;
            }
          }
        }
        for (const [t, r] of n) {
          if (r.isDirectHost) {
            continue;
          }
          const n = Ul(t);
          if (!n) {
            continue;
          }
          if (i.includes(n)) {
            continue;
          }
          r.hostElement = n;
          if (Hl(e, t, r)) {
            o = true;
          }
        }
        return o;
      }
      function Hl(t, e, n) {
        const { text: i, isDirectHost: o, hostElement: r } = n;
        let s = false;
        if (r.getAttribute("data-placeholder") !== i) {
          t.setAttribute("data-placeholder", i, r);
          s = true;
        }
        const a = o || e.childCount == 1;
        if (a && Fl(r, n.keepOnFocus)) {
          if (Ol(t, r)) {
            s = true;
          }
        } else if (jl(t, r)) {
          s = true;
        }
        return s;
      }
      function Ul(t) {
        if (t.childCount) {
          const e = t.getChild(0);
          if (
            e.is("element") &&
            !e.is("uiElement") &&
            !e.is("attributeElement")
          ) {
            return e;
          }
        }
        return null;
      }
      class ql {
        is() {
          throw new Error("is() method is abstract");
        }
      }
      var Wl = 4;
      function Gl(t) {
        return za(t, Wl);
      }
      const $l = Gl;
      class Kl extends q(ql) {
        constructor(t) {
          super();
          this.document = t;
          this.parent = null;
        }
        get index() {
          let t;
          if (!this.parent) {
            return null;
          }
          if ((t = this.parent.getChildIndex(this)) == -1) {
            throw new M("view-node-not-found-in-parent", this);
          }
          return t;
        }
        get nextSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t + 1)) || null;
        }
        get previousSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t - 1)) || null;
        }
        get root() {
          let t = this;
          while (t.parent) {
            t = t.parent;
          }
          return t;
        }
        isAttached() {
          return this.root.is("rootElement");
        }
        getPath() {
          const t = [];
          let e = this;
          while (e.parent) {
            t.unshift(e.index);
            e = e.parent;
          }
          return t;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this : this.parent;
          while (n) {
            e[t.parentFirst ? "push" : "unshift"](n);
            n = n.parent;
          }
          return e;
        }
        getCommonAncestor(t, e = {}) {
          const n = this.getAncestors(e);
          const i = t.getAncestors(e);
          let o = 0;
          while (n[o] == i[o] && n[o]) {
            o++;
          }
          return o === 0 ? null : n[o - 1];
        }
        isBefore(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          const e = this.getPath();
          const n = t.getPath();
          const i = vt(e, n);
          switch (i) {
            case "prefix":
              return true;
            case "extension":
              return false;
            default:
              return e[i] < n[i];
          }
        }
        isAfter(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          return !this.isBefore(t);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _fireChange(t, e) {
          this.fire(\`change:\${t}\`, e);
          if (this.parent) {
            this.parent._fireChange(t, e);
          }
        }
        toJSON() {
          const t = $l(this);
          delete t.parent;
          return t;
        }
      }
      Kl.prototype.is = function (t) {
        return t === "node" || t === "view:node";
      };
      class Yl extends Kl {
        constructor(t, e) {
          super(t);
          this._textData = e;
        }
        get data() {
          return this._textData;
        }
        get _data() {
          return this.data;
        }
        set _data(t) {
          this._fireChange("text", this);
          this._textData = t;
        }
        isSimilar(t) {
          if (!(t instanceof Yl)) {
            return false;
          }
          return this === t || this.data === t.data;
        }
        _clone() {
          return new Yl(this.document, this.data);
        }
      }
      Yl.prototype.is = function (t) {
        return (
          t === "$text" ||
          t === "view:$text" ||
          t === "text" ||
          t === "view:text" ||
          t === "node" ||
          t === "view:node"
        );
      };
      class Zl extends ql {
        constructor(t, e, n) {
          super();
          this.textNode = t;
          if (e < 0 || e > t.data.length) {
            throw new M("view-textproxy-wrong-offsetintext", this);
          }
          if (n < 0 || e + n > t.data.length) {
            throw new M("view-textproxy-wrong-length", this);
          }
          this.data = t.data.substring(e, e + n);
          this.offsetInText = e;
        }
        get offsetSize() {
          return this.data.length;
        }
        get isPartial() {
          return this.data.length !== this.textNode.data.length;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        get document() {
          return this.textNode.document;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this.textNode : this.parent;
          while (n !== null) {
            e[t.parentFirst ? "push" : "unshift"](n);
            n = n.parent;
          }
          return e;
        }
      }
      Zl.prototype.is = function (t) {
        return (
          t === "$textProxy" ||
          t === "view:$textProxy" ||
          t === "textProxy" ||
          t === "view:textProxy"
        );
      };
      class Ql {
        constructor(...t) {
          this._patterns = [];
          this.add(...t);
        }
        add(...t) {
          for (let e of t) {
            if (typeof e == "string" || e instanceof RegExp) {
              e = { name: e };
            }
            this._patterns.push(e);
          }
        }
        match(...t) {
          for (const e of t) {
            for (const t of this._patterns) {
              const n = Jl(e, t);
              if (n) {
                return { element: e, pattern: t, match: n };
              }
            }
          }
          return null;
        }
        matchAll(...t) {
          const e = [];
          for (const n of t) {
            for (const t of this._patterns) {
              const i = Jl(n, t);
              if (i) {
                e.push({ element: n, pattern: t, match: i });
              }
            }
          }
          return e.length > 0 ? e : null;
        }
        getElementName() {
          if (this._patterns.length !== 1) {
            return null;
          }
          const t = this._patterns[0];
          const e = t.name;
          return typeof t != "function" && e && !(e instanceof RegExp)
            ? e
            : null;
        }
      }
      function Jl(t, e) {
        if (typeof e == "function") {
          return e(t);
        }
        const n = {};
        if (e.name) {
          n.name = Xl(e.name, t.name);
          if (!n.name) {
            return null;
          }
        }
        if (e.attributes) {
          n.attributes = od(e.attributes, t);
          if (!n.attributes) {
            return null;
          }
        }
        if (e.classes) {
          n.classes = rd(e.classes, t);
          if (!n.classes) {
            return null;
          }
        }
        if (e.styles) {
          n.styles = sd(e.styles, t);
          if (!n.styles) {
            return null;
          }
        }
        return n;
      }
      function Xl(t, e) {
        if (t instanceof RegExp) {
          return !!e.match(t);
        }
        return t === e;
      }
      function td(t, e, n) {
        const i = ed(t);
        const o = Array.from(e);
        const r = [];
        i.forEach(([t, e]) => {
          o.forEach((i) => {
            if (nd(t, i) && id(e, i, n)) {
              r.push(i);
            }
          });
        });
        if (!i.length || r.length < i.length) {
          return undefined;
        }
        return r;
      }
      function ed(t) {
        if (Array.isArray(t)) {
          return t.map((t) => {
            if (he(t)) {
              if (t.key === undefined || t.value === undefined) {
                B("matcher-pattern-missing-key-or-value", t);
              }
              return [t.key, t.value];
            }
            return [t, true];
          });
        }
        if (he(t)) {
          return Object.entries(t);
        }
        return [[t, true]];
      }
      function nd(t, e) {
        return t === true || t === e || (t instanceof RegExp && e.match(t));
      }
      function id(t, e, n) {
        if (t === true) {
          return true;
        }
        const i = n(e);
        return t === i || (t instanceof RegExp && !!String(i).match(t));
      }
      function od(t, e) {
        const n = new Set(e.getAttributeKeys());
        if (he(t)) {
          if (t.style !== undefined) {
            B("matcher-pattern-deprecated-attributes-style-key", t);
          }
          if (t.class !== undefined) {
            B("matcher-pattern-deprecated-attributes-class-key", t);
          }
        } else {
          n.delete("style");
          n.delete("class");
        }
        return td(t, n, (t) => e.getAttribute(t));
      }
      function rd(t, e) {
        return td(t, e.getClassNames(), () => {});
      }
      function sd(t, e) {
        return td(t, e.getStyleNames(true), (t) => e.getStyle(t));
      }
      var ad = "[object Symbol]";
      function cd(t) {
        return typeof t == "symbol" || (Zt(t) && Gt(t) == ad);
      }
      const ld = cd;
      var dd = /\\.|\\[(?:[^[\\]]*|(["'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,
        ud = /^\\w*$/;
      function hd(t, e) {
        if (Kt(t)) {
          return false;
        }
        var n = typeof t;
        if (
          n == "number" ||
          n == "symbol" ||
          n == "boolean" ||
          t == null ||
          ld(t)
        ) {
          return true;
        }
        return ud.test(t) || !dd.test(t) || (e != null && t in Object(e));
      }
      const md = hd;
      var gd = "Expected a function";
      function fd(t, e) {
        if (typeof t != "function" || (e != null && typeof e != "function")) {
          throw new TypeError(gd);
        }
        var n = function () {
          var i = arguments,
            o = e ? e.apply(this, i) : i[0],
            r = n.cache;
          if (r.has(o)) {
            return r.get(o);
          }
          var s = t.apply(this, i);
          n.cache = r.set(o, s) || r;
          return s;
        };
        n.cache = new (fd.Cache || Qn)();
        return n;
      }
      fd.Cache = Qn;
      const pd = fd;
      var bd = 500;
      function kd(t) {
        var e = pd(t, function (t) {
          if (n.size === bd) {
            n.clear();
          }
          return t;
        });
        var n = e.cache;
        return e;
      }
      const wd = kd;
      var Ad =
        /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;
      var Cd = /\\\\(\\\\)?/g;
      var _d = wd(function (t) {
        var e = [];
        if (t.charCodeAt(0) === 46) {
          e.push("");
        }
        t.replace(Ad, function (t, n, i, o) {
          e.push(i ? o.replace(Cd, "$1") : n || t);
        });
        return e;
      });
      const vd = _d;
      function yd(t, e) {
        var n = -1,
          i = t == null ? 0 : t.length,
          o = Array(i);
        while (++n < i) {
          o[n] = e(t[n], n, t);
        }
        return o;
      }
      const xd = yd;
      var Ed = 1 / 0;
      var Dd = Mt ? Mt.prototype : undefined,
        Sd = Dd ? Dd.toString : undefined;
      function Td(t) {
        if (typeof t == "string") {
          return t;
        }
        if (Kt(t)) {
          return xd(t, Td) + "";
        }
        if (ld(t)) {
          return Sd ? Sd.call(t) : "";
        }
        var e = t + "";
        return e == "0" && 1 / t == -Ed ? "-0" : e;
      }
      const Id = Td;
      function Md(t) {
        return t == null ? "" : Id(t);
      }
      const Bd = Md;
      function Ld(t, e) {
        if (Kt(t)) {
          return t;
        }
        return md(t, e) ? [t] : vd(Bd(t));
      }
      const Nd = Ld;
      function zd(t) {
        var e = t == null ? 0 : t.length;
        return e ? t[e - 1] : undefined;
      }
      const Pd = zd;
      var Rd = 1 / 0;
      function Od(t) {
        if (typeof t == "string" || ld(t)) {
          return t;
        }
        var e = t + "";
        return e == "0" && 1 / t == -Rd ? "-0" : e;
      }
      const jd = Od;
      function Fd(t, e) {
        e = Nd(e, t);
        var n = 0,
          i = e.length;
        while (t != null && n < i) {
          t = t[jd(e[n++])];
        }
        return n && n == i ? t : undefined;
      }
      const Vd = Fd;
      function Hd(t, e, n) {
        var i = -1,
          o = t.length;
        if (e < 0) {
          e = -e > o ? 0 : o + e;
        }
        n = n > o ? o : n;
        if (n < 0) {
          n += o;
        }
        o = e > n ? 0 : (n - e) >>> 0;
        e >>>= 0;
        var r = Array(o);
        while (++i < o) {
          r[i] = t[i + e];
        }
        return r;
      }
      const Ud = Hd;
      function qd(t, e) {
        return e.length < 2 ? t : Vd(t, Ud(e, 0, -1));
      }
      const Wd = qd;
      function Gd(t, e) {
        e = Nd(e, t);
        t = Wd(t, e);
        return t == null || delete t[jd(Pd(e))];
      }
      const $d = Gd;
      function Kd(t, e) {
        return t == null ? true : $d(t, e);
      }
      const Yd = Kd;
      function Zd(t, e, n) {
        var i = t == null ? undefined : Vd(t, e);
        return i === undefined ? n : i;
      }
      const Qd = Zd;
      function Jd(t, e, n) {
        if (
          (n !== undefined && !pe(t[e], n)) ||
          (n === undefined && !(e in t))
        ) {
          ci(t, e, n);
        }
      }
      const Xd = Jd;
      function tu(t) {
        return function (e, n, i) {
          var o = -1,
            r = Object(e),
            s = i(e),
            a = s.length;
          while (a--) {
            var c = s[t ? a : ++o];
            if (n(r[c], c, r) === false) {
              break;
            }
          }
          return e;
        };
      }
      const eu = tu;
      var nu = eu();
      const iu = nu;
      function ou(t) {
        return Zt(t) && Fo(t);
      }
      const ru = ou;
      function su(t, e) {
        if (e === "constructor" && typeof t[e] === "function") {
          return;
        }
        if (e == "__proto__") {
          return;
        }
        return t[e];
      }
      const au = su;
      function cu(t) {
        return gi(t, Jo(t));
      }
      const lu = cu;
      function du(t, e, n, i, o, r, s) {
        var a = au(t, n),
          c = au(e, n),
          l = s.get(c);
        if (l) {
          Xd(t, n, l);
          return;
        }
        var d = r ? r(a, c, n + "", t, e, s) : undefined;
        var u = d === undefined;
        if (u) {
          var h = Kt(c),
            m = !h && Li(c),
            g = !h && !m && xo(c);
          d = c;
          if (h || m || g) {
            if (Kt(a)) {
              d = a;
            } else if (ru(a)) {
              d = lr(a);
            } else if (m) {
              u = false;
              d = ar(c, true);
            } else if (g) {
              u = false;
              d = ws(c, true);
            } else {
              d = [];
            }
          } else if (he(c) || yi(c)) {
            d = a;
            if (yi(a)) {
              d = lu(a);
            } else if (!it(a) || qe(a)) {
              d = Ws(c);
            }
          } else {
            u = false;
          }
        }
        if (u) {
          s.set(c, d);
          o(d, c, i, r, s);
          s["delete"](c);
        }
        Xd(t, n, d);
      }
      const uu = du;
      function hu(t, e, n, i, o) {
        if (t === e) {
          return;
        }
        iu(
          e,
          function (r, s) {
            o || (o = new ni());
            if (it(r)) {
              uu(t, e, s, n, hu, i, o);
            } else {
              var a = i ? i(au(t, s), r, s + "", t, e, o) : undefined;
              if (a === undefined) {
                a = r;
              }
              Xd(t, s, a);
            }
          },
          Jo
        );
      }
      const mu = hu;
      function gu(t) {
        return t;
      }
      const fu = gu;
      function pu(t, e, n) {
        switch (n.length) {
          case 0:
            return t.call(e);
          case 1:
            return t.call(e, n[0]);
          case 2:
            return t.call(e, n[0], n[1]);
          case 3:
            return t.call(e, n[0], n[1], n[2]);
        }
        return t.apply(e, n);
      }
      const bu = pu;
      var ku = Math.max;
      function wu(t, e, n) {
        e = ku(e === undefined ? t.length - 1 : e, 0);
        return function () {
          var i = arguments,
            o = -1,
            r = ku(i.length - e, 0),
            s = Array(r);
          while (++o < r) {
            s[o] = i[e + o];
          }
          o = -1;
          var a = Array(e + 1);
          while (++o < e) {
            a[o] = i[o];
          }
          a[e] = n(s);
          return bu(t, this, a);
        };
      }
      const Au = wu;
      function Cu(t) {
        return function () {
          return t;
        };
      }
      const _u = Cu;
      var vu = !si
        ? fu
        : function (t, e) {
            return si(t, "toString", {
              configurable: true,
              enumerable: false,
              value: _u(e),
              writable: true,
            });
          };
      const yu = vu;
      var xu = 800,
        Eu = 16;
      var Du = Date.now;
      function Su(t) {
        var e = 0,
          n = 0;
        return function () {
          var i = Du(),
            o = Eu - (i - n);
          n = i;
          if (o > 0) {
            if (++e >= xu) {
              return arguments[0];
            }
          } else {
            e = 0;
          }
          return t.apply(undefined, arguments);
        };
      }
      const Tu = Su;
      var Iu = Tu(yu);
      const Mu = Iu;
      function Bu(t, e) {
        return Mu(Au(t, e, fu), t + "");
      }
      const Lu = Bu;
      function Nu(t, e, n) {
        if (!it(n)) {
          return false;
        }
        var i = typeof e;
        if (
          i == "number" ? Fo(n) && Ri(e, n.length) : i == "string" && e in n
        ) {
          return pe(n[e], t);
        }
        return false;
      }
      const zu = Nu;
      function Pu(t) {
        return Lu(function (e, n) {
          var i = -1,
            o = n.length,
            r = o > 1 ? n[o - 1] : undefined,
            s = o > 2 ? n[2] : undefined;
          r = t.length > 3 && typeof r == "function" ? (o--, r) : undefined;
          if (s && zu(n[0], n[1], s)) {
            r = o < 3 ? undefined : r;
            o = 1;
          }
          e = Object(e);
          while (++i < o) {
            var a = n[i];
            if (a) {
              t(e, a, i, r);
            }
          }
          return e;
        });
      }
      const Ru = Pu;
      var Ou = Ru(function (t, e, n) {
        mu(t, e, n);
      });
      const ju = Ou;
      function Fu(t, e, n, i) {
        if (!it(t)) {
          return t;
        }
        e = Nd(e, t);
        var o = -1,
          r = e.length,
          s = r - 1,
          a = t;
        while (a != null && ++o < r) {
          var c = jd(e[o]),
            l = n;
          if (c === "__proto__" || c === "constructor" || c === "prototype") {
            return t;
          }
          if (o != s) {
            var d = a[c];
            l = i ? i(d, c, a) : undefined;
            if (l === undefined) {
              l = it(d) ? d : Ri(e[o + 1]) ? [] : {};
            }
          }
          hi(a, c, l);
          a = a[c];
        }
        return t;
      }
      const Vu = Fu;
      function Hu(t, e, n) {
        return t == null ? t : Vu(t, e, n);
      }
      const Uu = Hu;
      class qu {
        constructor(t) {
          this._styles = {};
          this._styleProcessor = t;
        }
        get isEmpty() {
          const t = Object.entries(this._styles);
          const e = Array.from(t);
          return !e.length;
        }
        get size() {
          if (this.isEmpty) {
            return 0;
          }
          return this.getStyleNames().length;
        }
        setTo(t) {
          this.clear();
          const e = Array.from(Gu(t).entries());
          for (const [t, n] of e) {
            this._styleProcessor.toNormalizedForm(t, n, this._styles);
          }
        }
        has(t) {
          if (this.isEmpty) {
            return false;
          }
          const e = this._styleProcessor.getReducedForm(t, this._styles);
          const n = e.find(([e]) => e === t);
          return Array.isArray(n);
        }
        set(t, e) {
          if (it(t)) {
            for (const [e, n] of Object.entries(t)) {
              this._styleProcessor.toNormalizedForm(e, n, this._styles);
            }
          } else {
            this._styleProcessor.toNormalizedForm(t, e, this._styles);
          }
        }
        remove(t) {
          const e = $u(t);
          Yd(this._styles, e);
          delete this._styles[t];
          this._cleanEmptyObjectsOnPath(e);
        }
        getNormalized(t) {
          return this._styleProcessor.getNormalized(t, this._styles);
        }
        toString() {
          if (this.isEmpty) {
            return "";
          }
          return (
            this._getStylesEntries()
              .map((t) => t.join(":"))
              .sort()
              .join(";") + ";"
          );
        }
        getAsString(t) {
          if (this.isEmpty) {
            return;
          }
          if (this._styles[t] && !it(this._styles[t])) {
            return this._styles[t];
          }
          const e = this._styleProcessor.getReducedForm(t, this._styles);
          const n = e.find(([e]) => e === t);
          if (Array.isArray(n)) {
            return n[1];
          }
        }
        getStyleNames(t = false) {
          if (this.isEmpty) {
            return [];
          }
          if (t) {
            return this._styleProcessor.getStyleNames(this._styles);
          }
          const e = this._getStylesEntries();
          return e.map(([t]) => t);
        }
        clear() {
          this._styles = {};
        }
        _getStylesEntries() {
          const t = [];
          const e = Object.keys(this._styles);
          for (const n of e) {
            t.push(...this._styleProcessor.getReducedForm(n, this._styles));
          }
          return t;
        }
        _cleanEmptyObjectsOnPath(t) {
          const e = t.split(".");
          const n = e.length > 1;
          if (!n) {
            return;
          }
          const i = e.splice(0, e.length - 1).join(".");
          const o = Qd(this._styles, i);
          if (!o) {
            return;
          }
          const r = !Array.from(Object.keys(o)).length;
          if (r) {
            this.remove(i);
          }
        }
      }
      class Wu {
        constructor() {
          this._normalizers = new Map();
          this._extractors = new Map();
          this._reducers = new Map();
          this._consumables = new Map();
        }
        toNormalizedForm(t, e, n) {
          if (it(e)) {
            Ku(n, $u(t), e);
            return;
          }
          if (this._normalizers.has(t)) {
            const i = this._normalizers.get(t);
            const { path: o, value: r } = i(e);
            Ku(n, o, r);
          } else {
            Ku(n, t, e);
          }
        }
        getNormalized(t, e) {
          if (!t) {
            return ju({}, e);
          }
          if (e[t] !== undefined) {
            return e[t];
          }
          if (this._extractors.has(t)) {
            const n = this._extractors.get(t);
            if (typeof n === "string") {
              return Qd(e, n);
            }
            const i = n(t, e);
            if (i) {
              return i;
            }
          }
          return Qd(e, $u(t));
        }
        getReducedForm(t, e) {
          const n = this.getNormalized(t, e);
          if (n === undefined) {
            return [];
          }
          if (this._reducers.has(t)) {
            const e = this._reducers.get(t);
            return e(n);
          }
          return [[t, n]];
        }
        getStyleNames(t) {
          const e = Array.from(this._consumables.keys()).filter((e) => {
            const n = this.getNormalized(e, t);
            if (n && typeof n == "object") {
              return Object.keys(n).length;
            }
            return n;
          });
          const n = new Set([...e, ...Object.keys(t)]);
          return Array.from(n.values());
        }
        getRelatedStyles(t) {
          return this._consumables.get(t) || [];
        }
        setNormalizer(t, e) {
          this._normalizers.set(t, e);
        }
        setExtractor(t, e) {
          this._extractors.set(t, e);
        }
        setReducer(t, e) {
          this._reducers.set(t, e);
        }
        setStyleRelation(t, e) {
          this._mapStyleNames(t, e);
          for (const n of e) {
            this._mapStyleNames(n, [t]);
          }
        }
        _mapStyleNames(t, e) {
          if (!this._consumables.has(t)) {
            this._consumables.set(t, []);
          }
          this._consumables.get(t).push(...e);
        }
      }
      function Gu(t) {
        let e = null;
        let n = 0;
        let i = 0;
        let o = null;
        const r = new Map();
        if (t === "") {
          return r;
        }
        if (t.charAt(t.length - 1) != ";") {
          t = t + ";";
        }
        for (let s = 0; s < t.length; s++) {
          const a = t.charAt(s);
          if (e === null) {
            switch (a) {
              case ":":
                if (!o) {
                  o = t.substr(n, s - n);
                  i = s + 1;
                }
                break;
              case '"':
              case "'":
                e = a;
                break;
              case ";": {
                const e = t.substr(i, s - i);
                if (o) {
                  r.set(o.trim(), e.trim());
                }
                o = null;
                n = s + 1;
                break;
              }
            }
          } else if (a === e) {
            e = null;
          }
        }
        return r;
      }
      function $u(t) {
        return t.replace("-", ".");
      }
      function Ku(t, e, n) {
        let i = n;
        if (it(n)) {
          i = ju({}, Qd(t, e), n);
        }
        Uu(t, e, i);
      }
      class Yu extends Kl {
        constructor(t, e, n, i) {
          super(t);
          this.name = e;
          this._attrs = Zu(n);
          this._children = [];
          if (i) {
            this._insertChild(0, i);
          }
          this._classes = new Set();
          if (this._attrs.has("class")) {
            const t = this._attrs.get("class");
            Qu(this._classes, t);
            this._attrs.delete("class");
          }
          this._styles = new qu(this.document.stylesProcessor);
          if (this._attrs.has("style")) {
            this._styles.setTo(this._attrs.get("style"));
            this._attrs.delete("style");
          }
          this._customProperties = new Map();
          this._unsafeAttributesToRender = [];
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this._children.length === 0;
        }
        getChild(t) {
          return this._children[t];
        }
        getChildIndex(t) {
          return this._children.indexOf(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        *getAttributeKeys() {
          if (this._classes.size > 0) {
            yield "class";
          }
          if (!this._styles.isEmpty) {
            yield "style";
          }
          yield* this._attrs.keys();
        }
        *getAttributes() {
          yield* this._attrs.entries();
          if (this._classes.size > 0) {
            yield ["class", this.getAttribute("class")];
          }
          if (!this._styles.isEmpty) {
            yield ["style", this.getAttribute("style")];
          }
        }
        getAttribute(t) {
          if (t == "class") {
            if (this._classes.size > 0) {
              return [...this._classes].join(" ");
            }
            return undefined;
          }
          if (t == "style") {
            const t = this._styles.toString();
            return t == "" ? undefined : t;
          }
          return this._attrs.get(t);
        }
        hasAttribute(t) {
          if (t == "class") {
            return this._classes.size > 0;
          }
          if (t == "style") {
            return !this._styles.isEmpty;
          }
          return this._attrs.has(t);
        }
        isSimilar(t) {
          if (!(t instanceof Yu)) {
            return false;
          }
          if (this === t) {
            return true;
          }
          if (this.name != t.name) {
            return false;
          }
          if (
            this._attrs.size !== t._attrs.size ||
            this._classes.size !== t._classes.size ||
            this._styles.size !== t._styles.size
          ) {
            return false;
          }
          for (const [e, n] of this._attrs) {
            if (!t._attrs.has(e) || t._attrs.get(e) !== n) {
              return false;
            }
          }
          for (const e of this._classes) {
            if (!t._classes.has(e)) {
              return false;
            }
          }
          for (const e of this._styles.getStyleNames()) {
            if (
              !t._styles.has(e) ||
              t._styles.getAsString(e) !== this._styles.getAsString(e)
            ) {
              return false;
            }
          }
          return true;
        }
        hasClass(...t) {
          for (const e of t) {
            if (!this._classes.has(e)) {
              return false;
            }
          }
          return true;
        }
        getClassNames() {
          return this._classes.keys();
        }
        getStyle(t) {
          return this._styles.getAsString(t);
        }
        getNormalizedStyle(t) {
          return this._styles.getNormalized(t);
        }
        getStyleNames(t) {
          return this._styles.getStyleNames(t);
        }
        hasStyle(...t) {
          for (const e of t) {
            if (!this._styles.has(e)) {
              return false;
            }
          }
          return true;
        }
        findAncestor(...t) {
          const e = new Ql(...t);
          let n = this.parent;
          while (n && !n.is("documentFragment")) {
            if (e.match(n)) {
              return n;
            }
            n = n.parent;
          }
          return null;
        }
        getCustomProperty(t) {
          return this._customProperties.get(t);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        getIdentity() {
          const t = Array.from(this._classes).sort().join(",");
          const e = this._styles.toString();
          const n = Array.from(this._attrs)
            .map((t) => \`\${t[0]}="\${t[1]}"\`)
            .sort()
            .join(" ");
          return (
            this.name +
            (t == "" ? "" : \` class="\${t}"\`) +
            (!e ? "" : \` style="\${e}"\`) +
            (n == "" ? "" : \` \${n}\`)
          );
        }
        shouldRenderUnsafeAttribute(t) {
          return this._unsafeAttributesToRender.includes(t);
        }
        _clone(t = false) {
          const e = [];
          if (t) {
            for (const n of this.getChildren()) {
              e.push(n._clone(t));
            }
          }
          const n = new this.constructor(
            this.document,
            this.name,
            this._attrs,
            e
          );
          n._classes = new Set(this._classes);
          n._styles.set(this._styles.getNormalized());
          n._customProperties = new Map(this._customProperties);
          n.getFillerOffset = this.getFillerOffset;
          n._unsafeAttributesToRender = this._unsafeAttributesToRender;
          return n;
        }
        _appendChild(t) {
          return this._insertChild(this.childCount, t);
        }
        _insertChild(t, e) {
          this._fireChange("children", this);
          let n = 0;
          const i = Ju(this.document, e);
          for (const e of i) {
            if (e.parent !== null) {
              e._remove();
            }
            e.parent = this;
            e.document = this.document;
            this._children.splice(t, 0, e);
            t++;
            n++;
          }
          return n;
        }
        _removeChildren(t, e = 1) {
          this._fireChange("children", this);
          for (let n = t; n < t + e; n++) {
            this._children[n].parent = null;
          }
          return this._children.splice(t, e);
        }
        _setAttribute(t, e) {
          e = String(e);
          this._fireChange("attributes", this);
          if (t == "class") {
            Qu(this._classes, e);
          } else if (t == "style") {
            this._styles.setTo(e);
          } else {
            this._attrs.set(t, e);
          }
        }
        _removeAttribute(t) {
          this._fireChange("attributes", this);
          if (t == "class") {
            if (this._classes.size > 0) {
              this._classes.clear();
              return true;
            }
            return false;
          }
          if (t == "style") {
            if (!this._styles.isEmpty) {
              this._styles.clear();
              return true;
            }
            return false;
          }
          return this._attrs.delete(t);
        }
        _addClass(t) {
          this._fireChange("attributes", this);
          for (const e of Yc(t)) {
            this._classes.add(e);
          }
        }
        _removeClass(t) {
          this._fireChange("attributes", this);
          for (const e of Yc(t)) {
            this._classes.delete(e);
          }
        }
        _setStyle(t, e) {
          this._fireChange("attributes", this);
          if (he(t)) {
            this._styles.set(t);
          } else {
            this._styles.set(t, e);
          }
        }
        _removeStyle(t) {
          this._fireChange("attributes", this);
          for (const e of Yc(t)) {
            this._styles.remove(e);
          }
        }
        _setCustomProperty(t, e) {
          this._customProperties.set(t, e);
        }
        _removeCustomProperty(t) {
          return this._customProperties.delete(t);
        }
      }
      Yu.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          );
        } else {
          return e === this.name && (t === "element" || t === "view:element");
        }
      };
      function Zu(t) {
        const e = dl(t);
        for (const [t, n] of e) {
          if (n === null) {
            e.delete(t);
          } else if (typeof n != "string") {
            e.set(t, String(n));
          }
        }
        return e;
      }
      function Qu(t, e) {
        const n = e.split(/\\s+/);
        t.clear();
        n.forEach((e) => t.add(e));
      }
      function Ju(t, e) {
        if (typeof e == "string") {
          return [new Yl(t, e)];
        }
        if (!yt(e)) {
          e = [e];
        }
        return Array.from(e).map((e) => {
          if (typeof e == "string") {
            return new Yl(t, e);
          }
          if (e instanceof Zl) {
            return new Yl(t, e.data);
          }
          return e;
        });
      }
      class Xu extends Yu {
        constructor(...t) {
          super(...t);
          this.getFillerOffset = th;
        }
      }
      Xu.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "containerElement" ||
            t === "view:containerElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          );
        } else {
          return (
            e === this.name &&
            (t === "containerElement" ||
              t === "view:containerElement" ||
              t === "element" ||
              t === "view:element")
          );
        }
      };
      function th() {
        const t = [...this.getChildren()];
        const e = t[this.childCount - 1];
        if (e && e.is("element", "br")) {
          return this.childCount;
        }
        for (const e of t) {
          if (!e.is("uiElement")) {
            return null;
          }
        }
        return this.childCount;
      }
      class eh extends dt(Xu) {
        constructor(...t) {
          super(...t);
          const e = t[0];
          this.set("isReadOnly", false);
          this.set("isFocused", false);
          this.bind("isReadOnly").to(e);
          this.bind("isFocused").to(
            e,
            "isFocused",
            (t) => t && e.selection.editableElement == this
          );
          this.listenTo(e.selection, "change", () => {
            this.isFocused = e.isFocused && e.selection.editableElement == this;
          });
        }
        destroy() {
          this.stopListening();
        }
      }
      eh.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "editableElement" ||
            t === "view:editableElement" ||
            t === "containerElement" ||
            t === "view:containerElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          );
        } else {
          return (
            e === this.name &&
            (t === "editableElement" ||
              t === "view:editableElement" ||
              t === "containerElement" ||
              t === "view:containerElement" ||
              t === "element" ||
              t === "view:element")
          );
        }
      };
      const nh = Symbol("rootName");
      class ih extends eh {
        constructor(t, e) {
          super(t, e);
          this.rootName = "main";
        }
        get rootName() {
          return this.getCustomProperty(nh);
        }
        set rootName(t) {
          this._setCustomProperty(nh, t);
        }
        set _name(t) {
          this.name = t;
        }
      }
      ih.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "rootElement" ||
            t === "view:rootElement" ||
            t === "editableElement" ||
            t === "view:editableElement" ||
            t === "containerElement" ||
            t === "view:containerElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          );
        } else {
          return (
            e === this.name &&
            (t === "rootElement" ||
              t === "view:rootElement" ||
              t === "editableElement" ||
              t === "view:editableElement" ||
              t === "containerElement" ||
              t === "view:containerElement" ||
              t === "element" ||
              t === "view:element")
          );
        }
      };
      class oh {
        constructor(t = {}) {
          if (!t.boundaries && !t.startPosition) {
            throw new M("view-tree-walker-no-start-position", null);
          }
          if (
            t.direction &&
            t.direction != "forward" &&
            t.direction != "backward"
          ) {
            throw new M("view-tree-walker-unknown-direction", t.startPosition, {
              direction: t.direction,
            });
          }
          this.boundaries = t.boundaries || null;
          if (t.startPosition) {
            this.position = rh._createAt(t.startPosition);
          } else {
            this.position = rh._createAt(
              t.boundaries[t.direction == "backward" ? "end" : "start"]
            );
          }
          this.direction = t.direction || "forward";
          this.singleCharacters = !!t.singleCharacters;
          this.shallow = !!t.shallow;
          this.ignoreElementEnd = !!t.ignoreElementEnd;
          this._boundaryStartParent = this.boundaries
            ? this.boundaries.start.parent
            : null;
          this._boundaryEndParent = this.boundaries
            ? this.boundaries.end.parent
            : null;
        }
        [Symbol.iterator]() {
          return this;
        }
        skip(t) {
          let e, n, i;
          do {
            i = this.position;
            ({ done: e, value: n } = this.next());
          } while (!e && t(n));
          if (!e) {
            this.position = i;
          }
        }
        next() {
          if (this.direction == "forward") {
            return this._next();
          } else {
            return this._previous();
          }
        }
        _next() {
          let t = this.position.clone();
          const e = this.position;
          const n = t.parent;
          if (n.parent === null && t.offset === n.childCount) {
            return { done: true, value: undefined };
          }
          if (
            n === this._boundaryEndParent &&
            t.offset == this.boundaries.end.offset
          ) {
            return { done: true, value: undefined };
          }
          let i;
          if (n instanceof Yl) {
            if (t.isAtEnd) {
              this.position = rh._createAfter(n);
              return this._next();
            }
            i = n.data[t.offset];
          } else {
            i = n.getChild(t.offset);
          }
          if (i instanceof Yu) {
            if (!this.shallow) {
              t = new rh(i, 0);
            } else {
              t.offset++;
            }
            this.position = t;
            return this._formatReturnValue("elementStart", i, e, t, 1);
          } else if (i instanceof Yl) {
            if (this.singleCharacters) {
              t = new rh(i, 0);
              this.position = t;
              return this._next();
            } else {
              let n = i.data.length;
              let o;
              if (i == this._boundaryEndParent) {
                n = this.boundaries.end.offset;
                o = new Zl(i, 0, n);
                t = rh._createAfter(o);
              } else {
                o = new Zl(i, 0, i.data.length);
                t.offset++;
              }
              this.position = t;
              return this._formatReturnValue("text", o, e, t, n);
            }
          } else if (typeof i == "string") {
            let i;
            if (this.singleCharacters) {
              i = 1;
            } else {
              const e =
                n === this._boundaryEndParent
                  ? this.boundaries.end.offset
                  : n.data.length;
              i = e - t.offset;
            }
            const o = new Zl(n, t.offset, i);
            t.offset += i;
            this.position = t;
            return this._formatReturnValue("text", o, e, t, i);
          } else {
            t = rh._createAfter(n);
            this.position = t;
            if (this.ignoreElementEnd) {
              return this._next();
            } else {
              return this._formatReturnValue("elementEnd", n, e, t);
            }
          }
        }
        _previous() {
          let t = this.position.clone();
          const e = this.position;
          const n = t.parent;
          if (n.parent === null && t.offset === 0) {
            return { done: true, value: undefined };
          }
          if (
            n == this._boundaryStartParent &&
            t.offset == this.boundaries.start.offset
          ) {
            return { done: true, value: undefined };
          }
          let i;
          if (n instanceof Yl) {
            if (t.isAtStart) {
              this.position = rh._createBefore(n);
              return this._previous();
            }
            i = n.data[t.offset - 1];
          } else {
            i = n.getChild(t.offset - 1);
          }
          if (i instanceof Yu) {
            if (!this.shallow) {
              t = new rh(i, i.childCount);
              this.position = t;
              if (this.ignoreElementEnd) {
                return this._previous();
              } else {
                return this._formatReturnValue("elementEnd", i, e, t);
              }
            } else {
              t.offset--;
              this.position = t;
              return this._formatReturnValue("elementStart", i, e, t, 1);
            }
          } else if (i instanceof Yl) {
            if (this.singleCharacters) {
              t = new rh(i, i.data.length);
              this.position = t;
              return this._previous();
            } else {
              let n = i.data.length;
              let o;
              if (i == this._boundaryStartParent) {
                const e = this.boundaries.start.offset;
                o = new Zl(i, e, i.data.length - e);
                n = o.data.length;
                t = rh._createBefore(o);
              } else {
                o = new Zl(i, 0, i.data.length);
                t.offset--;
              }
              this.position = t;
              return this._formatReturnValue("text", o, e, t, n);
            }
          } else if (typeof i == "string") {
            let i;
            if (!this.singleCharacters) {
              const e =
                n === this._boundaryStartParent
                  ? this.boundaries.start.offset
                  : 0;
              i = t.offset - e;
            } else {
              i = 1;
            }
            t.offset -= i;
            const o = new Zl(n, t.offset, i);
            this.position = t;
            return this._formatReturnValue("text", o, e, t, i);
          } else {
            t = rh._createBefore(n);
            this.position = t;
            return this._formatReturnValue("elementStart", n, e, t, 1);
          }
        }
        _formatReturnValue(t, e, n, i, o) {
          if (e instanceof Zl) {
            if (e.offsetInText + e.data.length == e.textNode.data.length) {
              if (
                this.direction == "forward" &&
                !(this.boundaries && this.boundaries.end.isEqual(this.position))
              ) {
                i = rh._createAfter(e.textNode);
                this.position = i;
              } else {
                n = rh._createAfter(e.textNode);
              }
            }
            if (e.offsetInText === 0) {
              if (
                this.direction == "backward" &&
                !(
                  this.boundaries &&
                  this.boundaries.start.isEqual(this.position)
                )
              ) {
                i = rh._createBefore(e.textNode);
                this.position = i;
              } else {
                n = rh._createBefore(e.textNode);
              }
            }
          }
          return {
            done: false,
            value: {
              type: t,
              item: e,
              previousPosition: n,
              nextPosition: i,
              length: o,
            },
          };
        }
      }
      class rh extends ql {
        constructor(t, e) {
          super();
          this.parent = t;
          this.offset = e;
        }
        get nodeAfter() {
          if (this.parent.is("$text")) {
            return null;
          }
          return this.parent.getChild(this.offset) || null;
        }
        get nodeBefore() {
          if (this.parent.is("$text")) {
            return null;
          }
          return this.parent.getChild(this.offset - 1) || null;
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          const t = this.parent.is("$text")
            ? this.parent.data.length
            : this.parent.childCount;
          return this.offset === t;
        }
        get root() {
          return this.parent.root;
        }
        get editableElement() {
          let t = this.parent;
          while (!(t instanceof eh)) {
            if (t.parent) {
              t = t.parent;
            } else {
              return null;
            }
          }
          return t;
        }
        getShiftedBy(t) {
          const e = rh._createAt(this);
          const n = e.offset + t;
          e.offset = n < 0 ? 0 : n;
          return e;
        }
        getLastMatchingPosition(t, e = {}) {
          e.startPosition = this;
          const n = new oh(e);
          n.skip(t);
          return n.position;
        }
        getAncestors() {
          if (this.parent.is("documentFragment")) {
            return [this.parent];
          } else {
            return this.parent.getAncestors({ includeSelf: true });
          }
        }
        getCommonAncestor(t) {
          const e = this.getAncestors();
          const n = t.getAncestors();
          let i = 0;
          while (e[i] == n[i] && e[i]) {
            i++;
          }
          return i === 0 ? null : e[i - 1];
        }
        isEqual(t) {
          return this.parent == t.parent && this.offset == t.offset;
        }
        isBefore(t) {
          return this.compareWith(t) == "before";
        }
        isAfter(t) {
          return this.compareWith(t) == "after";
        }
        compareWith(t) {
          if (this.root !== t.root) {
            return "different";
          }
          if (this.isEqual(t)) {
            return "same";
          }
          const e = this.parent.is("node") ? this.parent.getPath() : [];
          const n = t.parent.is("node") ? t.parent.getPath() : [];
          e.push(this.offset);
          n.push(t.offset);
          const i = vt(e, n);
          switch (i) {
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return e[i] < n[i] ? "before" : "after";
          }
        }
        getWalker(t = {}) {
          t.startPosition = this;
          return new oh(t);
        }
        clone() {
          return new rh(this.parent, this.offset);
        }
        static _createAt(t, e) {
          if (t instanceof rh) {
            return new this(t.parent, t.offset);
          } else {
            const n = t;
            if (e == "end") {
              e = n.is("$text") ? n.data.length : n.childCount;
            } else if (e == "before") {
              return this._createBefore(n);
            } else if (e == "after") {
              return this._createAfter(n);
            } else if (e !== 0 && !e) {
              throw new M("view-createpositionat-offset-required", n);
            }
            return new rh(n, e);
          }
        }
        static _createAfter(t) {
          if (t.is("$textProxy")) {
            return new rh(t.textNode, t.offsetInText + t.data.length);
          }
          if (!t.parent) {
            throw new M("view-position-after-root", t, { root: t });
          }
          return new rh(t.parent, t.index + 1);
        }
        static _createBefore(t) {
          if (t.is("$textProxy")) {
            return new rh(t.textNode, t.offsetInText);
          }
          if (!t.parent) {
            throw new M("view-position-before-root", t, { root: t });
          }
          return new rh(t.parent, t.index);
        }
      }
      rh.prototype.is = function (t) {
        return t === "position" || t === "view:position";
      };
      class sh extends ql {
        constructor(t, e = null) {
          super();
          this.start = t.clone();
          this.end = e ? e.clone() : t.clone();
        }
        *[Symbol.iterator]() {
          yield* new oh({ boundaries: this, ignoreElementEnd: true });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          return this.start.parent === this.end.parent;
        }
        get root() {
          return this.start.root;
        }
        getEnlarged() {
          let t = this.start.getLastMatchingPosition(ah, {
            direction: "backward",
          });
          let e = this.end.getLastMatchingPosition(ah);
          if (t.parent.is("$text") && t.isAtStart) {
            t = rh._createBefore(t.parent);
          }
          if (e.parent.is("$text") && e.isAtEnd) {
            e = rh._createAfter(e.parent);
          }
          return new sh(t, e);
        }
        getTrimmed() {
          let t = this.start.getLastMatchingPosition(ah);
          if (t.isAfter(this.end) || t.isEqual(this.end)) {
            return new sh(t, t);
          }
          let e = this.end.getLastMatchingPosition(ah, {
            direction: "backward",
          });
          const n = t.nodeAfter;
          const i = e.nodeBefore;
          if (n && n.is("$text")) {
            t = new rh(n, 0);
          }
          if (i && i.is("$text")) {
            e = new rh(i, i.data.length);
          }
          return new sh(t, e);
        }
        isEqual(t) {
          return (
            this == t ||
            (this.start.isEqual(t.start) && this.end.isEqual(t.end))
          );
        }
        containsPosition(t) {
          return t.isAfter(this.start) && t.isBefore(this.end);
        }
        containsRange(t, e = false) {
          if (t.isCollapsed) {
            e = false;
          }
          const n =
            this.containsPosition(t.start) ||
            (e && this.start.isEqual(t.start));
          const i =
            this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
          return n && i;
        }
        getDifference(t) {
          const e = [];
          if (this.isIntersecting(t)) {
            if (this.containsPosition(t.start)) {
              e.push(new sh(this.start, t.start));
            }
            if (this.containsPosition(t.end)) {
              e.push(new sh(t.end, this.end));
            }
          } else {
            e.push(this.clone());
          }
          return e;
        }
        getIntersection(t) {
          if (this.isIntersecting(t)) {
            let e = this.start;
            let n = this.end;
            if (this.containsPosition(t.start)) {
              e = t.start;
            }
            if (this.containsPosition(t.end)) {
              n = t.end;
            }
            return new sh(e, n);
          }
          return null;
        }
        getWalker(t = {}) {
          t.boundaries = this;
          return new oh(t);
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed) {
            return null;
          }
          let t = this.start.nodeAfter;
          let e = this.end.nodeBefore;
          if (
            this.start.parent.is("$text") &&
            this.start.isAtEnd &&
            this.start.parent.nextSibling
          ) {
            t = this.start.parent.nextSibling;
          }
          if (
            this.end.parent.is("$text") &&
            this.end.isAtStart &&
            this.end.parent.previousSibling
          ) {
            e = this.end.parent.previousSibling;
          }
          if (t && t.is("element") && t === e) {
            return t;
          }
          return null;
        }
        clone() {
          return new sh(this.start, this.end);
        }
        *getItems(t = {}) {
          t.boundaries = this;
          t.ignoreElementEnd = true;
          const e = new oh(t);
          for (const t of e) {
            yield t.item;
          }
        }
        *getPositions(t = {}) {
          t.boundaries = this;
          const e = new oh(t);
          yield e.position;
          for (const t of e) {
            yield t.nextPosition;
          }
        }
        isIntersecting(t) {
          return this.start.isBefore(t.end) && this.end.isAfter(t.start);
        }
        static _createFromParentsAndOffsets(t, e, n, i) {
          return new this(new rh(t, e), new rh(n, i));
        }
        static _createFromPositionAndShift(t, e) {
          const n = t;
          const i = t.getShiftedBy(e);
          return e > 0 ? new this(n, i) : new this(i, n);
        }
        static _createIn(t) {
          return this._createFromParentsAndOffsets(t, 0, t, t.childCount);
        }
        static _createOn(t) {
          const e = t.is("$textProxy") ? t.offsetSize : 1;
          return this._createFromPositionAndShift(rh._createBefore(t), e);
        }
      }
      sh.prototype.is = function (t) {
        return t === "range" || t === "view:range";
      };
      function ah(t) {
        if (t.item.is("attributeElement") || t.item.is("uiElement")) {
          return true;
        }
        return false;
      }
      class ch extends q(ql) {
        constructor(...t) {
          super();
          this._ranges = [];
          this._lastRangeBackward = false;
          this._isFake = false;
          this._fakeSelectionLabel = "";
          if (t.length) {
            this.setTo(...t);
          }
        }
        get isFake() {
          return this._isFake;
        }
        get fakeSelectionLabel() {
          return this._fakeSelectionLabel;
        }
        get anchor() {
          if (!this._ranges.length) {
            return null;
          }
          const t = this._ranges[this._ranges.length - 1];
          const e = this._lastRangeBackward ? t.end : t.start;
          return e.clone();
        }
        get focus() {
          if (!this._ranges.length) {
            return null;
          }
          const t = this._ranges[this._ranges.length - 1];
          const e = this._lastRangeBackward ? t.start : t.end;
          return e.clone();
        }
        get isCollapsed() {
          return this.rangeCount === 1 && this._ranges[0].isCollapsed;
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        get editableElement() {
          if (this.anchor) {
            return this.anchor.editableElement;
          }
          return null;
        }
        *getRanges() {
          for (const t of this._ranges) {
            yield t.clone();
          }
        }
        getFirstRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.start.isBefore(t.start)) {
              t = e;
            }
          }
          return t ? t.clone() : null;
        }
        getLastRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.end.isAfter(t.end)) {
              t = e;
            }
          }
          return t ? t.clone() : null;
        }
        getFirstPosition() {
          const t = this.getFirstRange();
          return t ? t.start.clone() : null;
        }
        getLastPosition() {
          const t = this.getLastRange();
          return t ? t.end.clone() : null;
        }
        isEqual(t) {
          if (this.isFake != t.isFake) {
            return false;
          }
          if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) {
            return false;
          }
          if (this.rangeCount != t.rangeCount) {
            return false;
          } else if (this.rangeCount === 0) {
            return true;
          }
          if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
            return false;
          }
          for (const e of this._ranges) {
            let n = false;
            for (const i of t._ranges) {
              if (e.isEqual(i)) {
                n = true;
                break;
              }
            }
            if (!n) {
              return false;
            }
          }
          return true;
        }
        isSimilar(t) {
          if (this.isBackward != t.isBackward) {
            return false;
          }
          const e = _t(this.getRanges());
          const n = _t(t.getRanges());
          if (e != n) {
            return false;
          }
          if (e == 0) {
            return true;
          }
          for (let e of this.getRanges()) {
            e = e.getTrimmed();
            let n = false;
            for (let i of t.getRanges()) {
              i = i.getTrimmed();
              if (e.start.isEqual(i.start) && e.end.isEqual(i.end)) {
                n = true;
                break;
              }
            }
            if (!n) {
              return false;
            }
          }
          return true;
        }
        getSelectedElement() {
          if (this.rangeCount !== 1) {
            return null;
          }
          return this.getFirstRange().getContainedElement();
        }
        setTo(...t) {
          let [e, n, i] = t;
          if (typeof n == "object") {
            i = n;
            n = undefined;
          }
          if (e === null) {
            this._setRanges([]);
            this._setFakeOptions(i);
          } else if (e instanceof ch || e instanceof lh) {
            this._setRanges(e.getRanges(), e.isBackward);
            this._setFakeOptions({
              fake: e.isFake,
              label: e.fakeSelectionLabel,
            });
          } else if (e instanceof sh) {
            this._setRanges([e], i && i.backward);
            this._setFakeOptions(i);
          } else if (e instanceof rh) {
            this._setRanges([new sh(e)]);
            this._setFakeOptions(i);
          } else if (e instanceof Kl) {
            const t = !!i && !!i.backward;
            let o;
            if (n === undefined) {
              throw new M(
                "view-selection-setto-required-second-parameter",
                this
              );
            } else if (n == "in") {
              o = sh._createIn(e);
            } else if (n == "on") {
              o = sh._createOn(e);
            } else {
              o = new sh(rh._createAt(e, n));
            }
            this._setRanges([o], t);
            this._setFakeOptions(i);
          } else if (yt(e)) {
            this._setRanges(e, i && i.backward);
            this._setFakeOptions(i);
          } else {
            throw new M("view-selection-setto-not-selectable", this);
          }
          this.fire("change");
        }
        setFocus(t, e) {
          if (this.anchor === null) {
            throw new M("view-selection-setfocus-no-ranges", this);
          }
          const n = rh._createAt(t, e);
          if (n.compareWith(this.focus) == "same") {
            return;
          }
          const i = this.anchor;
          this._ranges.pop();
          if (n.compareWith(i) == "before") {
            this._addRange(new sh(n, i), true);
          } else {
            this._addRange(new sh(i, n));
          }
          this.fire("change");
        }
        _setRanges(t, e = false) {
          t = Array.from(t);
          this._ranges = [];
          for (const e of t) {
            this._addRange(e);
          }
          this._lastRangeBackward = !!e;
        }
        _setFakeOptions(t = {}) {
          this._isFake = !!t.fake;
          this._fakeSelectionLabel = t.fake ? t.label || "" : "";
        }
        _addRange(t, e = false) {
          if (!(t instanceof sh)) {
            throw new M("view-selection-add-range-not-range", this);
          }
          this._pushRange(t);
          this._lastRangeBackward = !!e;
        }
        _pushRange(t) {
          for (const e of this._ranges) {
            if (t.isIntersecting(e)) {
              throw new M("view-selection-range-intersects", this, {
                addedRange: t,
                intersectingRange: e,
              });
            }
          }
          this._ranges.push(new sh(t.start, t.end));
        }
      }
      ch.prototype.is = function (t) {
        return t === "selection" || t === "view:selection";
      };
      class lh extends q(ql) {
        constructor(...t) {
          super();
          this._selection = new ch();
          this._selection.delegate("change").to(this);
          if (t.length) {
            this._selection.setTo(...t);
          }
        }
        get isFake() {
          return this._selection.isFake;
        }
        get fakeSelectionLabel() {
          return this._selection.fakeSelectionLabel;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get editableElement() {
          return this._selection.editableElement;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        *getRanges() {
          yield* this._selection.getRanges();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        isEqual(t) {
          return this._selection.isEqual(t);
        }
        isSimilar(t) {
          return this._selection.isSimilar(t);
        }
        _setTo(...t) {
          this._selection.setTo(...t);
        }
        _setFocus(t, e) {
          this._selection.setFocus(t, e);
        }
      }
      lh.prototype.is = function (t) {
        return (
          t === "selection" ||
          t == "documentSelection" ||
          t == "view:selection" ||
          t == "view:documentSelection"
        );
      };
      class dh extends y {
        constructor(t, e, n) {
          super(t, e);
          this.startRange = n;
          this._eventPhase = "none";
          this._currentTarget = null;
        }
        get eventPhase() {
          return this._eventPhase;
        }
        get currentTarget() {
          return this._currentTarget;
        }
      }
      const uh = Symbol("bubbling contexts");
      function hh(t) {
        class e extends t {
          fire(t, ...e) {
            try {
              const n = t instanceof y ? t : new y(this, t);
              const i = ph(this);
              if (!i.size) {
                return;
              }
              mh(n, "capturing", this);
              if (gh(i, "$capture", n, ...e)) {
                return n.return;
              }
              const o = n.startRange || this.selection.getFirstRange();
              const r = o ? o.getContainedElement() : null;
              const s = r ? Boolean(fh(i, r)) : false;
              let a = r || bh(o);
              mh(n, "atTarget", a);
              if (!s) {
                if (gh(i, "$text", n, ...e)) {
                  return n.return;
                }
                mh(n, "bubbling", a);
              }
              while (a) {
                if (a.is("rootElement")) {
                  if (gh(i, "$root", n, ...e)) {
                    return n.return;
                  }
                } else if (a.is("element")) {
                  if (gh(i, a.name, n, ...e)) {
                    return n.return;
                  }
                }
                if (gh(i, a, n, ...e)) {
                  return n.return;
                }
                a = a.parent;
                mh(n, "bubbling", a);
              }
              mh(n, "bubbling", this);
              gh(i, "$document", n, ...e);
              return n.return;
            } catch (t) {
              M.rethrowUnexpectedError(t, this);
            }
          }
          _addEventListener(t, e, n) {
            const i = Yc(n.context || "$document");
            const o = ph(this);
            for (const r of i) {
              let i = o.get(r);
              if (!i) {
                i = new (q())();
                o.set(r, i);
              }
              this.listenTo(i, t, e, n);
            }
          }
          _removeEventListener(t, e) {
            const n = ph(this);
            for (const i of n.values()) {
              this.stopListening(i, t, e);
            }
          }
        }
        return e;
      }
      {
        const t = hh(Object);
        ["fire", "_addEventListener", "_removeEventListener"].forEach((e) => {
          hh[e] = t.prototype[e];
        });
      }
      function mh(t, e, n) {
        if (t instanceof dh) {
          t._eventPhase = e;
          t._currentTarget = n;
        }
      }
      function gh(t, e, n, ...i) {
        const o = typeof e == "string" ? t.get(e) : fh(t, e);
        if (!o) {
          return false;
        }
        o.fire(n, ...i);
        return n.stop.called;
      }
      function fh(t, e) {
        for (const [n, i] of t) {
          if (typeof n == "function" && n(e)) {
            return i;
          }
        }
        return null;
      }
      function ph(t) {
        if (!t[uh]) {
          t[uh] = new Map();
        }
        return t[uh];
      }
      function bh(t) {
        if (!t) {
          return null;
        }
        const e = t.start.parent;
        const n = t.end.parent;
        const i = e.getPath();
        const o = n.getPath();
        return i.length > o.length ? e : n;
      }
      class kh extends hh(dt()) {
        constructor(t) {
          super();
          this.selection = new lh();
          this.roots = new rl({ idProperty: "rootName" });
          this.stylesProcessor = t;
          this.set("isReadOnly", false);
          this.set("isFocused", false);
          this.set("_isFocusChanging", false);
          this.set("isSelecting", false);
          this.set("isComposing", false);
          this._postFixers = new Set();
        }
        getRoot(t = "main") {
          return this.roots.get(t);
        }
        registerPostFixer(t) {
          this._postFixers.add(t);
        }
        destroy() {
          this.roots.map((t) => t.destroy());
          this.stopListening();
        }
        _callPostFixers(t) {
          let e = false;
          do {
            for (const n of this._postFixers) {
              e = n(t);
              if (e) {
                break;
              }
            }
          } while (e);
        }
      }
      const wh = 10;
      class Ah extends Yu {
        constructor(...t) {
          super(...t);
          this.getFillerOffset = Ch;
          this._priority = wh;
          this._id = null;
          this._clonesGroup = null;
        }
        get priority() {
          return this._priority;
        }
        get id() {
          return this._id;
        }
        getElementsWithSameId() {
          if (this.id === null) {
            throw new M(
              "attribute-element-get-elements-with-same-id-no-id",
              this
            );
          }
          return new Set(this._clonesGroup);
        }
        isSimilar(t) {
          if (this.id !== null || t.id !== null) {
            return this.id === t.id;
          }
          return super.isSimilar(t) && this.priority == t.priority;
        }
        _clone(t = false) {
          const e = super._clone(t);
          e._priority = this._priority;
          e._id = this._id;
          return e;
        }
      }
      Ah.DEFAULT_PRIORITY = wh;
      Ah.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "attributeElement" ||
            t === "view:attributeElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          );
        } else {
          return (
            e === this.name &&
            (t === "attributeElement" ||
              t === "view:attributeElement" ||
              t === "element" ||
              t === "view:element")
          );
        }
      };
      function Ch() {
        if (_h(this)) {
          return null;
        }
        let t = this.parent;
        while (t && t.is("attributeElement")) {
          if (_h(t) > 1) {
            return null;
          }
          t = t.parent;
        }
        if (!t || _h(t) > 1) {
          return null;
        }
        return this.childCount;
      }
      function _h(t) {
        return Array.from(t.getChildren()).filter((t) => !t.is("uiElement"))
          .length;
      }
      class vh extends Yu {
        constructor(t, e, n, i) {
          super(t, e, n, i);
          this.getFillerOffset = yh;
        }
        _insertChild(t, e) {
          if (e && (e instanceof Kl || Array.from(e).length > 0)) {
            throw new M("view-emptyelement-cannot-add", [this, e]);
          }
          return 0;
        }
      }
      vh.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "emptyElement" ||
            t === "view:emptyElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          );
        } else {
          return (
            e === this.name &&
            (t === "emptyElement" ||
              t === "view:emptyElement" ||
              t === "element" ||
              t === "view:element")
          );
        }
      };
      function yh() {
        return null;
      }
      class xh extends Yu {
        constructor(...t) {
          super(...t);
          this.getFillerOffset = Dh;
        }
        _insertChild(t, e) {
          if (e && (e instanceof Kl || Array.from(e).length > 0)) {
            throw new M("view-uielement-cannot-add", [this, e]);
          }
          return 0;
        }
        render(t, e) {
          return this.toDomElement(t);
        }
        toDomElement(t) {
          const e = t.createElement(this.name);
          for (const t of this.getAttributeKeys()) {
            e.setAttribute(t, this.getAttribute(t));
          }
          return e;
        }
      }
      xh.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "uiElement" ||
            t === "view:uiElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          );
        } else {
          return (
            e === this.name &&
            (t === "uiElement" ||
              t === "view:uiElement" ||
              t === "element" ||
              t === "view:element")
          );
        }
      };
      function Eh(t) {
        t.document.on("arrowKey", (e, n) => Sh(e, n, t.domConverter), {
          priority: "low",
        });
      }
      function Dh() {
        return null;
      }
      function Sh(t, e, n) {
        if (e.keyCode == Oc.arrowright) {
          const t = e.domTarget.ownerDocument.defaultView.getSelection();
          const i = t.rangeCount == 1 && t.getRangeAt(0).collapsed;
          if (i || e.shiftKey) {
            const e = t.focusNode;
            const o = t.focusOffset;
            const r = n.domPositionToView(e, o);
            if (r === null) {
              return;
            }
            let s = false;
            const a = r.getLastMatchingPosition((t) => {
              if (t.item.is("uiElement")) {
                s = true;
              }
              if (t.item.is("uiElement") || t.item.is("attributeElement")) {
                return true;
              }
              return false;
            });
            if (s) {
              const e = n.viewPositionToDom(a);
              if (i) {
                t.collapse(e.parent, e.offset);
              } else {
                t.extend(e.parent, e.offset);
              }
            }
          }
        }
      }
      class Th extends Yu {
        constructor(...t) {
          super(...t);
          this.getFillerOffset = Ih;
        }
        _insertChild(t, e) {
          if (e && (e instanceof Kl || Array.from(e).length > 0)) {
            throw new M("view-rawelement-cannot-add", [this, e]);
          }
          return 0;
        }
        render() {}
      }
      Th.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "rawElement" ||
            t === "view:rawElement" ||
            t === this.name ||
            t === "view:" + this.name ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          );
        } else {
          return (
            e === this.name &&
            (t === "rawElement" ||
              t === "view:rawElement" ||
              t === "element" ||
              t === "view:element")
          );
        }
      };
      function Ih() {
        return null;
      }
      class Mh extends q(ql) {
        constructor(t, e) {
          super();
          this.document = t;
          this._children = [];
          if (e) {
            this._insertChild(0, e);
          }
        }
        [Symbol.iterator]() {
          return this._children[Symbol.iterator]();
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        _appendChild(t) {
          return this._insertChild(this.childCount, t);
        }
        getChild(t) {
          return this._children[t];
        }
        getChildIndex(t) {
          return this._children.indexOf(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        _insertChild(t, e) {
          this._fireChange("children", this);
          let n = 0;
          const i = Bh(this.document, e);
          for (const e of i) {
            if (e.parent !== null) {
              e._remove();
            }
            e.parent = this;
            this._children.splice(t, 0, e);
            t++;
            n++;
          }
          return n;
        }
        _removeChildren(t, e = 1) {
          this._fireChange("children", this);
          for (let n = t; n < t + e; n++) {
            this._children[n].parent = null;
          }
          return this._children.splice(t, e);
        }
        _fireChange(t, e) {
          this.fire("change:" + t, e);
        }
      }
      Mh.prototype.is = function (t) {
        return t === "documentFragment" || t === "view:documentFragment";
      };
      function Bh(t, e) {
        if (typeof e == "string") {
          return [new Yl(t, e)];
        }
        if (!yt(e)) {
          e = [e];
        }
        return Array.from(e).map((e) => {
          if (typeof e == "string") {
            return new Yl(t, e);
          }
          if (e instanceof Zl) {
            return new Yl(t, e.data);
          }
          return e;
        });
      }
      class Lh {
        constructor(t) {
          this.document = t;
          this._cloneGroups = new Map();
          this._slotFactory = null;
        }
        setSelection(...t) {
          this.document.selection._setTo(...t);
        }
        setSelectionFocus(...t) {
          this.document.selection._setFocus(...t);
        }
        createDocumentFragment(t) {
          return new Mh(this.document, t);
        }
        createText(t) {
          return new Yl(this.document, t);
        }
        createAttributeElement(t, e, n = {}) {
          const i = new Ah(this.document, t, e);
          if (typeof n.priority === "number") {
            i._priority = n.priority;
          }
          if (n.id) {
            i._id = n.id;
          }
          if (n.renderUnsafeAttributes) {
            i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes);
          }
          return i;
        }
        createContainerElement(t, e, n = {}, i = {}) {
          let o = null;
          if (he(n)) {
            i = n;
          } else {
            o = n;
          }
          const r = new Xu(this.document, t, e, o);
          if (i.renderUnsafeAttributes) {
            r._unsafeAttributesToRender.push(...i.renderUnsafeAttributes);
          }
          return r;
        }
        createEditableElement(t, e, n = {}) {
          const i = new eh(this.document, t, e);
          if (n.renderUnsafeAttributes) {
            i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes);
          }
          return i;
        }
        createEmptyElement(t, e, n = {}) {
          const i = new vh(this.document, t, e);
          if (n.renderUnsafeAttributes) {
            i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes);
          }
          return i;
        }
        createUIElement(t, e, n) {
          const i = new xh(this.document, t, e);
          if (n) {
            i.render = n;
          }
          return i;
        }
        createRawElement(t, e, n, i = {}) {
          const o = new Th(this.document, t, e);
          if (n) {
            o.render = n;
          }
          if (i.renderUnsafeAttributes) {
            o._unsafeAttributesToRender.push(...i.renderUnsafeAttributes);
          }
          return o;
        }
        setAttribute(t, e, n) {
          n._setAttribute(t, e);
        }
        removeAttribute(t, e) {
          e._removeAttribute(t);
        }
        addClass(t, e) {
          e._addClass(t);
        }
        removeClass(t, e) {
          e._removeClass(t);
        }
        setStyle(t, e, n) {
          if (he(t) && n === undefined) {
            e._setStyle(t);
          } else {
            n._setStyle(t, e);
          }
        }
        removeStyle(t, e) {
          e._removeStyle(t);
        }
        setCustomProperty(t, e, n) {
          n._setCustomProperty(t, e);
        }
        removeCustomProperty(t, e) {
          return e._removeCustomProperty(t);
        }
        breakAttributes(t) {
          if (t instanceof rh) {
            return this._breakAttributes(t);
          } else {
            return this._breakAttributesRange(t);
          }
        }
        breakContainer(t) {
          const e = t.parent;
          if (!e.is("containerElement")) {
            throw new M(
              "view-writer-break-non-container-element",
              this.document
            );
          }
          if (!e.parent) {
            throw new M("view-writer-break-root", this.document);
          }
          if (t.isAtStart) {
            return rh._createBefore(e);
          } else if (!t.isAtEnd) {
            const n = e._clone(false);
            this.insert(rh._createAfter(e), n);
            const i = new sh(t, rh._createAt(e, "end"));
            const o = new rh(n, 0);
            this.move(i, o);
          }
          return rh._createAfter(e);
        }
        mergeAttributes(t) {
          const e = t.offset;
          const n = t.parent;
          if (n.is("$text")) {
            return t;
          }
          if (n.is("attributeElement") && n.childCount === 0) {
            const t = n.parent;
            const e = n.index;
            n._remove();
            this._removeFromClonedElementsGroup(n);
            return this.mergeAttributes(new rh(t, e));
          }
          const i = n.getChild(e - 1);
          const o = n.getChild(e);
          if (!i || !o) {
            return t;
          }
          if (i.is("$text") && o.is("$text")) {
            return jh(i, o);
          } else if (
            i.is("attributeElement") &&
            o.is("attributeElement") &&
            i.isSimilar(o)
          ) {
            const t = i.childCount;
            i._appendChild(o.getChildren());
            o._remove();
            this._removeFromClonedElementsGroup(o);
            return this.mergeAttributes(new rh(i, t));
          }
          return t;
        }
        mergeContainers(t) {
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          if (
            !e ||
            !n ||
            !e.is("containerElement") ||
            !n.is("containerElement")
          ) {
            throw new M(
              "view-writer-merge-containers-invalid-position",
              this.document
            );
          }
          const i = e.getChild(e.childCount - 1);
          const o =
            i instanceof Yl ? rh._createAt(i, "end") : rh._createAt(e, "end");
          this.move(sh._createIn(n), rh._createAt(e, "end"));
          this.remove(sh._createOn(n));
          return o;
        }
        insert(t, e) {
          e = yt(e) ? [...e] : [e];
          Vh(e, this.document);
          const n = e.reduce((t, e) => {
            const n = t[t.length - 1];
            const i = !e.is("uiElement");
            if (!n || n.breakAttributes != i) {
              t.push({ breakAttributes: i, nodes: [e] });
            } else {
              n.nodes.push(e);
            }
            return t;
          }, []);
          let i = null;
          let o = t;
          for (const { nodes: t, breakAttributes: e } of n) {
            const n = this._insertNodes(o, t, e);
            if (!i) {
              i = n.start;
            }
            o = n.end;
          }
          if (!i) {
            return new sh(t);
          }
          return new sh(i, o);
        }
        remove(t) {
          const e = t instanceof sh ? t : sh._createOn(t);
          Uh(e, this.document);
          if (e.isCollapsed) {
            return new Mh(this.document);
          }
          const { start: n, end: i } = this._breakAttributesRange(e, true);
          const o = n.parent;
          const r = i.offset - n.offset;
          const s = o._removeChildren(n.offset, r);
          for (const t of s) {
            this._removeFromClonedElementsGroup(t);
          }
          const a = this.mergeAttributes(n);
          e.start = a;
          e.end = a.clone();
          return new Mh(this.document, s);
        }
        clear(t, e) {
          Uh(t, this.document);
          const n = t.getWalker({
            direction: "backward",
            ignoreElementEnd: true,
          });
          for (const i of n) {
            const n = i.item;
            let o;
            if (n.is("element") && e.isSimilar(n)) {
              o = sh._createOn(n);
            } else if (!i.nextPosition.isAfter(t.start) && n.is("$textProxy")) {
              const t = n
                .getAncestors()
                .find((t) => t.is("element") && e.isSimilar(t));
              if (t) {
                o = sh._createIn(t);
              }
            }
            if (o) {
              if (o.end.isAfter(t.end)) {
                o.end = t.end;
              }
              if (o.start.isBefore(t.start)) {
                o.start = t.start;
              }
              this.remove(o);
            }
          }
        }
        move(t, e) {
          let n;
          if (e.isAfter(t.end)) {
            e = this._breakAttributes(e, true);
            const i = e.parent;
            const o = i.childCount;
            t = this._breakAttributesRange(t, true);
            n = this.remove(t);
            e.offset += i.childCount - o;
          } else {
            n = this.remove(t);
          }
          return this.insert(e, n);
        }
        wrap(t, e) {
          if (!(e instanceof Ah)) {
            throw new M("view-writer-wrap-invalid-attribute", this.document);
          }
          Uh(t, this.document);
          if (!t.isCollapsed) {
            return this._wrapRange(t, e);
          } else {
            let n = t.start;
            if (n.parent.is("element") && !Nh(n.parent)) {
              n = n.getLastMatchingPosition((t) => t.item.is("uiElement"));
            }
            n = this._wrapPosition(n, e);
            const i = this.document.selection;
            if (i.isCollapsed && i.getFirstPosition().isEqual(t.start)) {
              this.setSelection(n);
            }
            return new sh(n);
          }
        }
        unwrap(t, e) {
          if (!(e instanceof Ah)) {
            throw new M("view-writer-unwrap-invalid-attribute", this.document);
          }
          Uh(t, this.document);
          if (t.isCollapsed) {
            return t;
          }
          const { start: n, end: i } = this._breakAttributesRange(t, true);
          const o = n.parent;
          const r = this._unwrapChildren(o, n.offset, i.offset, e);
          const s = this.mergeAttributes(r.start);
          if (!s.isEqual(r.start)) {
            r.end.offset--;
          }
          const a = this.mergeAttributes(r.end);
          return new sh(s, a);
        }
        rename(t, e) {
          const n = new Xu(this.document, t, e.getAttributes());
          this.insert(rh._createAfter(e), n);
          this.move(sh._createIn(e), rh._createAt(n, 0));
          this.remove(sh._createOn(e));
          return n;
        }
        clearClonedElementsGroup(t) {
          this._cloneGroups.delete(t);
        }
        createPositionAt(t, e) {
          return rh._createAt(t, e);
        }
        createPositionAfter(t) {
          return rh._createAfter(t);
        }
        createPositionBefore(t) {
          return rh._createBefore(t);
        }
        createRange(...t) {
          return new sh(...t);
        }
        createRangeOn(t) {
          return sh._createOn(t);
        }
        createRangeIn(t) {
          return sh._createIn(t);
        }
        createSelection(...t) {
          return new ch(...t);
        }
        createSlot(t) {
          if (!this._slotFactory) {
            throw new M(
              "view-writer-invalid-create-slot-context",
              this.document
            );
          }
          return this._slotFactory(this, t);
        }
        _registerSlotFactory(t) {
          this._slotFactory = t;
        }
        _clearSlotFactory() {
          this._slotFactory = null;
        }
        _insertNodes(t, e, n) {
          let i;
          if (n) {
            i = zh(t);
          } else {
            i = t.parent.is("$text") ? t.parent.parent : t.parent;
          }
          if (!i) {
            throw new M(
              "view-writer-invalid-position-container",
              this.document
            );
          }
          let o;
          if (n) {
            o = this._breakAttributes(t, true);
          } else {
            o = t.parent.is("$text") ? Oh(t) : t;
          }
          const r = i._insertChild(o.offset, e);
          for (const t of e) {
            this._addToClonedElementsGroup(t);
          }
          const s = o.getShiftedBy(r);
          const a = this.mergeAttributes(o);
          if (!a.isEqual(o)) {
            s.offset--;
          }
          const c = this.mergeAttributes(s);
          return new sh(a, c);
        }
        _wrapChildren(t, e, n, i) {
          let o = e;
          const r = [];
          while (o < n) {
            const e = t.getChild(o);
            const n = e.is("$text");
            const s = e.is("attributeElement");
            if (s && this._wrapAttributeElement(i, e)) {
              r.push(new rh(t, o));
            } else if (n || !s || Ph(i, e)) {
              const n = i._clone();
              e._remove();
              n._appendChild(e);
              t._insertChild(o, n);
              this._addToClonedElementsGroup(n);
              r.push(new rh(t, o));
            } else {
              this._wrapChildren(e, 0, e.childCount, i);
            }
            o++;
          }
          let s = 0;
          for (const t of r) {
            t.offset -= s;
            if (t.offset == e) {
              continue;
            }
            const i = this.mergeAttributes(t);
            if (!i.isEqual(t)) {
              s++;
              n--;
            }
          }
          return sh._createFromParentsAndOffsets(t, e, t, n);
        }
        _unwrapChildren(t, e, n, i) {
          let o = e;
          const r = [];
          while (o < n) {
            const e = t.getChild(o);
            if (!e.is("attributeElement")) {
              o++;
              continue;
            }
            if (e.isSimilar(i)) {
              const i = e.getChildren();
              const s = e.childCount;
              e._remove();
              t._insertChild(o, i);
              this._removeFromClonedElementsGroup(e);
              r.push(new rh(t, o), new rh(t, o + s));
              o += s;
              n += s - 1;
              continue;
            }
            if (this._unwrapAttributeElement(i, e)) {
              r.push(new rh(t, o), new rh(t, o + 1));
              o++;
              continue;
            }
            this._unwrapChildren(e, 0, e.childCount, i);
            o++;
          }
          let s = 0;
          for (const t of r) {
            t.offset -= s;
            if (t.offset == e || t.offset == n) {
              continue;
            }
            const i = this.mergeAttributes(t);
            if (!i.isEqual(t)) {
              s++;
              n--;
            }
          }
          return sh._createFromParentsAndOffsets(t, e, t, n);
        }
        _wrapRange(t, e) {
          const { start: n, end: i } = this._breakAttributesRange(t, true);
          const o = n.parent;
          const r = this._wrapChildren(o, n.offset, i.offset, e);
          const s = this.mergeAttributes(r.start);
          if (!s.isEqual(r.start)) {
            r.end.offset--;
          }
          const a = this.mergeAttributes(r.end);
          return new sh(s, a);
        }
        _wrapPosition(t, e) {
          if (e.isSimilar(t.parent)) {
            return Rh(t.clone());
          }
          if (t.parent.is("$text")) {
            t = Oh(t);
          }
          const n = this.createAttributeElement("_wrapPosition-fake-element");
          n._priority = Number.POSITIVE_INFINITY;
          n.isSimilar = () => false;
          t.parent._insertChild(t.offset, n);
          const i = new sh(t, t.getShiftedBy(1));
          this.wrap(i, e);
          const o = new rh(n.parent, n.index);
          n._remove();
          const r = o.nodeBefore;
          const s = o.nodeAfter;
          if (r instanceof Yl && s instanceof Yl) {
            return jh(r, s);
          }
          return Rh(o);
        }
        _wrapAttributeElement(t, e) {
          if (!qh(t, e)) {
            return false;
          }
          if (t.name !== e.name || t.priority !== e.priority) {
            return false;
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue;
            }
            if (e.hasAttribute(n) && e.getAttribute(n) !== t.getAttribute(n)) {
              return false;
            }
          }
          for (const n of t.getStyleNames()) {
            if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) {
              return false;
            }
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue;
            }
            if (!e.hasAttribute(n)) {
              this.setAttribute(n, t.getAttribute(n), e);
            }
          }
          for (const n of t.getStyleNames()) {
            if (!e.hasStyle(n)) {
              this.setStyle(n, t.getStyle(n), e);
            }
          }
          for (const n of t.getClassNames()) {
            if (!e.hasClass(n)) {
              this.addClass(n, e);
            }
          }
          return true;
        }
        _unwrapAttributeElement(t, e) {
          if (!qh(t, e)) {
            return false;
          }
          if (t.name !== e.name || t.priority !== e.priority) {
            return false;
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue;
            }
            if (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n)) {
              return false;
            }
          }
          if (!e.hasClass(...t.getClassNames())) {
            return false;
          }
          for (const n of t.getStyleNames()) {
            if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) {
              return false;
            }
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue;
            }
            this.removeAttribute(n, e);
          }
          this.removeClass(Array.from(t.getClassNames()), e);
          this.removeStyle(Array.from(t.getStyleNames()), e);
          return true;
        }
        _breakAttributesRange(t, e = false) {
          const n = t.start;
          const i = t.end;
          Uh(t, this.document);
          if (t.isCollapsed) {
            const n = this._breakAttributes(t.start, e);
            return new sh(n, n);
          }
          const o = this._breakAttributes(i, e);
          const r = o.parent.childCount;
          const s = this._breakAttributes(n, e);
          o.offset += o.parent.childCount - r;
          return new sh(s, o);
        }
        _breakAttributes(t, e = false) {
          const n = t.offset;
          const i = t.parent;
          if (t.parent.is("emptyElement")) {
            throw new M(
              "view-writer-cannot-break-empty-element",
              this.document
            );
          }
          if (t.parent.is("uiElement")) {
            throw new M("view-writer-cannot-break-ui-element", this.document);
          }
          if (t.parent.is("rawElement")) {
            throw new M("view-writer-cannot-break-raw-element", this.document);
          }
          if (!e && i.is("$text") && Hh(i.parent)) {
            return t.clone();
          }
          if (Hh(i)) {
            return t.clone();
          }
          if (i.is("$text")) {
            return this._breakAttributes(Oh(t), e);
          }
          const o = i.childCount;
          if (n == o) {
            const t = new rh(i.parent, i.index + 1);
            return this._breakAttributes(t, e);
          } else {
            if (n === 0) {
              const t = new rh(i.parent, i.index);
              return this._breakAttributes(t, e);
            } else {
              const t = i.index + 1;
              const o = i._clone();
              i.parent._insertChild(t, o);
              this._addToClonedElementsGroup(o);
              const r = i.childCount - n;
              const s = i._removeChildren(n, r);
              o._appendChild(s);
              const a = new rh(i.parent, t);
              return this._breakAttributes(a, e);
            }
          }
        }
        _addToClonedElementsGroup(t) {
          if (!t.root.is("rootElement")) {
            return;
          }
          if (t.is("element")) {
            for (const e of t.getChildren()) {
              this._addToClonedElementsGroup(e);
            }
          }
          const e = t.id;
          if (!e) {
            return;
          }
          let n = this._cloneGroups.get(e);
          if (!n) {
            n = new Set();
            this._cloneGroups.set(e, n);
          }
          n.add(t);
          t._clonesGroup = n;
        }
        _removeFromClonedElementsGroup(t) {
          if (t.is("element")) {
            for (const e of t.getChildren()) {
              this._removeFromClonedElementsGroup(e);
            }
          }
          const e = t.id;
          if (!e) {
            return;
          }
          const n = this._cloneGroups.get(e);
          if (!n) {
            return;
          }
          n.delete(t);
        }
      }
      function Nh(t) {
        return Array.from(t.getChildren()).some((t) => !t.is("uiElement"));
      }
      function zh(t) {
        let e = t.parent;
        while (!Hh(e)) {
          if (!e) {
            return undefined;
          }
          e = e.parent;
        }
        return e;
      }
      function Ph(t, e) {
        if (t.priority < e.priority) {
          return true;
        } else if (t.priority > e.priority) {
          return false;
        }
        return t.getIdentity() < e.getIdentity();
      }
      function Rh(t) {
        const e = t.nodeBefore;
        if (e && e.is("$text")) {
          return new rh(e, e.data.length);
        }
        const n = t.nodeAfter;
        if (n && n.is("$text")) {
          return new rh(n, 0);
        }
        return t;
      }
      function Oh(t) {
        if (t.offset == t.parent.data.length) {
          return new rh(t.parent.parent, t.parent.index + 1);
        }
        if (t.offset === 0) {
          return new rh(t.parent.parent, t.parent.index);
        }
        const e = t.parent.data.slice(t.offset);
        t.parent._data = t.parent.data.slice(0, t.offset);
        t.parent.parent._insertChild(
          t.parent.index + 1,
          new Yl(t.root.document, e)
        );
        return new rh(t.parent.parent, t.parent.index + 1);
      }
      function jh(t, e) {
        const n = t.data.length;
        t._data += e.data;
        e._remove();
        return new rh(t, n);
      }
      const Fh = [Yl, Ah, Xu, vh, Th, xh];
      function Vh(t, e) {
        for (const n of t) {
          if (!Fh.some((t) => n instanceof t)) {
            throw new M("view-writer-insert-invalid-node-type", e);
          }
          if (!n.is("$text")) {
            Vh(n.getChildren(), e);
          }
        }
      }
      function Hh(t) {
        return t && (t.is("containerElement") || t.is("documentFragment"));
      }
      function Uh(t, e) {
        const n = zh(t.start);
        const i = zh(t.end);
        if (!n || !i || n !== i) {
          throw new M("view-writer-invalid-range-container", e);
        }
      }
      function qh(t, e) {
        return t.id === null && e.id === null;
      }
      const Wh = (t) => t.createTextNode("");
      const Gh = (t) => {
        const e = t.createElement("span");
        e.dataset.ckeFiller = "true";
        e.innerText = "";
        return e;
      };
      const $h = (t) => {
        const e = t.createElement("br");
        e.dataset.ckeFiller = "true";
        return e;
      };
      const Kh = 7;
      const Yh = "".repeat(Kh);
      function Zh(t) {
        return nc(t) && t.data.substr(0, Kh) === Yh;
      }
      function Qh(t) {
        return t.data.length == Kh && Zh(t);
      }
      function Jh(t) {
        if (Zh(t)) {
          return t.data.slice(Kh);
        } else {
          return t.data;
        }
      }
      function Xh(t) {
        t.document.on("arrowKey", tm, { priority: "low" });
      }
      function tm(t, e) {
        if (e.keyCode == Oc.arrowleft) {
          const t = e.domTarget.ownerDocument.defaultView.getSelection();
          if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
            const e = t.getRangeAt(0).startContainer;
            const n = t.getRangeAt(0).startOffset;
            if (Zh(e) && n <= Kh) {
              t.collapse(e, 0);
            }
          }
        }
      }
      var em = n(4401);
      var nm = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      nm.insert = "head";
      nm.singleton = true;
      var im = Il()(em.Z, nm);
      const om = em.Z.locals || {};
      class rm extends dt() {
        constructor(t, e) {
          super();
          this.domDocuments = new Set();
          this.domConverter = t;
          this.markedAttributes = new Set();
          this.markedChildren = new Set();
          this.markedTexts = new Set();
          this.selection = e;
          this.set("isFocused", false);
          this.set("_isFocusChanging", false);
          this.set("isSelecting", false);
          if (r.isBlink && !r.isAndroid) {
            this.on("change:isSelecting", () => {
              if (!this.isSelecting) {
                this.render();
              }
            });
          }
          this.set("isComposing", false);
          this.on("change:isComposing", () => {
            if (!this.isComposing) {
              this.render();
            }
          });
          this._inlineFiller = null;
          this._fakeSelectionContainer = null;
        }
        markToSync(t, e) {
          if (t === "text") {
            if (this.domConverter.mapViewToDom(e.parent)) {
              this.markedTexts.add(e);
            }
          } else {
            if (!this.domConverter.mapViewToDom(e)) {
              return;
            }
            if (t === "attributes") {
              this.markedAttributes.add(e);
            } else if (t === "children") {
              this.markedChildren.add(e);
            } else {
              throw new M("view-renderer-unknown-type", this);
            }
          }
        }
        render() {
          if (this.isComposing && !r.isAndroid) {
            return;
          }
          let t = null;
          const e = r.isBlink && !r.isAndroid ? !this.isSelecting : true;
          for (const t of this.markedChildren) {
            this._updateChildrenMappings(t);
          }
          if (e) {
            if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
              this._removeInlineFiller();
            }
            if (this._inlineFiller) {
              t = this._getInlineFillerPosition();
            } else if (this._needsInlineFillerAtSelection()) {
              t = this.selection.getFirstPosition();
              this.markedChildren.add(t.parent);
            }
          } else if (this._inlineFiller && this._inlineFiller.parentNode) {
            t = this.domConverter.domPositionToView(this._inlineFiller);
            if (t && t.parent.is("$text")) {
              t = rh._createBefore(t.parent);
            }
          }
          for (const t of this.markedAttributes) {
            this._updateAttrs(t);
          }
          for (const e of this.markedChildren) {
            this._updateChildren(e, { inlineFillerPosition: t });
          }
          for (const e of this.markedTexts) {
            if (
              !this.markedChildren.has(e.parent) &&
              this.domConverter.mapViewToDom(e.parent)
            ) {
              this._updateText(e, { inlineFillerPosition: t });
            }
          }
          if (e) {
            if (t) {
              const e = this.domConverter.viewPositionToDom(t);
              const n = e.parent.ownerDocument;
              if (!Zh(e.parent)) {
                this._inlineFiller = am(n, e.parent, e.offset);
              } else {
                this._inlineFiller = e.parent;
              }
            } else {
              this._inlineFiller = null;
            }
          }
          this._updateFocus();
          this._updateSelection();
          this.markedTexts.clear();
          this.markedAttributes.clear();
          this.markedChildren.clear();
        }
        _updateChildrenMappings(t) {
          const e = this.domConverter.mapViewToDom(t);
          if (!e) {
            return;
          }
          const n = Array.from(this.domConverter.mapViewToDom(t).childNodes);
          const i = Array.from(
            this.domConverter.viewChildrenToDom(t, { withChildren: false })
          );
          const o = this._diffNodeLists(n, i);
          const r = this._findReplaceActions(o, n, i);
          if (r.indexOf("replace") !== -1) {
            const e = { equal: 0, insert: 0, delete: 0 };
            for (const o of r) {
              if (o === "replace") {
                const o = e.equal + e.insert;
                const r = e.equal + e.delete;
                const s = t.getChild(o);
                if (s && !(s.is("uiElement") || s.is("rawElement"))) {
                  this._updateElementMappings(s, n[r]);
                }
                yc(i[o]);
                e.equal++;
              } else {
                e[o]++;
              }
            }
          }
        }
        _updateElementMappings(t, e) {
          this.domConverter.unbindDomElement(e);
          this.domConverter.bindElements(e, t);
          this.markedChildren.add(t);
          this.markedAttributes.add(t);
        }
        _getInlineFillerPosition() {
          const t = this.selection.getFirstPosition();
          if (t.parent.is("$text")) {
            return rh._createBefore(t.parent);
          } else {
            return t;
          }
        }
        _isSelectionInInlineFiller() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
            return false;
          }
          const t = this.selection.getFirstPosition();
          const e = this.domConverter.viewPositionToDom(t);
          if (e && nc(e.parent) && Zh(e.parent)) {
            return true;
          }
          return false;
        }
        _removeInlineFiller() {
          const t = this._inlineFiller;
          if (!Zh(t)) {
            throw new M("view-renderer-filler-was-lost", this);
          }
          if (Qh(t)) {
            t.remove();
          } else {
            t.data = t.data.substr(Kh);
          }
          this._inlineFiller = null;
        }
        _needsInlineFillerAtSelection() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
            return false;
          }
          const t = this.selection.getFirstPosition();
          const e = t.parent;
          const n = t.offset;
          if (!this.domConverter.mapViewToDom(e.root)) {
            return false;
          }
          if (!e.is("element")) {
            return false;
          }
          if (!sm(e)) {
            return false;
          }
          if (n === e.getFillerOffset()) {
            return false;
          }
          const i = t.nodeBefore;
          const o = t.nodeAfter;
          if (i instanceof Yl || o instanceof Yl) {
            return false;
          }
          if (r.isAndroid && (i || o)) {
            return false;
          }
          return true;
        }
        _updateText(t, e) {
          const n = this.domConverter.findCorrespondingDomText(t);
          const i = this.domConverter.viewToDom(t);
          let o = i.data;
          const r = e.inlineFillerPosition;
          if (r && r.parent == t.parent && r.offset == t.index) {
            o = Yh + o;
          }
          gm(n, o);
        }
        _updateAttrs(t) {
          const e = this.domConverter.mapViewToDom(t);
          if (!e) {
            return;
          }
          const n = Array.from(e.attributes).map((t) => t.name);
          const i = t.getAttributeKeys();
          for (const n of i) {
            this.domConverter.setDomElementAttribute(
              e,
              n,
              t.getAttribute(n),
              t
            );
          }
          for (const i of n) {
            if (!t.hasAttribute(i)) {
              this.domConverter.removeDomElementAttribute(e, i);
            }
          }
        }
        _updateChildren(t, e) {
          const n = this.domConverter.mapViewToDom(t);
          if (!n) {
            return;
          }
          if (r.isAndroid) {
            let t = null;
            for (const e of Array.from(n.childNodes)) {
              if (t && nc(t) && nc(e)) {
                n.normalize();
                break;
              }
              t = e;
            }
          }
          const i = e.inlineFillerPosition;
          const o = n.childNodes;
          const s = Array.from(
            this.domConverter.viewChildrenToDom(t, { bind: true })
          );
          if (i && i.parent === t) {
            am(n.ownerDocument, s, i.offset);
          }
          const a = this._diffNodeLists(o, s);
          const c = r.isAndroid
            ? this._findReplaceActions(a, o, s, { replaceText: true })
            : a;
          let l = 0;
          const d = new Set();
          for (const t of c) {
            if (t === "delete") {
              d.add(o[l]);
              yc(o[l]);
            } else if (t === "equal" || t === "replace") {
              l++;
            }
          }
          l = 0;
          for (const t of c) {
            if (t === "insert") {
              gc(n, l, s[l]);
              l++;
            } else if (t === "replace") {
              gm(o[l], s[l].data);
              l++;
            } else if (t === "equal") {
              this._markDescendantTextToSync(this.domConverter.domToView(s[l]));
              l++;
            }
          }
          for (const t of d) {
            if (!t.parentNode) {
              this.domConverter.unbindDomElement(t);
            }
          }
        }
        _diffNodeLists(t, e) {
          t = hm(t, this._fakeSelectionContainer);
          return A(t, e, dm.bind(null, this.domConverter));
        }
        _findReplaceActions(t, e, n, i = {}) {
          if (t.indexOf("insert") === -1 || t.indexOf("delete") === -1) {
            return t;
          }
          let o = [];
          let r = [];
          let s = [];
          const a = { equal: 0, insert: 0, delete: 0 };
          for (const c of t) {
            if (c === "insert") {
              s.push(n[a.equal + a.insert]);
            } else if (c === "delete") {
              r.push(e[a.equal + a.delete]);
            } else {
              o = o.concat(
                A(r, s, i.replaceText ? lm : cm).map((t) =>
                  t === "equal" ? "replace" : t
                )
              );
              o.push("equal");
              r = [];
              s = [];
            }
            a[c]++;
          }
          return o.concat(
            A(r, s, i.replaceText ? lm : cm).map((t) =>
              t === "equal" ? "replace" : t
            )
          );
        }
        _markDescendantTextToSync(t) {
          if (!t) {
            return;
          }
          if (t.is("$text")) {
            this.markedTexts.add(t);
          } else if (t.is("element")) {
            for (const e of t.getChildren()) {
              this._markDescendantTextToSync(e);
            }
          }
        }
        _updateSelection() {
          if (
            r.isBlink &&
            !r.isAndroid &&
            this.isSelecting &&
            !this.markedChildren.size
          ) {
            return;
          }
          if (this._isFocusChanging) {
            return;
          }
          if (this.selection.rangeCount === 0) {
            this._removeDomSelection();
            this._removeFakeSelection();
            return;
          }
          const t = this.domConverter.mapViewToDom(
            this.selection.editableElement
          );
          if (!this.isFocused || !t) {
            return;
          }
          if (this.selection.isFake) {
            this._updateFakeSelection(t);
          } else if (
            this._fakeSelectionContainer &&
            this._fakeSelectionContainer.isConnected
          ) {
            this._removeFakeSelection();
            this._updateDomSelection(t);
          } else if (!(this.isComposing && r.isAndroid)) {
            this._updateDomSelection(t);
          }
        }
        _updateFakeSelection(t) {
          const e = t.ownerDocument;
          if (!this._fakeSelectionContainer) {
            this._fakeSelectionContainer = mm(e);
          }
          const n = this._fakeSelectionContainer;
          this.domConverter.bindFakeSelection(n, this.selection);
          if (!this._fakeSelectionNeedsUpdate(t)) {
            return;
          }
          if (!n.parentElement || n.parentElement != t) {
            t.appendChild(n);
          }
          n.textContent = this.selection.fakeSelectionLabel || "";
          const i = e.getSelection();
          const o = e.createRange();
          i.removeAllRanges();
          o.selectNodeContents(n);
          i.addRange(o);
        }
        _updateDomSelection(t) {
          const e = t.ownerDocument.defaultView.getSelection();
          if (!this._domSelectionNeedsUpdate(e)) {
            return;
          }
          const n = this.domConverter.viewPositionToDom(this.selection.anchor);
          const i = this.domConverter.viewPositionToDom(this.selection.focus);
          e.collapse(n.parent, n.offset);
          e.extend(i.parent, i.offset);
          if (r.isGecko) {
            um(i, e);
          }
        }
        _domSelectionNeedsUpdate(t) {
          if (!this.domConverter.isDomSelectionCorrect(t)) {
            return true;
          }
          const e = t && this.domConverter.domSelectionToView(t);
          if (e && this.selection.isEqual(e)) {
            return false;
          }
          if (!this.selection.isCollapsed && this.selection.isSimilar(e)) {
            return false;
          }
          return true;
        }
        _fakeSelectionNeedsUpdate(t) {
          const e = this._fakeSelectionContainer;
          const n = t.ownerDocument.getSelection();
          if (!e || e.parentElement !== t) {
            return true;
          }
          if (n.anchorNode !== e && !e.contains(n.anchorNode)) {
            return true;
          }
          return e.textContent !== this.selection.fakeSelectionLabel;
        }
        _removeDomSelection() {
          for (const t of this.domDocuments) {
            const e = t.getSelection();
            if (e.rangeCount) {
              const n = t.activeElement;
              const i = this.domConverter.mapDomToView(n);
              if (n && i) {
                e.removeAllRanges();
              }
            }
          }
        }
        _removeFakeSelection() {
          const t = this._fakeSelectionContainer;
          if (t) {
            t.remove();
          }
        }
        _updateFocus() {
          if (this.isFocused) {
            const t = this.selection.editableElement;
            if (t) {
              this.domConverter.focus(t);
            }
          }
        }
      }
      function sm(t) {
        if (t.getAttribute("contenteditable") == "false") {
          return false;
        }
        const e = t.findAncestor((t) => t.hasAttribute("contenteditable"));
        return !e || e.getAttribute("contenteditable") == "true";
      }
      function am(t, e, n) {
        const i = e instanceof Array ? e : e.childNodes;
        const o = i[n];
        if (nc(o)) {
          o.data = Yh + o.data;
          return o;
        } else {
          const o = t.createTextNode(Yh);
          if (Array.isArray(e)) {
            i.splice(n, 0, o);
          } else {
            gc(e, n, o);
          }
          return o;
        }
      }
      function cm(t, e) {
        return (
          Wa(t) &&
          Wa(e) &&
          !nc(t) &&
          !nc(e) &&
          !fc(t) &&
          !fc(e) &&
          t.tagName.toLowerCase() === e.tagName.toLowerCase()
        );
      }
      function lm(t, e) {
        return Wa(t) && Wa(e) && nc(t) && nc(e);
      }
      function dm(t, e, n) {
        if (e === n) {
          return true;
        } else if (nc(e) && nc(n)) {
          return e.data === n.data;
        } else if (t.isBlockFiller(e) && t.isBlockFiller(n)) {
          return true;
        }
        return false;
      }
      function um(t, e) {
        const n = t.parent;
        if (
          n.nodeType != Node.ELEMENT_NODE ||
          t.offset != n.childNodes.length - 1
        ) {
          return;
        }
        const i = n.childNodes[t.offset];
        if (i && i.tagName == "BR") {
          e.addRange(e.getRangeAt(0));
        }
      }
      function hm(t, e) {
        const n = Array.from(t);
        if (n.length == 0 || !e) {
          return n;
        }
        const i = n[n.length - 1];
        if (i == e) {
          n.pop();
        }
        return n;
      }
      function mm(t) {
        const e = t.createElement("div");
        e.className = "ck-fake-selection-container";
        Object.assign(e.style, {
          position: "fixed",
          top: 0,
          left: "-9999px",
          width: "42px",
        });
        e.textContent = "";
        return e;
      }
      function gm(t, e) {
        const n = t.data;
        if (n == e) {
          return;
        }
        const i = g(n, e);
        for (const e of i) {
          if (e.type === "insert") {
            t.insertData(e.index, e.values.join(""));
          } else {
            t.deleteData(e.index, e.howMany);
          }
        }
      }
      const fm = $h(Xa.document);
      const pm = Wh(Xa.document);
      const bm = Gh(Xa.document);
      const km = "data-ck-unsafe-attribute-";
      const wm = "data-ck-unsafe-element";
      class Am {
        constructor(t, e = {}) {
          this.document = t;
          this.renderingMode = e.renderingMode || "editing";
          this.blockFillerMode =
            e.blockFillerMode ||
            (this.renderingMode === "editing" ? "br" : "nbsp");
          this.preElements = ["pre"];
          this.blockElements = [
            "address",
            "article",
            "aside",
            "blockquote",
            "caption",
            "center",
            "dd",
            "details",
            "dir",
            "div",
            "dl",
            "dt",
            "fieldset",
            "figcaption",
            "figure",
            "footer",
            "form",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "header",
            "hgroup",
            "legend",
            "li",
            "main",
            "menu",
            "nav",
            "ol",
            "p",
            "pre",
            "section",
            "summary",
            "table",
            "tbody",
            "td",
            "tfoot",
            "th",
            "thead",
            "tr",
            "ul",
          ];
          this.inlineObjectElements = [
            "object",
            "iframe",
            "input",
            "button",
            "textarea",
            "select",
            "option",
            "video",
            "embed",
            "audio",
            "img",
            "canvas",
          ];
          this.unsafeElements = ["script", "style"];
          this._domDocument =
            this.renderingMode === "editing"
              ? Xa.document
              : Xa.document.implementation.createHTMLDocument("");
          this._domToViewMapping = new WeakMap();
          this._viewToDomMapping = new WeakMap();
          this._fakeSelectionMapping = new WeakMap();
          this._rawContentElementMatcher = new Ql();
          this._encounteredRawContentDomNodes = new WeakSet();
        }
        bindFakeSelection(t, e) {
          this._fakeSelectionMapping.set(t, new ch(e));
        }
        fakeSelectionToView(t) {
          return this._fakeSelectionMapping.get(t);
        }
        bindElements(t, e) {
          this._domToViewMapping.set(t, e);
          this._viewToDomMapping.set(e, t);
        }
        unbindDomElement(t) {
          const e = this._domToViewMapping.get(t);
          if (e) {
            this._domToViewMapping.delete(t);
            this._viewToDomMapping.delete(e);
            for (const e of Array.from(t.children)) {
              this.unbindDomElement(e);
            }
          }
        }
        bindDocumentFragments(t, e) {
          this._domToViewMapping.set(t, e);
          this._viewToDomMapping.set(e, t);
        }
        shouldRenderAttribute(t, e, n) {
          if (this.renderingMode === "data") {
            return true;
          }
          t = t.toLowerCase();
          if (t.startsWith("on")) {
            return false;
          }
          if (
            t === "srcdoc" &&
            e.match(/\\bon\\S+\\s*=|javascript:|<\\s*\\/*script/i)
          ) {
            return false;
          }
          if (n === "img" && (t === "src" || t === "srcset")) {
            return true;
          }
          if (n === "source" && t === "srcset") {
            return true;
          }
          if (e.match(/^\\s*(javascript:|data:(image\\/svg|text\\/x?html))/i)) {
            return false;
          }
          return true;
        }
        setContentOf(t, e) {
          if (this.renderingMode === "data") {
            t.innerHTML = e;
            return;
          }
          const n = new DOMParser().parseFromString(e, "text/html");
          const i = n.createDocumentFragment();
          const o = n.body.childNodes;
          while (o.length > 0) {
            i.appendChild(o[0]);
          }
          const r = n.createTreeWalker(i, NodeFilter.SHOW_ELEMENT);
          const s = [];
          let a;
          while ((a = r.nextNode())) {
            s.push(a);
          }
          for (const t of s) {
            for (const e of t.getAttributeNames()) {
              this.setDomElementAttribute(t, e, t.getAttribute(e));
            }
            const e = t.tagName.toLowerCase();
            if (this._shouldRenameElement(e)) {
              xm(e);
              t.replaceWith(this._createReplacementDomElement(e, t));
            }
          }
          while (t.firstChild) {
            t.firstChild.remove();
          }
          t.append(i);
        }
        viewToDom(t, e = {}) {
          if (t.is("$text")) {
            const e = this._processDataFromViewText(t);
            return this._domDocument.createTextNode(e);
          } else {
            if (this.mapViewToDom(t)) {
              return this.mapViewToDom(t);
            }
            let n;
            if (t.is("documentFragment")) {
              n = this._domDocument.createDocumentFragment();
              if (e.bind) {
                this.bindDocumentFragments(n, t);
              }
            } else if (t.is("uiElement")) {
              if (t.name === "$comment") {
                n = this._domDocument.createComment(
                  t.getCustomProperty("$rawContent")
                );
              } else {
                n = t.render(this._domDocument, this);
              }
              if (e.bind) {
                this.bindElements(n, t);
              }
              return n;
            } else {
              if (this._shouldRenameElement(t.name)) {
                xm(t.name);
                n = this._createReplacementDomElement(t.name);
              } else if (t.hasAttribute("xmlns")) {
                n = this._domDocument.createElementNS(
                  t.getAttribute("xmlns"),
                  t.name
                );
              } else {
                n = this._domDocument.createElement(t.name);
              }
              if (t.is("rawElement")) {
                t.render(n, this);
              }
              if (e.bind) {
                this.bindElements(n, t);
              }
              for (const e of t.getAttributeKeys()) {
                this.setDomElementAttribute(n, e, t.getAttribute(e), t);
              }
            }
            if (e.withChildren !== false) {
              for (const i of this.viewChildrenToDom(t, e)) {
                n.appendChild(i);
              }
            }
            return n;
          }
        }
        setDomElementAttribute(t, e, n, i) {
          const o =
            this.shouldRenderAttribute(e, n, t.tagName.toLowerCase()) ||
            (i && i.shouldRenderUnsafeAttribute(e));
          if (!o) {
            B("domconverter-unsafe-attribute-detected", {
              domElement: t,
              key: e,
              value: n,
            });
          }
          if (t.hasAttribute(e) && !o) {
            t.removeAttribute(e);
          } else if (t.hasAttribute(km + e) && o) {
            t.removeAttribute(km + e);
          }
          t.setAttribute(o ? e : km + e, n);
        }
        removeDomElementAttribute(t, e) {
          if (e == wm) {
            return;
          }
          t.removeAttribute(e);
          t.removeAttribute(km + e);
        }
        *viewChildrenToDom(t, e = {}) {
          const n = t.getFillerOffset && t.getFillerOffset();
          let i = 0;
          for (const o of t.getChildren()) {
            if (n === i) {
              yield this._getBlockFiller();
            }
            const t =
              o.is("element") &&
              o.getCustomProperty("dataPipeline:transparentRendering");
            if (t && this.renderingMode == "data") {
              yield* this.viewChildrenToDom(o, e);
            } else {
              if (t) {
                B(
                  "domconverter-transparent-rendering-unsupported-in-editing-pipeline",
                  { viewElement: o }
                );
              }
              yield this.viewToDom(o, e);
            }
            i++;
          }
          if (n === i) {
            yield this._getBlockFiller();
          }
        }
        viewRangeToDom(t) {
          const e = this.viewPositionToDom(t.start);
          const n = this.viewPositionToDom(t.end);
          const i = this._domDocument.createRange();
          i.setStart(e.parent, e.offset);
          i.setEnd(n.parent, n.offset);
          return i;
        }
        viewPositionToDom(t) {
          const e = t.parent;
          if (e.is("$text")) {
            const n = this.findCorrespondingDomText(e);
            if (!n) {
              return null;
            }
            let i = t.offset;
            if (Zh(n)) {
              i += Kh;
            }
            return { parent: n, offset: i };
          } else {
            let n, i, o;
            if (t.offset === 0) {
              n = this.mapViewToDom(e);
              if (!n) {
                return null;
              }
              o = n.childNodes[0];
            } else {
              const e = t.nodeBefore;
              i = e.is("$text")
                ? this.findCorrespondingDomText(e)
                : this.mapViewToDom(e);
              if (!i) {
                return null;
              }
              n = i.parentNode;
              o = i.nextSibling;
            }
            if (nc(o) && Zh(o)) {
              return { parent: o, offset: Kh };
            }
            const r = i ? mc(i) + 1 : 0;
            return { parent: n, offset: r };
          }
        }
        domToView(t, e = {}) {
          if (this.isBlockFiller(t)) {
            return null;
          }
          const n = this.getHostViewElement(t);
          if (n) {
            return n;
          }
          if (fc(t) && e.skipComments) {
            return null;
          }
          if (nc(t)) {
            if (Qh(t)) {
              return null;
            } else {
              const e = this._processDataFromDomText(t);
              return e === "" ? null : new Yl(this.document, e);
            }
          } else {
            if (this.mapDomToView(t)) {
              return this.mapDomToView(t);
            }
            let n;
            if (this.isDocumentFragment(t)) {
              n = new Mh(this.document);
              if (e.bind) {
                this.bindDocumentFragments(t, n);
              }
            } else {
              n = this._createViewElement(t, e);
              if (e.bind) {
                this.bindElements(t, n);
              }
              const i = t.attributes;
              if (i) {
                for (let t = i.length, e = 0; e < t; e++) {
                  n._setAttribute(i[e].name, i[e].value);
                }
              }
              if (this._isViewElementWithRawContent(n, e) || fc(t)) {
                const e = fc(t) ? t.data : t.innerHTML;
                n._setCustomProperty("$rawContent", e);
                this._encounteredRawContentDomNodes.add(t);
                return n;
              }
            }
            if (e.withChildren !== false) {
              for (const i of this.domChildrenToView(t, e)) {
                n._appendChild(i);
              }
            }
            return n;
          }
        }
        *domChildrenToView(t, e) {
          for (let n = 0; n < t.childNodes.length; n++) {
            const i = t.childNodes[n];
            const o = this.domToView(i, e);
            if (o !== null) {
              yield o;
            }
          }
        }
        domSelectionToView(t) {
          if (t.rangeCount === 1) {
            let e = t.getRangeAt(0).startContainer;
            if (nc(e)) {
              e = e.parentNode;
            }
            const n = this.fakeSelectionToView(e);
            if (n) {
              return n;
            }
          }
          const e = this.isDomSelectionBackward(t);
          const n = [];
          for (let e = 0; e < t.rangeCount; e++) {
            const i = t.getRangeAt(e);
            const o = this.domRangeToView(i);
            if (o) {
              n.push(o);
            }
          }
          return new ch(n, { backward: e });
        }
        domRangeToView(t) {
          const e = this.domPositionToView(t.startContainer, t.startOffset);
          const n = this.domPositionToView(t.endContainer, t.endOffset);
          if (e && n) {
            return new sh(e, n);
          }
          return null;
        }
        domPositionToView(t, e = 0) {
          if (this.isBlockFiller(t)) {
            return this.domPositionToView(t.parentNode, mc(t));
          }
          const n = this.mapDomToView(t);
          if (n && (n.is("uiElement") || n.is("rawElement"))) {
            return rh._createBefore(n);
          }
          if (nc(t)) {
            if (Qh(t)) {
              return this.domPositionToView(t.parentNode, mc(t));
            }
            const n = this.findCorrespondingViewText(t);
            let i = e;
            if (!n) {
              return null;
            }
            if (Zh(t)) {
              i -= Kh;
              i = i < 0 ? 0 : i;
            }
            return new rh(n, i);
          } else {
            if (e === 0) {
              const e = this.mapDomToView(t);
              if (e) {
                return new rh(e, 0);
              }
            } else {
              const n = t.childNodes[e - 1];
              if (nc(n) && Qh(n)) {
                return this.domPositionToView(n.parentNode, mc(n));
              }
              const i = nc(n)
                ? this.findCorrespondingViewText(n)
                : this.mapDomToView(n);
              if (i && i.parent) {
                return new rh(i.parent, i.index + 1);
              }
            }
            return null;
          }
        }
        mapDomToView(t) {
          const e = this.getHostViewElement(t);
          return e || this._domToViewMapping.get(t);
        }
        findCorrespondingViewText(t) {
          if (Qh(t)) {
            return null;
          }
          const e = this.getHostViewElement(t);
          if (e) {
            return e;
          }
          const n = t.previousSibling;
          if (n) {
            if (!this.isElement(n)) {
              return null;
            }
            const t = this.mapDomToView(n);
            if (t) {
              const e = t.nextSibling;
              if (e instanceof Yl) {
                return e;
              } else {
                return null;
              }
            }
          } else {
            const e = this.mapDomToView(t.parentNode);
            if (e) {
              const t = e.getChild(0);
              if (t instanceof Yl) {
                return t;
              } else {
                return null;
              }
            }
          }
          return null;
        }
        mapViewToDom(t) {
          return this._viewToDomMapping.get(t);
        }
        findCorrespondingDomText(t) {
          const e = t.previousSibling;
          if (e && this.mapViewToDom(e)) {
            return this.mapViewToDom(e).nextSibling;
          }
          if (!e && t.parent && this.mapViewToDom(t.parent)) {
            return this.mapViewToDom(t.parent).childNodes[0];
          }
          return null;
        }
        focus(t) {
          const e = this.mapViewToDom(t);
          if (e && e.ownerDocument.activeElement !== e) {
            const { scrollX: t, scrollY: n } = Xa.window;
            const i = [];
            _m(e, (t) => {
              const { scrollLeft: e, scrollTop: n } = t;
              i.push([e, n]);
            });
            e.focus();
            _m(e, (t) => {
              const [e, n] = i.shift();
              t.scrollLeft = e;
              t.scrollTop = n;
            });
            Xa.window.scrollTo(t, n);
          }
        }
        isElement(t) {
          return t && t.nodeType == Node.ELEMENT_NODE;
        }
        isDocumentFragment(t) {
          return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
        }
        isBlockFiller(t) {
          if (this.blockFillerMode == "br") {
            return t.isEqualNode(fm);
          }
          if (
            t.tagName === "BR" &&
            ym(t, this.blockElements) &&
            t.parentNode.childNodes.length === 1
          ) {
            return true;
          }
          return t.isEqualNode(bm) || vm(t, this.blockElements);
        }
        isDomSelectionBackward(t) {
          if (t.isCollapsed) {
            return false;
          }
          const e = this._domDocument.createRange();
          try {
            e.setStart(t.anchorNode, t.anchorOffset);
            e.setEnd(t.focusNode, t.focusOffset);
          } catch (t) {
            return false;
          }
          const n = e.collapsed;
          e.detach();
          return n;
        }
        getHostViewElement(t) {
          const e = tc(t);
          e.pop();
          while (e.length) {
            const t = e.pop();
            const n = this._domToViewMapping.get(t);
            if (n && (n.is("uiElement") || n.is("rawElement"))) {
              return n;
            }
          }
          return null;
        }
        isDomSelectionCorrect(t) {
          return (
            this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) &&
            this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
          );
        }
        registerRawContentMatcher(t) {
          this._rawContentElementMatcher.add(t);
        }
        _getBlockFiller() {
          switch (this.blockFillerMode) {
            case "nbsp":
              return Wh(this._domDocument);
            case "markedNbsp":
              return Gh(this._domDocument);
            case "br":
              return $h(this._domDocument);
          }
        }
        _isDomSelectionPositionCorrect(t, e) {
          if (nc(t) && Zh(t) && e < Kh) {
            return false;
          }
          if (this.isElement(t) && Zh(t.childNodes[e])) {
            return false;
          }
          const n = this.mapDomToView(t);
          if (n && (n.is("uiElement") || n.is("rawElement"))) {
            return false;
          }
          return true;
        }
        _processDataFromViewText(t) {
          let e = t.data;
          if (t.getAncestors().some((t) => this.preElements.includes(t.name))) {
            return e;
          }
          if (e.charAt(0) == " ") {
            const n = this._getTouchingInlineViewNode(t, false);
            const i = n && n.is("$textProxy") && this._nodeEndsWithSpace(n);
            if (i || !n) {
              e = "" + e.substr(1);
            }
          }
          if (e.charAt(e.length - 1) == " ") {
            const n = this._getTouchingInlineViewNode(t, true);
            const i = n && n.is("$textProxy") && n.data.charAt(0) == " ";
            if (e.charAt(e.length - 2) == " " || !n || i) {
              e = e.substr(0, e.length - 1) + "";
            }
          }
          return e.replace(/ {2}/g, " ");
        }
        _nodeEndsWithSpace(t) {
          if (t.getAncestors().some((t) => this.preElements.includes(t.name))) {
            return false;
          }
          const e = this._processDataFromViewText(t);
          return e.charAt(e.length - 1) == " ";
        }
        _processDataFromDomText(t) {
          let e = t.data;
          if (Cm(t, this.preElements)) {
            return Jh(t);
          }
          e = e.replace(/[ \\n\\t\\r]{1,}/g, " ");
          const n = this._getTouchingInlineDomNode(t, false);
          const i = this._getTouchingInlineDomNode(t, true);
          const o = this._checkShouldLeftTrimDomText(t, n);
          const r = this._checkShouldRightTrimDomText(t, i);
          if (o) {
            e = e.replace(/^ /, "");
          }
          if (r) {
            e = e.replace(/ $/, "");
          }
          e = Jh(new Text(e));
          e = e.replace(/ \\u00A0/g, "  ");
          const s = i && this.isElement(i) && i.tagName != "BR";
          const a = i && nc(i) && i.data.charAt(0) == " ";
          if (/( |\\u00A0)\\u00A0$/.test(e) || !i || s || a) {
            e = e.replace(/\\u00A0$/, " ");
          }
          if (o || (n && this.isElement(n) && n.tagName != "BR")) {
            e = e.replace(/^\\u00A0/, " ");
          }
          return e;
        }
        _checkShouldLeftTrimDomText(t, e) {
          if (!e) {
            return true;
          }
          if (this.isElement(e)) {
            return e.tagName === "BR";
          }
          if (this._encounteredRawContentDomNodes.has(t.previousSibling)) {
            return false;
          }
          return /[^\\S\\u00A0]/.test(e.data.charAt(e.data.length - 1));
        }
        _checkShouldRightTrimDomText(t, e) {
          if (e) {
            return false;
          }
          return !Zh(t);
        }
        _getTouchingInlineViewNode(t, e) {
          const n = new oh({
            startPosition: e ? rh._createAfter(t) : rh._createBefore(t),
            direction: e ? "forward" : "backward",
          });
          for (const t of n) {
            if (
              t.item.is("element") &&
              this.inlineObjectElements.includes(t.item.name)
            ) {
              return t.item;
            } else if (t.item.is("containerElement")) {
              return null;
            } else if (t.item.is("element", "br")) {
              return null;
            } else if (t.item.is("$textProxy")) {
              return t.item;
            }
          }
          return null;
        }
        _getTouchingInlineDomNode(t, e) {
          if (!t.parentNode) {
            return null;
          }
          const n = e ? "firstChild" : "lastChild";
          const i = e ? "nextSibling" : "previousSibling";
          let o = true;
          let r = t;
          do {
            if (!o && r[n]) {
              r = r[n];
            } else if (r[i]) {
              r = r[i];
              o = false;
            } else {
              r = r.parentNode;
              o = true;
            }
            if (!r || this._isBlockElement(r)) {
              return null;
            }
          } while (
            !(nc(r) || r.tagName == "BR" || this._isInlineObjectElement(r))
          );
          return r;
        }
        _isBlockElement(t) {
          return (
            this.isElement(t) &&
            this.blockElements.includes(t.tagName.toLowerCase())
          );
        }
        _isInlineObjectElement(t) {
          return (
            this.isElement(t) &&
            this.inlineObjectElements.includes(t.tagName.toLowerCase())
          );
        }
        _createViewElement(t, e) {
          if (fc(t)) {
            return new xh(this.document, "$comment");
          }
          const n = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase();
          return new Yu(this.document, n);
        }
        _isViewElementWithRawContent(t, e) {
          return (
            e.withChildren !== false &&
            !!this._rawContentElementMatcher.match(t)
          );
        }
        _shouldRenameElement(t) {
          const e = t.toLowerCase();
          return (
            this.renderingMode === "editing" && this.unsafeElements.includes(e)
          );
        }
        _createReplacementDomElement(t, e) {
          const n = this._domDocument.createElement("span");
          n.setAttribute(wm, t);
          if (e) {
            while (e.firstChild) {
              n.appendChild(e.firstChild);
            }
            for (const t of e.getAttributeNames()) {
              n.setAttribute(t, e.getAttribute(t));
            }
          }
          return n;
        }
      }
      function Cm(t, e) {
        const n = tc(t);
        return n.some((t) => t.tagName && e.includes(t.tagName.toLowerCase()));
      }
      function _m(t, e) {
        let n = t;
        while (n) {
          e(n);
          n = n.parentElement;
        }
      }
      function vm(t, e) {
        const n = t.isEqualNode(pm);
        return n && ym(t, e) && t.parentNode.childNodes.length === 1;
      }
      function ym(t, e) {
        const n = t.parentNode;
        return !!n && !!n.tagName && e.includes(n.tagName.toLowerCase());
      }
      function xm(t) {
        if (t === "script") {
          B("domconverter-unsafe-script-element-detected");
        }
        if (t === "style") {
          B("domconverter-unsafe-style-element-detected");
        }
      }
      class Em extends Ka() {
        constructor(t) {
          super();
          this.view = t;
          this.document = t.document;
          this.isEnabled = false;
        }
        enable() {
          this.isEnabled = true;
        }
        disable() {
          this.isEnabled = false;
        }
        destroy() {
          this.disable();
          this.stopListening();
        }
        checkShouldIgnoreEventFromTarget(t) {
          if (t && t.nodeType === 3) {
            t = t.parentNode;
          }
          if (!t || t.nodeType !== 1) {
            return false;
          }
          return t.matches(
            "[data-cke-ignore-events], [data-cke-ignore-events] *"
          );
        }
      }
      var Dm = Ru(function (t, e) {
        gi(e, Jo(e), t);
      });
      const Sm = Dm;
      class Tm {
        constructor(t, e, n) {
          this.view = t;
          this.document = t.document;
          this.domEvent = e;
          this.domTarget = e.target;
          Sm(this, n);
        }
        get target() {
          return this.view.domConverter.mapDomToView(this.domTarget);
        }
        preventDefault() {
          this.domEvent.preventDefault();
        }
        stopPropagation() {
          this.domEvent.stopPropagation();
        }
      }
      class Im extends Em {
        constructor(t) {
          super(t);
          this.useCapture = false;
        }
        observe(t) {
          const e =
            typeof this.domEventType == "string"
              ? [this.domEventType]
              : this.domEventType;
          e.forEach((e) => {
            this.listenTo(
              t,
              e,
              (t, e) => {
                if (
                  this.isEnabled &&
                  !this.checkShouldIgnoreEventFromTarget(e.target)
                ) {
                  this.onDomEvent(e);
                }
              },
              { useCapture: this.useCapture }
            );
          });
        }
        fire(t, e, n) {
          if (this.isEnabled) {
            this.document.fire(t, new Tm(this.view, e, n));
          }
        }
      }
      class Mm extends Im {
        constructor(t) {
          super(t);
          this.domEventType = ["keydown", "keyup"];
        }
        onDomEvent(t) {
          const e = {
            keyCode: t.keyCode,
            altKey: t.altKey,
            ctrlKey: t.ctrlKey,
            shiftKey: t.shiftKey,
            metaKey: t.metaKey,
            get keystroke() {
              return Fc(this);
            },
          };
          this.fire(t.type, t, e);
        }
      }
      var Bm = function () {
        return Tt.Date.now();
      };
      const Lm = Bm;
      var Nm = /\\s/;
      function zm(t) {
        var e = t.length;
        while (e-- && Nm.test(t.charAt(e))) {}
        return e;
      }
      const Pm = zm;
      var Rm = /^\\s+/;
      function Om(t) {
        return t ? t.slice(0, Pm(t) + 1).replace(Rm, "") : t;
      }
      const jm = Om;
      var Fm = 0 / 0;
      var Vm = /^[-+]0x[0-9a-f]+$/i;
      var Hm = /^0b[01]+$/i;
      var Um = /^0o[0-7]+$/i;
      var qm = parseInt;
      function Wm(t) {
        if (typeof t == "number") {
          return t;
        }
        if (ld(t)) {
          return Fm;
        }
        if (it(t)) {
          var e = typeof t.valueOf == "function" ? t.valueOf() : t;
          t = it(e) ? e + "" : e;
        }
        if (typeof t != "string") {
          return t === 0 ? t : +t;
        }
        t = jm(t);
        var n = Hm.test(t);
        return n || Um.test(t)
          ? qm(t.slice(2), n ? 2 : 8)
          : Vm.test(t)
          ? Fm
          : +t;
      }
      const Gm = Wm;
      var $m = "Expected a function";
      var Km = Math.max,
        Ym = Math.min;
      function Zm(t, e, n) {
        var i,
          o,
          r,
          s,
          a,
          c,
          l = 0,
          d = false,
          u = false,
          h = true;
        if (typeof t != "function") {
          throw new TypeError($m);
        }
        e = Gm(e) || 0;
        if (it(n)) {
          d = !!n.leading;
          u = "maxWait" in n;
          r = u ? Km(Gm(n.maxWait) || 0, e) : r;
          h = "trailing" in n ? !!n.trailing : h;
        }
        function m(e) {
          var n = i,
            r = o;
          i = o = undefined;
          l = e;
          s = t.apply(r, n);
          return s;
        }
        function g(t) {
          l = t;
          a = setTimeout(b, e);
          return d ? m(t) : s;
        }
        function f(t) {
          var n = t - c,
            i = t - l,
            o = e - n;
          return u ? Ym(o, r - i) : o;
        }
        function p(t) {
          var n = t - c,
            i = t - l;
          return c === undefined || n >= e || n < 0 || (u && i >= r);
        }
        function b() {
          var t = Lm();
          if (p(t)) {
            return k(t);
          }
          a = setTimeout(b, f(t));
        }
        function k(t) {
          a = undefined;
          if (h && i) {
            return m(t);
          }
          i = o = undefined;
          return s;
        }
        function w() {
          if (a !== undefined) {
            clearTimeout(a);
          }
          l = 0;
          i = c = o = a = undefined;
        }
        function A() {
          return a === undefined ? s : k(Lm());
        }
        function C() {
          var t = Lm(),
            n = p(t);
          i = arguments;
          o = this;
          c = t;
          if (n) {
            if (a === undefined) {
              return g(c);
            }
            if (u) {
              clearTimeout(a);
              a = setTimeout(b, e);
              return m(c);
            }
          }
          if (a === undefined) {
            a = setTimeout(b, e);
          }
          return s;
        }
        C.cancel = w;
        C.flush = A;
        return C;
      }
      const Qm = Zm;
      class Jm extends Em {
        constructor(t) {
          super(t);
          this._fireSelectionChangeDoneDebounced = Qm((t) => {
            this.document.fire("selectionChangeDone", t);
          }, 200);
        }
        observe() {
          const t = this.document;
          t.on(
            "arrowKey",
            (e, n) => {
              const i = t.selection;
              if (i.isFake && this.isEnabled) {
                n.preventDefault();
              }
            },
            { context: "$capture" }
          );
          t.on(
            "arrowKey",
            (e, n) => {
              const i = t.selection;
              if (i.isFake && this.isEnabled) {
                this._handleSelectionMove(n.keyCode);
              }
            },
            { priority: "lowest" }
          );
        }
        destroy() {
          super.destroy();
          this._fireSelectionChangeDoneDebounced.cancel();
        }
        _handleSelectionMove(t) {
          const e = this.document.selection;
          const n = new ch(e.getRanges(), {
            backward: e.isBackward,
            fake: false,
          });
          if (t == Oc.arrowleft || t == Oc.arrowup) {
            n.setTo(n.getFirstPosition());
          }
          if (t == Oc.arrowright || t == Oc.arrowdown) {
            n.setTo(n.getLastPosition());
          }
          const i = { oldSelection: e, newSelection: n, domSelection: null };
          this.document.fire("selectionChange", i);
          this._fireSelectionChangeDoneDebounced(i);
        }
      }
      var Xm = "__lodash_hash_undefined__";
      function tg(t) {
        this.__data__.set(t, Xm);
        return this;
      }
      const eg = tg;
      function ng(t) {
        return this.__data__.has(t);
      }
      const ig = ng;
      function og(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.__data__ = new Qn();
        while (++e < n) {
          this.add(t[e]);
        }
      }
      og.prototype.add = og.prototype.push = eg;
      og.prototype.has = ig;
      const rg = og;
      function sg(t, e) {
        var n = -1,
          i = t == null ? 0 : t.length;
        while (++n < i) {
          if (e(t[n], n, t)) {
            return true;
          }
        }
        return false;
      }
      const ag = sg;
      function cg(t, e) {
        return t.has(e);
      }
      const lg = cg;
      var dg = 1,
        ug = 2;
      function hg(t, e, n, i, o, r) {
        var s = n & dg,
          a = t.length,
          c = e.length;
        if (a != c && !(s && c > a)) {
          return false;
        }
        var l = r.get(t);
        var d = r.get(e);
        if (l && d) {
          return l == e && d == t;
        }
        var u = -1,
          h = true,
          m = n & ug ? new rg() : undefined;
        r.set(t, e);
        r.set(e, t);
        while (++u < a) {
          var g = t[u],
            f = e[u];
          if (i) {
            var p = s ? i(f, g, u, e, t, r) : i(g, f, u, t, e, r);
          }
          if (p !== undefined) {
            if (p) {
              continue;
            }
            h = false;
            break;
          }
          if (m) {
            if (
              !ag(e, function (t, e) {
                if (!lg(m, e) && (g === t || o(g, t, n, i, r))) {
                  return m.push(e);
                }
              })
            ) {
              h = false;
              break;
            }
          } else if (!(g === f || o(g, f, n, i, r))) {
            h = false;
            break;
          }
        }
        r["delete"](t);
        r["delete"](e);
        return h;
      }
      const mg = hg;
      function gg(t) {
        var e = -1,
          n = Array(t.size);
        t.forEach(function (t, i) {
          n[++e] = [i, t];
        });
        return n;
      }
      const fg = gg;
      function pg(t) {
        var e = -1,
          n = Array(t.size);
        t.forEach(function (t) {
          n[++e] = t;
        });
        return n;
      }
      const bg = pg;
      var kg = 1,
        wg = 2;
      var Ag = "[object Boolean]",
        Cg = "[object Date]",
        _g = "[object Error]",
        vg = "[object Map]",
        yg = "[object Number]",
        xg = "[object RegExp]",
        Eg = "[object Set]",
        Dg = "[object String]",
        Sg = "[object Symbol]";
      var Tg = "[object ArrayBuffer]",
        Ig = "[object DataView]";
      var Mg = Mt ? Mt.prototype : undefined,
        Bg = Mg ? Mg.valueOf : undefined;
      function Lg(t, e, n, i, o, r, s) {
        switch (n) {
          case Ig:
            if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) {
              return false;
            }
            t = t.buffer;
            e = e.buffer;
          case Tg:
            if (t.byteLength != e.byteLength || !r(new ss(t), new ss(e))) {
              return false;
            }
            return true;
          case Ag:
          case Cg:
          case yg:
            return pe(+t, +e);
          case _g:
            return t.name == e.name && t.message == e.message;
          case xg:
          case Dg:
            return t == e + "";
          case vg:
            var a = fg;
          case Eg:
            var c = i & kg;
            a || (a = bg);
            if (t.size != e.size && !c) {
              return false;
            }
            var l = s.get(t);
            if (l) {
              return l == e;
            }
            i |= wg;
            s.set(t, e);
            var d = mg(a(t), a(e), i, o, r, s);
            s["delete"](t);
            return d;
          case Sg:
            if (Bg) {
              return Bg.call(t) == Bg.call(e);
            }
        }
        return false;
      }
      const Ng = Lg;
      var zg = 1;
      var Pg = Object.prototype;
      var Rg = Pg.hasOwnProperty;
      function Og(t, e, n, i, o, r) {
        var s = n & zg,
          a = Mr(t),
          c = a.length,
          l = Mr(e),
          d = l.length;
        if (c != d && !s) {
          return false;
        }
        var u = c;
        while (u--) {
          var h = a[u];
          if (!(s ? h in e : Rg.call(e, h))) {
            return false;
          }
        }
        var m = r.get(t);
        var g = r.get(e);
        if (m && g) {
          return m == e && g == t;
        }
        var f = true;
        r.set(t, e);
        r.set(e, t);
        var p = s;
        while (++u < c) {
          h = a[u];
          var b = t[h],
            k = e[h];
          if (i) {
            var w = s ? i(k, b, h, e, t, r) : i(b, k, h, t, e, r);
          }
          if (!(w === undefined ? b === k || o(b, k, n, i, r) : w)) {
            f = false;
            break;
          }
          p || (p = h == "constructor");
        }
        if (f && !p) {
          var A = t.constructor,
            C = e.constructor;
          if (
            A != C &&
            "constructor" in t &&
            "constructor" in e &&
            !(
              typeof A == "function" &&
              A instanceof A &&
              typeof C == "function" &&
              C instanceof C
            )
          ) {
            f = false;
          }
        }
        r["delete"](t);
        r["delete"](e);
        return f;
      }
      const jg = Og;
      var Fg = 1;
      var Vg = "[object Arguments]",
        Hg = "[object Array]",
        Ug = "[object Object]";
      var qg = Object.prototype;
      var Wg = qg.hasOwnProperty;
      function Gg(t, e, n, i, o, r) {
        var s = Kt(t),
          a = Kt(e),
          c = s ? Hg : ts(t),
          l = a ? Hg : ts(e);
        c = c == Vg ? Ug : c;
        l = l == Vg ? Ug : l;
        var d = c == Ug,
          u = l == Ug,
          h = c == l;
        if (h && Li(t)) {
          if (!Li(e)) {
            return false;
          }
          s = true;
          d = false;
        }
        if (h && !d) {
          r || (r = new ni());
          return s || xo(t) ? mg(t, e, n, i, o, r) : Ng(t, e, c, n, i, o, r);
        }
        if (!(n & Fg)) {
          var m = d && Wg.call(t, "__wrapped__"),
            g = u && Wg.call(e, "__wrapped__");
          if (m || g) {
            var f = m ? t.value() : t,
              p = g ? e.value() : e;
            r || (r = new ni());
            return o(f, p, n, i, r);
          }
        }
        if (!h) {
          return false;
        }
        r || (r = new ni());
        return jg(t, e, n, i, o, r);
      }
      const $g = Gg;
      function Kg(t, e, n, i, o) {
        if (t === e) {
          return true;
        }
        if (t == null || e == null || (!Zt(t) && !Zt(e))) {
          return t !== t && e !== e;
        }
        return $g(t, e, n, i, Kg, o);
      }
      const Yg = Kg;
      function Zg(t, e, n) {
        n = typeof n == "function" ? n : undefined;
        var i = n ? n(t, e) : undefined;
        return i === undefined ? Yg(t, e, undefined, n) : !!i;
      }
      const Qg = Zg;
      class Jg extends Em {
        constructor(t) {
          super(t);
          this._config = {
            childList: true,
            characterData: true,
            subtree: true,
          };
          this.domConverter = t.domConverter;
          this.renderer = t._renderer;
          this._domElements = [];
          this._mutationObserver = new window.MutationObserver(
            this._onMutations.bind(this)
          );
        }
        flush() {
          this._onMutations(this._mutationObserver.takeRecords());
        }
        observe(t) {
          this._domElements.push(t);
          if (this.isEnabled) {
            this._mutationObserver.observe(t, this._config);
          }
        }
        enable() {
          super.enable();
          for (const t of this._domElements) {
            this._mutationObserver.observe(t, this._config);
          }
        }
        disable() {
          super.disable();
          this._mutationObserver.disconnect();
        }
        destroy() {
          super.destroy();
          this._mutationObserver.disconnect();
        }
        _onMutations(t) {
          if (t.length === 0) {
            return;
          }
          const e = this.domConverter;
          const n = new Set();
          const i = new Set();
          for (const n of t) {
            const t = e.mapDomToView(n.target);
            if (!t) {
              continue;
            }
            if (t.is("uiElement") || t.is("rawElement")) {
              continue;
            }
            if (n.type === "childList" && !this._isBogusBrMutation(n)) {
              i.add(t);
            }
          }
          for (const o of t) {
            const t = e.mapDomToView(o.target);
            if (t && (t.is("uiElement") || t.is("rawElement"))) {
              continue;
            }
            if (o.type === "characterData") {
              const t = e.findCorrespondingViewText(o.target);
              if (t && !i.has(t.parent)) {
                n.add(t);
              } else if (!t && Zh(o.target)) {
                i.add(e.mapDomToView(o.target.parentNode));
              }
            }
          }
          let o = false;
          for (const t of n) {
            o = true;
            this.renderer.markToSync("text", t);
          }
          for (const t of i) {
            const n = e.mapViewToDom(t);
            const i = Array.from(t.getChildren());
            const r = Array.from(
              e.domChildrenToView(n, { withChildren: false })
            );
            if (!Qg(i, r, Xg)) {
              o = true;
              this.renderer.markToSync("children", t);
            }
          }
          if (o) {
            this.view.forceRender();
          }
        }
        _isBogusBrMutation(t) {
          let e = null;
          if (
            t.nextSibling === null &&
            t.removedNodes.length === 0 &&
            t.addedNodes.length == 1
          ) {
            e = this.domConverter.domToView(t.addedNodes[0], {
              withChildren: false,
            });
          }
          return e && e.is("element", "br");
        }
      }
      function Xg(t, e) {
        if (Array.isArray(t)) {
          return;
        }
        if (t === e) {
          return true;
        } else if (t.is("$text") && e.is("$text")) {
          return t.data === e.data;
        }
        return false;
      }
      class tf extends Em {
        constructor(t) {
          super(t);
          this.mutationObserver = t.getObserver(Jg);
          this.selection = this.document.selection;
          this.domConverter = t.domConverter;
          this._documents = new WeakSet();
          this._fireSelectionChangeDoneDebounced = Qm((t) => {
            this.document.fire("selectionChangeDone", t);
          }, 200);
          this._clearInfiniteLoopInterval = setInterval(
            () => this._clearInfiniteLoop(),
            1e3
          );
          this._documentIsSelectingInactivityTimeoutDebounced = Qm(
            () => (this.document.isSelecting = false),
            5e3
          );
          this._loopbackCounter = 0;
        }
        observe(t) {
          const e = t.ownerDocument;
          const n = () => {
            this.document.isSelecting = true;
            this._documentIsSelectingInactivityTimeoutDebounced();
          };
          const i = () => {
            if (!this.document.isSelecting) {
              return;
            }
            this._handleSelectionChange(null, e);
            this.document.isSelecting = false;
            this._documentIsSelectingInactivityTimeoutDebounced.cancel();
          };
          this.listenTo(t, "selectstart", n, { priority: "highest" });
          this.listenTo(t, "keydown", i, {
            priority: "highest",
            useCapture: true,
          });
          this.listenTo(t, "keyup", i, {
            priority: "highest",
            useCapture: true,
          });
          if (this._documents.has(e)) {
            return;
          }
          this.listenTo(e, "mouseup", i, {
            priority: "highest",
            useCapture: true,
          });
          this.listenTo(e, "selectionchange", (t, n) => {
            if (this.document.isComposing && !r.isAndroid) {
              return;
            }
            this._handleSelectionChange(n, e);
            this._documentIsSelectingInactivityTimeoutDebounced();
          });
          this._documents.add(e);
        }
        destroy() {
          super.destroy();
          clearInterval(this._clearInfiniteLoopInterval);
          this._fireSelectionChangeDoneDebounced.cancel();
          this._documentIsSelectingInactivityTimeoutDebounced.cancel();
        }
        _handleSelectionChange(t, e) {
          if (!this.isEnabled) {
            return;
          }
          const n = e.defaultView.getSelection();
          if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) {
            return;
          }
          this.mutationObserver.flush();
          const i = this.domConverter.domSelectionToView(n);
          if (i.rangeCount == 0) {
            this.view.hasDomSelection = false;
            return;
          }
          this.view.hasDomSelection = true;
          if (
            this.selection.isEqual(i) &&
            this.domConverter.isDomSelectionCorrect(n)
          ) {
            return;
          }
          if (++this._loopbackCounter > 60) {
            return;
          }
          if (this.selection.isSimilar(i)) {
            this.view.forceRender();
          } else {
            const t = {
              oldSelection: this.selection,
              newSelection: i,
              domSelection: n,
            };
            this.document._isFocusChanging = false;
            this.document.fire("selectionChange", t);
            this._fireSelectionChangeDoneDebounced(t);
          }
        }
        _clearInfiniteLoop() {
          this._loopbackCounter = 0;
        }
      }
      class ef extends Im {
        constructor(t) {
          super(t);
          this.domEventType = ["focus", "blur"];
          this.useCapture = true;
          const e = this.document;
          e.on("focus", () => {
            e.isFocused = true;
            e._isFocusChanging = true;
            this._renderTimeoutId = setTimeout(() => {
              e._isFocusChanging = false;
              t.change(() => {});
            }, 50);
          });
          e.on("blur", (n, i) => {
            const o = e.selection.editableElement;
            if (o === null || o === i.target) {
              e.isFocused = false;
              t.change(() => {});
            }
          });
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
        destroy() {
          if (this._renderTimeoutId) {
            clearTimeout(this._renderTimeoutId);
          }
          super.destroy();
        }
      }
      class nf extends Im {
        constructor(t) {
          super(t);
          this.domEventType = [
            "compositionstart",
            "compositionupdate",
            "compositionend",
          ];
          const e = this.document;
          e.on(
            "compositionstart",
            () => {
              e.isComposing = true;
            },
            { priority: "low" }
          );
          e.on(
            "compositionend",
            () => {
              e.isComposing = false;
            },
            { priority: "low" }
          );
        }
        onDomEvent(t) {
          this.fire(t.type, t, { data: t.data });
        }
      }
      class of {
        constructor(t) {
          this.files = rf(t);
          this._native = t;
        }
        get types() {
          return this._native.types;
        }
        getData(t) {
          return this._native.getData(t);
        }
        setData(t, e) {
          this._native.setData(t, e);
        }
        set effectAllowed(t) {
          this._native.effectAllowed = t;
        }
        get effectAllowed() {
          return this._native.effectAllowed;
        }
        set dropEffect(t) {
          this._native.dropEffect = t;
        }
        get dropEffect() {
          return this._native.dropEffect;
        }
        get isCanceled() {
          return (
            this._native.dropEffect == "none" || !!this._native.mozUserCancelled
          );
        }
      }
      function rf(t) {
        const e = Array.from(t.files || []);
        const n = Array.from(t.items || []);
        if (e.length) {
          return e;
        }
        return n.filter((t) => t.kind === "file").map((t) => t.getAsFile());
      }
      class sf extends Im {
        constructor(t) {
          super(t);
          this.domEventType = ["beforeinput"];
        }
        onDomEvent(t) {
          const e = t.getTargetRanges();
          const n = this.view;
          const i = n.document;
          let o = null;
          let s = null;
          let a = [];
          if (t.dataTransfer) {
            o = new of(t.dataTransfer);
          }
          if (t.data !== null) {
            s = t.data;
          } else if (o) {
            s = o.getData("text/plain");
          }
          if (i.selection.isFake) {
            a = Array.from(i.selection.getRanges());
          } else if (e.length) {
            a = e.map((t) => n.domConverter.domRangeToView(t));
          } else if (r.isAndroid) {
            const e = t.target.ownerDocument.defaultView.getSelection();
            a = Array.from(n.domConverter.domSelectionToView(e).getRanges());
          }
          if (
            r.isAndroid &&
            t.inputType == "insertCompositionText" &&
            s &&
            s.endsWith("\\n")
          ) {
            this.fire(t.type, t, {
              inputType: "insertParagraph",
              targetRanges: [n.createRange(a[0].end)],
            });
            return;
          }
          if (t.inputType == "insertText" && s && s.includes("\\n")) {
            const e = s.split(/\\n{1,2}/g);
            let n = a;
            for (let r = 0; r < e.length; r++) {
              const s = e[r];
              if (s != "") {
                this.fire(t.type, t, {
                  data: s,
                  dataTransfer: o,
                  targetRanges: n,
                  inputType: t.inputType,
                  isComposing: t.isComposing,
                });
                n = [i.selection.getFirstRange()];
              }
              if (r + 1 < e.length) {
                this.fire(t.type, t, {
                  inputType: "insertParagraph",
                  targetRanges: n,
                });
                n = [i.selection.getFirstRange()];
              }
            }
            return;
          }
          this.fire(t.type, t, {
            data: s,
            dataTransfer: o,
            targetRanges: a,
            inputType: t.inputType,
            isComposing: t.isComposing,
          });
        }
      }
      class af extends Em {
        constructor(t) {
          super(t);
          this.document.on("keydown", (t, e) => {
            if (this.isEnabled && Uc(e.keyCode)) {
              const n = new dh(
                this.document,
                "arrowKey",
                this.document.selection.getFirstRange()
              );
              this.document.fire(n, e);
              if (n.stop.called) {
                t.stop();
              }
            }
          });
        }
        observe() {}
      }
      class cf extends Em {
        constructor(t) {
          super(t);
          const e = this.document;
          e.on("keydown", (t, n) => {
            if (!this.isEnabled || n.keyCode != Oc.tab || n.ctrlKey) {
              return;
            }
            const i = new dh(e, "tab", e.selection.getFirstRange());
            e.fire(i, n);
            if (i.stop.called) {
              t.stop();
            }
          });
        }
        observe() {}
      }
      class lf extends dt() {
        constructor(t) {
          super();
          this.document = new kh(t);
          this.domConverter = new Am(this.document);
          this.domRoots = new Map();
          this.set("isRenderingInProgress", false);
          this.set("hasDomSelection", false);
          this._renderer = new rm(this.domConverter, this.document.selection);
          this._renderer
            .bind("isFocused", "isSelecting", "isComposing", "_isFocusChanging")
            .to(
              this.document,
              "isFocused",
              "isSelecting",
              "isComposing",
              "_isFocusChanging"
            );
          this._initialDomRootAttributes = new WeakMap();
          this._observers = new Map();
          this._ongoingChange = false;
          this._postFixersInProgress = false;
          this._renderingDisabled = false;
          this._hasChangedSinceTheLastRendering = false;
          this._writer = new Lh(this.document);
          this.addObserver(Jg);
          this.addObserver(tf);
          this.addObserver(ef);
          this.addObserver(Mm);
          this.addObserver(Jm);
          this.addObserver(nf);
          this.addObserver(af);
          this.addObserver(sf);
          this.addObserver(cf);
          Xh(this);
          Eh(this);
          this.on("render", () => {
            this._render();
            this.document.fire("layoutChanged");
            this._hasChangedSinceTheLastRendering = false;
          });
          this.listenTo(this.document.selection, "change", () => {
            this._hasChangedSinceTheLastRendering = true;
          });
          this.listenTo(this.document, "change:isFocused", () => {
            this._hasChangedSinceTheLastRendering = true;
          });
        }
        attachDomRoot(t, e = "main") {
          const n = this.document.getRoot(e);
          n._name = t.tagName.toLowerCase();
          const i = {};
          for (const { name: e, value: o } of Array.from(t.attributes)) {
            i[e] = o;
            if (e === "class") {
              this._writer.addClass(o.split(" "), n);
            } else {
              this._writer.setAttribute(e, o, n);
            }
          }
          this._initialDomRootAttributes.set(t, i);
          const o = () => {
            this._writer.setAttribute(
              "contenteditable",
              (!n.isReadOnly).toString(),
              n
            );
            if (n.isReadOnly) {
              this._writer.addClass("ck-read-only", n);
            } else {
              this._writer.removeClass("ck-read-only", n);
            }
          };
          o();
          this.domRoots.set(e, t);
          this.domConverter.bindElements(t, n);
          this._renderer.markToSync("children", n);
          this._renderer.markToSync("attributes", n);
          this._renderer.domDocuments.add(t.ownerDocument);
          n.on("change:children", (t, e) =>
            this._renderer.markToSync("children", e)
          );
          n.on("change:attributes", (t, e) =>
            this._renderer.markToSync("attributes", e)
          );
          n.on("change:text", (t, e) => this._renderer.markToSync("text", e));
          n.on("change:isReadOnly", () => this.change(o));
          n.on("change", () => {
            this._hasChangedSinceTheLastRendering = true;
          });
          for (const n of this._observers.values()) {
            n.observe(t, e);
          }
        }
        detachDomRoot(t) {
          const e = this.domRoots.get(t);
          Array.from(e.attributes).forEach(({ name: t }) =>
            e.removeAttribute(t)
          );
          const n = this._initialDomRootAttributes.get(e);
          for (const t in n) {
            e.setAttribute(t, n[t]);
          }
          this.domRoots.delete(t);
          this.domConverter.unbindDomElement(e);
        }
        getDomRoot(t = "main") {
          return this.domRoots.get(t);
        }
        addObserver(t) {
          let e = this._observers.get(t);
          if (e) {
            return e;
          }
          e = new t(this);
          this._observers.set(t, e);
          for (const [t, n] of this.domRoots) {
            e.observe(n, t);
          }
          e.enable();
          return e;
        }
        getObserver(t) {
          return this._observers.get(t);
        }
        disableObservers() {
          for (const t of this._observers.values()) {
            t.disable();
          }
        }
        enableObservers() {
          for (const t of this._observers.values()) {
            t.enable();
          }
        }
        scrollToTheSelection() {
          const t = this.document.selection.getFirstRange();
          if (t) {
            xc({
              target: this.domConverter.viewRangeToDom(t),
              viewportOffset: 20,
            });
          }
        }
        focus() {
          if (!this.document.isFocused) {
            const t = this.document.selection.editableElement;
            if (t) {
              this.domConverter.focus(t);
              this.forceRender();
            } else {
            }
          }
        }
        change(t) {
          if (this.isRenderingInProgress || this._postFixersInProgress) {
            throw new M("cannot-change-view-tree", this);
          }
          try {
            if (this._ongoingChange) {
              return t(this._writer);
            }
            this._ongoingChange = true;
            const e = t(this._writer);
            this._ongoingChange = false;
            if (
              !this._renderingDisabled &&
              this._hasChangedSinceTheLastRendering
            ) {
              this._postFixersInProgress = true;
              this.document._callPostFixers(this._writer);
              this._postFixersInProgress = false;
              this.fire("render");
            }
            return e;
          } catch (t) {
            M.rethrowUnexpectedError(t, this);
          }
        }
        forceRender() {
          this._hasChangedSinceTheLastRendering = true;
          this.document._isFocusChanging = false;
          this.change(() => {});
        }
        destroy() {
          for (const t of this._observers.values()) {
            t.destroy();
          }
          this.document.destroy();
          this.stopListening();
        }
        createPositionAt(t, e) {
          return rh._createAt(t, e);
        }
        createPositionAfter(t) {
          return rh._createAfter(t);
        }
        createPositionBefore(t) {
          return rh._createBefore(t);
        }
        createRange(...t) {
          return new sh(...t);
        }
        createRangeOn(t) {
          return sh._createOn(t);
        }
        createRangeIn(t) {
          return sh._createIn(t);
        }
        createSelection(...t) {
          return new ch(...t);
        }
        _disableRendering(t) {
          this._renderingDisabled = t;
          if (t == false) {
            this.change(() => {});
          }
        }
        _render() {
          this.isRenderingInProgress = true;
          this.disableObservers();
          this._renderer.render();
          this.enableObservers();
          this.isRenderingInProgress = false;
        }
      }
      class df {
        is() {
          throw new Error("is() method is abstract");
        }
      }
      class uf extends df {
        constructor(t) {
          super();
          this.parent = null;
          this._attrs = dl(t);
        }
        get document() {
          return null;
        }
        get index() {
          let t;
          if (!this.parent) {
            return null;
          }
          if ((t = this.parent.getChildIndex(this)) === null) {
            throw new M("model-node-not-found-in-parent", this);
          }
          return t;
        }
        get startOffset() {
          let t;
          if (!this.parent) {
            return null;
          }
          if ((t = this.parent.getChildStartOffset(this)) === null) {
            throw new M("model-node-not-found-in-parent", this);
          }
          return t;
        }
        get offsetSize() {
          return 1;
        }
        get endOffset() {
          if (!this.parent) {
            return null;
          }
          return this.startOffset + this.offsetSize;
        }
        get nextSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t + 1)) || null;
        }
        get previousSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t - 1)) || null;
        }
        get root() {
          let t = this;
          while (t.parent) {
            t = t.parent;
          }
          return t;
        }
        isAttached() {
          return this.root.is("rootElement");
        }
        getPath() {
          const t = [];
          let e = this;
          while (e.parent) {
            t.unshift(e.startOffset);
            e = e.parent;
          }
          return t;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this : this.parent;
          while (n) {
            e[t.parentFirst ? "push" : "unshift"](n);
            n = n.parent;
          }
          return e;
        }
        getCommonAncestor(t, e = {}) {
          const n = this.getAncestors(e);
          const i = t.getAncestors(e);
          let o = 0;
          while (n[o] == i[o] && n[o]) {
            o++;
          }
          return o === 0 ? null : n[o - 1];
        }
        isBefore(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          const e = this.getPath();
          const n = t.getPath();
          const i = vt(e, n);
          switch (i) {
            case "prefix":
              return true;
            case "extension":
              return false;
            default:
              return e[i] < n[i];
          }
        }
        isAfter(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          return !this.isBefore(t);
        }
        hasAttribute(t) {
          return this._attrs.has(t);
        }
        getAttribute(t) {
          return this._attrs.get(t);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        toJSON() {
          const t = {};
          if (this._attrs.size) {
            t.attributes = Array.from(this._attrs).reduce((t, e) => {
              t[e[0]] = e[1];
              return t;
            }, {});
          }
          return t;
        }
        _clone(t) {
          return new uf(this._attrs);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _setAttribute(t, e) {
          this._attrs.set(t, e);
        }
        _setAttributesTo(t) {
          this._attrs = dl(t);
        }
        _removeAttribute(t) {
          return this._attrs.delete(t);
        }
        _clearAttributes() {
          this._attrs.clear();
        }
      }
      uf.prototype.is = function (t) {
        return t === "node" || t === "model:node";
      };
      class hf {
        constructor(t) {
          this._nodes = [];
          if (t) {
            this._insertNodes(0, t);
          }
        }
        [Symbol.iterator]() {
          return this._nodes[Symbol.iterator]();
        }
        get length() {
          return this._nodes.length;
        }
        get maxOffset() {
          return this._nodes.reduce((t, e) => t + e.offsetSize, 0);
        }
        getNode(t) {
          return this._nodes[t] || null;
        }
        getNodeIndex(t) {
          const e = this._nodes.indexOf(t);
          return e == -1 ? null : e;
        }
        getNodeStartOffset(t) {
          const e = this.getNodeIndex(t);
          return e === null
            ? null
            : this._nodes.slice(0, e).reduce((t, e) => t + e.offsetSize, 0);
        }
        indexToOffset(t) {
          if (t == this._nodes.length) {
            return this.maxOffset;
          }
          const e = this._nodes[t];
          if (!e) {
            throw new M("model-nodelist-index-out-of-bounds", this);
          }
          return this.getNodeStartOffset(e);
        }
        offsetToIndex(t) {
          let e = 0;
          for (const n of this._nodes) {
            if (t >= e && t < e + n.offsetSize) {
              return this.getNodeIndex(n);
            }
            e += n.offsetSize;
          }
          if (e != t) {
            throw new M("model-nodelist-offset-out-of-bounds", this, {
              offset: t,
              nodeList: this,
            });
          }
          return this.length;
        }
        _insertNodes(t, e) {
          for (const t of e) {
            if (!(t instanceof uf)) {
              throw new M("model-nodelist-insertnodes-not-node", this);
            }
          }
          this._nodes = hl(this._nodes, Array.from(e), t, 0);
        }
        _removeNodes(t, e = 1) {
          return this._nodes.splice(t, e);
        }
        toJSON() {
          return this._nodes.map((t) => t.toJSON());
        }
      }
      class mf extends uf {
        constructor(t, e) {
          super(e);
          this._data = t || "";
        }
        get offsetSize() {
          return this.data.length;
        }
        get data() {
          return this._data;
        }
        toJSON() {
          const t = super.toJSON();
          t.data = this.data;
          return t;
        }
        _clone() {
          return new mf(this.data, this.getAttributes());
        }
        static fromJSON(t) {
          return new mf(t.data, t.attributes);
        }
      }
      mf.prototype.is = function (t) {
        return (
          t === "$text" ||
          t === "model:$text" ||
          t === "text" ||
          t === "model:text" ||
          t === "node" ||
          t === "model:node"
        );
      };
      class gf extends df {
        constructor(t, e, n) {
          super();
          this.textNode = t;
          if (e < 0 || e > t.offsetSize) {
            throw new M("model-textproxy-wrong-offsetintext", this);
          }
          if (n < 0 || e + n > t.offsetSize) {
            throw new M("model-textproxy-wrong-length", this);
          }
          this.data = t.data.substring(e, e + n);
          this.offsetInText = e;
        }
        get startOffset() {
          return this.textNode.startOffset !== null
            ? this.textNode.startOffset + this.offsetInText
            : null;
        }
        get offsetSize() {
          return this.data.length;
        }
        get endOffset() {
          return this.startOffset !== null
            ? this.startOffset + this.offsetSize
            : null;
        }
        get isPartial() {
          return this.offsetSize !== this.textNode.offsetSize;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        getPath() {
          const t = this.textNode.getPath();
          if (t.length > 0) {
            t[t.length - 1] += this.offsetInText;
          }
          return t;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this : this.parent;
          while (n) {
            e[t.parentFirst ? "push" : "unshift"](n);
            n = n.parent;
          }
          return e;
        }
        hasAttribute(t) {
          return this.textNode.hasAttribute(t);
        }
        getAttribute(t) {
          return this.textNode.getAttribute(t);
        }
        getAttributes() {
          return this.textNode.getAttributes();
        }
        getAttributeKeys() {
          return this.textNode.getAttributeKeys();
        }
      }
      gf.prototype.is = function (t) {
        return (
          t === "$textProxy" ||
          t === "model:$textProxy" ||
          t === "textProxy" ||
          t === "model:textProxy"
        );
      };
      class ff extends uf {
        constructor(t, e, n) {
          super(e);
          this.name = t;
          this._children = new hf();
          if (n) {
            this._insertChild(0, n);
          }
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        getChild(t) {
          return this._children.getNode(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(t) {
          return this._children.getNodeIndex(t);
        }
        getChildStartOffset(t) {
          return this._children.getNodeStartOffset(t);
        }
        offsetToIndex(t) {
          return this._children.offsetToIndex(t);
        }
        getNodeByPath(t) {
          let e = this;
          for (const n of t) {
            e = e.getChild(e.offsetToIndex(n));
          }
          return e;
        }
        findAncestor(t, e = {}) {
          let n = e.includeSelf ? this : this.parent;
          while (n) {
            if (n.name === t) {
              return n;
            }
            n = n.parent;
          }
          return null;
        }
        toJSON() {
          const t = super.toJSON();
          t.name = this.name;
          if (this._children.length > 0) {
            t.children = [];
            for (const e of this._children) {
              t.children.push(e.toJSON());
            }
          }
          return t;
        }
        _clone(t = false) {
          const e = t
            ? Array.from(this._children).map((t) => t._clone(true))
            : undefined;
          return new ff(this.name, this.getAttributes(), e);
        }
        _appendChild(t) {
          this._insertChild(this.childCount, t);
        }
        _insertChild(t, e) {
          const n = pf(e);
          for (const t of n) {
            if (t.parent !== null) {
              t._remove();
            }
            t.parent = this;
          }
          this._children._insertNodes(t, n);
        }
        _removeChildren(t, e = 1) {
          const n = this._children._removeNodes(t, e);
          for (const t of n) {
            t.parent = null;
          }
          return n;
        }
        static fromJSON(t) {
          let e;
          if (t.children) {
            e = [];
            for (const n of t.children) {
              if (n.name) {
                e.push(ff.fromJSON(n));
              } else {
                e.push(mf.fromJSON(n));
              }
            }
          }
          return new ff(t.name, t.attributes, e);
        }
      }
      ff.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "element" ||
            t === "model:element" ||
            t === "node" ||
            t === "model:node"
          );
        }
        return e === this.name && (t === "element" || t === "model:element");
      };
      function pf(t) {
        if (typeof t == "string") {
          return [new mf(t)];
        }
        if (!yt(t)) {
          t = [t];
        }
        return Array.from(t).map((t) => {
          if (typeof t == "string") {
            return new mf(t);
          }
          if (t instanceof gf) {
            return new mf(t.data, t.getAttributes());
          }
          return t;
        });
      }
      class bf {
        constructor(t = {}) {
          if (!t.boundaries && !t.startPosition) {
            throw new M("model-tree-walker-no-start-position", null);
          }
          const e = t.direction || "forward";
          if (e != "forward" && e != "backward") {
            throw new M("model-tree-walker-unknown-direction", t, {
              direction: e,
            });
          }
          this.direction = e;
          this.boundaries = t.boundaries || null;
          if (t.startPosition) {
            this.position = t.startPosition.clone();
          } else {
            this.position = wf._createAt(
              this.boundaries[this.direction == "backward" ? "end" : "start"]
            );
          }
          this.position.stickiness = "toNone";
          this.singleCharacters = !!t.singleCharacters;
          this.shallow = !!t.shallow;
          this.ignoreElementEnd = !!t.ignoreElementEnd;
          this._boundaryStartParent = this.boundaries
            ? this.boundaries.start.parent
            : null;
          this._boundaryEndParent = this.boundaries
            ? this.boundaries.end.parent
            : null;
          this._visitedParent = this.position.parent;
        }
        [Symbol.iterator]() {
          return this;
        }
        skip(t) {
          let e, n, i, o;
          do {
            i = this.position;
            o = this._visitedParent;
            ({ done: e, value: n } = this.next());
          } while (!e && t(n));
          if (!e) {
            this.position = i;
            this._visitedParent = o;
          }
        }
        next() {
          if (this.direction == "forward") {
            return this._next();
          } else {
            return this._previous();
          }
        }
        _next() {
          const t = this.position;
          const e = this.position.clone();
          const n = this._visitedParent;
          if (n.parent === null && e.offset === n.maxOffset) {
            return { done: true, value: undefined };
          }
          if (
            n === this._boundaryEndParent &&
            e.offset == this.boundaries.end.offset
          ) {
            return { done: true, value: undefined };
          }
          const i = Af(e, n);
          const o = i ? i : Cf(e, n, i);
          if (o instanceof ff) {
            if (!this.shallow) {
              e.path.push(0);
              this._visitedParent = o;
            } else {
              e.offset++;
            }
            this.position = e;
            return kf("elementStart", o, t, e, 1);
          } else if (o instanceof mf) {
            let i;
            if (this.singleCharacters) {
              i = 1;
            } else {
              let t = o.endOffset;
              if (
                this._boundaryEndParent == n &&
                this.boundaries.end.offset < t
              ) {
                t = this.boundaries.end.offset;
              }
              i = t - e.offset;
            }
            const r = e.offset - o.startOffset;
            const s = new gf(o, r, i);
            e.offset += i;
            this.position = e;
            return kf("text", s, t, e, i);
          } else {
            e.path.pop();
            e.offset++;
            this.position = e;
            this._visitedParent = n.parent;
            if (this.ignoreElementEnd) {
              return this._next();
            } else {
              return kf("elementEnd", n, t, e);
            }
          }
        }
        _previous() {
          const t = this.position;
          const e = this.position.clone();
          const n = this._visitedParent;
          if (n.parent === null && e.offset === 0) {
            return { done: true, value: undefined };
          }
          if (
            n == this._boundaryStartParent &&
            e.offset == this.boundaries.start.offset
          ) {
            return { done: true, value: undefined };
          }
          const i = e.parent;
          const o = Af(e, i);
          const r = o ? o : _f(e, i, o);
          if (r instanceof ff) {
            e.offset--;
            if (!this.shallow) {
              e.path.push(r.maxOffset);
              this.position = e;
              this._visitedParent = r;
              if (this.ignoreElementEnd) {
                return this._previous();
              } else {
                return kf("elementEnd", r, t, e);
              }
            } else {
              this.position = e;
              return kf("elementStart", r, t, e, 1);
            }
          } else if (r instanceof mf) {
            let i;
            if (this.singleCharacters) {
              i = 1;
            } else {
              let t = r.startOffset;
              if (
                this._boundaryStartParent == n &&
                this.boundaries.start.offset > t
              ) {
                t = this.boundaries.start.offset;
              }
              i = e.offset - t;
            }
            const o = e.offset - r.startOffset;
            const s = new gf(r, o - i, i);
            e.offset -= i;
            this.position = e;
            return kf("text", s, t, e, i);
          } else {
            e.path.pop();
            this.position = e;
            this._visitedParent = n.parent;
            return kf("elementStart", n, t, e, 1);
          }
        }
      }
      function kf(t, e, n, i, o) {
        return {
          done: false,
          value: {
            type: t,
            item: e,
            previousPosition: n,
            nextPosition: i,
            length: o,
          },
        };
      }
      class wf extends df {
        constructor(t, e, n = "toNone") {
          super();
          if (!t.is("element") && !t.is("documentFragment")) {
            throw new M("model-position-root-invalid", t);
          }
          if (!(e instanceof Array) || e.length === 0) {
            throw new M("model-position-path-incorrect-format", t, { path: e });
          }
          if (t.is("rootElement")) {
            e = e.slice();
          } else {
            e = [...t.getPath(), ...e];
            t = t.root;
          }
          this.root = t;
          this.path = e;
          this.stickiness = n;
        }
        get offset() {
          return this.path[this.path.length - 1];
        }
        set offset(t) {
          this.path[this.path.length - 1] = t;
        }
        get parent() {
          let t = this.root;
          for (let e = 0; e < this.path.length - 1; e++) {
            t = t.getChild(t.offsetToIndex(this.path[e]));
            if (!t) {
              throw new M("model-position-path-incorrect", this, {
                position: this,
              });
            }
          }
          if (t.is("$text")) {
            throw new M("model-position-path-incorrect", this, {
              position: this,
            });
          }
          return t;
        }
        get index() {
          return this.parent.offsetToIndex(this.offset);
        }
        get textNode() {
          return Af(this, this.parent);
        }
        get nodeAfter() {
          const t = this.parent;
          return Cf(this, t, Af(this, t));
        }
        get nodeBefore() {
          const t = this.parent;
          return _f(this, t, Af(this, t));
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          return this.offset == this.parent.maxOffset;
        }
        compareWith(t) {
          if (this.root != t.root) {
            return "different";
          }
          const e = vt(this.path, t.path);
          switch (e) {
            case "same":
              return "same";
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return this.path[e] < t.path[e] ? "before" : "after";
          }
        }
        getLastMatchingPosition(t, e = {}) {
          e.startPosition = this;
          const n = new bf(e);
          n.skip(t);
          return n.position;
        }
        getParentPath() {
          return this.path.slice(0, -1);
        }
        getAncestors() {
          const t = this.parent;
          if (t.is("documentFragment")) {
            return [t];
          } else {
            return t.getAncestors({ includeSelf: true });
          }
        }
        findAncestor(t) {
          const e = this.parent;
          if (e.is("element")) {
            return e.findAncestor(t, { includeSelf: true });
          }
          return null;
        }
        getCommonPath(t) {
          if (this.root != t.root) {
            return [];
          }
          const e = vt(this.path, t.path);
          const n =
            typeof e == "string"
              ? Math.min(this.path.length, t.path.length)
              : e;
          return this.path.slice(0, n);
        }
        getCommonAncestor(t) {
          const e = this.getAncestors();
          const n = t.getAncestors();
          let i = 0;
          while (e[i] == n[i] && e[i]) {
            i++;
          }
          return i === 0 ? null : e[i - 1];
        }
        getShiftedBy(t) {
          const e = this.clone();
          const n = e.offset + t;
          e.offset = n < 0 ? 0 : n;
          return e;
        }
        isAfter(t) {
          return this.compareWith(t) == "after";
        }
        isBefore(t) {
          return this.compareWith(t) == "before";
        }
        isEqual(t) {
          return this.compareWith(t) == "same";
        }
        isTouching(t) {
          if (this.root !== t.root) {
            return false;
          }
          const e = Math.min(this.path.length, t.path.length);
          for (let n = 0; n < e; n++) {
            const e = this.path[n] - t.path[n];
            if (e < -1 || e > 1) {
              return false;
            } else if (e === 1) {
              return vf(t, this, n);
            } else if (e === -1) {
              return vf(this, t, n);
            }
          }
          if (this.path.length === t.path.length) {
            return true;
          } else if (this.path.length > t.path.length) {
            return yf(this.path, e);
          } else {
            return yf(t.path, e);
          }
        }
        hasSameParentAs(t) {
          if (this.root !== t.root) {
            return false;
          }
          const e = this.getParentPath();
          const n = t.getParentPath();
          return vt(e, n) == "same";
        }
        getTransformedByOperation(t) {
          let e;
          switch (t.type) {
            case "insert":
              e = this._getTransformedByInsertOperation(t);
              break;
            case "move":
            case "remove":
            case "reinsert":
              e = this._getTransformedByMoveOperation(t);
              break;
            case "split":
              e = this._getTransformedBySplitOperation(t);
              break;
            case "merge":
              e = this._getTransformedByMergeOperation(t);
              break;
            default:
              e = wf._createAt(this);
              break;
          }
          return e;
        }
        _getTransformedByInsertOperation(t) {
          return this._getTransformedByInsertion(t.position, t.howMany);
        }
        _getTransformedByMoveOperation(t) {
          return this._getTransformedByMove(
            t.sourcePosition,
            t.targetPosition,
            t.howMany
          );
        }
        _getTransformedBySplitOperation(t) {
          const e = t.movedRange;
          const n =
            e.containsPosition(this) ||
            (e.start.isEqual(this) && this.stickiness == "toNext");
          if (n) {
            return this._getCombined(t.splitPosition, t.moveTargetPosition);
          } else {
            if (t.graveyardPosition) {
              return this._getTransformedByMove(
                t.graveyardPosition,
                t.insertionPosition,
                1
              );
            } else {
              return this._getTransformedByInsertion(t.insertionPosition, 1);
            }
          }
        }
        _getTransformedByMergeOperation(t) {
          const e = t.movedRange;
          const n = e.containsPosition(this) || e.start.isEqual(this);
          let i;
          if (n) {
            i = this._getCombined(t.sourcePosition, t.targetPosition);
            if (t.sourcePosition.isBefore(t.targetPosition)) {
              i = i._getTransformedByDeletion(t.deletionPosition, 1);
            }
          } else if (this.isEqual(t.deletionPosition)) {
            i = wf._createAt(t.deletionPosition);
          } else {
            i = this._getTransformedByMove(
              t.deletionPosition,
              t.graveyardPosition,
              1
            );
          }
          return i;
        }
        _getTransformedByDeletion(t, e) {
          const n = wf._createAt(this);
          if (this.root != t.root) {
            return n;
          }
          if (vt(t.getParentPath(), this.getParentPath()) == "same") {
            if (t.offset < this.offset) {
              if (t.offset + e > this.offset) {
                return null;
              } else {
                n.offset -= e;
              }
            }
          } else if (vt(t.getParentPath(), this.getParentPath()) == "prefix") {
            const i = t.path.length - 1;
            if (t.offset <= this.path[i]) {
              if (t.offset + e > this.path[i]) {
                return null;
              } else {
                n.path[i] -= e;
              }
            }
          }
          return n;
        }
        _getTransformedByInsertion(t, e) {
          const n = wf._createAt(this);
          if (this.root != t.root) {
            return n;
          }
          if (vt(t.getParentPath(), this.getParentPath()) == "same") {
            if (
              t.offset < this.offset ||
              (t.offset == this.offset && this.stickiness != "toPrevious")
            ) {
              n.offset += e;
            }
          } else if (vt(t.getParentPath(), this.getParentPath()) == "prefix") {
            const i = t.path.length - 1;
            if (t.offset <= this.path[i]) {
              n.path[i] += e;
            }
          }
          return n;
        }
        _getTransformedByMove(t, e, n) {
          e = e._getTransformedByDeletion(t, n);
          if (t.isEqual(e)) {
            return wf._createAt(this);
          }
          const i = this._getTransformedByDeletion(t, n);
          const o =
            i === null ||
            (t.isEqual(this) && this.stickiness == "toNext") ||
            (t.getShiftedBy(n).isEqual(this) &&
              this.stickiness == "toPrevious");
          if (o) {
            return this._getCombined(t, e);
          } else {
            return i._getTransformedByInsertion(e, n);
          }
        }
        _getCombined(t, e) {
          const n = t.path.length - 1;
          const i = wf._createAt(e);
          i.stickiness = this.stickiness;
          i.offset = i.offset + this.path[n] - t.offset;
          i.path = [...i.path, ...this.path.slice(n + 1)];
          return i;
        }
        toJSON() {
          return {
            root: this.root.toJSON(),
            path: Array.from(this.path),
            stickiness: this.stickiness,
          };
        }
        clone() {
          return new this.constructor(this.root, this.path, this.stickiness);
        }
        static _createAt(t, e, n = "toNone") {
          if (t instanceof wf) {
            return new wf(t.root, t.path, t.stickiness);
          } else {
            const i = t;
            if (e == "end") {
              e = i.maxOffset;
            } else if (e == "before") {
              return this._createBefore(i, n);
            } else if (e == "after") {
              return this._createAfter(i, n);
            } else if (e !== 0 && !e) {
              throw new M("model-createpositionat-offset-required", [this, t]);
            }
            if (!i.is("element") && !i.is("documentFragment")) {
              throw new M("model-position-parent-incorrect", [this, t]);
            }
            const o = i.getPath();
            o.push(e);
            return new this(i.root, o, n);
          }
        }
        static _createAfter(t, e) {
          if (!t.parent) {
            throw new M("model-position-after-root", [this, t], { root: t });
          }
          return this._createAt(t.parent, t.endOffset, e);
        }
        static _createBefore(t, e) {
          if (!t.parent) {
            throw new M("model-position-before-root", t, { root: t });
          }
          return this._createAt(t.parent, t.startOffset, e);
        }
        static fromJSON(t, e) {
          if (t.root === "$graveyard") {
            const n = new wf(e.graveyard, t.path);
            n.stickiness = t.stickiness;
            return n;
          }
          if (!e.getRoot(t.root)) {
            throw new M("model-position-fromjson-no-root", e, {
              rootName: t.root,
            });
          }
          return new wf(e.getRoot(t.root), t.path, t.stickiness);
        }
      }
      wf.prototype.is = function (t) {
        return t === "position" || t === "model:position";
      };
      function Af(t, e) {
        const n = e.getChild(e.offsetToIndex(t.offset));
        if (n && n.is("$text") && n.startOffset < t.offset) {
          return n;
        }
        return null;
      }
      function Cf(t, e, n) {
        if (n !== null) {
          return null;
        }
        return e.getChild(e.offsetToIndex(t.offset));
      }
      function _f(t, e, n) {
        if (n !== null) {
          return null;
        }
        return e.getChild(e.offsetToIndex(t.offset) - 1);
      }
      function vf(t, e, n) {
        if (n + 1 === t.path.length) {
          return false;
        }
        if (!yf(e.path, n + 1)) {
          return false;
        }
        if (!xf(t, n + 1)) {
          return false;
        }
        return true;
      }
      function yf(t, e) {
        while (e < t.length) {
          if (t[e] !== 0) {
            return false;
          }
          e++;
        }
        return true;
      }
      function xf(t, e) {
        let n = t.parent;
        let i = t.path.length - 1;
        let o = 0;
        while (i >= e) {
          if (t.path[i] + o !== n.maxOffset) {
            return false;
          }
          o = 1;
          i--;
          n = n.parent;
        }
        return true;
      }
      class Ef extends df {
        constructor(t, e) {
          super();
          this.start = wf._createAt(t);
          this.end = e ? wf._createAt(e) : wf._createAt(t);
          this.start.stickiness = this.isCollapsed ? "toNone" : "toNext";
          this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
        }
        *[Symbol.iterator]() {
          yield* new bf({ boundaries: this, ignoreElementEnd: true });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          const t = this.start.getParentPath();
          const e = this.end.getParentPath();
          return vt(t, e) == "same";
        }
        get root() {
          return this.start.root;
        }
        containsPosition(t) {
          return t.isAfter(this.start) && t.isBefore(this.end);
        }
        containsRange(t, e = false) {
          if (t.isCollapsed) {
            e = false;
          }
          const n =
            this.containsPosition(t.start) ||
            (e && this.start.isEqual(t.start));
          const i =
            this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
          return n && i;
        }
        containsItem(t) {
          const e = wf._createBefore(t);
          return this.containsPosition(e) || this.start.isEqual(e);
        }
        isEqual(t) {
          return this.start.isEqual(t.start) && this.end.isEqual(t.end);
        }
        isIntersecting(t) {
          return this.start.isBefore(t.end) && this.end.isAfter(t.start);
        }
        getDifference(t) {
          const e = [];
          if (this.isIntersecting(t)) {
            if (this.containsPosition(t.start)) {
              e.push(new Ef(this.start, t.start));
            }
            if (this.containsPosition(t.end)) {
              e.push(new Ef(t.end, this.end));
            }
          } else {
            e.push(new Ef(this.start, this.end));
          }
          return e;
        }
        getIntersection(t) {
          if (this.isIntersecting(t)) {
            let e = this.start;
            let n = this.end;
            if (this.containsPosition(t.start)) {
              e = t.start;
            }
            if (this.containsPosition(t.end)) {
              n = t.end;
            }
            return new Ef(e, n);
          }
          return null;
        }
        getJoined(t, e = false) {
          let n = this.isIntersecting(t);
          if (!n) {
            if (this.start.isBefore(t.start)) {
              n = e ? this.end.isTouching(t.start) : this.end.isEqual(t.start);
            } else {
              n = e ? t.end.isTouching(this.start) : t.end.isEqual(this.start);
            }
          }
          if (!n) {
            return null;
          }
          let i = this.start;
          let o = this.end;
          if (t.start.isBefore(i)) {
            i = t.start;
          }
          if (t.end.isAfter(o)) {
            o = t.end;
          }
          return new Ef(i, o);
        }
        getMinimalFlatRanges() {
          const t = [];
          const e = this.start.getCommonPath(this.end).length;
          const n = wf._createAt(this.start);
          let i = n.parent;
          while (n.path.length > e + 1) {
            const e = i.maxOffset - n.offset;
            if (e !== 0) {
              t.push(new Ef(n, n.getShiftedBy(e)));
            }
            n.path = n.path.slice(0, -1);
            n.offset++;
            i = i.parent;
          }
          while (n.path.length <= this.end.path.length) {
            const e = this.end.path[n.path.length - 1];
            const i = e - n.offset;
            if (i !== 0) {
              t.push(new Ef(n, n.getShiftedBy(i)));
            }
            n.offset = e;
            n.path.push(0);
          }
          return t;
        }
        getWalker(t = {}) {
          t.boundaries = this;
          return new bf(t);
        }
        *getItems(t = {}) {
          t.boundaries = this;
          t.ignoreElementEnd = true;
          const e = new bf(t);
          for (const t of e) {
            yield t.item;
          }
        }
        *getPositions(t = {}) {
          t.boundaries = this;
          const e = new bf(t);
          yield e.position;
          for (const t of e) {
            yield t.nextPosition;
          }
        }
        getTransformedByOperation(t) {
          switch (t.type) {
            case "insert":
              return this._getTransformedByInsertOperation(t);
            case "move":
            case "remove":
            case "reinsert":
              return this._getTransformedByMoveOperation(t);
            case "split":
              return [this._getTransformedBySplitOperation(t)];
            case "merge":
              return [this._getTransformedByMergeOperation(t)];
          }
          return [new Ef(this.start, this.end)];
        }
        getTransformedByOperations(t) {
          const e = [new Ef(this.start, this.end)];
          for (const n of t) {
            for (let t = 0; t < e.length; t++) {
              const i = e[t].getTransformedByOperation(n);
              e.splice(t, 1, ...i);
              t += i.length - 1;
            }
          }
          for (let t = 0; t < e.length; t++) {
            const n = e[t];
            for (let i = t + 1; i < e.length; i++) {
              const t = e[i];
              if (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) {
                e.splice(i, 1);
              }
            }
          }
          return e;
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed) {
            return null;
          }
          const t = this.start.nodeAfter;
          const e = this.end.nodeBefore;
          if (t && t.is("element") && t === e) {
            return t;
          }
          return null;
        }
        toJSON() {
          return { start: this.start.toJSON(), end: this.end.toJSON() };
        }
        clone() {
          return new this.constructor(this.start, this.end);
        }
        _getTransformedByInsertOperation(t, e = false) {
          return this._getTransformedByInsertion(t.position, t.howMany, e);
        }
        _getTransformedByMoveOperation(t, e = false) {
          const n = t.sourcePosition;
          const i = t.howMany;
          const o = t.targetPosition;
          return this._getTransformedByMove(n, o, i, e);
        }
        _getTransformedBySplitOperation(t) {
          const e = this.start._getTransformedBySplitOperation(t);
          let n = this.end._getTransformedBySplitOperation(t);
          if (this.end.isEqual(t.insertionPosition)) {
            n = this.end.getShiftedBy(1);
          }
          if (e.root != n.root) {
            n = this.end.getShiftedBy(-1);
          }
          return new Ef(e, n);
        }
        _getTransformedByMergeOperation(t) {
          if (
            this.start.isEqual(t.targetPosition) &&
            this.end.isEqual(t.deletionPosition)
          ) {
            return new Ef(this.start);
          }
          let e = this.start._getTransformedByMergeOperation(t);
          let n = this.end._getTransformedByMergeOperation(t);
          if (e.root != n.root) {
            n = this.end.getShiftedBy(-1);
          }
          if (e.isAfter(n)) {
            if (t.sourcePosition.isBefore(t.targetPosition)) {
              e = wf._createAt(n);
              e.offset = 0;
            } else {
              if (!t.deletionPosition.isEqual(e)) {
                n = t.deletionPosition;
              }
              e = t.targetPosition;
            }
            return new Ef(e, n);
          }
          return new Ef(e, n);
        }
        _getTransformedByInsertion(t, e, n = false) {
          if (n && this.containsPosition(t)) {
            return [
              new Ef(this.start, t),
              new Ef(
                t.getShiftedBy(e),
                this.end._getTransformedByInsertion(t, e)
              ),
            ];
          } else {
            const n = new Ef(this.start, this.end);
            n.start = n.start._getTransformedByInsertion(t, e);
            n.end = n.end._getTransformedByInsertion(t, e);
            return [n];
          }
        }
        _getTransformedByMove(t, e, n, i = false) {
          if (this.isCollapsed) {
            const i = this.start._getTransformedByMove(t, e, n);
            return [new Ef(i)];
          }
          const o = Ef._createFromPositionAndShift(t, n);
          const r = e._getTransformedByDeletion(t, n);
          if (this.containsPosition(e) && !i) {
            if (
              o.containsPosition(this.start) ||
              o.containsPosition(this.end)
            ) {
              const i = this.start._getTransformedByMove(t, e, n);
              const o = this.end._getTransformedByMove(t, e, n);
              return [new Ef(i, o)];
            }
          }
          let s;
          const a = this.getDifference(o);
          let c = null;
          const l = this.getIntersection(o);
          if (a.length == 1) {
            c = new Ef(
              a[0].start._getTransformedByDeletion(t, n),
              a[0].end._getTransformedByDeletion(t, n)
            );
          } else if (a.length == 2) {
            c = new Ef(this.start, this.end._getTransformedByDeletion(t, n));
          }
          if (c) {
            s = c._getTransformedByInsertion(r, n, l !== null || i);
          } else {
            s = [];
          }
          if (l) {
            const t = new Ef(
              l.start._getCombined(o.start, r),
              l.end._getCombined(o.start, r)
            );
            if (s.length == 2) {
              s.splice(1, 0, t);
            } else {
              s.push(t);
            }
          }
          return s;
        }
        _getTransformedByDeletion(t, e) {
          let n = this.start._getTransformedByDeletion(t, e);
          let i = this.end._getTransformedByDeletion(t, e);
          if (n == null && i == null) {
            return null;
          }
          if (n == null) {
            n = t;
          }
          if (i == null) {
            i = t;
          }
          return new Ef(n, i);
        }
        static _createFromPositionAndShift(t, e) {
          const n = t;
          const i = t.getShiftedBy(e);
          return e > 0 ? new this(n, i) : new this(i, n);
        }
        static _createIn(t) {
          return new this(wf._createAt(t, 0), wf._createAt(t, t.maxOffset));
        }
        static _createOn(t) {
          return this._createFromPositionAndShift(
            wf._createBefore(t),
            t.offsetSize
          );
        }
        static _createFromRanges(t) {
          if (t.length === 0) {
            throw new M("range-create-from-ranges-empty-array", null);
          } else if (t.length == 1) {
            return t[0].clone();
          }
          const e = t[0];
          t.sort((t, e) => (t.start.isAfter(e.start) ? 1 : -1));
          const n = t.indexOf(e);
          const i = new this(e.start, e.end);
          if (n > 0) {
            for (let e = n - 1; true; e++) {
              if (t[e].end.isEqual(i.start)) {
                i.start = wf._createAt(t[e].start);
              } else {
                break;
              }
            }
          }
          for (let e = n + 1; e < t.length; e++) {
            if (t[e].start.isEqual(i.end)) {
              i.end = wf._createAt(t[e].end);
            } else {
              break;
            }
          }
          return i;
        }
        static fromJSON(t, e) {
          return new this(wf.fromJSON(t.start, e), wf.fromJSON(t.end, e));
        }
      }
      Ef.prototype.is = function (t) {
        return t === "range" || t === "model:range";
      };
      class Df extends q() {
        constructor() {
          super();
          this._modelToViewMapping = new WeakMap();
          this._viewToModelMapping = new WeakMap();
          this._viewToModelLengthCallbacks = new Map();
          this._markerNameToElements = new Map();
          this._elementToMarkerNames = new Map();
          this._deferredBindingRemovals = new Map();
          this._unboundMarkerNames = new Set();
          this.on(
            "modelToViewPosition",
            (t, e) => {
              if (e.viewPosition) {
                return;
              }
              const n = this._modelToViewMapping.get(e.modelPosition.parent);
              if (!n) {
                throw new M(
                  "mapping-model-position-view-parent-not-found",
                  this,
                  { modelPosition: e.modelPosition }
                );
              }
              e.viewPosition = this.findPositionIn(n, e.modelPosition.offset);
            },
            { priority: "low" }
          );
          this.on(
            "viewToModelPosition",
            (t, e) => {
              if (e.modelPosition) {
                return;
              }
              const n = this.findMappedViewAncestor(e.viewPosition);
              const i = this._viewToModelMapping.get(n);
              const o = this._toModelOffset(
                e.viewPosition.parent,
                e.viewPosition.offset,
                n
              );
              e.modelPosition = wf._createAt(i, o);
            },
            { priority: "low" }
          );
        }
        bindElements(t, e) {
          this._modelToViewMapping.set(t, e);
          this._viewToModelMapping.set(e, t);
        }
        unbindViewElement(t, e = {}) {
          const n = this.toModelElement(t);
          if (this._elementToMarkerNames.has(t)) {
            for (const e of this._elementToMarkerNames.get(t)) {
              this._unboundMarkerNames.add(e);
            }
          }
          if (e.defer) {
            this._deferredBindingRemovals.set(t, t.root);
          } else {
            this._viewToModelMapping.delete(t);
            if (this._modelToViewMapping.get(n) == t) {
              this._modelToViewMapping.delete(n);
            }
          }
        }
        unbindModelElement(t) {
          const e = this.toViewElement(t);
          this._modelToViewMapping.delete(t);
          if (this._viewToModelMapping.get(e) == t) {
            this._viewToModelMapping.delete(e);
          }
        }
        bindElementToMarker(t, e) {
          const n = this._markerNameToElements.get(e) || new Set();
          n.add(t);
          const i = this._elementToMarkerNames.get(t) || new Set();
          i.add(e);
          this._markerNameToElements.set(e, n);
          this._elementToMarkerNames.set(t, i);
        }
        unbindElementFromMarkerName(t, e) {
          const n = this._markerNameToElements.get(e);
          if (n) {
            n.delete(t);
            if (n.size == 0) {
              this._markerNameToElements.delete(e);
            }
          }
          const i = this._elementToMarkerNames.get(t);
          if (i) {
            i.delete(e);
            if (i.size == 0) {
              this._elementToMarkerNames.delete(t);
            }
          }
        }
        flushUnboundMarkerNames() {
          const t = Array.from(this._unboundMarkerNames);
          this._unboundMarkerNames.clear();
          return t;
        }
        flushDeferredBindings() {
          for (const [t, e] of this._deferredBindingRemovals) {
            if (t.root == e) {
              this.unbindViewElement(t);
            }
          }
          this._deferredBindingRemovals = new Map();
        }
        clearBindings() {
          this._modelToViewMapping = new WeakMap();
          this._viewToModelMapping = new WeakMap();
          this._markerNameToElements = new Map();
          this._elementToMarkerNames = new Map();
          this._unboundMarkerNames = new Set();
          this._deferredBindingRemovals = new Map();
        }
        toModelElement(t) {
          return this._viewToModelMapping.get(t);
        }
        toViewElement(t) {
          return this._modelToViewMapping.get(t);
        }
        toModelRange(t) {
          return new Ef(
            this.toModelPosition(t.start),
            this.toModelPosition(t.end)
          );
        }
        toViewRange(t) {
          return new sh(
            this.toViewPosition(t.start),
            this.toViewPosition(t.end)
          );
        }
        toModelPosition(t) {
          const e = { viewPosition: t, mapper: this };
          this.fire("viewToModelPosition", e);
          return e.modelPosition;
        }
        toViewPosition(t, e = {}) {
          const n = { modelPosition: t, mapper: this, isPhantom: e.isPhantom };
          this.fire("modelToViewPosition", n);
          return n.viewPosition;
        }
        markerNameToElements(t) {
          const e = this._markerNameToElements.get(t);
          if (!e) {
            return null;
          }
          const n = new Set();
          for (const t of e) {
            if (t.is("attributeElement")) {
              for (const e of t.getElementsWithSameId()) {
                n.add(e);
              }
            } else {
              n.add(t);
            }
          }
          return n;
        }
        registerViewToModelLength(t, e) {
          this._viewToModelLengthCallbacks.set(t, e);
        }
        findMappedViewAncestor(t) {
          let e = t.parent;
          while (!this._viewToModelMapping.has(e)) {
            e = e.parent;
          }
          return e;
        }
        _toModelOffset(t, e, n) {
          if (n != t) {
            const i = this._toModelOffset(t.parent, t.index, n);
            const o = this._toModelOffset(t, e, t);
            return i + o;
          }
          if (t.is("$text")) {
            return e;
          }
          let i = 0;
          for (let n = 0; n < e; n++) {
            i += this.getModelLength(t.getChild(n));
          }
          return i;
        }
        getModelLength(t) {
          if (this._viewToModelLengthCallbacks.get(t.name)) {
            const e = this._viewToModelLengthCallbacks.get(t.name);
            return e(t);
          } else if (this._viewToModelMapping.has(t)) {
            return 1;
          } else if (t.is("$text")) {
            return t.data.length;
          } else if (t.is("uiElement")) {
            return 0;
          } else {
            let e = 0;
            for (const n of t.getChildren()) {
              e += this.getModelLength(n);
            }
            return e;
          }
        }
        findPositionIn(t, e) {
          let n;
          let i = 0;
          let o = 0;
          let r = 0;
          if (t.is("$text")) {
            return new rh(t, e);
          }
          while (o < e) {
            n = t.getChild(r);
            i = this.getModelLength(n);
            o += i;
            r++;
          }
          if (o == e) {
            return this._moveViewPositionToTextNode(new rh(t, r));
          } else {
            return this.findPositionIn(n, e - (o - i));
          }
        }
        _moveViewPositionToTextNode(t) {
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          if (e instanceof Yl) {
            return new rh(e, e.data.length);
          } else if (n instanceof Yl) {
            return new rh(n, 0);
          }
          return t;
        }
      }
      class Sf {
        constructor() {
          this._consumable = new Map();
          this._textProxyRegistry = new Map();
        }
        add(t, e) {
          e = Tf(e);
          if (t instanceof gf) {
            t = this._getSymbolForTextProxy(t);
          }
          if (!this._consumable.has(t)) {
            this._consumable.set(t, new Map());
          }
          this._consumable.get(t).set(e, true);
        }
        consume(t, e) {
          e = Tf(e);
          if (t instanceof gf) {
            t = this._getSymbolForTextProxy(t);
          }
          if (this.test(t, e)) {
            this._consumable.get(t).set(e, false);
            return true;
          } else {
            return false;
          }
        }
        test(t, e) {
          e = Tf(e);
          if (t instanceof gf) {
            t = this._getSymbolForTextProxy(t);
          }
          const n = this._consumable.get(t);
          if (n === undefined) {
            return null;
          }
          const i = n.get(e);
          if (i === undefined) {
            return null;
          }
          return i;
        }
        revert(t, e) {
          e = Tf(e);
          if (t instanceof gf) {
            t = this._getSymbolForTextProxy(t);
          }
          const n = this.test(t, e);
          if (n === false) {
            this._consumable.get(t).set(e, true);
            return true;
          } else if (n === true) {
            return false;
          }
          return null;
        }
        verifyAllConsumed(t) {
          const e = [];
          for (const [n, i] of this._consumable) {
            for (const [o, r] of i) {
              const i = o.split(":")[0];
              if (r && t == i) {
                e.push({ event: o, item: n.name || n.description });
              }
            }
          }
          if (e.length) {
            throw new M("conversion-model-consumable-not-consumed", null, {
              items: e,
            });
          }
        }
        _getSymbolForTextProxy(t) {
          let e = null;
          const n = this._textProxyRegistry.get(t.startOffset);
          if (n) {
            const i = n.get(t.endOffset);
            if (i) {
              e = i.get(t.parent);
            }
          }
          if (!e) {
            e = this._addSymbolForTextProxy(t);
          }
          return e;
        }
        _addSymbolForTextProxy(t) {
          const e = t.startOffset;
          const n = t.endOffset;
          const i = t.parent;
          const o = Symbol("$textProxy:" + t.data);
          let r;
          let s;
          r = this._textProxyRegistry.get(e);
          if (!r) {
            r = new Map();
            this._textProxyRegistry.set(e, r);
          }
          s = r.get(n);
          if (!s) {
            s = new Map();
            r.set(n, s);
          }
          s.set(i, o);
          return o;
        }
      }
      function Tf(t) {
        const e = t.split(":");
        if (e[0] == "insert") {
          return e[0];
        }
        if (e[0] == "addMarker" || e[0] == "removeMarker") {
          return t;
        }
        return e.length > 1 ? e[0] + ":" + e[1] : e[0];
      }
      class If extends q() {
        constructor(t) {
          super();
          this._conversionApi = { dispatcher: this, ...t };
          this._firedEventsMap = new WeakMap();
        }
        convertChanges(t, e, n) {
          const i = this._createConversionApi(n, t.getRefreshedItems());
          for (const e of t.getMarkersToRemove()) {
            this._convertMarkerRemove(e.name, e.range, i);
          }
          const o = this._reduceChanges(t.getChanges());
          for (const t of o) {
            if (t.type === "insert") {
              this._convertInsert(
                Ef._createFromPositionAndShift(t.position, t.length),
                i
              );
            } else if (t.type === "reinsert") {
              this._convertReinsert(
                Ef._createFromPositionAndShift(t.position, t.length),
                i
              );
            } else if (t.type === "remove") {
              this._convertRemove(t.position, t.length, t.name, i);
            } else {
              this._convertAttribute(
                t.range,
                t.attributeKey,
                t.attributeOldValue,
                t.attributeNewValue,
                i
              );
            }
          }
          for (const t of i.mapper.flushUnboundMarkerNames()) {
            const n = e.get(t).getRange();
            this._convertMarkerRemove(t, n, i);
            this._convertMarkerAdd(t, n, i);
          }
          for (const e of t.getMarkersToAdd()) {
            this._convertMarkerAdd(e.name, e.range, i);
          }
          i.mapper.flushDeferredBindings();
          i.consumable.verifyAllConsumed("insert");
        }
        convert(t, e, n, i = {}) {
          const o = this._createConversionApi(n, undefined, i);
          this._convertInsert(t, o);
          for (const [t, n] of e) {
            this._convertMarkerAdd(t, n, o);
          }
          o.consumable.verifyAllConsumed("insert");
        }
        convertSelection(t, e, n) {
          const i = Array.from(e.getMarkersAtPosition(t.getFirstPosition()));
          const o = this._createConversionApi(n);
          this._addConsumablesForSelection(o.consumable, t, i);
          this.fire("selection", { selection: t }, o);
          if (!t.isCollapsed) {
            return;
          }
          for (const e of i) {
            const n = e.getRange();
            if (!Mf(t.getFirstPosition(), e, o.mapper)) {
              continue;
            }
            const i = { item: t, markerName: e.name, markerRange: n };
            if (o.consumable.test(t, "addMarker:" + e.name)) {
              this.fire(\`addMarker:\${e.name}\`, i, o);
            }
          }
          for (const e of t.getAttributeKeys()) {
            const n = {
              item: t,
              range: t.getFirstRange(),
              attributeKey: e,
              attributeOldValue: null,
              attributeNewValue: t.getAttribute(e),
            };
            if (o.consumable.test(t, "attribute:" + n.attributeKey)) {
              this.fire(\`attribute:\${n.attributeKey}:$text\`, n, o);
            }
          }
        }
        _convertInsert(t, e, n = {}) {
          if (!n.doNotAddConsumables) {
            this._addConsumablesForInsert(e.consumable, Array.from(t));
          }
          for (const n of Array.from(t.getWalker({ shallow: true })).map(Lf)) {
            this._testAndFire("insert", n, e);
          }
        }
        _convertRemove(t, e, n, i) {
          this.fire(\`remove:\${n}\`, { position: t, length: e }, i);
        }
        _convertAttribute(t, e, n, i, o) {
          this._addConsumablesForRange(o.consumable, t, \`attribute:\${e}\`);
          for (const r of t) {
            const t = {
              item: r.item,
              range: Ef._createFromPositionAndShift(
                r.previousPosition,
                r.length
              ),
              attributeKey: e,
              attributeOldValue: n,
              attributeNewValue: i,
            };
            this._testAndFire(\`attribute:\${e}\`, t, o);
          }
        }
        _convertReinsert(t, e) {
          const n = Array.from(t.getWalker({ shallow: true }));
          this._addConsumablesForInsert(e.consumable, n);
          for (const t of n.map(Lf)) {
            this._testAndFire("insert", { ...t, reconversion: true }, e);
          }
        }
        _convertMarkerAdd(t, e, n) {
          if (e.root.rootName == "$graveyard") {
            return;
          }
          const i = \`addMarker:\${t}\`;
          n.consumable.add(e, i);
          this.fire(i, { markerName: t, markerRange: e }, n);
          if (!n.consumable.consume(e, i)) {
            return;
          }
          this._addConsumablesForRange(n.consumable, e, i);
          for (const o of e.getItems()) {
            if (!n.consumable.test(o, i)) {
              continue;
            }
            const r = {
              item: o,
              range: Ef._createOn(o),
              markerName: t,
              markerRange: e,
            };
            this.fire(i, r, n);
          }
        }
        _convertMarkerRemove(t, e, n) {
          if (e.root.rootName == "$graveyard") {
            return;
          }
          this.fire(\`removeMarker:\${t}\`, { markerName: t, markerRange: e }, n);
        }
        _reduceChanges(t) {
          const e = { changes: t };
          this.fire("reduceChanges", e);
          return e.changes;
        }
        _addConsumablesForInsert(t, e) {
          for (const n of e) {
            const e = n.item;
            if (t.test(e, "insert") === null) {
              t.add(e, "insert");
              for (const n of e.getAttributeKeys()) {
                t.add(e, "attribute:" + n);
              }
            }
          }
          return t;
        }
        _addConsumablesForRange(t, e, n) {
          for (const i of e.getItems()) {
            t.add(i, n);
          }
          return t;
        }
        _addConsumablesForSelection(t, e, n) {
          t.add(e, "selection");
          for (const i of n) {
            t.add(e, "addMarker:" + i.name);
          }
          for (const n of e.getAttributeKeys()) {
            t.add(e, "attribute:" + n);
          }
          return t;
        }
        _testAndFire(t, e, n) {
          const i = Bf(t, e);
          const o = e.item.is("$textProxy")
            ? n.consumable._getSymbolForTextProxy(e.item)
            : e.item;
          const r = this._firedEventsMap.get(n);
          const s = r.get(o);
          if (!s) {
            r.set(o, new Set([i]));
          } else if (!s.has(i)) {
            s.add(i);
          } else {
            return;
          }
          this.fire(i, e, n);
        }
        _testAndFireAddAttributes(t, e) {
          const n = { item: t, range: Ef._createOn(t) };
          for (const t of n.item.getAttributeKeys()) {
            n.attributeKey = t;
            n.attributeOldValue = null;
            n.attributeNewValue = n.item.getAttribute(t);
            this._testAndFire(\`attribute:\${t}\`, n, e);
          }
        }
        _createConversionApi(t, e = new Set(), n = {}) {
          const i = {
            ...this._conversionApi,
            consumable: new Sf(),
            writer: t,
            options: n,
            convertItem: (t) => this._convertInsert(Ef._createOn(t), i),
            convertChildren: (t) =>
              this._convertInsert(Ef._createIn(t), i, {
                doNotAddConsumables: true,
              }),
            convertAttributes: (t) => this._testAndFireAddAttributes(t, i),
            canReuseView: (t) => !e.has(i.mapper.toModelElement(t)),
          };
          this._firedEventsMap.set(i, new Map());
          return i;
        }
      }
      function Mf(t, e, n) {
        const i = e.getRange();
        const o = Array.from(t.getAncestors());
        o.shift();
        o.reverse();
        const r = o.some((t) => {
          if (i.containsItem(t)) {
            const e = n.toViewElement(t);
            return !!e.getCustomProperty("addHighlight");
          }
        });
        return !r;
      }
      function Bf(t, e) {
        const n = e.item.is("element") ? e.item.name : "$text";
        return \`\${t}:\${n}\`;
      }
      function Lf(t) {
        const e = t.item;
        const n = Ef._createFromPositionAndShift(t.previousPosition, t.length);
        return { item: e, range: n };
      }
      class Nf extends q(df) {
        constructor(...t) {
          super();
          this._lastRangeBackward = false;
          this._ranges = [];
          this._attrs = new Map();
          if (t.length) {
            this.setTo(...t);
          }
        }
        get anchor() {
          if (this._ranges.length > 0) {
            const t = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? t.end : t.start;
          }
          return null;
        }
        get focus() {
          if (this._ranges.length > 0) {
            const t = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? t.start : t.end;
          }
          return null;
        }
        get isCollapsed() {
          const t = this._ranges.length;
          if (t === 1) {
            return this._ranges[0].isCollapsed;
          } else {
            return false;
          }
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        isEqual(t) {
          if (this.rangeCount != t.rangeCount) {
            return false;
          } else if (this.rangeCount === 0) {
            return true;
          }
          if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
            return false;
          }
          for (const e of this._ranges) {
            let n = false;
            for (const i of t._ranges) {
              if (e.isEqual(i)) {
                n = true;
                break;
              }
            }
            if (!n) {
              return false;
            }
          }
          return true;
        }
        *getRanges() {
          for (const t of this._ranges) {
            yield new Ef(t.start, t.end);
          }
        }
        getFirstRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.start.isBefore(t.start)) {
              t = e;
            }
          }
          return t ? new Ef(t.start, t.end) : null;
        }
        getLastRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.end.isAfter(t.end)) {
              t = e;
            }
          }
          return t ? new Ef(t.start, t.end) : null;
        }
        getFirstPosition() {
          const t = this.getFirstRange();
          return t ? t.start.clone() : null;
        }
        getLastPosition() {
          const t = this.getLastRange();
          return t ? t.end.clone() : null;
        }
        setTo(...t) {
          let [e, n, i] = t;
          if (typeof n == "object") {
            i = n;
            n = undefined;
          }
          if (e === null) {
            this._setRanges([]);
          } else if (e instanceof Nf) {
            this._setRanges(e.getRanges(), e.isBackward);
          } else if (e && typeof e.getRanges == "function") {
            this._setRanges(e.getRanges(), e.isBackward);
          } else if (e instanceof Ef) {
            this._setRanges([e], !!i && !!i.backward);
          } else if (e instanceof wf) {
            this._setRanges([new Ef(e)]);
          } else if (e instanceof uf) {
            const t = !!i && !!i.backward;
            let o;
            if (n == "in") {
              o = Ef._createIn(e);
            } else if (n == "on") {
              o = Ef._createOn(e);
            } else if (n !== undefined) {
              o = new Ef(wf._createAt(e, n));
            } else {
              throw new M("model-selection-setto-required-second-parameter", [
                this,
                e,
              ]);
            }
            this._setRanges([o], t);
          } else if (yt(e)) {
            this._setRanges(e, i && !!i.backward);
          } else {
            throw new M("model-selection-setto-not-selectable", [this, e]);
          }
        }
        _setRanges(t, e = false) {
          const n = Array.from(t);
          const i = n.some((e) => {
            if (!(e instanceof Ef)) {
              throw new M("model-selection-set-ranges-not-range", [this, t]);
            }
            return this._ranges.every((t) => !t.isEqual(e));
          });
          if (n.length === this._ranges.length && !i) {
            return;
          }
          this._replaceAllRanges(n);
          this._lastRangeBackward = !!e;
          this.fire("change:range", { directChange: true });
        }
        setFocus(t, e) {
          if (this.anchor === null) {
            throw new M("model-selection-setfocus-no-ranges", [this, t]);
          }
          const n = wf._createAt(t, e);
          if (n.compareWith(this.focus) == "same") {
            return;
          }
          const i = this.anchor;
          if (this._ranges.length) {
            this._popRange();
          }
          if (n.compareWith(i) == "before") {
            this._pushRange(new Ef(n, i));
            this._lastRangeBackward = true;
          } else {
            this._pushRange(new Ef(i, n));
            this._lastRangeBackward = false;
          }
          this.fire("change:range", { directChange: true });
        }
        getAttribute(t) {
          return this._attrs.get(t);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        hasAttribute(t) {
          return this._attrs.has(t);
        }
        removeAttribute(t) {
          if (this.hasAttribute(t)) {
            this._attrs.delete(t);
            this.fire("change:attribute", {
              attributeKeys: [t],
              directChange: true,
            });
          }
        }
        setAttribute(t, e) {
          if (this.getAttribute(t) !== e) {
            this._attrs.set(t, e);
            this.fire("change:attribute", {
              attributeKeys: [t],
              directChange: true,
            });
          }
        }
        getSelectedElement() {
          if (this.rangeCount !== 1) {
            return null;
          }
          return this.getFirstRange().getContainedElement();
        }
        *getSelectedBlocks() {
          const t = new WeakSet();
          for (const e of this.getRanges()) {
            const n = Rf(e.start, t);
            if (n && Of(n, e)) {
              yield n;
            }
            for (const n of e.getWalker()) {
              const i = n.item;
              if (n.type == "elementEnd" && Pf(i, t, e)) {
                yield i;
              }
            }
            const i = Rf(e.end, t);
            if (i && !e.end.isTouching(wf._createAt(i, 0)) && Of(i, e)) {
              yield i;
            }
          }
        }
        containsEntireContent(t = this.anchor.root) {
          const e = wf._createAt(t, 0);
          const n = wf._createAt(t, "end");
          return (
            e.isTouching(this.getFirstPosition()) &&
            n.isTouching(this.getLastPosition())
          );
        }
        _pushRange(t) {
          this._checkRange(t);
          this._ranges.push(new Ef(t.start, t.end));
        }
        _checkRange(t) {
          for (let e = 0; e < this._ranges.length; e++) {
            if (t.isIntersecting(this._ranges[e])) {
              throw new M("model-selection-range-intersects", [this, t], {
                addedRange: t,
                intersectingRange: this._ranges[e],
              });
            }
          }
        }
        _replaceAllRanges(t) {
          this._removeAllRanges();
          for (const e of t) {
            this._pushRange(e);
          }
        }
        _removeAllRanges() {
          while (this._ranges.length > 0) {
            this._popRange();
          }
        }
        _popRange() {
          this._ranges.pop();
        }
      }
      Nf.prototype.is = function (t) {
        return t === "selection" || t === "model:selection";
      };
      function zf(t, e) {
        if (e.has(t)) {
          return false;
        }
        e.add(t);
        return t.root.document.model.schema.isBlock(t) && !!t.parent;
      }
      function Pf(t, e, n) {
        return zf(t, e) && Of(t, n);
      }
      function Rf(t, e) {
        const n = t.parent;
        const i = n.root.document.model.schema;
        const o = t.parent.getAncestors({
          parentFirst: true,
          includeSelf: true,
        });
        let r = false;
        const s = o.find((t) => {
          if (r) {
            return false;
          }
          r = i.isLimit(t);
          return !r && zf(t, e);
        });
        o.forEach((t) => e.add(t));
        return s;
      }
      function Of(t, e) {
        const n = jf(t);
        if (!n) {
          return true;
        }
        const i = e.containsRange(Ef._createOn(n), true);
        return !i;
      }
      function jf(t) {
        const e = t.root.document.model.schema;
        let n = t.parent;
        while (n) {
          if (e.isBlock(n)) {
            return n;
          }
          n = n.parent;
        }
      }
      class Ff extends q(Ef) {
        constructor(t, e) {
          super(t, e);
          Vf.call(this);
        }
        detach() {
          this.stopListening();
        }
        toRange() {
          return new Ef(this.start, this.end);
        }
        static fromRange(t) {
          return new Ff(t.start, t.end);
        }
      }
      Ff.prototype.is = function (t) {
        return (
          t === "liveRange" ||
          t === "model:liveRange" ||
          t == "range" ||
          t === "model:range"
        );
      };
      function Vf() {
        this.listenTo(
          this.root.document.model,
          "applyOperation",
          (t, e) => {
            const n = e[0];
            if (!n.isDocumentOperation) {
              return;
            }
            Hf.call(this, n);
          },
          { priority: "low" }
        );
      }
      function Hf(t) {
        const e = this.getTransformedByOperation(t);
        const n = Ef._createFromRanges(e);
        const i = !n.isEqual(this);
        const o = Uf(this, t);
        let r = null;
        if (i) {
          if (n.root.rootName == "$graveyard") {
            if (t.type == "remove") {
              r = t.sourcePosition;
            } else {
              r = t.deletionPosition;
            }
          }
          const e = this.toRange();
          this.start = n.start;
          this.end = n.end;
          this.fire("change:range", e, { deletionPosition: r });
        } else if (o) {
          this.fire("change:content", this.toRange(), { deletionPosition: r });
        }
      }
      function Uf(t, e) {
        switch (e.type) {
          case "insert":
            return t.containsPosition(e.position);
          case "move":
          case "remove":
          case "reinsert":
          case "merge":
            return (
              t.containsPosition(e.sourcePosition) ||
              t.start.isEqual(e.sourcePosition) ||
              t.containsPosition(e.targetPosition)
            );
          case "split":
            return (
              t.containsPosition(e.splitPosition) ||
              t.containsPosition(e.insertionPosition)
            );
        }
        return false;
      }
      const qf = "selection:";
      class Wf extends q(df) {
        constructor(t) {
          super();
          this._selection = new Gf(t);
          this._selection.delegate("change:range").to(this);
          this._selection.delegate("change:attribute").to(this);
          this._selection.delegate("change:marker").to(this);
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get hasOwnRange() {
          return this._selection.hasOwnRange;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get isGravityOverridden() {
          return this._selection.isGravityOverridden;
        }
        get markers() {
          return this._selection.markers;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        getRanges() {
          return this._selection.getRanges();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getSelectedBlocks() {
          return this._selection.getSelectedBlocks();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        containsEntireContent(t) {
          return this._selection.containsEntireContent(t);
        }
        destroy() {
          this._selection.destroy();
        }
        getAttributeKeys() {
          return this._selection.getAttributeKeys();
        }
        getAttributes() {
          return this._selection.getAttributes();
        }
        getAttribute(t) {
          return this._selection.getAttribute(t);
        }
        hasAttribute(t) {
          return this._selection.hasAttribute(t);
        }
        refresh() {
          this._selection.updateMarkers();
          this._selection._updateAttributes(false);
        }
        observeMarkers(t) {
          this._selection.observeMarkers(t);
        }
        _setFocus(t, e) {
          this._selection.setFocus(t, e);
        }
        _setTo(...t) {
          this._selection.setTo(...t);
        }
        _setAttribute(t, e) {
          this._selection.setAttribute(t, e);
        }
        _removeAttribute(t) {
          this._selection.removeAttribute(t);
        }
        _getStoredAttributes() {
          return this._selection.getStoredAttributes();
        }
        _overrideGravity() {
          return this._selection.overrideGravity();
        }
        _restoreGravity(t) {
          this._selection.restoreGravity(t);
        }
        static _getStoreAttributeKey(t) {
          return qf + t;
        }
        static _isStoreAttributeKey(t) {
          return t.startsWith(qf);
        }
      }
      Wf.prototype.is = function (t) {
        return (
          t === "selection" ||
          t == "model:selection" ||
          t == "documentSelection" ||
          t == "model:documentSelection"
        );
      };
      class Gf extends Nf {
        constructor(t) {
          super();
          this.markers = new rl({ idProperty: "name" });
          this._model = t.model;
          this._document = t;
          this._attributePriority = new Map();
          this._selectionRestorePosition = null;
          this._hasChangedRange = false;
          this._overriddenGravityRegister = new Set();
          this._observedMarkers = new Set();
          this.listenTo(
            this._model,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              if (
                !n.isDocumentOperation ||
                n.type == "marker" ||
                n.type == "rename" ||
                n.type == "noop"
              ) {
                return;
              }
              if (this._ranges.length == 0 && this._selectionRestorePosition) {
                this._fixGraveyardSelection(this._selectionRestorePosition);
              }
              this._selectionRestorePosition = null;
              if (this._hasChangedRange) {
                this._hasChangedRange = false;
                this.fire("change:range", { directChange: false });
              }
            },
            { priority: "lowest" }
          );
          this.on("change:range", () => {
            this._validateSelectionRanges(this.getRanges());
          });
          this.listenTo(this._model.markers, "update", (t, e, n, i) => {
            this._updateMarker(e, i);
          });
          this.listenTo(this._document, "change", (t, e) => {
            Kf(this._model, e);
          });
        }
        get isCollapsed() {
          const t = this._ranges.length;
          return t === 0
            ? this._document._getDefaultRange().isCollapsed
            : super.isCollapsed;
        }
        get anchor() {
          return super.anchor || this._document._getDefaultRange().start;
        }
        get focus() {
          return super.focus || this._document._getDefaultRange().end;
        }
        get rangeCount() {
          return this._ranges.length ? this._ranges.length : 1;
        }
        get hasOwnRange() {
          return this._ranges.length > 0;
        }
        get isGravityOverridden() {
          return !!this._overriddenGravityRegister.size;
        }
        destroy() {
          for (let t = 0; t < this._ranges.length; t++) {
            this._ranges[t].detach();
          }
          this.stopListening();
        }
        *getRanges() {
          if (this._ranges.length) {
            yield* super.getRanges();
          } else {
            yield this._document._getDefaultRange();
          }
        }
        getFirstRange() {
          return super.getFirstRange() || this._document._getDefaultRange();
        }
        getLastRange() {
          return super.getLastRange() || this._document._getDefaultRange();
        }
        setTo(...t) {
          super.setTo(...t);
          this._updateAttributes(true);
          this.updateMarkers();
        }
        setFocus(t, e) {
          super.setFocus(t, e);
          this._updateAttributes(true);
          this.updateMarkers();
        }
        setAttribute(t, e) {
          if (this._setAttribute(t, e)) {
            const e = [t];
            this.fire("change:attribute", {
              attributeKeys: e,
              directChange: true,
            });
          }
        }
        removeAttribute(t) {
          if (this._removeAttribute(t)) {
            const e = [t];
            this.fire("change:attribute", {
              attributeKeys: e,
              directChange: true,
            });
          }
        }
        overrideGravity() {
          const t = E();
          this._overriddenGravityRegister.add(t);
          if (this._overriddenGravityRegister.size === 1) {
            this._updateAttributes(true);
          }
          return t;
        }
        restoreGravity(t) {
          if (!this._overriddenGravityRegister.has(t)) {
            throw new M("document-selection-gravity-wrong-restore", this, {
              uid: t,
            });
          }
          this._overriddenGravityRegister.delete(t);
          if (!this.isGravityOverridden) {
            this._updateAttributes(true);
          }
        }
        observeMarkers(t) {
          this._observedMarkers.add(t);
          this.updateMarkers();
        }
        _replaceAllRanges(t) {
          this._validateSelectionRanges(t);
          super._replaceAllRanges(t);
        }
        _popRange() {
          this._ranges.pop().detach();
        }
        _pushRange(t) {
          const e = this._prepareRange(t);
          if (e) {
            this._ranges.push(e);
          }
        }
        _validateSelectionRanges(t) {
          for (const e of t) {
            if (!this._document._validateSelectionRange(e)) {
              throw new M("document-selection-wrong-position", this, {
                range: e,
              });
            }
          }
        }
        _prepareRange(t) {
          this._checkRange(t);
          if (t.root == this._document.graveyard) {
            return;
          }
          const e = Ff.fromRange(t);
          e.on("change:range", (t, n, i) => {
            this._hasChangedRange = true;
            if (e.root == this._document.graveyard) {
              this._selectionRestorePosition = i.deletionPosition;
              const t = this._ranges.indexOf(e);
              this._ranges.splice(t, 1);
              e.detach();
            }
          });
          return e;
        }
        updateMarkers() {
          if (!this._observedMarkers.size) {
            return;
          }
          const t = [];
          let e = false;
          for (const e of this._model.markers) {
            const n = e.name.split(":", 1)[0];
            if (!this._observedMarkers.has(n)) {
              continue;
            }
            const i = e.getRange();
            for (const n of this.getRanges()) {
              if (i.containsRange(n, !n.isCollapsed)) {
                t.push(e);
              }
            }
          }
          const n = Array.from(this.markers);
          for (const n of t) {
            if (!this.markers.has(n)) {
              this.markers.add(n);
              e = true;
            }
          }
          for (const n of Array.from(this.markers)) {
            if (!t.includes(n)) {
              this.markers.remove(n);
              e = true;
            }
          }
          if (e) {
            this.fire("change:marker", { oldMarkers: n, directChange: false });
          }
        }
        _updateMarker(t, e) {
          const n = t.name.split(":", 1)[0];
          if (!this._observedMarkers.has(n)) {
            return;
          }
          let i = false;
          const o = Array.from(this.markers);
          const r = this.markers.has(t);
          if (!e) {
            if (r) {
              this.markers.remove(t);
              i = true;
            }
          } else {
            let n = false;
            for (const t of this.getRanges()) {
              if (e.containsRange(t, !t.isCollapsed)) {
                n = true;
                break;
              }
            }
            if (n && !r) {
              this.markers.add(t);
              i = true;
            } else if (!n && r) {
              this.markers.remove(t);
              i = true;
            }
          }
          if (i) {
            this.fire("change:marker", { oldMarkers: o, directChange: false });
          }
        }
        _updateAttributes(t) {
          const e = dl(this._getSurroundingAttributes());
          const n = dl(this.getAttributes());
          if (t) {
            this._attributePriority = new Map();
            this._attrs = new Map();
          } else {
            for (const [t, e] of this._attributePriority) {
              if (e == "low") {
                this._attrs.delete(t);
                this._attributePriority.delete(t);
              }
            }
          }
          this._setAttributesTo(e);
          const i = [];
          for (const [t, e] of this.getAttributes()) {
            if (!n.has(t) || n.get(t) !== e) {
              i.push(t);
            }
          }
          for (const [t] of n) {
            if (!this.hasAttribute(t)) {
              i.push(t);
            }
          }
          if (i.length > 0) {
            this.fire("change:attribute", {
              attributeKeys: i,
              directChange: false,
            });
          }
        }
        _setAttribute(t, e, n = true) {
          const i = n ? "normal" : "low";
          if (i == "low" && this._attributePriority.get(t) == "normal") {
            return false;
          }
          const o = super.getAttribute(t);
          if (o === e) {
            return false;
          }
          this._attrs.set(t, e);
          this._attributePriority.set(t, i);
          return true;
        }
        _removeAttribute(t, e = true) {
          const n = e ? "normal" : "low";
          if (n == "low" && this._attributePriority.get(t) == "normal") {
            return false;
          }
          this._attributePriority.set(t, n);
          if (!super.hasAttribute(t)) {
            return false;
          }
          this._attrs.delete(t);
          return true;
        }
        _setAttributesTo(t) {
          const e = new Set();
          for (const [e, n] of this.getAttributes()) {
            if (t.get(e) === n) {
              continue;
            }
            this._removeAttribute(e, false);
          }
          for (const [n, i] of t) {
            const t = this._setAttribute(n, i, false);
            if (t) {
              e.add(n);
            }
          }
          return e;
        }
        *getStoredAttributes() {
          const t = this.getFirstPosition().parent;
          if (this.isCollapsed && t.isEmpty) {
            for (const e of t.getAttributeKeys()) {
              if (e.startsWith(qf)) {
                const n = e.substr(qf.length);
                yield [n, t.getAttribute(e)];
              }
            }
          }
        }
        _getSurroundingAttributes() {
          const t = this.getFirstPosition();
          const e = this._model.schema;
          let n = null;
          if (!this.isCollapsed) {
            const t = this.getFirstRange();
            for (const i of t) {
              if (i.item.is("element") && e.isObject(i.item)) {
                break;
              }
              if (i.type == "text") {
                n = i.item.getAttributes();
                break;
              }
            }
          } else {
            const i = t.textNode ? t.textNode : t.nodeBefore;
            const o = t.textNode ? t.textNode : t.nodeAfter;
            if (!this.isGravityOverridden) {
              n = $f(i);
            }
            if (!n) {
              n = $f(o);
            }
            if (!this.isGravityOverridden && !n) {
              let t = i;
              while (t && !e.isInline(t) && !n) {
                t = t.previousSibling;
                n = $f(t);
              }
            }
            if (!n) {
              let t = o;
              while (t && !e.isInline(t) && !n) {
                t = t.nextSibling;
                n = $f(t);
              }
            }
            if (!n) {
              n = this.getStoredAttributes();
            }
          }
          return n;
        }
        _fixGraveyardSelection(t) {
          const e = this._model.schema.getNearestSelectionRange(t);
          if (e) {
            this._pushRange(e);
          }
        }
      }
      function $f(t) {
        if (t instanceof gf || t instanceof mf) {
          return t.getAttributes();
        }
        return null;
      }
      function Kf(t, e) {
        const n = t.document.differ;
        for (const i of n.getChanges()) {
          if (i.type != "insert") {
            continue;
          }
          const n = i.position.parent;
          const o = i.length === n.maxOffset;
          if (o) {
            t.enqueueChange(e, (t) => {
              const e = Array.from(n.getAttributeKeys()).filter((t) =>
                t.startsWith(qf)
              );
              for (const i of e) {
                t.removeAttribute(i, n);
              }
            });
          }
        }
      }
      class Yf {
        constructor(t) {
          this._dispatchers = t;
        }
        add(t) {
          for (const e of this._dispatchers) {
            t(e);
          }
          return this;
        }
      }
      var Zf = 1,
        Qf = 4;
      function Jf(t) {
        return za(t, Zf | Qf);
      }
      const Xf = Jf;
      class tp extends Yf {
        elementToElement(t) {
          return this.add(_p(t));
        }
        elementToStructure(t) {
          return this.add(vp(t));
        }
        attributeToElement(t) {
          return this.add(yp(t));
        }
        attributeToAttribute(t) {
          return this.add(xp(t));
        }
        markerToElement(t) {
          return this.add(Ep(t));
        }
        markerToHighlight(t) {
          return this.add(Sp(t));
        }
        markerToData(t) {
          return this.add(Dp(t));
        }
      }
      function ep() {
        return (t, e, n) => {
          if (!n.consumable.consume(e.item, t.name)) {
            return;
          }
          const i = n.writer;
          const o = n.mapper.toViewPosition(e.range.start);
          const r = i.createText(e.item.data);
          i.insert(o, r);
        };
      }
      function np() {
        return (t, e, n) => {
          n.convertAttributes(e.item);
          if (!e.reconversion && e.item.is("element") && !e.item.isEmpty) {
            n.convertChildren(e.item);
          }
        };
      }
      function ip() {
        return (t, e, n) => {
          const i = n.mapper.toViewPosition(e.position);
          const o = e.position.getShiftedBy(e.length);
          const r = n.mapper.toViewPosition(o, { isPhantom: true });
          const s = n.writer.createRange(i, r);
          const a = n.writer.remove(s.getTrimmed());
          for (const t of n.writer.createRangeIn(a).getItems()) {
            n.mapper.unbindViewElement(t, { defer: true });
          }
        };
      }
      function op(t, e) {
        const n = t.createAttributeElement("span", e.attributes);
        if (e.classes) {
          n._addClass(e.classes);
        }
        if (typeof e.priority === "number") {
          n._priority = e.priority;
        }
        n._id = e.id;
        return n;
      }
      function rp() {
        return (t, e, n) => {
          const i = e.selection;
          if (i.isCollapsed) {
            return;
          }
          if (!n.consumable.consume(i, "selection")) {
            return;
          }
          const o = [];
          for (const t of i.getRanges()) {
            o.push(n.mapper.toViewRange(t));
          }
          n.writer.setSelection(o, { backward: i.isBackward });
        };
      }
      function sp() {
        return (t, e, n) => {
          const i = e.selection;
          if (!i.isCollapsed) {
            return;
          }
          if (!n.consumable.consume(i, "selection")) {
            return;
          }
          const o = n.writer;
          const r = i.getFirstPosition();
          const s = n.mapper.toViewPosition(r);
          const a = o.breakAttributes(s);
          o.setSelection(a);
        };
      }
      function ap() {
        return (t, e, n) => {
          const i = n.writer;
          const o = i.document.selection;
          for (const t of o.getRanges()) {
            if (t.isCollapsed) {
              if (t.end.parent.isAttached()) {
                n.writer.mergeAttributes(t.start);
              }
            }
          }
          i.setSelection(null);
        };
      }
      function cp(t) {
        return (e, n, i) => {
          if (!i.consumable.test(n.item, e.name)) {
            return;
          }
          const o = t(n.attributeOldValue, i, n);
          const r = t(n.attributeNewValue, i, n);
          if (!o && !r) {
            return;
          }
          i.consumable.consume(n.item, e.name);
          const s = i.writer;
          const a = s.document.selection;
          if (n.item instanceof Nf || n.item instanceof Wf) {
            s.wrap(a.getFirstRange(), r);
          } else {
            let t = i.mapper.toViewRange(n.range);
            if (n.attributeOldValue !== null && o) {
              t = s.unwrap(t, o);
            }
            if (n.attributeNewValue !== null && r) {
              s.wrap(t, r);
            }
          }
        };
      }
      function lp(t, e = Up) {
        return (n, i, o) => {
          if (!e(i.item, o.consumable, { preflight: true })) {
            return;
          }
          const r = t(i.item, o, i);
          if (!r) {
            return;
          }
          e(i.item, o.consumable);
          const s = o.mapper.toViewPosition(i.range.start);
          o.mapper.bindElements(i.item, r);
          o.writer.insert(s, r);
          o.convertAttributes(i.item);
          Vp(r, i.item.getChildren(), o, { reconversion: i.reconversion });
        };
      }
      function dp(t, e) {
        return (n, i, o) => {
          if (!e(i.item, o.consumable, { preflight: true })) {
            return;
          }
          const r = new Map();
          o.writer._registerSlotFactory(Op(i.item, r, o));
          const s = t(i.item, o, i);
          o.writer._clearSlotFactory();
          if (!s) {
            return;
          }
          jp(i.item, r, o);
          e(i.item, o.consumable);
          const a = o.mapper.toViewPosition(i.range.start);
          o.mapper.bindElements(i.item, s);
          o.writer.insert(a, s);
          o.convertAttributes(i.item);
          Fp(s, r, o, { reconversion: i.reconversion });
        };
      }
      function up(t) {
        return (e, n, i) => {
          n.isOpening = true;
          const o = t(n, i);
          n.isOpening = false;
          const r = t(n, i);
          if (!o || !r) {
            return;
          }
          const s = n.markerRange;
          if (s.isCollapsed && !i.consumable.consume(s, e.name)) {
            return;
          }
          for (const t of s) {
            if (!i.consumable.consume(t.item, e.name)) {
              return;
            }
          }
          const a = i.mapper;
          const c = i.writer;
          c.insert(a.toViewPosition(s.start), o);
          i.mapper.bindElementToMarker(o, n.markerName);
          if (!s.isCollapsed) {
            c.insert(a.toViewPosition(s.end), r);
            i.mapper.bindElementToMarker(r, n.markerName);
          }
          e.stop();
        };
      }
      function hp() {
        return (t, e, n) => {
          const i = n.mapper.markerNameToElements(e.markerName);
          if (!i) {
            return;
          }
          for (const t of i) {
            n.mapper.unbindElementFromMarkerName(t, e.markerName);
            n.writer.clear(n.writer.createRangeOn(t), t);
          }
          n.writer.clearClonedElementsGroup(e.markerName);
          t.stop();
        };
      }
      function mp(t) {
        return (e, n, i) => {
          const o = t(n.markerName, i);
          if (!o) {
            return;
          }
          const r = n.markerRange;
          if (!i.consumable.consume(r, e.name)) {
            return;
          }
          gp(r, false, i, n, o);
          gp(r, true, i, n, o);
          e.stop();
        };
      }
      function gp(t, e, n, i, o) {
        const r = e ? t.start : t.end;
        const s = r.nodeAfter && r.nodeAfter.is("element") ? r.nodeAfter : null;
        const a =
          r.nodeBefore && r.nodeBefore.is("element") ? r.nodeBefore : null;
        if (s || a) {
          let t;
          let r;
          if ((e && s) || (!e && !a)) {
            t = s;
            r = true;
          } else {
            t = a;
            r = false;
          }
          const c = n.mapper.toViewElement(t);
          if (c) {
            fp(c, e, r, n, i, o);
            return;
          }
        }
        const c = n.mapper.toViewPosition(r);
        pp(c, e, n, i, o);
      }
      function fp(t, e, n, i, o, r) {
        const s = \`data-\${r.group}-\${e ? "start" : "end"}-\${
          n ? "before" : "after"
        }\`;
        const a = t.hasAttribute(s) ? t.getAttribute(s).split(",") : [];
        a.unshift(r.name);
        i.writer.setAttribute(s, a.join(","), t);
        i.mapper.bindElementToMarker(t, o.markerName);
      }
      function pp(t, e, n, i, o) {
        const r = \`\${o.group}-\${e ? "start" : "end"}\`;
        const s = o.name ? { name: o.name } : null;
        const a = n.writer.createUIElement(r, s);
        n.writer.insert(t, a);
        n.mapper.bindElementToMarker(a, i.markerName);
      }
      function bp(t) {
        return (e, n, i) => {
          const o = t(n.markerName, i);
          if (!o) {
            return;
          }
          const r = i.mapper.markerNameToElements(n.markerName);
          if (!r) {
            return;
          }
          for (const t of r) {
            i.mapper.unbindElementFromMarkerName(t, n.markerName);
            if (t.is("containerElement")) {
              s(\`data-\${o.group}-start-before\`, t);
              s(\`data-\${o.group}-start-after\`, t);
              s(\`data-\${o.group}-end-before\`, t);
              s(\`data-\${o.group}-end-after\`, t);
            } else {
              i.writer.clear(i.writer.createRangeOn(t), t);
            }
          }
          i.writer.clearClonedElementsGroup(n.markerName);
          e.stop();
          function s(t, e) {
            if (e.hasAttribute(t)) {
              const n = new Set(e.getAttribute(t).split(","));
              n.delete(o.name);
              if (n.size == 0) {
                i.writer.removeAttribute(t, e);
              } else {
                i.writer.setAttribute(t, Array.from(n).join(","), e);
              }
            }
          }
        };
      }
      function kp(t) {
        return (e, n, i) => {
          if (!i.consumable.test(n.item, e.name)) {
            return;
          }
          const o = t(n.attributeOldValue, i, n);
          const r = t(n.attributeNewValue, i, n);
          if (!o && !r) {
            return;
          }
          i.consumable.consume(n.item, e.name);
          const s = i.mapper.toViewElement(n.item);
          const a = i.writer;
          if (!s) {
            throw new M(
              "conversion-attribute-to-attribute-on-text",
              i.dispatcher,
              n
            );
          }
          if (n.attributeOldValue !== null && o) {
            if (o.key == "class") {
              const t = Yc(o.value);
              for (const e of t) {
                a.removeClass(e, s);
              }
            } else if (o.key == "style") {
              const t = Object.keys(o.value);
              for (const e of t) {
                a.removeStyle(e, s);
              }
            } else {
              a.removeAttribute(o.key, s);
            }
          }
          if (n.attributeNewValue !== null && r) {
            if (r.key == "class") {
              const t = Yc(r.value);
              for (const e of t) {
                a.addClass(e, s);
              }
            } else if (r.key == "style") {
              const t = Object.keys(r.value);
              for (const e of t) {
                a.setStyle(e, r.value[e], s);
              }
            } else {
              a.setAttribute(r.key, r.value, s);
            }
          }
        };
      }
      function wp(t) {
        return (e, n, i) => {
          if (!n.item) {
            return;
          }
          if (
            !(n.item instanceof Nf || n.item instanceof Wf) &&
            !n.item.is("$textProxy")
          ) {
            return;
          }
          const o = Np(t, n, i);
          if (!o) {
            return;
          }
          if (!i.consumable.consume(n.item, e.name)) {
            return;
          }
          const r = i.writer;
          const s = op(r, o);
          const a = r.document.selection;
          if (n.item instanceof Nf || n.item instanceof Wf) {
            r.wrap(a.getFirstRange(), s);
          } else {
            const t = i.mapper.toViewRange(n.range);
            const e = r.wrap(t, s);
            for (const t of e.getItems()) {
              if (t.is("attributeElement") && t.isSimilar(s)) {
                i.mapper.bindElementToMarker(t, n.markerName);
                break;
              }
            }
          }
        };
      }
      function Ap(t) {
        return (e, n, i) => {
          if (!n.item) {
            return;
          }
          if (!(n.item instanceof ff)) {
            return;
          }
          const o = Np(t, n, i);
          if (!o) {
            return;
          }
          if (!i.consumable.test(n.item, e.name)) {
            return;
          }
          const r = i.mapper.toViewElement(n.item);
          if (r && r.getCustomProperty("addHighlight")) {
            i.consumable.consume(n.item, e.name);
            for (const t of Ef._createIn(n.item)) {
              i.consumable.consume(t.item, e.name);
            }
            const t = r.getCustomProperty("addHighlight");
            t(r, o, i.writer);
            i.mapper.bindElementToMarker(r, n.markerName);
          }
        };
      }
      function Cp(t) {
        return (e, n, i) => {
          if (n.markerRange.isCollapsed) {
            return;
          }
          const o = Np(t, n, i);
          if (!o) {
            return;
          }
          const r = op(i.writer, o);
          const s = i.mapper.markerNameToElements(n.markerName);
          if (!s) {
            return;
          }
          for (const t of s) {
            i.mapper.unbindElementFromMarkerName(t, n.markerName);
            if (t.is("attributeElement")) {
              i.writer.unwrap(i.writer.createRangeOn(t), r);
            } else {
              const e = t.getCustomProperty("removeHighlight");
              e(t, o.id, i.writer);
            }
          }
          i.writer.clearClonedElementsGroup(n.markerName);
          e.stop();
        };
      }
      function _p(t) {
        const e = Tp(t.model);
        const n = Ip(t.view, "container");
        if (e.attributes.length) {
          e.children = true;
        }
        return (i) => {
          i.on(\`insert:\${e.name}\`, lp(n, Rp(e)), {
            priority: t.converterPriority || "normal",
          });
          if (e.children || e.attributes.length) {
            i.on("reduceChanges", Pp(e), { priority: "low" });
          }
        };
      }
      function vp(t) {
        const e = Tp(t.model);
        const n = Ip(t.view, "container");
        e.children = true;
        return (i) => {
          if (i._conversionApi.schema.checkChild(e.name, "$text")) {
            throw new M("conversion-element-to-structure-disallowed-text", i, {
              elementName: e.name,
            });
          }
          i.on(\`insert:\${e.name}\`, dp(n, Rp(e)), {
            priority: t.converterPriority || "normal",
          });
          i.on("reduceChanges", Pp(e), { priority: "low" });
        };
      }
      function yp(t) {
        t = Xf(t);
        let e = t.model;
        if (typeof e == "string") {
          e = { key: e };
        }
        let n = \`attribute:\${e.key}\`;
        if (e.name) {
          n += ":" + e.name;
        }
        if (e.values) {
          for (const n of e.values) {
            t.view[n] = Ip(t.view[n], "attribute");
          }
        } else {
          t.view = Ip(t.view, "attribute");
        }
        const i = Bp(t);
        return (e) => {
          e.on(n, cp(i), { priority: t.converterPriority || "normal" });
        };
      }
      function xp(t) {
        t = Xf(t);
        let e = t.model;
        if (typeof e == "string") {
          e = { key: e };
        }
        let n = \`attribute:\${e.key}\`;
        if (e.name) {
          n += ":" + e.name;
        }
        if (e.values) {
          for (const n of e.values) {
            t.view[n] = Lp(t.view[n]);
          }
        } else {
          t.view = Lp(t.view);
        }
        const i = Bp(t);
        return (e) => {
          e.on(n, kp(i), { priority: t.converterPriority || "normal" });
        };
      }
      function Ep(t) {
        const e = Ip(t.view, "ui");
        return (n) => {
          n.on(\`addMarker:\${t.model}\`, up(e), {
            priority: t.converterPriority || "normal",
          });
          n.on(\`removeMarker:\${t.model}\`, hp(), {
            priority: t.converterPriority || "normal",
          });
        };
      }
      function Dp(t) {
        t = Xf(t);
        const e = t.model;
        let n = t.view;
        if (!n) {
          n = (n) => ({ group: e, name: n.substr(t.model.length + 1) });
        }
        return (i) => {
          i.on(\`addMarker:\${e}\`, mp(n), {
            priority: t.converterPriority || "normal",
          });
          i.on(\`removeMarker:\${e}\`, bp(n), {
            priority: t.converterPriority || "normal",
          });
        };
      }
      function Sp(t) {
        return (e) => {
          e.on(\`addMarker:\${t.model}\`, wp(t.view), {
            priority: t.converterPriority || "normal",
          });
          e.on(\`addMarker:\${t.model}\`, Ap(t.view), {
            priority: t.converterPriority || "normal",
          });
          e.on(\`removeMarker:\${t.model}\`, Cp(t.view), {
            priority: t.converterPriority || "normal",
          });
        };
      }
      function Tp(t) {
        if (typeof t == "string") {
          t = { name: t };
        }
        if (!t.attributes) {
          t.attributes = [];
        } else if (!Array.isArray(t.attributes)) {
          t.attributes = [t.attributes];
        }
        t.children = !!t.children;
        return t;
      }
      function Ip(t, e) {
        if (typeof t == "function") {
          return t;
        }
        return (n, i) => Mp(t, i, e);
      }
      function Mp(t, e, n) {
        if (typeof t == "string") {
          t = { name: t };
        }
        let i;
        const o = e.writer;
        const r = Object.assign({}, t.attributes);
        if (n == "container") {
          i = o.createContainerElement(t.name, r);
        } else if (n == "attribute") {
          const e = { priority: t.priority || Ah.DEFAULT_PRIORITY };
          i = o.createAttributeElement(t.name, r, e);
        } else {
          i = o.createUIElement(t.name, r);
        }
        if (t.styles) {
          const e = Object.keys(t.styles);
          for (const n of e) {
            o.setStyle(n, t.styles[n], i);
          }
        }
        if (t.classes) {
          const e = t.classes;
          if (typeof e == "string") {
            o.addClass(e, i);
          } else {
            for (const t of e) {
              o.addClass(t, i);
            }
          }
        }
        return i;
      }
      function Bp(t) {
        if (t.model.values) {
          return (e, n, i) => {
            const o = t.view[e];
            if (o) {
              return o(e, n, i);
            }
            return null;
          };
        } else {
          return t.view;
        }
      }
      function Lp(t) {
        if (typeof t == "string") {
          return (e) => ({ key: t, value: e });
        } else if (typeof t == "object") {
          if (t.value) {
            return () => t;
          } else {
            return (e) => ({ key: t.key, value: e });
          }
        } else {
          return t;
        }
      }
      function Np(t, e, n) {
        const i = typeof t == "function" ? t(e, n) : t;
        if (!i) {
          return null;
        }
        if (!i.priority) {
          i.priority = 10;
        }
        if (!i.id) {
          i.id = e.markerName;
        }
        return i;
      }
      function zp(t) {
        return (e, n) => {
          if (!e.is("element", t.name)) {
            return false;
          }
          if (n.type == "attribute") {
            if (t.attributes.includes(n.attributeKey)) {
              return true;
            }
          } else {
            if (t.children) {
              return true;
            }
          }
          return false;
        };
      }
      function Pp(t) {
        const e = zp(t);
        return (t, n) => {
          const i = [];
          if (!n.reconvertedElements) {
            n.reconvertedElements = new Set();
          }
          for (const t of n.changes) {
            const o =
              t.type == "attribute"
                ? t.range.start.nodeAfter
                : t.position.parent;
            if (!o || !e(o, t)) {
              i.push(t);
              continue;
            }
            if (!n.reconvertedElements.has(o)) {
              n.reconvertedElements.add(o);
              const t = wf._createBefore(o);
              i.push(
                { type: "remove", name: o.name, position: t, length: 1 },
                { type: "reinsert", name: o.name, position: t, length: 1 }
              );
            }
          }
          n.changes = i;
        };
      }
      function Rp(t) {
        return (e, n, i = {}) => {
          const o = ["insert"];
          for (const n of t.attributes) {
            if (e.hasAttribute(n)) {
              o.push(\`attribute:\${n}\`);
            }
          }
          if (!o.every((t) => n.test(e, t))) {
            return false;
          }
          if (!i.preflight) {
            o.forEach((t) => n.consume(e, t));
          }
          return true;
        };
      }
      function Op(t, e, n) {
        return (i, o = "children") => {
          const r = i.createContainerElement("$slot");
          let s = null;
          if (o === "children") {
            s = Array.from(t.getChildren());
          } else if (typeof o == "function") {
            s = Array.from(t.getChildren()).filter((t) => o(t));
          } else {
            throw new M("conversion-slot-mode-unknown", n.dispatcher, {
              modeOrFilter: o,
            });
          }
          e.set(r, s);
          return r;
        };
      }
      function jp(t, e, n) {
        const i = Array.from(e.values()).flat();
        const o = new Set(i);
        if (o.size != i.length) {
          throw new M("conversion-slot-filter-overlap", n.dispatcher, {
            element: t,
          });
        }
        if (o.size != t.childCount) {
          throw new M("conversion-slot-filter-incomplete", n.dispatcher, {
            element: t,
          });
        }
      }
      function Fp(t, e, n, i) {
        n.mapper.on("modelToViewPosition", s, { priority: "highest" });
        let o = null;
        let r = null;
        for ([o, r] of e) {
          Vp(t, r, n, i);
          n.writer.move(
            n.writer.createRangeIn(o),
            n.writer.createPositionBefore(o)
          );
          n.writer.remove(o);
        }
        n.mapper.off("modelToViewPosition", s);
        function s(t, e) {
          const n = e.modelPosition.nodeAfter;
          const i = r.indexOf(n);
          if (i < 0) {
            return;
          }
          e.viewPosition = e.mapper.findPositionIn(o, i);
        }
      }
      function Vp(t, e, n, i) {
        for (const o of e) {
          if (!Hp(t.root, o, n, i)) {
            n.convertItem(o);
          }
        }
      }
      function Hp(t, e, n, i) {
        const { writer: o, mapper: r } = n;
        if (!i.reconversion) {
          return false;
        }
        const s = r.toViewElement(e);
        if (!s || s.root == t) {
          return false;
        }
        if (!n.canReuseView(s)) {
          return false;
        }
        o.move(o.createRangeOn(s), r.toViewPosition(wf._createBefore(e)));
        return true;
      }
      function Up(t, e, { preflight: n } = {}) {
        if (n) {
          return e.test(t, "insert");
        } else {
          return e.consume(t, "insert");
        }
      }
      function qp(t) {
        const { schema: e, document: n } = t.model;
        for (const i of n.getRootNames()) {
          const o = n.getRoot(i);
          if (o.isEmpty && !e.checkChild(o, "$text")) {
            if (e.checkChild(o, "paragraph")) {
              t.insertElement("paragraph", o);
              return true;
            }
          }
        }
        return false;
      }
      function Wp(t, e, n) {
        const i = n.createContext(t);
        if (!n.checkChild(i, "paragraph")) {
          return false;
        }
        if (!n.checkChild(i.push("paragraph"), e)) {
          return false;
        }
        return true;
      }
      function Gp(t, e) {
        const n = e.createElement("paragraph");
        e.insert(n, t);
        return e.createPositionAt(n, 0);
      }
      class $p extends Yf {
        elementToElement(t) {
          return this.add(Qp(t));
        }
        elementToAttribute(t) {
          return this.add(Jp(t));
        }
        attributeToAttribute(t) {
          return this.add(Xp(t));
        }
        elementToMarker(t) {
          return this.add(tb(t));
        }
        dataToMarker(t) {
          return this.add(eb(t));
        }
      }
      function Kp() {
        return (t, e, n) => {
          if (
            !e.modelRange &&
            n.consumable.consume(e.viewItem, { name: true })
          ) {
            const { modelRange: t, modelCursor: i } = n.convertChildren(
              e.viewItem,
              e.modelCursor
            );
            e.modelRange = t;
            e.modelCursor = i;
          }
        };
      }
      function Yp() {
        return (t, e, { schema: n, consumable: i, writer: o }) => {
          let r = e.modelCursor;
          if (!i.test(e.viewItem)) {
            return;
          }
          if (!n.checkChild(r, "$text")) {
            if (!Wp(r, "$text", n)) {
              return;
            }
            if (e.viewItem.data.trim().length == 0) {
              return;
            }
            r = Gp(r, o);
          }
          i.consume(e.viewItem);
          const s = o.createText(e.viewItem.data);
          o.insert(s, r);
          e.modelRange = o.createRange(r, r.getShiftedBy(s.offsetSize));
          e.modelCursor = e.modelRange.end;
        };
      }
      function Zp(t, e) {
        return (n, i) => {
          const o = i.newSelection;
          const r = [];
          for (const t of o.getRanges()) {
            r.push(e.toModelRange(t));
          }
          const s = t.createSelection(r, { backward: o.isBackward });
          if (!s.isEqual(t.document.selection)) {
            t.change((t) => {
              t.setSelection(s);
            });
          }
        };
      }
      function Qp(t) {
        t = Xf(t);
        const e = ob(t);
        const n = ib(t.view);
        const i = n ? \`element:\${n}\` : "element";
        return (n) => {
          n.on(i, e, { priority: t.converterPriority || "normal" });
        };
      }
      function Jp(t) {
        t = Xf(t);
        ab(t);
        const e = cb(t, false);
        const n = ib(t.view);
        const i = n ? \`element:\${n}\` : "element";
        return (n) => {
          n.on(i, e, { priority: t.converterPriority || "low" });
        };
      }
      function Xp(t) {
        t = Xf(t);
        let e = null;
        if (typeof t.view == "string" || t.view.key) {
          e = sb(t);
        }
        ab(t, e);
        const n = cb(t, true);
        return (e) => {
          e.on("element", n, { priority: t.converterPriority || "low" });
        };
      }
      function tb(t) {
        const e = ub(t.model);
        return Qp({ ...t, model: e });
      }
      function eb(t) {
        t = Xf(t);
        if (!t.model) {
          t.model = (e) => (e ? t.view + ":" + e : t.view);
        }
        const e = { view: t.view, model: t.model };
        const n = ob(hb(e, "start"));
        const i = ob(hb(e, "end"));
        return (o) => {
          o.on(\`element:\${t.view}-start\`, n, {
            priority: t.converterPriority || "normal",
          });
          o.on(\`element:\${t.view}-end\`, i, {
            priority: t.converterPriority || "normal",
          });
          const r = S.get("low");
          const s = S.get("highest");
          const a = S.get(t.converterPriority) / s;
          o.on("element", nb(e), { priority: r + a });
        };
      }
      function nb(t) {
        return (e, n, i) => {
          const o = \`data-\${t.view}\`;
          if (
            !i.consumable.test(n.viewItem, { attributes: o + "-end-after" }) &&
            !i.consumable.test(n.viewItem, {
              attributes: o + "-start-after",
            }) &&
            !i.consumable.test(n.viewItem, { attributes: o + "-end-before" }) &&
            !i.consumable.test(n.viewItem, { attributes: o + "-start-before" })
          ) {
            return;
          }
          if (!n.modelRange) {
            Object.assign(n, i.convertChildren(n.viewItem, n.modelCursor));
          }
          if (
            i.consumable.consume(n.viewItem, { attributes: o + "-end-after" })
          ) {
            r(
              n.modelRange.end,
              n.viewItem.getAttribute(o + "-end-after").split(",")
            );
          }
          if (
            i.consumable.consume(n.viewItem, { attributes: o + "-start-after" })
          ) {
            r(
              n.modelRange.end,
              n.viewItem.getAttribute(o + "-start-after").split(",")
            );
          }
          if (
            i.consumable.consume(n.viewItem, { attributes: o + "-end-before" })
          ) {
            r(
              n.modelRange.start,
              n.viewItem.getAttribute(o + "-end-before").split(",")
            );
          }
          if (
            i.consumable.consume(n.viewItem, {
              attributes: o + "-start-before",
            })
          ) {
            r(
              n.modelRange.start,
              n.viewItem.getAttribute(o + "-start-before").split(",")
            );
          }
          function r(e, o) {
            for (const r of o) {
              const o = t.model(r, i);
              const s = i.writer.createElement("$marker", { "data-name": o });
              i.writer.insert(s, e);
              if (n.modelCursor.isEqual(e)) {
                n.modelCursor = n.modelCursor.getShiftedBy(1);
              } else {
                n.modelCursor = n.modelCursor._getTransformedByInsertion(e, 1);
              }
              n.modelRange = n.modelRange._getTransformedByInsertion(e, 1)[0];
            }
          }
        };
      }
      function ib(t) {
        if (typeof t == "string") {
          return t;
        }
        if (typeof t == "object" && typeof t.name == "string") {
          return t.name;
        }
        return null;
      }
      function ob(t) {
        const e = new Ql(t.view);
        return (n, i, o) => {
          const r = e.match(i.viewItem);
          if (!r) {
            return;
          }
          const s = r.match;
          s.name = true;
          if (!o.consumable.test(i.viewItem, s)) {
            return;
          }
          const a = rb(t.model, i.viewItem, o);
          if (!a) {
            return;
          }
          if (!o.safeInsert(a, i.modelCursor)) {
            return;
          }
          o.consumable.consume(i.viewItem, s);
          o.convertChildren(i.viewItem, a);
          o.updateConversionResult(a, i);
        };
      }
      function rb(t, e, n) {
        if (t instanceof Function) {
          return t(e, n);
        } else {
          return n.writer.createElement(t);
        }
      }
      function sb(t) {
        if (typeof t.view == "string") {
          t.view = { key: t.view };
        }
        const e = t.view.key;
        let n;
        if (e == "class" || e == "style") {
          const i = e == "class" ? "classes" : "styles";
          n = { [i]: t.view.value };
        } else {
          const i =
            typeof t.view.value == "undefined" ? /[\\s\\S]*/ : t.view.value;
          n = { attributes: { [e]: i } };
        }
        if (t.view.name) {
          n.name = t.view.name;
        }
        t.view = n;
        return e;
      }
      function ab(t, e = null) {
        const n = e === null ? true : (t) => t.getAttribute(e);
        const i = typeof t.model != "object" ? t.model : t.model.key;
        const o =
          typeof t.model != "object" || typeof t.model.value == "undefined"
            ? n
            : t.model.value;
        t.model = { key: i, value: o };
      }
      function cb(t, e) {
        const n = new Ql(t.view);
        return (i, o, r) => {
          if (!o.modelRange && e) {
            return;
          }
          const s = n.match(o.viewItem);
          if (!s) {
            return;
          }
          if (lb(t.view, o.viewItem)) {
            s.match.name = true;
          } else {
            delete s.match.name;
          }
          if (!r.consumable.test(o.viewItem, s.match)) {
            return;
          }
          const a = t.model.key;
          const c =
            typeof t.model.value == "function"
              ? t.model.value(o.viewItem, r)
              : t.model.value;
          if (c === null) {
            return;
          }
          if (!o.modelRange) {
            Object.assign(o, r.convertChildren(o.viewItem, o.modelCursor));
          }
          const l = db(o.modelRange, { key: a, value: c }, e, r);
          if (l) {
            if (r.consumable.test(o.viewItem, { name: true })) {
              s.match.name = true;
            }
            r.consumable.consume(o.viewItem, s.match);
          }
        };
      }
      function lb(t, e) {
        const n = typeof t == "function" ? t(e) : t;
        if (typeof n == "object" && !ib(n)) {
          return false;
        }
        return !n.classes && !n.attributes && !n.styles;
      }
      function db(t, e, n, i) {
        let o = false;
        for (const r of Array.from(t.getItems({ shallow: n }))) {
          if (!i.schema.checkAttribute(r, e.key)) {
            continue;
          }
          o = true;
          if (r.hasAttribute(e.key)) {
            continue;
          }
          i.writer.setAttribute(e.key, e.value, r);
        }
        return o;
      }
      function ub(t) {
        return (e, n) => {
          const i = typeof t == "string" ? t : t(e, n);
          return n.writer.createElement("$marker", { "data-name": i });
        };
      }
      function hb(t, e) {
        const n = (e, n) => {
          const i = e.getAttribute("name");
          const o = t.model(i, n);
          return n.writer.createElement("$marker", { "data-name": o });
        };
        return { view: \`\${t.view}-\${e}\`, model: n };
      }
      class mb extends dt() {
        constructor(t, e) {
          super();
          this.model = t;
          this.view = new lf(e);
          this.mapper = new Df();
          this.downcastDispatcher = new If({
            mapper: this.mapper,
            schema: t.schema,
          });
          const n = this.model.document;
          const i = n.selection;
          const o = this.model.markers;
          this.listenTo(
            this.model,
            "_beforeChanges",
            () => {
              this.view._disableRendering(true);
            },
            { priority: "highest" }
          );
          this.listenTo(
            this.model,
            "_afterChanges",
            () => {
              this.view._disableRendering(false);
            },
            { priority: "lowest" }
          );
          this.listenTo(
            n,
            "change",
            () => {
              this.view.change((t) => {
                this.downcastDispatcher.convertChanges(n.differ, o, t);
                this.downcastDispatcher.convertSelection(i, o, t);
              });
            },
            { priority: "low" }
          );
          this.listenTo(
            this.view.document,
            "selectionChange",
            Zp(this.model, this.mapper)
          );
          this.downcastDispatcher.on("insert:$text", ep(), {
            priority: "lowest",
          });
          this.downcastDispatcher.on("insert", np(), { priority: "lowest" });
          this.downcastDispatcher.on("remove", ip(), { priority: "low" });
          this.downcastDispatcher.on("selection", ap(), { priority: "high" });
          this.downcastDispatcher.on("selection", rp(), { priority: "low" });
          this.downcastDispatcher.on("selection", sp(), { priority: "low" });
          this.view.document.roots
            .bindTo(this.model.document.roots)
            .using((t) => {
              if (t.rootName == "$graveyard") {
                return null;
              }
              const e = new ih(this.view.document, t.name);
              e.rootName = t.rootName;
              this.mapper.bindElements(t, e);
              return e;
            });
        }
        destroy() {
          this.view.destroy();
          this.stopListening();
        }
        reconvertMarker(t) {
          const e = typeof t == "string" ? t : t.name;
          const n = this.model.markers.get(e);
          if (!n) {
            throw new M(
              "editingcontroller-reconvertmarker-marker-not-exist",
              this,
              { markerName: e }
            );
          }
          this.model.change(() => {
            this.model.markers._refresh(n);
          });
        }
        reconvertItem(t) {
          this.model.change(() => {
            this.model.document.differ._refreshItem(t);
          });
        }
      }
      class gb {
        constructor() {
          this._consumables = new Map();
        }
        add(t, e) {
          let n;
          if (t.is("$text") || t.is("documentFragment")) {
            this._consumables.set(t, true);
            return;
          }
          if (!this._consumables.has(t)) {
            n = new pb(t);
            this._consumables.set(t, n);
          } else {
            n = this._consumables.get(t);
          }
          n.add(e);
        }
        test(t, e) {
          const n = this._consumables.get(t);
          if (n === undefined) {
            return null;
          }
          if (t.is("$text") || t.is("documentFragment")) {
            return n;
          }
          return n.test(e);
        }
        consume(t, e) {
          if (this.test(t, e)) {
            if (t.is("$text") || t.is("documentFragment")) {
              this._consumables.set(t, false);
            } else {
              this._consumables.get(t).consume(e);
            }
            return true;
          }
          return false;
        }
        revert(t, e) {
          const n = this._consumables.get(t);
          if (n !== undefined) {
            if (t.is("$text") || t.is("documentFragment")) {
              this._consumables.set(t, true);
            } else {
              n.revert(e);
            }
          }
        }
        static consumablesFromElement(t) {
          const e = {
            element: t,
            name: true,
            attributes: [],
            classes: [],
            styles: [],
          };
          const n = t.getAttributeKeys();
          for (const t of n) {
            if (t == "style" || t == "class") {
              continue;
            }
            e.attributes.push(t);
          }
          const i = t.getClassNames();
          for (const t of i) {
            e.classes.push(t);
          }
          const o = t.getStyleNames();
          for (const t of o) {
            e.styles.push(t);
          }
          return e;
        }
        static createFrom(t, e) {
          if (!e) {
            e = new gb();
          }
          if (t.is("$text")) {
            e.add(t);
            return e;
          }
          if (t.is("element")) {
            e.add(t, gb.consumablesFromElement(t));
          }
          if (t.is("documentFragment")) {
            e.add(t);
          }
          for (const n of t.getChildren()) {
            e = gb.createFrom(n, e);
          }
          return e;
        }
      }
      const fb = ["attributes", "classes", "styles"];
      class pb {
        constructor(t) {
          this.element = t;
          this._canConsumeName = null;
          this._consumables = {
            attributes: new Map(),
            styles: new Map(),
            classes: new Map(),
          };
        }
        add(t) {
          if (t.name) {
            this._canConsumeName = true;
          }
          for (const e of fb) {
            if (e in t) {
              this._add(e, t[e]);
            }
          }
        }
        test(t) {
          if (t.name && !this._canConsumeName) {
            return this._canConsumeName;
          }
          for (const e of fb) {
            if (e in t) {
              const n = this._test(e, t[e]);
              if (n !== true) {
                return n;
              }
            }
          }
          return true;
        }
        consume(t) {
          if (t.name) {
            this._canConsumeName = false;
          }
          for (const e of fb) {
            if (e in t) {
              this._consume(e, t[e]);
            }
          }
        }
        revert(t) {
          if (t.name) {
            this._canConsumeName = true;
          }
          for (const e of fb) {
            if (e in t) {
              this._revert(e, t[e]);
            }
          }
        }
        _add(t, e) {
          const n = Kt(e) ? e : [e];
          const i = this._consumables[t];
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              throw new M("viewconsumable-invalid-attribute", this);
            }
            i.set(e, true);
            if (t === "styles") {
              for (const t of this.element.document.stylesProcessor.getRelatedStyles(
                e
              )) {
                i.set(t, true);
              }
            }
          }
        }
        _test(t, e) {
          const n = Kt(e) ? e : [e];
          const i = this._consumables[t];
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              const t = e == "class" ? "classes" : "styles";
              const n = this._test(t, [...this._consumables[t].keys()]);
              if (n !== true) {
                return n;
              }
            } else {
              const t = i.get(e);
              if (t === undefined) {
                return null;
              }
              if (!t) {
                return false;
              }
            }
          }
          return true;
        }
        _consume(t, e) {
          const n = Kt(e) ? e : [e];
          const i = this._consumables[t];
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              const t = e == "class" ? "classes" : "styles";
              this._consume(t, [...this._consumables[t].keys()]);
            } else {
              i.set(e, false);
              if (t == "styles") {
                for (const t of this.element.document.stylesProcessor.getRelatedStyles(
                  e
                )) {
                  i.set(t, false);
                }
              }
            }
          }
        }
        _revert(t, e) {
          const n = Kt(e) ? e : [e];
          const i = this._consumables[t];
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              const t = e == "class" ? "classes" : "styles";
              this._revert(t, [...this._consumables[t].keys()]);
            } else {
              const t = i.get(e);
              if (t === false) {
                i.set(e, true);
              }
            }
          }
        }
      }
      class bb extends dt() {
        constructor() {
          super();
          this._sourceDefinitions = {};
          this._attributeProperties = {};
          this.decorate("checkChild");
          this.decorate("checkAttribute");
          this.on(
            "checkAttribute",
            (t, e) => {
              e[0] = new kb(e[0]);
            },
            { priority: "highest" }
          );
          this.on(
            "checkChild",
            (t, e) => {
              e[0] = new kb(e[0]);
              e[1] = this.getDefinition(e[1]);
            },
            { priority: "highest" }
          );
        }
        register(t, e) {
          if (this._sourceDefinitions[t]) {
            throw new M("schema-cannot-register-item-twice", this, {
              itemName: t,
            });
          }
          this._sourceDefinitions[t] = [Object.assign({}, e)];
          this._clearCache();
        }
        extend(t, e) {
          if (!this._sourceDefinitions[t]) {
            throw new M("schema-cannot-extend-missing-item", this, {
              itemName: t,
            });
          }
          this._sourceDefinitions[t].push(Object.assign({}, e));
          this._clearCache();
        }
        getDefinitions() {
          if (!this._compiledDefinitions) {
            this._compile();
          }
          return this._compiledDefinitions;
        }
        getDefinition(t) {
          let e;
          if (typeof t == "string") {
            e = t;
          } else if ("is" in t && (t.is("$text") || t.is("$textProxy"))) {
            e = "$text";
          } else {
            e = t.name;
          }
          return this.getDefinitions()[e];
        }
        isRegistered(t) {
          return !!this.getDefinition(t);
        }
        isBlock(t) {
          const e = this.getDefinition(t);
          return !!(e && e.isBlock);
        }
        isLimit(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isLimit || e.isObject);
        }
        isObject(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isObject || (e.isLimit && e.isSelectable && e.isContent));
        }
        isInline(t) {
          const e = this.getDefinition(t);
          return !!(e && e.isInline);
        }
        isSelectable(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isSelectable || e.isObject);
        }
        isContent(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isContent || e.isObject);
        }
        checkChild(t, e) {
          if (!e) {
            return false;
          }
          return this._checkContextMatch(e, t);
        }
        checkAttribute(t, e) {
          const n = this.getDefinition(t.last);
          if (!n) {
            return false;
          }
          return n.allowAttributes.includes(e);
        }
        checkMerge(t, e) {
          if (t instanceof wf) {
            const e = t.nodeBefore;
            const n = t.nodeAfter;
            if (!(e instanceof ff)) {
              throw new M("schema-check-merge-no-element-before", this);
            }
            if (!(n instanceof ff)) {
              throw new M("schema-check-merge-no-element-after", this);
            }
            return this.checkMerge(e, n);
          }
          for (const n of e.getChildren()) {
            if (!this.checkChild(t, n)) {
              return false;
            }
          }
          return true;
        }
        addChildCheck(t) {
          this.on(
            "checkChild",
            (e, [n, i]) => {
              if (!i) {
                return;
              }
              const o = t(n, i);
              if (typeof o == "boolean") {
                e.stop();
                e.return = o;
              }
            },
            { priority: "high" }
          );
        }
        addAttributeCheck(t) {
          this.on(
            "checkAttribute",
            (e, [n, i]) => {
              const o = t(n, i);
              if (typeof o == "boolean") {
                e.stop();
                e.return = o;
              }
            },
            { priority: "high" }
          );
        }
        setAttributeProperties(t, e) {
          this._attributeProperties[t] = Object.assign(
            this.getAttributeProperties(t),
            e
          );
        }
        getAttributeProperties(t) {
          return this._attributeProperties[t] || {};
        }
        getLimitElement(t) {
          let e;
          if (t instanceof wf) {
            e = t.parent;
          } else {
            const n = t instanceof Ef ? [t] : Array.from(t.getRanges());
            e = n.reduce((t, e) => {
              const n = e.getCommonAncestor();
              if (!t) {
                return n;
              }
              return t.getCommonAncestor(n, { includeSelf: true });
            }, null);
          }
          while (!this.isLimit(e)) {
            if (e.parent) {
              e = e.parent;
            } else {
              break;
            }
          }
          return e;
        }
        checkAttributeInSelection(t, e) {
          if (t.isCollapsed) {
            const n = t.getFirstPosition();
            const i = [...n.getAncestors(), new mf("", t.getAttributes())];
            return this.checkAttribute(i, e);
          } else {
            const n = t.getRanges();
            for (const t of n) {
              for (const n of t) {
                if (this.checkAttribute(n.item, e)) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        *getValidRanges(t, e) {
          t = zb(t);
          for (const n of t) {
            yield* this._getValidRangesForRange(n, e);
          }
        }
        getNearestSelectionRange(t, e = "both") {
          if (this.checkChild(t, "$text")) {
            return new Ef(t);
          }
          let n, i;
          const o =
            t
              .getAncestors()
              .reverse()
              .find((t) => this.isLimit(t)) || t.root;
          if (e == "both" || e == "backward") {
            n = new bf({
              boundaries: Ef._createIn(o),
              startPosition: t,
              direction: "backward",
            });
          }
          if (e == "both" || e == "forward") {
            i = new bf({ boundaries: Ef._createIn(o), startPosition: t });
          }
          for (const t of Nb(n, i)) {
            const e = t.walker == n ? "elementEnd" : "elementStart";
            const i = t.value;
            if (i.type == e && this.isObject(i.item)) {
              return Ef._createOn(i.item);
            }
            if (this.checkChild(i.nextPosition, "$text")) {
              return new Ef(i.nextPosition);
            }
          }
          return null;
        }
        findAllowedParent(t, e) {
          let n = t.parent;
          while (n) {
            if (this.checkChild(n, e)) {
              return n;
            }
            if (this.isLimit(n)) {
              return null;
            }
            n = n.parent;
          }
          return null;
        }
        setAllowedAttributes(t, e, n) {
          const i = n.model;
          for (const [o, r] of Object.entries(e)) {
            if (i.schema.checkAttribute(t, o)) {
              n.setAttribute(o, r, t);
            }
          }
        }
        removeDisallowedAttributes(t, e) {
          for (const n of t) {
            if (n.is("$text")) {
              Pb(this, n, e);
            } else {
              const t = Ef._createIn(n);
              const i = t.getPositions();
              for (const t of i) {
                const n = t.nodeBefore || t.parent;
                Pb(this, n, e);
              }
            }
          }
        }
        getAttributesWithProperty(t, e, n) {
          const i = {};
          for (const [o, r] of t.getAttributes()) {
            const t = this.getAttributeProperties(o);
            if (t[e] === undefined) {
              continue;
            }
            if (n === undefined || n === t[e]) {
              i[o] = r;
            }
          }
          return i;
        }
        createContext(t) {
          return new kb(t);
        }
        _clearCache() {
          this._compiledDefinitions = null;
        }
        _compile() {
          const t = {};
          const e = this._sourceDefinitions;
          const n = Object.keys(e);
          for (const i of n) {
            t[i] = wb(e[i], i);
          }
          for (const e of n) {
            Ab(t, e);
          }
          for (const e of n) {
            Cb(t, e);
          }
          for (const e of n) {
            _b(t, e);
          }
          for (const e of n) {
            vb(t, e);
            yb(t, e);
          }
          for (const e of n) {
            xb(t, e);
            Eb(t, e);
            Db(t, e);
          }
          this._compiledDefinitions = t;
        }
        _checkContextMatch(t, e, n = e.length - 1) {
          const i = e.getItem(n);
          if (t.allowIn.includes(i.name)) {
            if (n == 0) {
              return true;
            } else {
              const t = this.getDefinition(i);
              return this._checkContextMatch(t, e, n - 1);
            }
          } else {
            return false;
          }
        }
        *_getValidRangesForRange(t, e) {
          let n = t.start;
          let i = t.start;
          for (const o of t.getItems({ shallow: true })) {
            if (o.is("element")) {
              yield* this._getValidRangesForRange(Ef._createIn(o), e);
            }
            if (!this.checkAttribute(o, e)) {
              if (!n.isEqual(i)) {
                yield new Ef(n, i);
              }
              n = wf._createAfter(o);
            }
            i = wf._createAfter(o);
          }
          if (!n.isEqual(i)) {
            yield new Ef(n, i);
          }
        }
      }
      class kb {
        constructor(t) {
          if (t instanceof kb) {
            return t;
          }
          let e;
          if (typeof t == "string") {
            e = [t];
          } else if (!Array.isArray(t)) {
            e = t.getAncestors({ includeSelf: true });
          } else {
            e = t;
          }
          this._items = e.map(Lb);
        }
        get length() {
          return this._items.length;
        }
        get last() {
          return this._items[this._items.length - 1];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
        push(t) {
          const e = new kb([t]);
          e._items = [...this._items, ...e._items];
          return e;
        }
        getItem(t) {
          return this._items[t];
        }
        *getNames() {
          yield* this._items.map((t) => t.name);
        }
        endsWith(t) {
          return Array.from(this.getNames()).join(" ").endsWith(t);
        }
        startsWith(t) {
          return Array.from(this.getNames()).join(" ").startsWith(t);
        }
      }
      function wb(t, e) {
        const n = {
          name: e,
          allowIn: [],
          allowContentOf: [],
          allowWhere: [],
          allowAttributes: [],
          allowAttributesOf: [],
          allowChildren: [],
          inheritTypesFrom: [],
        };
        Sb(t, n);
        Tb(t, n, "allowIn");
        Tb(t, n, "allowContentOf");
        Tb(t, n, "allowWhere");
        Tb(t, n, "allowAttributes");
        Tb(t, n, "allowAttributesOf");
        Tb(t, n, "allowChildren");
        Tb(t, n, "inheritTypesFrom");
        Ib(t, n);
        return n;
      }
      function Ab(t, e) {
        const n = t[e];
        for (const i of n.allowChildren) {
          const n = t[i];
          if (!n) {
            continue;
          }
          n.allowIn.push(e);
        }
        n.allowChildren.length = 0;
      }
      function Cb(t, e) {
        for (const n of t[e].allowContentOf) {
          if (t[n]) {
            const i = Mb(t, n);
            i.forEach((t) => {
              t.allowIn.push(e);
            });
          }
        }
        delete t[e].allowContentOf;
      }
      function _b(t, e) {
        for (const n of t[e].allowWhere) {
          const i = t[n];
          if (i) {
            const n = i.allowIn;
            t[e].allowIn.push(...n);
          }
        }
        delete t[e].allowWhere;
      }
      function vb(t, e) {
        for (const n of t[e].allowAttributesOf) {
          const i = t[n];
          if (i) {
            const n = i.allowAttributes;
            t[e].allowAttributes.push(...n);
          }
        }
        delete t[e].allowAttributesOf;
      }
      function yb(t, e) {
        const n = t[e];
        for (const e of n.inheritTypesFrom) {
          const i = t[e];
          if (i) {
            const t = Object.keys(i).filter((t) => t.startsWith("is"));
            for (const e of t) {
              if (!(e in n)) {
                n[e] = i[e];
              }
            }
          }
        }
        delete n.inheritTypesFrom;
      }
      function xb(t, e) {
        const n = t[e];
        const i = n.allowIn.filter((e) => t[e]);
        n.allowIn = Array.from(new Set(i));
      }
      function Eb(t, e) {
        const n = t[e];
        for (const i of n.allowIn) {
          const n = t[i];
          n.allowChildren.push(e);
        }
      }
      function Db(t, e) {
        const n = t[e];
        n.allowAttributes = Array.from(new Set(n.allowAttributes));
      }
      function Sb(t, e) {
        for (const n of t) {
          const t = Object.keys(n).filter((t) => t.startsWith("is"));
          for (const i of t) {
            e[i] = !!n[i];
          }
        }
      }
      function Tb(t, e, n) {
        for (const i of t) {
          const t = i[n];
          if (typeof t == "string") {
            e[n].push(t);
          } else if (Array.isArray(t)) {
            e[n].push(...t);
          }
        }
      }
      function Ib(t, e) {
        for (const n of t) {
          const t = n.inheritAllFrom;
          if (t) {
            e.allowContentOf.push(t);
            e.allowWhere.push(t);
            e.allowAttributesOf.push(t);
            e.inheritTypesFrom.push(t);
          }
        }
      }
      function Mb(t, e) {
        const n = t[e];
        return Bb(t).filter((t) => t.allowIn.includes(n.name));
      }
      function Bb(t) {
        return Object.keys(t).map((e) => t[e]);
      }
      function Lb(t) {
        if (typeof t == "string" || t.is("documentFragment")) {
          return {
            name: typeof t == "string" ? t : "$documentFragment",
            *getAttributeKeys() {},
            getAttribute() {},
          };
        } else {
          return {
            name: t.is("element") ? t.name : "$text",
            *getAttributeKeys() {
              yield* t.getAttributeKeys();
            },
            getAttribute(e) {
              return t.getAttribute(e);
            },
          };
        }
      }
      function* Nb(t, e) {
        let n = false;
        while (!n) {
          n = true;
          if (t) {
            const e = t.next();
            if (!e.done) {
              n = false;
              yield { walker: t, value: e.value };
            }
          }
          if (e) {
            const t = e.next();
            if (!t.done) {
              n = false;
              yield { walker: e, value: t.value };
            }
          }
        }
      }
      function* zb(t) {
        for (const e of t) {
          yield* e.getMinimalFlatRanges();
        }
      }
      function Pb(t, e, n) {
        for (const i of e.getAttributeKeys()) {
          if (!t.checkAttribute(e, i)) {
            n.removeAttribute(i, e);
          }
        }
      }
      class Rb extends q() {
        constructor(t) {
          super();
          this._splitParts = new Map();
          this._cursorParents = new Map();
          this._modelCursor = null;
          this._emptyElementsToKeep = new Set();
          this.conversionApi = {
            ...t,
            consumable: null,
            writer: null,
            store: null,
            convertItem: (t, e) => this._convertItem(t, e),
            convertChildren: (t, e) => this._convertChildren(t, e),
            safeInsert: (t, e) => this._safeInsert(t, e),
            updateConversionResult: (t, e) =>
              this._updateConversionResult(t, e),
            splitToAllowedParent: (t, e) => this._splitToAllowedParent(t, e),
            getSplitParts: (t) => this._getSplitParts(t),
            keepEmptyElement: (t) => this._keepEmptyElement(t),
          };
        }
        convert(t, e, n = ["$root"]) {
          this.fire("viewCleanup", t);
          this._modelCursor = jb(n, e);
          this.conversionApi.writer = e;
          this.conversionApi.consumable = gb.createFrom(t);
          this.conversionApi.store = {};
          const { modelRange: i } = this._convertItem(t, this._modelCursor);
          const o = e.createDocumentFragment();
          if (i) {
            this._removeEmptyElements();
            for (const t of Array.from(
              this._modelCursor.parent.getChildren()
            )) {
              e.append(t, o);
            }
            o.markers = Ob(o, e);
          }
          this._modelCursor = null;
          this._splitParts.clear();
          this._cursorParents.clear();
          this._emptyElementsToKeep.clear();
          this.conversionApi.writer = null;
          this.conversionApi.store = null;
          return o;
        }
        _convertItem(t, e) {
          const n = { viewItem: t, modelCursor: e, modelRange: null };
          if (t.is("element")) {
            this.fire(\`element:\${t.name}\`, n, this.conversionApi);
          } else if (t.is("$text")) {
            this.fire("text", n, this.conversionApi);
          } else {
            this.fire("documentFragment", n, this.conversionApi);
          }
          if (n.modelRange && !(n.modelRange instanceof Ef)) {
            throw new M("view-conversion-dispatcher-incorrect-result", this);
          }
          return { modelRange: n.modelRange, modelCursor: n.modelCursor };
        }
        _convertChildren(t, e) {
          let n = e.is("position") ? e : wf._createAt(e, 0);
          const i = new Ef(n);
          for (const e of Array.from(t.getChildren())) {
            const t = this._convertItem(e, n);
            if (t.modelRange instanceof Ef) {
              i.end = t.modelRange.end;
              n = t.modelCursor;
            }
          }
          return { modelRange: i, modelCursor: n };
        }
        _safeInsert(t, e) {
          const n = this._splitToAllowedParent(t, e);
          if (!n) {
            return false;
          }
          this.conversionApi.writer.insert(t, n.position);
          return true;
        }
        _updateConversionResult(t, e) {
          const n = this._getSplitParts(t);
          const i = this.conversionApi.writer;
          if (!e.modelRange) {
            e.modelRange = i.createRange(
              i.createPositionBefore(t),
              i.createPositionAfter(n[n.length - 1])
            );
          }
          const o = this._cursorParents.get(t);
          if (o) {
            e.modelCursor = i.createPositionAt(o, 0);
          } else {
            e.modelCursor = e.modelRange.end;
          }
        }
        _splitToAllowedParent(t, e) {
          const { schema: n, writer: i } = this.conversionApi;
          let o = n.findAllowedParent(e, t);
          if (o) {
            if (o === e.parent) {
              return { position: e };
            }
            if (this._modelCursor.parent.getAncestors().includes(o)) {
              o = null;
            }
          }
          if (!o) {
            if (!Wp(e, t, n)) {
              return null;
            }
            return { position: Gp(e, i) };
          }
          const r = this.conversionApi.writer.split(e, o);
          const s = [];
          for (const t of r.range.getWalker()) {
            if (t.type == "elementEnd") {
              s.push(t.item);
            } else {
              const e = s.pop();
              const n = t.item;
              this._registerSplitPair(e, n);
            }
          }
          const a = r.range.end.parent;
          this._cursorParents.set(t, a);
          return { position: r.position, cursorParent: a };
        }
        _registerSplitPair(t, e) {
          if (!this._splitParts.has(t)) {
            this._splitParts.set(t, [t]);
          }
          const n = this._splitParts.get(t);
          this._splitParts.set(e, n);
          n.push(e);
        }
        _getSplitParts(t) {
          let e;
          if (!this._splitParts.has(t)) {
            e = [t];
          } else {
            e = this._splitParts.get(t);
          }
          return e;
        }
        _keepEmptyElement(t) {
          this._emptyElementsToKeep.add(t);
        }
        _removeEmptyElements() {
          let t = false;
          for (const e of this._splitParts.keys()) {
            if (e.isEmpty && !this._emptyElementsToKeep.has(e)) {
              this.conversionApi.writer.remove(e);
              this._splitParts.delete(e);
              t = true;
            }
          }
          if (t) {
            this._removeEmptyElements();
          }
        }
      }
      function Ob(t, e) {
        const n = new Set();
        const i = new Map();
        const o = Ef._createIn(t).getItems();
        for (const t of o) {
          if (t.is("element", "$marker")) {
            n.add(t);
          }
        }
        for (const t of n) {
          const n = t.getAttribute("data-name");
          const o = e.createPositionBefore(t);
          if (!i.has(n)) {
            i.set(n, new Ef(o.clone()));
          } else {
            i.get(n).end = o.clone();
          }
          e.remove(t);
        }
        return i;
      }
      function jb(t, e) {
        let n;
        for (const i of new kb(t)) {
          const t = {};
          for (const e of i.getAttributeKeys()) {
            t[e] = i.getAttribute(e);
          }
          const o = e.createElement(i.name, t);
          if (n) {
            e.insert(o, n);
          }
          n = wf._createAt(o, 0);
        }
        return n;
      }
      class Fb {
        getHtml(t) {
          const e = document.implementation.createHTMLDocument("");
          const n = e.createElement("div");
          n.appendChild(t);
          return n.innerHTML;
        }
      }
      class Vb {
        constructor(t) {
          this.skipComments = true;
          this.domParser = new DOMParser();
          this.domConverter = new Am(t, { renderingMode: "data" });
          this.htmlWriter = new Fb();
        }
        toData(t) {
          const e = this.domConverter.viewToDom(t);
          return this.htmlWriter.getHtml(e);
        }
        toView(t) {
          const e = this._toDom(t);
          return this.domConverter.domToView(e, {
            skipComments: this.skipComments,
          });
        }
        registerRawContentMatcher(t) {
          this.domConverter.registerRawContentMatcher(t);
        }
        useFillerType(t) {
          this.domConverter.blockFillerMode =
            t == "marked" ? "markedNbsp" : "nbsp";
        }
        _toDom(t) {
          if (!t.match(/<(?:html|body|head|meta)(?:\\s[^>]*)?>/i)) {
            t = \`<body>\${t}</body>\`;
          }
          const e = this.domParser.parseFromString(t, "text/html");
          const n = e.createDocumentFragment();
          const i = e.body.childNodes;
          while (i.length > 0) {
            n.appendChild(i[0]);
          }
          return n;
        }
      }
      class Hb extends q() {
        constructor(t, e) {
          super();
          this.model = t;
          this.mapper = new Df();
          this.downcastDispatcher = new If({
            mapper: this.mapper,
            schema: t.schema,
          });
          this.downcastDispatcher.on("insert:$text", ep(), {
            priority: "lowest",
          });
          this.downcastDispatcher.on("insert", np(), { priority: "lowest" });
          this.upcastDispatcher = new Rb({ schema: t.schema });
          this.viewDocument = new kh(e);
          this.stylesProcessor = e;
          this.htmlProcessor = new Vb(this.viewDocument);
          this.processor = this.htmlProcessor;
          this._viewWriter = new Lh(this.viewDocument);
          this.upcastDispatcher.on("text", Yp(), { priority: "lowest" });
          this.upcastDispatcher.on("element", Kp(), { priority: "lowest" });
          this.upcastDispatcher.on("documentFragment", Kp(), {
            priority: "lowest",
          });
          dt().prototype.decorate.call(this, "init");
          dt().prototype.decorate.call(this, "set");
          dt().prototype.decorate.call(this, "get");
          this.on(
            "init",
            () => {
              this.fire("ready");
            },
            { priority: "lowest" }
          );
          this.on(
            "ready",
            () => {
              this.model.enqueueChange({ isUndoable: false }, qp);
            },
            { priority: "lowest" }
          );
        }
        get(t = {}) {
          const { rootName: e = "main", trim: n = "empty" } = t;
          if (!this._checkIfRootsExists([e])) {
            throw new M("datacontroller-get-non-existent-root", this);
          }
          const i = this.model.document.getRoot(e);
          if (
            n === "empty" &&
            !this.model.hasContent(i, { ignoreWhitespaces: true })
          ) {
            return "";
          }
          return this.stringify(i, t);
        }
        stringify(t, e = {}) {
          const n = this.toView(t, e);
          return this.processor.toData(n);
        }
        toView(t, e = {}) {
          const n = this.viewDocument;
          const i = this._viewWriter;
          this.mapper.clearBindings();
          const o = Ef._createIn(t);
          const r = new Mh(n);
          this.mapper.bindElements(t, r);
          const s = t.is("documentFragment") ? t.markers : Ub(t);
          this.downcastDispatcher.convert(o, s, i, e);
          return r;
        }
        init(t) {
          if (this.model.document.version) {
            throw new M("datacontroller-init-document-not-empty", this);
          }
          let e = {};
          if (typeof t === "string") {
            e.main = t;
          } else {
            e = t;
          }
          if (!this._checkIfRootsExists(Object.keys(e))) {
            throw new M("datacontroller-init-non-existent-root", this);
          }
          this.model.enqueueChange({ isUndoable: false }, (t) => {
            for (const n of Object.keys(e)) {
              const i = this.model.document.getRoot(n);
              t.insert(this.parse(e[n], i), i, 0);
            }
          });
          return Promise.resolve();
        }
        set(t, e = {}) {
          let n = {};
          if (typeof t === "string") {
            n.main = t;
          } else {
            n = t;
          }
          if (!this._checkIfRootsExists(Object.keys(n))) {
            throw new M("datacontroller-set-non-existent-root", this);
          }
          this.model.enqueueChange(e.batchType || {}, (t) => {
            t.setSelection(null);
            t.removeSelectionAttribute(
              this.model.document.selection.getAttributeKeys()
            );
            for (const e of Object.keys(n)) {
              const i = this.model.document.getRoot(e);
              t.remove(t.createRangeIn(i));
              t.insert(this.parse(n[e], i), i, 0);
            }
          });
        }
        parse(t, e = "$root") {
          const n = this.processor.toView(t);
          return this.toModel(n, e);
        }
        toModel(t, e = "$root") {
          return this.model.change((n) =>
            this.upcastDispatcher.convert(t, n, e)
          );
        }
        addStyleProcessorRules(t) {
          t(this.stylesProcessor);
        }
        registerRawContentMatcher(t) {
          if (this.processor && this.processor !== this.htmlProcessor) {
            this.processor.registerRawContentMatcher(t);
          }
          this.htmlProcessor.registerRawContentMatcher(t);
        }
        destroy() {
          this.stopListening();
        }
        _checkIfRootsExists(t) {
          for (const e of t) {
            if (!this.model.document.getRootNames().includes(e)) {
              return false;
            }
          }
          return true;
        }
      }
      function Ub(t) {
        const e = [];
        const n = t.root.document;
        if (!n) {
          return new Map();
        }
        const i = Ef._createIn(t);
        for (const t of n.model.markers) {
          const n = t.getRange();
          const o = n.isCollapsed;
          const r = n.start.isEqual(i.start) || n.end.isEqual(i.end);
          if (o && r) {
            e.push([t.name, n]);
          } else {
            const o = i.getIntersection(n);
            if (o) {
              e.push([t.name, o]);
            }
          }
        }
        e.sort(([t, e], [n, i]) => {
          if (e.end.compareWith(i.start) !== "after") {
            return 1;
          } else if (e.start.compareWith(i.end) !== "before") {
            return -1;
          } else {
            switch (e.start.compareWith(i.start)) {
              case "before":
                return 1;
              case "after":
                return -1;
              default:
                switch (e.end.compareWith(i.end)) {
                  case "before":
                    return 1;
                  case "after":
                    return -1;
                  default:
                    return n.localeCompare(t);
                }
            }
          }
        });
        return new Map(e);
      }
      class qb {
        constructor(t, e) {
          this._helpers = new Map();
          this._downcast = Yc(t);
          this._createConversionHelpers({
            name: "downcast",
            dispatchers: this._downcast,
            isDowncast: true,
          });
          this._upcast = Yc(e);
          this._createConversionHelpers({
            name: "upcast",
            dispatchers: this._upcast,
            isDowncast: false,
          });
        }
        addAlias(t, e) {
          const n = this._downcast.includes(e);
          const i = this._upcast.includes(e);
          if (!i && !n) {
            throw new M("conversion-add-alias-dispatcher-not-registered", this);
          }
          this._createConversionHelpers({
            name: t,
            dispatchers: [e],
            isDowncast: n,
          });
        }
        for(t) {
          if (!this._helpers.has(t)) {
            throw new M("conversion-for-unknown-group", this);
          }
          return this._helpers.get(t);
        }
        elementToElement(t) {
          this.for("downcast").elementToElement(t);
          for (const { model: e, view: n } of Wb(t)) {
            this.for("upcast").elementToElement({
              model: e,
              view: n,
              converterPriority: t.converterPriority,
            });
          }
        }
        attributeToElement(t) {
          this.for("downcast").attributeToElement(t);
          for (const { model: e, view: n } of Wb(t)) {
            this.for("upcast").elementToAttribute({
              view: n,
              model: e,
              converterPriority: t.converterPriority,
            });
          }
        }
        attributeToAttribute(t) {
          this.for("downcast").attributeToAttribute(t);
          for (const { model: e, view: n } of Wb(t)) {
            this.for("upcast").attributeToAttribute({ view: n, model: e });
          }
        }
        _createConversionHelpers({ name: t, dispatchers: e, isDowncast: n }) {
          if (this._helpers.has(t)) {
            throw new M("conversion-group-exists", this);
          }
          const i = n ? new tp(e) : new $p(e);
          this._helpers.set(t, i);
        }
      }
      function* Wb(t) {
        if (t.model.values) {
          for (const e of t.model.values) {
            const n = { key: t.model.key, value: e };
            const i = t.view[e];
            const o = t.upcastAlso ? t.upcastAlso[e] : undefined;
            yield* Gb(n, i, o);
          }
        } else {
          yield* Gb(t.model, t.view, t.upcastAlso);
        }
      }
      function* Gb(t, e, n) {
        yield { model: t, view: e };
        if (n) {
          for (const e of Yc(n)) {
            yield { model: t, view: e };
          }
        }
      }
      class $b {
        constructor(t) {
          this.baseVersion = t;
          this.isDocumentOperation = this.baseVersion !== null;
          this.batch = null;
        }
        _validate() {}
        toJSON() {
          const t = Object.assign({}, this);
          t.__className = this.constructor.className;
          delete t.batch;
          delete t.isDocumentOperation;
          return t;
        }
        static get className() {
          return "Operation";
        }
        static fromJSON(t, e) {
          return new this(t.baseVersion);
        }
      }
      function Kb(t, e) {
        const n = Jb(e);
        const i = n.reduce((t, e) => t + e.offsetSize, 0);
        const o = t.parent;
        tk(t);
        const r = t.index;
        o._insertChild(r, n);
        Xb(o, r + n.length);
        Xb(o, r);
        return new Ef(t, t.getShiftedBy(i));
      }
      function Yb(t) {
        if (!t.isFlat) {
          throw new M("operation-utils-remove-range-not-flat", this);
        }
        const e = t.start.parent;
        tk(t.start);
        tk(t.end);
        const n = e._removeChildren(t.start.index, t.end.index - t.start.index);
        Xb(e, t.start.index);
        return n;
      }
      function Zb(t, e) {
        if (!t.isFlat) {
          throw new M("operation-utils-move-range-not-flat", this);
        }
        const n = Yb(t);
        e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset);
        return Kb(e, n);
      }
      function Qb(t, e, n) {
        tk(t.start);
        tk(t.end);
        for (const i of t.getItems({ shallow: true })) {
          const t = i.is("$textProxy") ? i.textNode : i;
          if (n !== null) {
            t._setAttribute(e, n);
          } else {
            t._removeAttribute(e);
          }
          Xb(t.parent, t.index);
        }
        Xb(t.end.parent, t.end.index);
      }
      function Jb(t) {
        const e = [];
        function n(t) {
          if (typeof t == "string") {
            e.push(new mf(t));
          } else if (t instanceof gf) {
            e.push(new mf(t.data, t.getAttributes()));
          } else if (t instanceof uf) {
            e.push(t);
          } else if (yt(t)) {
            for (const e of t) {
              n(e);
            }
          }
        }
        n(t);
        for (let t = 1; t < e.length; t++) {
          const n = e[t];
          const i = e[t - 1];
          if (n instanceof mf && i instanceof mf && ek(n, i)) {
            e.splice(t - 1, 2, new mf(i.data + n.data, i.getAttributes()));
            t--;
          }
        }
        return e;
      }
      function Xb(t, e) {
        const n = t.getChild(e - 1);
        const i = t.getChild(e);
        if (n && i && n.is("$text") && i.is("$text") && ek(n, i)) {
          const o = new mf(n.data + i.data, n.getAttributes());
          t._removeChildren(e - 1, 2);
          t._insertChild(e - 1, o);
        }
      }
      function tk(t) {
        const e = t.textNode;
        const n = t.parent;
        if (e) {
          const i = t.offset - e.startOffset;
          const o = e.index;
          n._removeChildren(o, 1);
          const r = new mf(e.data.substr(0, i), e.getAttributes());
          const s = new mf(e.data.substr(i), e.getAttributes());
          n._insertChild(o, [r, s]);
        }
      }
      function ek(t, e) {
        const n = t.getAttributes();
        const i = e.getAttributes();
        for (const t of n) {
          if (t[1] !== e.getAttribute(t[0])) {
            return false;
          }
          i.next();
        }
        return i.next().done;
      }
      class nk extends $b {
        constructor(t, e, n, i) {
          super(i);
          this.sourcePosition = t.clone();
          this.sourcePosition.stickiness = "toNext";
          this.howMany = e;
          this.targetPosition = n.clone();
          this.targetPosition.stickiness = "toNone";
        }
        get type() {
          if (this.targetPosition.root.rootName == "$graveyard") {
            return "remove";
          } else if (this.sourcePosition.root.rootName == "$graveyard") {
            return "reinsert";
          }
          return "move";
        }
        clone() {
          return new nk(
            this.sourcePosition,
            this.howMany,
            this.targetPosition,
            this.baseVersion
          );
        }
        getMovedRangeStart() {
          return this.targetPosition._getTransformedByDeletion(
            this.sourcePosition,
            this.howMany
          );
        }
        getReversed() {
          const t = this.sourcePosition._getTransformedByInsertion(
            this.targetPosition,
            this.howMany
          );
          return new nk(
            this.getMovedRangeStart(),
            this.howMany,
            t,
            this.baseVersion + 1
          );
        }
        _validate() {
          const t = this.sourcePosition.parent;
          const e = this.targetPosition.parent;
          const n = this.sourcePosition.offset;
          const i = this.targetPosition.offset;
          if (n + this.howMany > t.maxOffset) {
            throw new M("move-operation-nodes-do-not-exist", this);
          } else if (t === e && n < i && i < n + this.howMany) {
            throw new M("move-operation-range-into-itself", this);
          } else if (this.sourcePosition.root == this.targetPosition.root) {
            if (
              vt(
                this.sourcePosition.getParentPath(),
                this.targetPosition.getParentPath()
              ) == "prefix"
            ) {
              const t = this.sourcePosition.path.length - 1;
              if (
                this.targetPosition.path[t] >= n &&
                this.targetPosition.path[t] < n + this.howMany
              ) {
                throw new M("move-operation-node-into-itself", this);
              }
            }
          }
        }
        _execute() {
          Zb(
            Ef._createFromPositionAndShift(this.sourcePosition, this.howMany),
            this.targetPosition
          );
        }
        toJSON() {
          const t = super.toJSON();
          t.sourcePosition = this.sourcePosition.toJSON();
          t.targetPosition = this.targetPosition.toJSON();
          return t;
        }
        static get className() {
          return "MoveOperation";
        }
        static fromJSON(t, e) {
          const n = wf.fromJSON(t.sourcePosition, e);
          const i = wf.fromJSON(t.targetPosition, e);
          return new this(n, t.howMany, i, t.baseVersion);
        }
      }
      class ik extends $b {
        constructor(t, e, n) {
          super(n);
          this.position = t.clone();
          this.position.stickiness = "toNone";
          this.nodes = new hf(Jb(e));
          this.shouldReceiveAttributes = false;
        }
        get type() {
          return "insert";
        }
        get howMany() {
          return this.nodes.maxOffset;
        }
        clone() {
          const t = new hf([...this.nodes].map((t) => t._clone(true)));
          const e = new ik(this.position, t, this.baseVersion);
          e.shouldReceiveAttributes = this.shouldReceiveAttributes;
          return e;
        }
        getReversed() {
          const t = this.position.root.document.graveyard;
          const e = new wf(t, [0]);
          return new nk(
            this.position,
            this.nodes.maxOffset,
            e,
            this.baseVersion + 1
          );
        }
        _validate() {
          const t = this.position.parent;
          if (!t || t.maxOffset < this.position.offset) {
            throw new M("insert-operation-position-invalid", this);
          }
        }
        _execute() {
          const t = this.nodes;
          this.nodes = new hf([...t].map((t) => t._clone(true)));
          Kb(this.position, t);
        }
        toJSON() {
          const t = super.toJSON();
          t.position = this.position.toJSON();
          t.nodes = this.nodes.toJSON();
          return t;
        }
        static get className() {
          return "InsertOperation";
        }
        static fromJSON(t, e) {
          const n = [];
          for (const e of t.nodes) {
            if (e.name) {
              n.push(ff.fromJSON(e));
            } else {
              n.push(mf.fromJSON(e));
            }
          }
          const i = new ik(wf.fromJSON(t.position, e), n, t.baseVersion);
          i.shouldReceiveAttributes = t.shouldReceiveAttributes;
          return i;
        }
      }
      class ok extends $b {
        constructor(t, e, n, i, o, r) {
          super(r);
          this.name = t;
          this.oldRange = e ? e.clone() : null;
          this.newRange = n ? n.clone() : null;
          this.affectsData = o;
          this._markers = i;
        }
        get type() {
          return "marker";
        }
        clone() {
          return new ok(
            this.name,
            this.oldRange,
            this.newRange,
            this._markers,
            this.affectsData,
            this.baseVersion
          );
        }
        getReversed() {
          return new ok(
            this.name,
            this.newRange,
            this.oldRange,
            this._markers,
            this.affectsData,
            this.baseVersion + 1
          );
        }
        _execute() {
          if (this.newRange) {
            this._markers._set(
              this.name,
              this.newRange,
              true,
              this.affectsData
            );
          } else {
            this._markers._remove(this.name);
          }
        }
        toJSON() {
          const t = super.toJSON();
          if (this.oldRange) {
            t.oldRange = this.oldRange.toJSON();
          }
          if (this.newRange) {
            t.newRange = this.newRange.toJSON();
          }
          delete t._markers;
          return t;
        }
        static get className() {
          return "MarkerOperation";
        }
        static fromJSON(t, e) {
          return new ok(
            t.name,
            t.oldRange ? Ef.fromJSON(t.oldRange, e) : null,
            t.newRange ? Ef.fromJSON(t.newRange, e) : null,
            e.model.markers,
            t.affectsData,
            t.baseVersion
          );
        }
      }
      function rk(t, e) {
        return Yg(t, e);
      }
      const sk = rk;
      class ak extends $b {
        constructor(t, e, n, i, o) {
          super(o);
          this.range = t.clone();
          this.key = e;
          this.oldValue = n === undefined ? null : n;
          this.newValue = i === undefined ? null : i;
        }
        get type() {
          if (this.oldValue === null) {
            return "addAttribute";
          } else if (this.newValue === null) {
            return "removeAttribute";
          } else {
            return "changeAttribute";
          }
        }
        clone() {
          return new ak(
            this.range,
            this.key,
            this.oldValue,
            this.newValue,
            this.baseVersion
          );
        }
        getReversed() {
          return new ak(
            this.range,
            this.key,
            this.newValue,
            this.oldValue,
            this.baseVersion + 1
          );
        }
        toJSON() {
          const t = super.toJSON();
          t.range = this.range.toJSON();
          return t;
        }
        _validate() {
          if (!this.range.isFlat) {
            throw new M("attribute-operation-range-not-flat", this);
          }
          for (const t of this.range.getItems({ shallow: true })) {
            if (
              this.oldValue !== null &&
              !sk(t.getAttribute(this.key), this.oldValue)
            ) {
              throw new M("attribute-operation-wrong-old-value", this, {
                item: t,
                key: this.key,
                value: this.oldValue,
              });
            }
            if (
              this.oldValue === null &&
              this.newValue !== null &&
              t.hasAttribute(this.key)
            ) {
              throw new M("attribute-operation-attribute-exists", this, {
                node: t,
                key: this.key,
              });
            }
          }
        }
        _execute() {
          if (!sk(this.oldValue, this.newValue)) {
            Qb(this.range, this.key, this.newValue);
          }
        }
        static get className() {
          return "AttributeOperation";
        }
        static fromJSON(t, e) {
          return new ak(
            Ef.fromJSON(t.range, e),
            t.key,
            t.oldValue,
            t.newValue,
            t.baseVersion
          );
        }
      }
      class ck extends $b {
        get type() {
          return "noop";
        }
        clone() {
          return new ck(this.baseVersion);
        }
        getReversed() {
          return new ck(this.baseVersion + 1);
        }
        _execute() {}
        static get className() {
          return "NoOperation";
        }
      }
      class lk extends $b {
        constructor(t, e, n, i) {
          super(i);
          this.position = t;
          this.position.stickiness = "toNext";
          this.oldName = e;
          this.newName = n;
        }
        get type() {
          return "rename";
        }
        clone() {
          return new lk(
            this.position.clone(),
            this.oldName,
            this.newName,
            this.baseVersion
          );
        }
        getReversed() {
          return new lk(
            this.position.clone(),
            this.newName,
            this.oldName,
            this.baseVersion + 1
          );
        }
        _validate() {
          const t = this.position.nodeAfter;
          if (!(t instanceof ff)) {
            throw new M("rename-operation-wrong-position", this);
          } else if (t.name !== this.oldName) {
            throw new M("rename-operation-wrong-name", this);
          }
        }
        _execute() {
          const t = this.position.nodeAfter;
          t.name = this.newName;
        }
        toJSON() {
          const t = super.toJSON();
          t.position = this.position.toJSON();
          return t;
        }
        static get className() {
          return "RenameOperation";
        }
        static fromJSON(t, e) {
          return new lk(
            wf.fromJSON(t.position, e),
            t.oldName,
            t.newName,
            t.baseVersion
          );
        }
      }
      class dk extends $b {
        constructor(t, e, n, i, o) {
          super(o);
          this.root = t;
          this.key = e;
          this.oldValue = n;
          this.newValue = i;
        }
        get type() {
          if (this.oldValue === null) {
            return "addRootAttribute";
          } else if (this.newValue === null) {
            return "removeRootAttribute";
          } else {
            return "changeRootAttribute";
          }
        }
        clone() {
          return new dk(
            this.root,
            this.key,
            this.oldValue,
            this.newValue,
            this.baseVersion
          );
        }
        getReversed() {
          return new dk(
            this.root,
            this.key,
            this.newValue,
            this.oldValue,
            this.baseVersion + 1
          );
        }
        _validate() {
          if (this.root != this.root.root || this.root.is("documentFragment")) {
            throw new M("rootattribute-operation-not-a-root", this, {
              root: this.root,
              key: this.key,
            });
          }
          if (
            this.oldValue !== null &&
            this.root.getAttribute(this.key) !== this.oldValue
          ) {
            throw new M("rootattribute-operation-wrong-old-value", this, {
              root: this.root,
              key: this.key,
            });
          }
          if (
            this.oldValue === null &&
            this.newValue !== null &&
            this.root.hasAttribute(this.key)
          ) {
            throw new M("rootattribute-operation-attribute-exists", this, {
              root: this.root,
              key: this.key,
            });
          }
        }
        _execute() {
          if (this.newValue !== null) {
            this.root._setAttribute(this.key, this.newValue);
          } else {
            this.root._removeAttribute(this.key);
          }
        }
        toJSON() {
          const t = super.toJSON();
          t.root = this.root.toJSON();
          return t;
        }
        static get className() {
          return "RootAttributeOperation";
        }
        static fromJSON(t, e) {
          if (!e.getRoot(t.root)) {
            throw new M("rootattribute-operation-fromjson-no-root", this, {
              rootName: t.root,
            });
          }
          return new dk(
            e.getRoot(t.root),
            t.key,
            t.oldValue,
            t.newValue,
            t.baseVersion
          );
        }
      }
      class uk extends $b {
        constructor(t, e, n, i, o) {
          super(o);
          this.sourcePosition = t.clone();
          this.sourcePosition.stickiness = "toPrevious";
          this.howMany = e;
          this.targetPosition = n.clone();
          this.targetPosition.stickiness = "toNext";
          this.graveyardPosition = i.clone();
        }
        get type() {
          return "merge";
        }
        get deletionPosition() {
          return new wf(
            this.sourcePosition.root,
            this.sourcePosition.path.slice(0, -1)
          );
        }
        get movedRange() {
          const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new Ef(this.sourcePosition, t);
        }
        clone() {
          return new uk(
            this.sourcePosition,
            this.howMany,
            this.targetPosition,
            this.graveyardPosition,
            this.baseVersion
          );
        }
        getReversed() {
          const t = this.targetPosition._getTransformedByMergeOperation(this);
          const e = this.sourcePosition.path.slice(0, -1);
          const n = new wf(
            this.sourcePosition.root,
            e
          )._getTransformedByMergeOperation(this);
          return new hk(
            t,
            this.howMany,
            n,
            this.graveyardPosition,
            this.baseVersion + 1
          );
        }
        _validate() {
          const t = this.sourcePosition.parent;
          const e = this.targetPosition.parent;
          if (!t.parent) {
            throw new M("merge-operation-source-position-invalid", this);
          } else if (!e.parent) {
            throw new M("merge-operation-target-position-invalid", this);
          } else if (this.howMany != t.maxOffset) {
            throw new M("merge-operation-how-many-invalid", this);
          }
        }
        _execute() {
          const t = this.sourcePosition.parent;
          const e = Ef._createIn(t);
          Zb(e, this.targetPosition);
          Zb(Ef._createOn(t), this.graveyardPosition);
        }
        toJSON() {
          const t = super.toJSON();
          t.sourcePosition = t.sourcePosition.toJSON();
          t.targetPosition = t.targetPosition.toJSON();
          t.graveyardPosition = t.graveyardPosition.toJSON();
          return t;
        }
        static get className() {
          return "MergeOperation";
        }
        static fromJSON(t, e) {
          const n = wf.fromJSON(t.sourcePosition, e);
          const i = wf.fromJSON(t.targetPosition, e);
          const o = wf.fromJSON(t.graveyardPosition, e);
          return new this(n, t.howMany, i, o, t.baseVersion);
        }
      }
      class hk extends $b {
        constructor(t, e, n, i, o) {
          super(o);
          this.splitPosition = t.clone();
          this.splitPosition.stickiness = "toNext";
          this.howMany = e;
          this.insertionPosition = n;
          this.graveyardPosition = i ? i.clone() : null;
          if (this.graveyardPosition) {
            this.graveyardPosition.stickiness = "toNext";
          }
        }
        get type() {
          return "split";
        }
        get moveTargetPosition() {
          const t = this.insertionPosition.path.slice();
          t.push(0);
          return new wf(this.insertionPosition.root, t);
        }
        get movedRange() {
          const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new Ef(this.splitPosition, t);
        }
        clone() {
          return new hk(
            this.splitPosition,
            this.howMany,
            this.insertionPosition,
            this.graveyardPosition,
            this.baseVersion
          );
        }
        getReversed() {
          const t = this.splitPosition.root.document.graveyard;
          const e = new wf(t, [0]);
          return new uk(
            this.moveTargetPosition,
            this.howMany,
            this.splitPosition,
            e,
            this.baseVersion + 1
          );
        }
        _validate() {
          const t = this.splitPosition.parent;
          const e = this.splitPosition.offset;
          if (!t || t.maxOffset < e) {
            throw new M("split-operation-position-invalid", this);
          } else if (!t.parent) {
            throw new M("split-operation-split-in-root", this);
          } else if (this.howMany != t.maxOffset - this.splitPosition.offset) {
            throw new M("split-operation-how-many-invalid", this);
          } else if (
            this.graveyardPosition &&
            !this.graveyardPosition.nodeAfter
          ) {
            throw new M("split-operation-graveyard-position-invalid", this);
          }
        }
        _execute() {
          const t = this.splitPosition.parent;
          if (this.graveyardPosition) {
            Zb(
              Ef._createFromPositionAndShift(this.graveyardPosition, 1),
              this.insertionPosition
            );
          } else {
            const e = t._clone();
            Kb(this.insertionPosition, e);
          }
          const e = new Ef(
            wf._createAt(t, this.splitPosition.offset),
            wf._createAt(t, t.maxOffset)
          );
          Zb(e, this.moveTargetPosition);
        }
        toJSON() {
          const t = super.toJSON();
          t.splitPosition = this.splitPosition.toJSON();
          t.insertionPosition = this.insertionPosition.toJSON();
          if (this.graveyardPosition) {
            t.graveyardPosition = this.graveyardPosition.toJSON();
          }
          return t;
        }
        static get className() {
          return "SplitOperation";
        }
        static getInsertionPosition(t) {
          const e = t.path.slice(0, -1);
          e[e.length - 1]++;
          return new wf(t.root, e, "toPrevious");
        }
        static fromJSON(t, e) {
          const n = wf.fromJSON(t.splitPosition, e);
          const i = wf.fromJSON(t.insertionPosition, e);
          const o = t.graveyardPosition
            ? wf.fromJSON(t.graveyardPosition, e)
            : null;
          return new this(n, t.howMany, i, o, t.baseVersion);
        }
      }
      const mk = {};
      mk[ak.className] = ak;
      mk[ik.className] = ik;
      mk[ok.className] = ok;
      mk[nk.className] = nk;
      mk[ck.className] = ck;
      mk[$b.className] = $b;
      mk[lk.className] = lk;
      mk[dk.className] = dk;
      mk[hk.className] = hk;
      mk[uk.className] = uk;
      class gk {
        static fromJSON(t, e) {
          return mk[t.__className].fromJSON(t, e);
        }
      }
      const fk = new Map();
      function pk(t, e, n) {
        let i = fk.get(t);
        if (!i) {
          i = new Map();
          fk.set(t, i);
        }
        i.set(e, n);
      }
      function bk(t, e) {
        const n = fk.get(t);
        if (n && n.has(e)) {
          return n.get(e);
        }
        return kk;
      }
      function kk(t) {
        return [t];
      }
      function wk(t, e, n = {}) {
        const i = bk(t.constructor, e.constructor);
        try {
          t = t.clone();
          return i(t, e, n);
        } catch (t) {
          throw t;
        }
      }
      function Ak(t, e, n) {
        t = t.slice();
        e = e.slice();
        const i = new Ck(n.document, n.useRelations, n.forceWeakRemove);
        i.setOriginalOperations(t);
        i.setOriginalOperations(e);
        const o = i.originalOperations;
        if (t.length == 0 || e.length == 0) {
          return { operationsA: t, operationsB: e, originalOperations: o };
        }
        const r = new WeakMap();
        for (const e of t) {
          r.set(e, 0);
        }
        const s = {
          nextBaseVersionA: t[t.length - 1].baseVersion + 1,
          nextBaseVersionB: e[e.length - 1].baseVersion + 1,
          originalOperationsACount: t.length,
          originalOperationsBCount: e.length,
        };
        let a = 0;
        while (a < t.length) {
          const n = t[a];
          const o = r.get(n);
          if (o == e.length) {
            a++;
            continue;
          }
          const s = e[o];
          const c = wk(n, s, i.getContext(n, s, true));
          const l = wk(s, n, i.getContext(s, n, false));
          i.updateRelation(n, s);
          i.setOriginalOperations(c, n);
          i.setOriginalOperations(l, s);
          for (const t of c) {
            r.set(t, o + l.length);
          }
          t.splice(a, 1, ...c);
          e.splice(o, 1, ...l);
        }
        if (n.padWithNoOps) {
          const n = t.length - s.originalOperationsACount;
          const i = e.length - s.originalOperationsBCount;
          vk(t, i - n);
          vk(e, n - i);
        }
        _k(t, s.nextBaseVersionB);
        _k(e, s.nextBaseVersionA);
        return { operationsA: t, operationsB: e, originalOperations: o };
      }
      class Ck {
        constructor(t, e, n = false) {
          this.originalOperations = new Map();
          this._history = t.history;
          this._useRelations = e;
          this._forceWeakRemove = !!n;
          this._relations = new Map();
        }
        setOriginalOperations(t, e = null) {
          const n = e ? this.originalOperations.get(e) : null;
          for (const e of t) {
            this.originalOperations.set(e, n || e);
          }
        }
        updateRelation(t, e) {
          if (t instanceof nk) {
            if (e instanceof uk) {
              if (
                t.targetPosition.isEqual(e.sourcePosition) ||
                e.movedRange.containsPosition(t.targetPosition)
              ) {
                this._setRelation(t, e, "insertAtSource");
              } else if (t.targetPosition.isEqual(e.deletionPosition)) {
                this._setRelation(t, e, "insertBetween");
              } else if (t.targetPosition.isAfter(e.sourcePosition)) {
                this._setRelation(t, e, "moveTargetAfter");
              }
            } else if (e instanceof nk) {
              if (
                t.targetPosition.isEqual(e.sourcePosition) ||
                t.targetPosition.isBefore(e.sourcePosition)
              ) {
                this._setRelation(t, e, "insertBefore");
              } else {
                this._setRelation(t, e, "insertAfter");
              }
            }
          } else if (t instanceof hk) {
            if (e instanceof uk) {
              if (t.splitPosition.isBefore(e.sourcePosition)) {
                this._setRelation(t, e, "splitBefore");
              }
            } else if (e instanceof nk) {
              if (
                t.splitPosition.isEqual(e.sourcePosition) ||
                t.splitPosition.isBefore(e.sourcePosition)
              ) {
                this._setRelation(t, e, "splitBefore");
              } else {
                const n = Ef._createFromPositionAndShift(
                  e.sourcePosition,
                  e.howMany
                );
                if (
                  t.splitPosition.hasSameParentAs(e.sourcePosition) &&
                  n.containsPosition(t.splitPosition)
                ) {
                  const i = n.end.offset - t.splitPosition.offset;
                  const o = t.splitPosition.offset - n.start.offset;
                  this._setRelation(t, e, { howMany: i, offset: o });
                }
              }
            }
          } else if (t instanceof uk) {
            if (e instanceof uk) {
              if (!t.targetPosition.isEqual(e.sourcePosition)) {
                this._setRelation(t, e, "mergeTargetNotMoved");
              }
              if (t.sourcePosition.isEqual(e.targetPosition)) {
                this._setRelation(t, e, "mergeSourceNotMoved");
              }
              if (t.sourcePosition.isEqual(e.sourcePosition)) {
                this._setRelation(t, e, "mergeSameElement");
              }
            } else if (e instanceof hk) {
              if (t.sourcePosition.isEqual(e.splitPosition)) {
                this._setRelation(t, e, "splitAtSource");
              }
            }
          } else if (t instanceof ok) {
            const n = t.newRange;
            if (!n) {
              return;
            }
            if (e instanceof nk) {
              const i = Ef._createFromPositionAndShift(
                e.sourcePosition,
                e.howMany
              );
              const o = i.containsPosition(n.start) || i.start.isEqual(n.start);
              const r = i.containsPosition(n.end) || i.end.isEqual(n.end);
              if ((o || r) && !i.containsRange(n)) {
                this._setRelation(t, e, {
                  side: o ? "left" : "right",
                  path: o ? n.start.path.slice() : n.end.path.slice(),
                });
              }
            } else if (e instanceof uk) {
              const i = n.start.isEqual(e.targetPosition);
              const o = n.start.isEqual(e.deletionPosition);
              const r = n.end.isEqual(e.deletionPosition);
              const s = n.end.isEqual(e.sourcePosition);
              if (i || o || r || s) {
                this._setRelation(t, e, {
                  wasInLeftElement: i,
                  wasStartBeforeMergedElement: o,
                  wasEndBeforeMergedElement: r,
                  wasInRightElement: s,
                });
              }
            }
          }
        }
        getContext(t, e, n) {
          return {
            aIsStrong: n,
            aWasUndone: this._wasUndone(t),
            bWasUndone: this._wasUndone(e),
            abRelation: this._useRelations ? this._getRelation(t, e) : null,
            baRelation: this._useRelations ? this._getRelation(e, t) : null,
            forceWeakRemove: this._forceWeakRemove,
          };
        }
        _wasUndone(t) {
          const e = this.originalOperations.get(t);
          return e.wasUndone || this._history.isUndoneOperation(e);
        }
        _getRelation(t, e) {
          const n = this.originalOperations.get(e);
          const i = this._history.getUndoneOperation(n);
          if (!i) {
            return null;
          }
          const o = this.originalOperations.get(t);
          const r = this._relations.get(o);
          if (r) {
            return r.get(i) || null;
          }
          return null;
        }
        _setRelation(t, e, n) {
          const i = this.originalOperations.get(t);
          const o = this.originalOperations.get(e);
          let r = this._relations.get(i);
          if (!r) {
            r = new Map();
            this._relations.set(i, r);
          }
          r.set(o, n);
        }
      }
      function _k(t, e) {
        for (const n of t) {
          n.baseVersion = e++;
        }
      }
      function vk(t, e) {
        for (let n = 0; n < e; n++) {
          t.push(new ck(0));
        }
      }
      pk(ak, ak, (t, e, n) => {
        if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) {
          const i = t.range
            .getDifference(e.range)
            .map((e) => new ak(e, t.key, t.oldValue, t.newValue, 0));
          const o = t.range.getIntersection(e.range);
          if (o) {
            if (n.aIsStrong) {
              i.push(new ak(o, e.key, e.newValue, t.newValue, 0));
            }
          }
          if (i.length == 0) {
            return [new ck(0)];
          }
          return i;
        } else {
          return [t];
        }
      });
      pk(ak, ik, (t, e) => {
        if (
          t.range.start.hasSameParentAs(e.position) &&
          t.range.containsPosition(e.position)
        ) {
          const n = t.range._getTransformedByInsertion(
            e.position,
            e.howMany,
            !e.shouldReceiveAttributes
          );
          const i = n.map(
            (e) => new ak(e, t.key, t.oldValue, t.newValue, t.baseVersion)
          );
          if (e.shouldReceiveAttributes) {
            const n = yk(e, t.key, t.oldValue);
            if (n) {
              i.unshift(n);
            }
          }
          return i;
        }
        t.range = t.range._getTransformedByInsertion(
          e.position,
          e.howMany,
          false
        )[0];
        return [t];
      });
      function yk(t, e, n) {
        const i = t.nodes;
        const o = i.getNode(0).getAttribute(e);
        if (o == n) {
          return null;
        }
        const r = new Ef(t.position, t.position.getShiftedBy(t.howMany));
        return new ak(r, e, o, n, 0);
      }
      pk(ak, uk, (t, e) => {
        const n = [];
        if (t.range.start.hasSameParentAs(e.deletionPosition)) {
          if (
            t.range.containsPosition(e.deletionPosition) ||
            t.range.start.isEqual(e.deletionPosition)
          ) {
            n.push(Ef._createFromPositionAndShift(e.graveyardPosition, 1));
          }
        }
        const i = t.range._getTransformedByMergeOperation(e);
        if (!i.isCollapsed) {
          n.push(i);
        }
        return n.map(
          (e) => new ak(e, t.key, t.oldValue, t.newValue, t.baseVersion)
        );
      });
      pk(ak, nk, (t, e) => {
        const n = xk(t.range, e);
        return n.map(
          (e) => new ak(e, t.key, t.oldValue, t.newValue, t.baseVersion)
        );
      });
      function xk(t, e) {
        const n = Ef._createFromPositionAndShift(e.sourcePosition, e.howMany);
        let i = null;
        let o = [];
        if (n.containsRange(t, true)) {
          i = t;
        } else if (t.start.hasSameParentAs(n.start)) {
          o = t.getDifference(n);
          i = t.getIntersection(n);
        } else {
          o = [t];
        }
        const r = [];
        for (let t of o) {
          t = t._getTransformedByDeletion(e.sourcePosition, e.howMany);
          const n = e.getMovedRangeStart();
          const i = t.start.hasSameParentAs(n);
          const o = t._getTransformedByInsertion(n, e.howMany, i);
          r.push(...o);
        }
        if (i) {
          r.push(
            i._getTransformedByMove(
              e.sourcePosition,
              e.targetPosition,
              e.howMany,
              false
            )[0]
          );
        }
        return r;
      }
      pk(ak, hk, (t, e) => {
        if (t.range.end.isEqual(e.insertionPosition)) {
          if (!e.graveyardPosition) {
            t.range.end.offset++;
          }
          return [t];
        }
        if (
          t.range.start.hasSameParentAs(e.splitPosition) &&
          t.range.containsPosition(e.splitPosition)
        ) {
          const n = t.clone();
          n.range = new Ef(
            e.moveTargetPosition.clone(),
            t.range.end._getCombined(e.splitPosition, e.moveTargetPosition)
          );
          t.range.end = e.splitPosition.clone();
          t.range.end.stickiness = "toPrevious";
          return [t, n];
        }
        t.range = t.range._getTransformedBySplitOperation(e);
        return [t];
      });
      pk(ik, ak, (t, e) => {
        const n = [t];
        if (
          t.shouldReceiveAttributes &&
          t.position.hasSameParentAs(e.range.start) &&
          e.range.containsPosition(t.position)
        ) {
          const i = yk(t, e.key, e.newValue);
          if (i) {
            n.push(i);
          }
        }
        return n;
      });
      pk(ik, ik, (t, e, n) => {
        if (t.position.isEqual(e.position) && n.aIsStrong) {
          return [t];
        }
        t.position = t.position._getTransformedByInsertOperation(e);
        return [t];
      });
      pk(ik, nk, (t, e) => {
        t.position = t.position._getTransformedByMoveOperation(e);
        return [t];
      });
      pk(ik, hk, (t, e) => {
        t.position = t.position._getTransformedBySplitOperation(e);
        return [t];
      });
      pk(ik, uk, (t, e) => {
        t.position = t.position._getTransformedByMergeOperation(e);
        return [t];
      });
      pk(ok, ik, (t, e) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0];
        }
        if (t.newRange) {
          t.newRange = t.newRange._getTransformedByInsertOperation(e)[0];
        }
        return [t];
      });
      pk(ok, ok, (t, e, n) => {
        if (t.name == e.name) {
          if (n.aIsStrong) {
            t.oldRange = e.newRange ? e.newRange.clone() : null;
          } else {
            return [new ck(0)];
          }
        }
        return [t];
      });
      pk(ok, uk, (t, e) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedByMergeOperation(e);
        }
        if (t.newRange) {
          t.newRange = t.newRange._getTransformedByMergeOperation(e);
        }
        return [t];
      });
      pk(ok, nk, (t, e, n) => {
        if (t.oldRange) {
          t.oldRange = Ef._createFromRanges(
            t.oldRange._getTransformedByMoveOperation(e)
          );
        }
        if (t.newRange) {
          if (n.abRelation) {
            const i = Ef._createFromRanges(
              t.newRange._getTransformedByMoveOperation(e)
            );
            if (
              n.abRelation.side == "left" &&
              e.targetPosition.isEqual(t.newRange.start)
            ) {
              t.newRange.end = i.end;
              t.newRange.start.path = n.abRelation.path;
              return [t];
            } else if (
              n.abRelation.side == "right" &&
              e.targetPosition.isEqual(t.newRange.end)
            ) {
              t.newRange.start = i.start;
              t.newRange.end.path = n.abRelation.path;
              return [t];
            }
          }
          t.newRange = Ef._createFromRanges(
            t.newRange._getTransformedByMoveOperation(e)
          );
        }
        return [t];
      });
      pk(ok, hk, (t, e, n) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedBySplitOperation(e);
        }
        if (t.newRange) {
          if (n.abRelation) {
            const i = t.newRange._getTransformedBySplitOperation(e);
            if (
              t.newRange.start.isEqual(e.splitPosition) &&
              n.abRelation.wasStartBeforeMergedElement
            ) {
              t.newRange.start = wf._createAt(e.insertionPosition);
            } else if (
              t.newRange.start.isEqual(e.splitPosition) &&
              !n.abRelation.wasInLeftElement
            ) {
              t.newRange.start = wf._createAt(e.moveTargetPosition);
            }
            if (
              t.newRange.end.isEqual(e.splitPosition) &&
              n.abRelation.wasInRightElement
            ) {
              t.newRange.end = wf._createAt(e.moveTargetPosition);
            } else if (
              t.newRange.end.isEqual(e.splitPosition) &&
              n.abRelation.wasEndBeforeMergedElement
            ) {
              t.newRange.end = wf._createAt(e.insertionPosition);
            } else {
              t.newRange.end = i.end;
            }
            return [t];
          }
          t.newRange = t.newRange._getTransformedBySplitOperation(e);
        }
        return [t];
      });
      pk(uk, ik, (t, e) => {
        if (t.sourcePosition.hasSameParentAs(e.position)) {
          t.howMany += e.howMany;
        }
        t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e);
        t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e);
        return [t];
      });
      pk(uk, uk, (t, e, n) => {
        if (
          t.sourcePosition.isEqual(e.sourcePosition) &&
          t.targetPosition.isEqual(e.targetPosition)
        ) {
          if (!n.bWasUndone) {
            return [new ck(0)];
          } else {
            const n = e.graveyardPosition.path.slice();
            n.push(0);
            t.sourcePosition = new wf(e.graveyardPosition.root, n);
            t.howMany = 0;
            return [t];
          }
        }
        if (
          t.sourcePosition.isEqual(e.sourcePosition) &&
          !t.targetPosition.isEqual(e.targetPosition) &&
          !n.bWasUndone &&
          n.abRelation != "splitAtSource"
        ) {
          const i = t.targetPosition.root.rootName == "$graveyard";
          const o = e.targetPosition.root.rootName == "$graveyard";
          const r = i && !o;
          const s = o && !i;
          const a = s || (!r && n.aIsStrong);
          if (a) {
            const n = e.targetPosition._getTransformedByMergeOperation(e);
            const i = t.targetPosition._getTransformedByMergeOperation(e);
            return [new nk(n, t.howMany, i, 0)];
          } else {
            return [new ck(0)];
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany;
        }
        t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e);
        t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
        if (!t.graveyardPosition.isEqual(e.graveyardPosition) || !n.aIsStrong) {
          t.graveyardPosition =
            t.graveyardPosition._getTransformedByMergeOperation(e);
        }
        return [t];
      });
      pk(uk, nk, (t, e, n) => {
        const i = Ef._createFromPositionAndShift(e.sourcePosition, e.howMany);
        if (e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) {
          if (
            t.deletionPosition.hasSameParentAs(e.sourcePosition) &&
            i.containsPosition(t.sourcePosition)
          ) {
            return [new ck(0)];
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany;
        }
        if (t.sourcePosition.hasSameParentAs(e.sourcePosition)) {
          t.howMany -= e.howMany;
        }
        t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e);
        t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e);
        if (!t.graveyardPosition.isEqual(e.targetPosition)) {
          t.graveyardPosition =
            t.graveyardPosition._getTransformedByMoveOperation(e);
        }
        return [t];
      });
      pk(uk, hk, (t, e, n) => {
        if (e.graveyardPosition) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(
            e.graveyardPosition,
            1
          );
          if (t.deletionPosition.isEqual(e.graveyardPosition)) {
            t.howMany = e.howMany;
          }
        }
        if (t.targetPosition.isEqual(e.splitPosition)) {
          const i = e.howMany != 0;
          const o =
            e.graveyardPosition &&
            t.deletionPosition.isEqual(e.graveyardPosition);
          if (i || o || n.abRelation == "mergeTargetNotMoved") {
            t.sourcePosition =
              t.sourcePosition._getTransformedBySplitOperation(e);
            return [t];
          }
        }
        if (t.sourcePosition.isEqual(e.splitPosition)) {
          if (n.abRelation == "mergeSourceNotMoved") {
            t.howMany = 0;
            t.targetPosition =
              t.targetPosition._getTransformedBySplitOperation(e);
            return [t];
          }
          if (
            n.abRelation == "mergeSameElement" ||
            t.sourcePosition.offset > 0
          ) {
            t.sourcePosition = e.moveTargetPosition.clone();
            t.targetPosition =
              t.targetPosition._getTransformedBySplitOperation(e);
            return [t];
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.splitPosition)) {
          t.howMany = e.splitPosition.offset;
        }
        t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e);
        t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
        return [t];
      });
      pk(nk, ik, (t, e) => {
        const n = Ef._createFromPositionAndShift(t.sourcePosition, t.howMany);
        const i = n._getTransformedByInsertOperation(e, false)[0];
        t.sourcePosition = i.start;
        t.howMany = i.end.offset - i.start.offset;
        if (!t.targetPosition.isEqual(e.position)) {
          t.targetPosition =
            t.targetPosition._getTransformedByInsertOperation(e);
        }
        return [t];
      });
      pk(nk, nk, (t, e, n) => {
        const i = Ef._createFromPositionAndShift(t.sourcePosition, t.howMany);
        const o = Ef._createFromPositionAndShift(e.sourcePosition, e.howMany);
        let r = n.aIsStrong;
        let s = !n.aIsStrong;
        if (n.abRelation == "insertBefore" || n.baRelation == "insertAfter") {
          s = true;
        } else if (
          n.abRelation == "insertAfter" ||
          n.baRelation == "insertBefore"
        ) {
          s = false;
        }
        let a;
        if (t.targetPosition.isEqual(e.targetPosition) && s) {
          a = t.targetPosition._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany
          );
        } else {
          a = t.targetPosition._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany
          );
        }
        if (Ek(t, e) && Ek(e, t)) {
          return [e.getReversed()];
        }
        const c = i.containsPosition(e.targetPosition);
        if (c && i.containsRange(o, true)) {
          i.start = i.start._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany
          );
          i.end = i.end._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany
          );
          return Dk([i], a);
        }
        const l = o.containsPosition(t.targetPosition);
        if (l && o.containsRange(i, true)) {
          i.start = i.start._getCombined(
            e.sourcePosition,
            e.getMovedRangeStart()
          );
          i.end = i.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
          return Dk([i], a);
        }
        const d = vt(
          t.sourcePosition.getParentPath(),
          e.sourcePosition.getParentPath()
        );
        if (d == "prefix" || d == "extension") {
          i.start = i.start._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany
          );
          i.end = i.end._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany
          );
          return Dk([i], a);
        }
        if (
          t.type == "remove" &&
          e.type != "remove" &&
          !n.aWasUndone &&
          !n.forceWeakRemove
        ) {
          r = true;
        } else if (
          t.type != "remove" &&
          e.type == "remove" &&
          !n.bWasUndone &&
          !n.forceWeakRemove
        ) {
          r = false;
        }
        const u = [];
        const h = i.getDifference(o);
        for (const t of h) {
          t.start = t.start._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany
          );
          t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
          const n =
            vt(
              t.start.getParentPath(),
              e.getMovedRangeStart().getParentPath()
            ) == "same";
          const i = t._getTransformedByInsertion(
            e.getMovedRangeStart(),
            e.howMany,
            n
          );
          u.push(...i);
        }
        const m = i.getIntersection(o);
        if (m !== null && r) {
          m.start = m.start._getCombined(
            e.sourcePosition,
            e.getMovedRangeStart()
          );
          m.end = m.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
          if (u.length === 0) {
            u.push(m);
          } else if (u.length == 1) {
            if (o.start.isBefore(i.start) || o.start.isEqual(i.start)) {
              u.unshift(m);
            } else {
              u.push(m);
            }
          } else {
            u.splice(1, 0, m);
          }
        }
        if (u.length === 0) {
          return [new ck(t.baseVersion)];
        }
        return Dk(u, a);
      });
      pk(nk, hk, (t, e, n) => {
        let i = t.targetPosition.clone();
        if (
          !t.targetPosition.isEqual(e.insertionPosition) ||
          !e.graveyardPosition ||
          n.abRelation == "moveTargetAfter"
        ) {
          i = t.targetPosition._getTransformedBySplitOperation(e);
        }
        const o = Ef._createFromPositionAndShift(t.sourcePosition, t.howMany);
        if (o.end.isEqual(e.insertionPosition)) {
          if (!e.graveyardPosition) {
            t.howMany++;
          }
          t.targetPosition = i;
          return [t];
        }
        if (
          o.start.hasSameParentAs(e.splitPosition) &&
          o.containsPosition(e.splitPosition)
        ) {
          let t = new Ef(e.splitPosition, o.end);
          t = t._getTransformedBySplitOperation(e);
          const n = [new Ef(o.start, e.splitPosition), t];
          return Dk(n, i);
        }
        if (
          t.targetPosition.isEqual(e.splitPosition) &&
          n.abRelation == "insertAtSource"
        ) {
          i = e.moveTargetPosition;
        }
        if (
          t.targetPosition.isEqual(e.insertionPosition) &&
          n.abRelation == "insertBetween"
        ) {
          i = t.targetPosition;
        }
        const r = o._getTransformedBySplitOperation(e);
        const s = [r];
        if (e.graveyardPosition) {
          const i =
            o.start.isEqual(e.graveyardPosition) ||
            o.containsPosition(e.graveyardPosition);
          if (t.howMany > 1 && i && !n.aWasUndone) {
            s.push(Ef._createFromPositionAndShift(e.insertionPosition, 1));
          }
        }
        return Dk(s, i);
      });
      pk(nk, uk, (t, e, n) => {
        const i = Ef._createFromPositionAndShift(t.sourcePosition, t.howMany);
        if (
          e.deletionPosition.hasSameParentAs(t.sourcePosition) &&
          i.containsPosition(e.sourcePosition)
        ) {
          if (t.type == "remove" && !n.forceWeakRemove) {
            if (!n.aWasUndone) {
              const n = [];
              let i = e.graveyardPosition.clone();
              let o = e.targetPosition._getTransformedByMergeOperation(e);
              if (t.howMany > 1) {
                n.push(
                  new nk(t.sourcePosition, t.howMany - 1, t.targetPosition, 0)
                );
                i = i._getTransformedByMove(
                  t.sourcePosition,
                  t.targetPosition,
                  t.howMany - 1
                );
                o = o._getTransformedByMove(
                  t.sourcePosition,
                  t.targetPosition,
                  t.howMany - 1
                );
              }
              const r = e.deletionPosition._getCombined(
                t.sourcePosition,
                t.targetPosition
              );
              const s = new nk(i, 1, r, 0);
              const a = s.getMovedRangeStart().path.slice();
              a.push(0);
              const c = new wf(s.targetPosition.root, a);
              o = o._getTransformedByMove(i, r, 1);
              const l = new nk(o, e.howMany, c, 0);
              n.push(s);
              n.push(l);
              return n;
            }
          } else {
            if (t.howMany == 1) {
              if (!n.bWasUndone) {
                return [new ck(0)];
              } else {
                t.sourcePosition = e.graveyardPosition.clone();
                t.targetPosition =
                  t.targetPosition._getTransformedByMergeOperation(e);
                return [t];
              }
            }
          }
        }
        const o = Ef._createFromPositionAndShift(t.sourcePosition, t.howMany);
        const r = o._getTransformedByMergeOperation(e);
        t.sourcePosition = r.start;
        t.howMany = r.end.offset - r.start.offset;
        t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
        return [t];
      });
      pk(lk, ik, (t, e) => {
        t.position = t.position._getTransformedByInsertOperation(e);
        return [t];
      });
      pk(lk, uk, (t, e) => {
        if (t.position.isEqual(e.deletionPosition)) {
          t.position = e.graveyardPosition.clone();
          t.position.stickiness = "toNext";
          return [t];
        }
        t.position = t.position._getTransformedByMergeOperation(e);
        return [t];
      });
      pk(lk, nk, (t, e) => {
        t.position = t.position._getTransformedByMoveOperation(e);
        return [t];
      });
      pk(lk, lk, (t, e, n) => {
        if (t.position.isEqual(e.position)) {
          if (n.aIsStrong) {
            t.oldName = e.newName;
          } else {
            return [new ck(0)];
          }
        }
        return [t];
      });
      pk(lk, hk, (t, e) => {
        const n = t.position.path;
        const i = e.splitPosition.getParentPath();
        if (vt(n, i) == "same" && !e.graveyardPosition) {
          const e = new lk(t.position.getShiftedBy(1), t.oldName, t.newName, 0);
          return [t, e];
        }
        t.position = t.position._getTransformedBySplitOperation(e);
        return [t];
      });
      pk(dk, dk, (t, e, n) => {
        if (t.root === e.root && t.key === e.key) {
          if (!n.aIsStrong || t.newValue === e.newValue) {
            return [new ck(0)];
          } else {
            t.oldValue = e.newValue;
          }
        }
        return [t];
      });
      pk(hk, ik, (t, e) => {
        if (
          t.splitPosition.hasSameParentAs(e.position) &&
          t.splitPosition.offset < e.position.offset
        ) {
          t.howMany += e.howMany;
        }
        t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e);
        t.insertionPosition =
          t.insertionPosition._getTransformedByInsertOperation(e);
        return [t];
      });
      pk(hk, uk, (t, e, n) => {
        if (
          !t.graveyardPosition &&
          !n.bWasUndone &&
          t.splitPosition.hasSameParentAs(e.sourcePosition)
        ) {
          const n = e.graveyardPosition.path.slice();
          n.push(0);
          const i = new wf(e.graveyardPosition.root, n);
          const o = hk.getInsertionPosition(
            new wf(e.graveyardPosition.root, n)
          );
          const r = new hk(i, 0, o, null, 0);
          t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
          t.insertionPosition = hk.getInsertionPosition(t.splitPosition);
          t.graveyardPosition = r.insertionPosition.clone();
          t.graveyardPosition.stickiness = "toNext";
          return [r, t];
        }
        if (
          t.splitPosition.hasSameParentAs(e.deletionPosition) &&
          !t.splitPosition.isAfter(e.deletionPosition)
        ) {
          t.howMany--;
        }
        if (t.splitPosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany;
        }
        t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
        t.insertionPosition = hk.getInsertionPosition(t.splitPosition);
        if (t.graveyardPosition) {
          t.graveyardPosition =
            t.graveyardPosition._getTransformedByMergeOperation(e);
        }
        return [t];
      });
      pk(hk, nk, (t, e, n) => {
        const i = Ef._createFromPositionAndShift(e.sourcePosition, e.howMany);
        if (t.graveyardPosition) {
          const o =
            i.start.isEqual(t.graveyardPosition) ||
            i.containsPosition(t.graveyardPosition);
          if (!n.bWasUndone && o) {
            const n = t.splitPosition._getTransformedByMoveOperation(e);
            const i = t.graveyardPosition._getTransformedByMoveOperation(e);
            const o = i.path.slice();
            o.push(0);
            const r = new wf(i.root, o);
            const s = new nk(n, t.howMany, r, 0);
            return [s];
          }
          t.graveyardPosition =
            t.graveyardPosition._getTransformedByMoveOperation(e);
        }
        const o = t.splitPosition.isEqual(e.targetPosition);
        if (
          o &&
          (n.baRelation == "insertAtSource" || n.abRelation == "splitBefore")
        ) {
          t.howMany += e.howMany;
          t.splitPosition = t.splitPosition._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany
          );
          t.insertionPosition = hk.getInsertionPosition(t.splitPosition);
          return [t];
        }
        if (o && n.abRelation && n.abRelation.howMany) {
          const { howMany: e, offset: i } = n.abRelation;
          t.howMany += e;
          t.splitPosition = t.splitPosition.getShiftedBy(i);
          return [t];
        }
        if (
          t.splitPosition.hasSameParentAs(e.sourcePosition) &&
          i.containsPosition(t.splitPosition)
        ) {
          const n =
            e.howMany - (t.splitPosition.offset - e.sourcePosition.offset);
          t.howMany -= n;
          if (
            t.splitPosition.hasSameParentAs(e.targetPosition) &&
            t.splitPosition.offset < e.targetPosition.offset
          ) {
            t.howMany += e.howMany;
          }
          t.splitPosition = e.sourcePosition.clone();
          t.insertionPosition = hk.getInsertionPosition(t.splitPosition);
          return [t];
        }
        if (!e.sourcePosition.isEqual(e.targetPosition)) {
          if (
            t.splitPosition.hasSameParentAs(e.sourcePosition) &&
            t.splitPosition.offset <= e.sourcePosition.offset
          ) {
            t.howMany -= e.howMany;
          }
          if (
            t.splitPosition.hasSameParentAs(e.targetPosition) &&
            t.splitPosition.offset < e.targetPosition.offset
          ) {
            t.howMany += e.howMany;
          }
        }
        t.splitPosition.stickiness = "toNone";
        t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e);
        t.splitPosition.stickiness = "toNext";
        if (t.graveyardPosition) {
          t.insertionPosition =
            t.insertionPosition._getTransformedByMoveOperation(e);
        } else {
          t.insertionPosition = hk.getInsertionPosition(t.splitPosition);
        }
        return [t];
      });
      pk(hk, hk, (t, e, n) => {
        if (t.splitPosition.isEqual(e.splitPosition)) {
          if (!t.graveyardPosition && !e.graveyardPosition) {
            return [new ck(0)];
          }
          if (
            t.graveyardPosition &&
            e.graveyardPosition &&
            t.graveyardPosition.isEqual(e.graveyardPosition)
          ) {
            return [new ck(0)];
          }
          if (n.abRelation == "splitBefore") {
            t.howMany = 0;
            t.graveyardPosition =
              t.graveyardPosition._getTransformedBySplitOperation(e);
            return [t];
          }
        }
        if (
          t.graveyardPosition &&
          e.graveyardPosition &&
          t.graveyardPosition.isEqual(e.graveyardPosition)
        ) {
          const i = t.splitPosition.root.rootName == "$graveyard";
          const o = e.splitPosition.root.rootName == "$graveyard";
          const r = i && !o;
          const s = o && !i;
          const a = s || (!r && n.aIsStrong);
          if (a) {
            const n = [];
            if (e.howMany) {
              n.push(
                new nk(e.moveTargetPosition, e.howMany, e.splitPosition, 0)
              );
            }
            if (t.howMany) {
              n.push(
                new nk(t.splitPosition, t.howMany, t.moveTargetPosition, 0)
              );
            }
            return n;
          } else {
            return [new ck(0)];
          }
        }
        if (t.graveyardPosition) {
          t.graveyardPosition =
            t.graveyardPosition._getTransformedBySplitOperation(e);
        }
        if (
          t.splitPosition.isEqual(e.insertionPosition) &&
          n.abRelation == "splitBefore"
        ) {
          t.howMany++;
          return [t];
        }
        if (
          e.splitPosition.isEqual(t.insertionPosition) &&
          n.baRelation == "splitBefore"
        ) {
          const n = e.insertionPosition.path.slice();
          n.push(0);
          const i = new wf(e.insertionPosition.root, n);
          const o = new nk(t.insertionPosition, 1, i, 0);
          return [t, o];
        }
        if (
          t.splitPosition.hasSameParentAs(e.splitPosition) &&
          t.splitPosition.offset < e.splitPosition.offset
        ) {
          t.howMany -= e.howMany;
        }
        t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e);
        t.insertionPosition = hk.getInsertionPosition(t.splitPosition);
        return [t];
      });
      function Ek(t, e) {
        return (
          t.targetPosition._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany
          ) === null
        );
      }
      function Dk(t, e) {
        const n = [];
        for (let i = 0; i < t.length; i++) {
          const o = t[i];
          const r = new nk(o.start, o.end.offset - o.start.offset, e, 0);
          n.push(r);
          for (let e = i + 1; e < t.length; e++) {
            t[e] = t[e]._getTransformedByMove(
              r.sourcePosition,
              r.targetPosition,
              r.howMany
            )[0];
          }
          e = e._getTransformedByMove(
            r.sourcePosition,
            r.targetPosition,
            r.howMany
          );
        }
        return n;
      }
      class Sk extends q(wf) {
        constructor(t, e, n = "toNone") {
          super(t, e, n);
          if (!this.root.is("rootElement")) {
            throw new M("model-liveposition-root-not-rootelement", t);
          }
          Tk.call(this);
        }
        detach() {
          this.stopListening();
        }
        toPosition() {
          return new wf(this.root, this.path.slice(), this.stickiness);
        }
        static fromPosition(t, e) {
          return new this(t.root, t.path.slice(), e ? e : t.stickiness);
        }
      }
      Sk.prototype.is = function (t) {
        return (
          t === "livePosition" ||
          t === "model:livePosition" ||
          t == "position" ||
          t === "model:position"
        );
      };
      function Tk() {
        this.listenTo(
          this.root.document.model,
          "applyOperation",
          (t, e) => {
            const n = e[0];
            if (!n.isDocumentOperation) {
              return;
            }
            Ik.call(this, n);
          },
          { priority: "low" }
        );
      }
      function Ik(t) {
        const e = this.getTransformedByOperation(t);
        if (!this.isEqual(e)) {
          const t = this.toPosition();
          this.path = e.path;
          this.root = e.root;
          this.fire("change", t);
        }
      }
      class Mk {
        constructor(t = {}) {
          if (typeof t === "string") {
            t = t === "transparent" ? { isUndoable: false } : {};
            B("batch-constructor-deprecated-string-type");
          }
          const {
            isUndoable: e = true,
            isLocal: n = true,
            isUndo: i = false,
            isTyping: o = false,
          } = t;
          this.operations = [];
          this.isUndoable = e;
          this.isLocal = n;
          this.isUndo = i;
          this.isTyping = o;
        }
        get type() {
          B("batch-type-deprecated");
          return "default";
        }
        get baseVersion() {
          for (const t of this.operations) {
            if (t.baseVersion !== null) {
              return t.baseVersion;
            }
          }
          return null;
        }
        addOperation(t) {
          t.batch = this;
          this.operations.push(t);
          return t;
        }
      }
      class Bk {
        constructor(t) {
          this._markerCollection = t;
          this._changesInElement = new Map();
          this._elementSnapshots = new Map();
          this._changedMarkers = new Map();
          this._changeCount = 0;
          this._cachedChanges = null;
          this._cachedChangesWithGraveyard = null;
          this._refreshedItems = new Set();
        }
        get isEmpty() {
          return (
            this._changesInElement.size == 0 && this._changedMarkers.size == 0
          );
        }
        bufferOperation(t) {
          const e = t;
          switch (e.type) {
            case "insert": {
              if (this._isInInsertedElement(e.position.parent)) {
                return;
              }
              this._markInsert(
                e.position.parent,
                e.position.offset,
                e.nodes.maxOffset
              );
              break;
            }
            case "addAttribute":
            case "removeAttribute":
            case "changeAttribute": {
              for (const t of e.range.getItems({ shallow: true })) {
                if (this._isInInsertedElement(t.parent)) {
                  continue;
                }
                this._markAttribute(t);
              }
              break;
            }
            case "remove":
            case "move":
            case "reinsert": {
              if (
                e.sourcePosition.isEqual(e.targetPosition) ||
                e.sourcePosition
                  .getShiftedBy(e.howMany)
                  .isEqual(e.targetPosition)
              ) {
                return;
              }
              const t = this._isInInsertedElement(e.sourcePosition.parent);
              const n = this._isInInsertedElement(e.targetPosition.parent);
              if (!t) {
                this._markRemove(
                  e.sourcePosition.parent,
                  e.sourcePosition.offset,
                  e.howMany
                );
              }
              if (!n) {
                this._markInsert(
                  e.targetPosition.parent,
                  e.getMovedRangeStart().offset,
                  e.howMany
                );
              }
              break;
            }
            case "rename": {
              if (this._isInInsertedElement(e.position.parent)) {
                return;
              }
              this._markRemove(e.position.parent, e.position.offset, 1);
              this._markInsert(e.position.parent, e.position.offset, 1);
              const t = Ef._createFromPositionAndShift(e.position, 1);
              for (const e of this._markerCollection.getMarkersIntersectingRange(
                t
              )) {
                const t = e.getData();
                this.bufferMarkerChange(e.name, t, t);
              }
              break;
            }
            case "split": {
              const t = e.splitPosition.parent;
              if (!this._isInInsertedElement(t)) {
                this._markRemove(t, e.splitPosition.offset, e.howMany);
              }
              if (!this._isInInsertedElement(e.insertionPosition.parent)) {
                this._markInsert(
                  e.insertionPosition.parent,
                  e.insertionPosition.offset,
                  1
                );
              }
              if (e.graveyardPosition) {
                this._markRemove(
                  e.graveyardPosition.parent,
                  e.graveyardPosition.offset,
                  1
                );
              }
              break;
            }
            case "merge": {
              const t = e.sourcePosition.parent;
              if (!this._isInInsertedElement(t.parent)) {
                this._markRemove(t.parent, t.startOffset, 1);
              }
              const n = e.graveyardPosition.parent;
              this._markInsert(n, e.graveyardPosition.offset, 1);
              const i = e.targetPosition.parent;
              if (!this._isInInsertedElement(i)) {
                this._markInsert(i, e.targetPosition.offset, t.maxOffset);
              }
              break;
            }
          }
          this._cachedChanges = null;
        }
        bufferMarkerChange(t, e, n) {
          const i = this._changedMarkers.get(t);
          if (!i) {
            this._changedMarkers.set(t, { newMarkerData: n, oldMarkerData: e });
          } else {
            i.newMarkerData = n;
            if (i.oldMarkerData.range == null && n.range == null) {
              this._changedMarkers.delete(t);
            }
          }
        }
        getMarkersToRemove() {
          const t = [];
          for (const [e, n] of this._changedMarkers) {
            if (n.oldMarkerData.range != null) {
              t.push({ name: e, range: n.oldMarkerData.range });
            }
          }
          return t;
        }
        getMarkersToAdd() {
          const t = [];
          for (const [e, n] of this._changedMarkers) {
            if (n.newMarkerData.range != null) {
              t.push({ name: e, range: n.newMarkerData.range });
            }
          }
          return t;
        }
        getChangedMarkers() {
          return Array.from(this._changedMarkers).map(([t, e]) => ({
            name: t,
            data: {
              oldRange: e.oldMarkerData.range,
              newRange: e.newMarkerData.range,
            },
          }));
        }
        hasDataChanges() {
          if (this._changesInElement.size > 0) {
            return true;
          }
          for (const {
            newMarkerData: t,
            oldMarkerData: e,
          } of this._changedMarkers.values()) {
            if (t.affectsData !== e.affectsData) {
              return true;
            }
            if (t.affectsData) {
              const n = t.range && !e.range;
              const i = !t.range && e.range;
              const o = t.range && e.range && !t.range.isEqual(e.range);
              if (n || i || o) {
                return true;
              }
            }
          }
          return false;
        }
        getChanges(t = {}) {
          if (this._cachedChanges) {
            if (t.includeChangesInGraveyard) {
              return this._cachedChangesWithGraveyard.slice();
            } else {
              return this._cachedChanges.slice();
            }
          }
          let e = [];
          for (const t of this._changesInElement.keys()) {
            const n = this._changesInElement.get(t).sort((t, e) => {
              if (t.offset === e.offset) {
                if (t.type != e.type) {
                  return t.type == "remove" ? -1 : 1;
                }
                return 0;
              }
              return t.offset < e.offset ? -1 : 1;
            });
            const i = this._elementSnapshots.get(t);
            const o = Lk(t.getChildren());
            const r = Nk(i.length, n);
            let s = 0;
            let a = 0;
            for (const n of r) {
              if (n === "i") {
                e.push(this._getInsertDiff(t, s, o[s]));
                s++;
              } else if (n === "r") {
                e.push(this._getRemoveDiff(t, s, i[a]));
                a++;
              } else if (n === "a") {
                const n = o[s].attributes;
                const r = i[a].attributes;
                let c;
                if (o[s].name == "$text") {
                  c = new Ef(wf._createAt(t, s), wf._createAt(t, s + 1));
                } else {
                  const e = t.offsetToIndex(s);
                  c = new Ef(
                    wf._createAt(t, s),
                    wf._createAt(t.getChild(e), 0)
                  );
                }
                e.push(...this._getAttributesDiff(c, r, n));
                s++;
                a++;
              } else {
                s++;
                a++;
              }
            }
          }
          e.sort((t, e) => {
            if (t.position.root != e.position.root) {
              return t.position.root.rootName < e.position.root.rootName
                ? -1
                : 1;
            }
            if (t.position.isEqual(e.position)) {
              return t.changeCount - e.changeCount;
            }
            return t.position.isBefore(e.position) ? -1 : 1;
          });
          for (let t = 1, n = 0; t < e.length; t++) {
            const i = e[n];
            const o = e[t];
            const r =
              i.type == "remove" &&
              o.type == "remove" &&
              i.name == "$text" &&
              o.name == "$text" &&
              i.position.isEqual(o.position);
            const s =
              i.type == "insert" &&
              o.type == "insert" &&
              i.name == "$text" &&
              o.name == "$text" &&
              i.position.parent == o.position.parent &&
              i.position.offset + i.length == o.position.offset;
            const a =
              i.type == "attribute" &&
              o.type == "attribute" &&
              i.position.parent == o.position.parent &&
              i.range.isFlat &&
              o.range.isFlat &&
              i.position.offset + i.length == o.position.offset &&
              i.attributeKey == o.attributeKey &&
              i.attributeOldValue == o.attributeOldValue &&
              i.attributeNewValue == o.attributeNewValue;
            if (r || s || a) {
              i.length++;
              if (a) {
                i.range.end = i.range.end.getShiftedBy(1);
              }
              e[t] = null;
            } else {
              n = t;
            }
          }
          e = e.filter((t) => t);
          for (const t of e) {
            delete t.changeCount;
            if (t.type == "attribute") {
              delete t.position;
              delete t.length;
            }
          }
          this._changeCount = 0;
          this._cachedChangesWithGraveyard = e;
          this._cachedChanges = e.filter(zk);
          if (t.includeChangesInGraveyard) {
            return this._cachedChangesWithGraveyard.slice();
          } else {
            return this._cachedChanges.slice();
          }
        }
        getRefreshedItems() {
          return new Set(this._refreshedItems);
        }
        reset() {
          this._changesInElement.clear();
          this._elementSnapshots.clear();
          this._changedMarkers.clear();
          this._refreshedItems = new Set();
          this._cachedChanges = null;
        }
        _refreshItem(t) {
          if (this._isInInsertedElement(t.parent)) {
            return;
          }
          this._markRemove(t.parent, t.startOffset, t.offsetSize);
          this._markInsert(t.parent, t.startOffset, t.offsetSize);
          this._refreshedItems.add(t);
          const e = Ef._createOn(t);
          for (const t of this._markerCollection.getMarkersIntersectingRange(
            e
          )) {
            const e = t.getData();
            this.bufferMarkerChange(t.name, e, e);
          }
          this._cachedChanges = null;
        }
        _markInsert(t, e, n) {
          const i = {
            type: "insert",
            offset: e,
            howMany: n,
            count: this._changeCount++,
          };
          this._markChange(t, i);
        }
        _markRemove(t, e, n) {
          const i = {
            type: "remove",
            offset: e,
            howMany: n,
            count: this._changeCount++,
          };
          this._markChange(t, i);
          this._removeAllNestedChanges(t, e, n);
        }
        _markAttribute(t) {
          const e = {
            type: "attribute",
            offset: t.startOffset,
            howMany: t.offsetSize,
            count: this._changeCount++,
          };
          this._markChange(t.parent, e);
        }
        _markChange(t, e) {
          this._makeSnapshot(t);
          const n = this._getChangesForElement(t);
          this._handleChange(e, n);
          n.push(e);
          for (let t = 0; t < n.length; t++) {
            if (n[t].howMany < 1) {
              n.splice(t, 1);
              t--;
            }
          }
        }
        _getChangesForElement(t) {
          let e;
          if (this._changesInElement.has(t)) {
            e = this._changesInElement.get(t);
          } else {
            e = [];
            this._changesInElement.set(t, e);
          }
          return e;
        }
        _makeSnapshot(t) {
          if (!this._elementSnapshots.has(t)) {
            this._elementSnapshots.set(t, Lk(t.getChildren()));
          }
        }
        _handleChange(t, e) {
          t.nodesToHandle = t.howMany;
          for (const n of e) {
            const i = t.offset + t.howMany;
            const o = n.offset + n.howMany;
            if (t.type == "insert") {
              if (n.type == "insert") {
                if (t.offset <= n.offset) {
                  n.offset += t.howMany;
                } else if (t.offset < o) {
                  n.howMany += t.nodesToHandle;
                  t.nodesToHandle = 0;
                }
              }
              if (n.type == "remove") {
                if (t.offset < n.offset) {
                  n.offset += t.howMany;
                }
              }
              if (n.type == "attribute") {
                if (t.offset <= n.offset) {
                  n.offset += t.howMany;
                } else if (t.offset < o) {
                  const o = n.howMany;
                  n.howMany = t.offset - n.offset;
                  e.unshift({
                    type: "attribute",
                    offset: i,
                    howMany: o - n.howMany,
                    count: this._changeCount++,
                  });
                }
              }
            }
            if (t.type == "remove") {
              if (n.type == "insert") {
                if (i <= n.offset) {
                  n.offset -= t.howMany;
                } else if (i <= o) {
                  if (t.offset < n.offset) {
                    const e = i - n.offset;
                    n.offset = t.offset;
                    n.howMany -= e;
                    t.nodesToHandle -= e;
                  } else {
                    n.howMany -= t.nodesToHandle;
                    t.nodesToHandle = 0;
                  }
                } else {
                  if (t.offset <= n.offset) {
                    t.nodesToHandle -= n.howMany;
                    n.howMany = 0;
                  } else if (t.offset < o) {
                    const e = o - t.offset;
                    n.howMany -= e;
                    t.nodesToHandle -= e;
                  }
                }
              }
              if (n.type == "remove") {
                if (i <= n.offset) {
                  n.offset -= t.howMany;
                } else if (t.offset < n.offset) {
                  t.nodesToHandle += n.howMany;
                  n.howMany = 0;
                }
              }
              if (n.type == "attribute") {
                if (i <= n.offset) {
                  n.offset -= t.howMany;
                } else if (t.offset < n.offset) {
                  const e = i - n.offset;
                  n.offset = t.offset;
                  n.howMany -= e;
                } else if (t.offset < o) {
                  if (i <= o) {
                    const i = n.howMany;
                    n.howMany = t.offset - n.offset;
                    const o = i - n.howMany - t.nodesToHandle;
                    e.unshift({
                      type: "attribute",
                      offset: t.offset,
                      howMany: o,
                      count: this._changeCount++,
                    });
                  } else {
                    n.howMany -= o - t.offset;
                  }
                }
              }
            }
            if (t.type == "attribute") {
              if (n.type == "insert") {
                if (t.offset < n.offset && i > n.offset) {
                  if (i > o) {
                    const t = {
                      type: "attribute",
                      offset: o,
                      howMany: i - o,
                      count: this._changeCount++,
                    };
                    this._handleChange(t, e);
                    e.push(t);
                  }
                  t.nodesToHandle = n.offset - t.offset;
                  t.howMany = t.nodesToHandle;
                } else if (t.offset >= n.offset && t.offset < o) {
                  if (i > o) {
                    t.nodesToHandle = i - o;
                    t.offset = o;
                  } else {
                    t.nodesToHandle = 0;
                  }
                }
              }
              if (n.type == "remove") {
                if (t.offset < n.offset && i > n.offset) {
                  const o = {
                    type: "attribute",
                    offset: n.offset,
                    howMany: i - n.offset,
                    count: this._changeCount++,
                  };
                  this._handleChange(o, e);
                  e.push(o);
                  t.nodesToHandle = n.offset - t.offset;
                  t.howMany = t.nodesToHandle;
                }
              }
              if (n.type == "attribute") {
                if (t.offset >= n.offset && i <= o) {
                  t.nodesToHandle = 0;
                  t.howMany = 0;
                  t.offset = 0;
                } else if (t.offset <= n.offset && i >= o) {
                  n.howMany = 0;
                }
              }
            }
          }
          t.howMany = t.nodesToHandle;
          delete t.nodesToHandle;
        }
        _getInsertDiff(t, e, n) {
          return {
            type: "insert",
            position: wf._createAt(t, e),
            name: n.name,
            attributes: new Map(n.attributes),
            length: 1,
            changeCount: this._changeCount++,
          };
        }
        _getRemoveDiff(t, e, n) {
          return {
            type: "remove",
            position: wf._createAt(t, e),
            name: n.name,
            attributes: new Map(n.attributes),
            length: 1,
            changeCount: this._changeCount++,
          };
        }
        _getAttributesDiff(t, e, n) {
          const i = [];
          n = new Map(n);
          for (const [o, r] of e) {
            const e = n.has(o) ? n.get(o) : null;
            if (e !== r) {
              i.push({
                type: "attribute",
                position: t.start,
                range: t.clone(),
                length: 1,
                attributeKey: o,
                attributeOldValue: r,
                attributeNewValue: e,
                changeCount: this._changeCount++,
              });
            }
            n.delete(o);
          }
          for (const [e, o] of n) {
            i.push({
              type: "attribute",
              position: t.start,
              range: t.clone(),
              length: 1,
              attributeKey: e,
              attributeOldValue: null,
              attributeNewValue: o,
              changeCount: this._changeCount++,
            });
          }
          return i;
        }
        _isInInsertedElement(t) {
          const e = t.parent;
          if (!e) {
            return false;
          }
          const n = this._changesInElement.get(e);
          const i = t.startOffset;
          if (n) {
            for (const t of n) {
              if (
                t.type == "insert" &&
                i >= t.offset &&
                i < t.offset + t.howMany
              ) {
                return true;
              }
            }
          }
          return this._isInInsertedElement(e);
        }
        _removeAllNestedChanges(t, e, n) {
          const i = new Ef(wf._createAt(t, e), wf._createAt(t, e + n));
          for (const t of i.getItems({ shallow: true })) {
            if (t.is("element")) {
              this._elementSnapshots.delete(t);
              this._changesInElement.delete(t);
              this._removeAllNestedChanges(t, 0, t.maxOffset);
            }
          }
        }
      }
      function Lk(t) {
        const e = [];
        for (const n of t) {
          if (n.is("$text")) {
            for (let t = 0; t < n.data.length; t++) {
              e.push({ name: "$text", attributes: new Map(n.getAttributes()) });
            }
          } else {
            e.push({ name: n.name, attributes: new Map(n.getAttributes()) });
          }
        }
        return e;
      }
      function Nk(t, e) {
        const n = [];
        let i = 0;
        let o = 0;
        for (const t of e) {
          if (t.offset > i) {
            for (let e = 0; e < t.offset - i; e++) {
              n.push("e");
            }
            o += t.offset - i;
          }
          if (t.type == "insert") {
            for (let e = 0; e < t.howMany; e++) {
              n.push("i");
            }
            i = t.offset + t.howMany;
          } else if (t.type == "remove") {
            for (let e = 0; e < t.howMany; e++) {
              n.push("r");
            }
            i = t.offset;
            o += t.howMany;
          } else {
            n.push(..."a".repeat(t.howMany).split(""));
            i = t.offset + t.howMany;
            o += t.howMany;
          }
        }
        if (o < t) {
          for (let e = 0; e < t - o - i; e++) {
            n.push("e");
          }
        }
        return n;
      }
      function zk(t) {
        const e = "position" in t && t.position.root.rootName == "$graveyard";
        const n = "range" in t && t.range.root.rootName == "$graveyard";
        return !e && !n;
      }
      class Pk {
        constructor() {
          this._operations = [];
          this._undoPairs = new Map();
          this._undoneOperations = new Set();
          this._baseVersionToOperationIndex = new Map();
          this._version = 0;
          this._gaps = new Map();
        }
        get version() {
          return this._version;
        }
        set version(t) {
          if (this._operations.length && t > this._version + 1) {
            this._gaps.set(this._version, t);
          }
          this._version = t;
        }
        get lastOperation() {
          return this._operations[this._operations.length - 1];
        }
        addOperation(t) {
          if (t.baseVersion !== this.version) {
            throw new M(
              "model-document-history-addoperation-incorrect-version",
              this,
              { operation: t, historyVersion: this.version }
            );
          }
          this._operations.push(t);
          this._version++;
          this._baseVersionToOperationIndex.set(
            t.baseVersion,
            this._operations.length - 1
          );
        }
        getOperations(t, e = this.version) {
          if (!this._operations.length) {
            return [];
          }
          const n = this._operations[0];
          if (t === undefined) {
            t = n.baseVersion;
          }
          let i = e - 1;
          for (const [e, n] of this._gaps) {
            if (t > e && t < n) {
              t = n;
            }
            if (i > e && i < n) {
              i = e - 1;
            }
          }
          if (i < n.baseVersion || t > this.lastOperation.baseVersion) {
            return [];
          }
          let o = this._baseVersionToOperationIndex.get(t);
          if (o === undefined) {
            o = 0;
          }
          let r = this._baseVersionToOperationIndex.get(i);
          if (r === undefined) {
            r = this._operations.length - 1;
          }
          return this._operations.slice(o, r + 1);
        }
        getOperation(t) {
          const e = this._baseVersionToOperationIndex.get(t);
          if (e === undefined) {
            return;
          }
          return this._operations[e];
        }
        setOperationAsUndone(t, e) {
          this._undoPairs.set(e, t);
          this._undoneOperations.add(t);
        }
        isUndoingOperation(t) {
          return this._undoPairs.has(t);
        }
        isUndoneOperation(t) {
          return this._undoneOperations.has(t);
        }
        getUndoneOperation(t) {
          return this._undoPairs.get(t);
        }
        reset() {
          this._version = 0;
          this._undoPairs = new Map();
          this._operations = [];
          this._undoneOperations = new Set();
          this._gaps = new Map();
          this._baseVersionToOperationIndex = new Map();
        }
      }
      class Rk extends ff {
        constructor(t, e, n = "main") {
          super(e);
          this._document = t;
          this.rootName = n;
        }
        get document() {
          return this._document;
        }
        toJSON() {
          return this.rootName;
        }
      }
      Rk.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "rootElement" ||
            t === "model:rootElement" ||
            t === "element" ||
            t === "model:element" ||
            t === "node" ||
            t === "model:node"
          );
        }
        return (
          e === this.name &&
          (t === "rootElement" ||
            t === "model:rootElement" ||
            t === "element" ||
            t === "model:element")
        );
      };
      const Ok = "$graveyard";
      class jk extends q() {
        constructor(t) {
          super();
          this.model = t;
          this.history = new Pk();
          this.selection = new Wf(this);
          this.roots = new rl({ idProperty: "rootName" });
          this.differ = new Bk(t.markers);
          this._postFixers = new Set();
          this._hasSelectionChangedFromTheLastChangeBlock = false;
          this.createRoot("$root", Ok);
          this.listenTo(
            t,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              if (n.isDocumentOperation) {
                this.differ.bufferOperation(n);
              }
            },
            { priority: "high" }
          );
          this.listenTo(
            t,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              if (n.isDocumentOperation) {
                this.history.addOperation(n);
              }
            },
            { priority: "low" }
          );
          this.listenTo(this.selection, "change", () => {
            this._hasSelectionChangedFromTheLastChangeBlock = true;
          });
          this.listenTo(t.markers, "update", (t, e, n, i, o) => {
            const r = { ...e.getData(), range: i };
            this.differ.bufferMarkerChange(e.name, o, r);
            if (n === null) {
              e.on("change", (t, n) => {
                const i = e.getData();
                this.differ.bufferMarkerChange(e.name, { ...i, range: n }, i);
              });
            }
          });
        }
        get version() {
          return this.history.version;
        }
        set version(t) {
          this.history.version = t;
        }
        get graveyard() {
          return this.getRoot(Ok);
        }
        createRoot(t = "$root", e = "main") {
          if (this.roots.get(e)) {
            throw new M("model-document-createroot-name-exists", this, {
              name: e,
            });
          }
          const n = new Rk(this, t, e);
          this.roots.add(n);
          return n;
        }
        destroy() {
          this.selection.destroy();
          this.stopListening();
        }
        getRoot(t = "main") {
          return this.roots.get(t);
        }
        getRootNames() {
          return Array.from(this.roots, (t) => t.rootName).filter(
            (t) => t != Ok
          );
        }
        registerPostFixer(t) {
          this._postFixers.add(t);
        }
        toJSON() {
          const t = $l(this);
          t.selection = "[engine.model.DocumentSelection]";
          t.model = "[engine.model.Model]";
          return t;
        }
        _handleChangeBlock(t) {
          if (this._hasDocumentChangedFromTheLastChangeBlock()) {
            this._callPostFixers(t);
            this.selection.refresh();
            if (this.differ.hasDataChanges()) {
              this.fire("change:data", t.batch);
            } else {
              this.fire("change", t.batch);
            }
            this.selection.refresh();
            this.differ.reset();
          }
          this._hasSelectionChangedFromTheLastChangeBlock = false;
        }
        _hasDocumentChangedFromTheLastChangeBlock() {
          return (
            !this.differ.isEmpty ||
            this._hasSelectionChangedFromTheLastChangeBlock
          );
        }
        _getDefaultRoot() {
          for (const t of this.roots) {
            if (t !== this.graveyard) {
              return t;
            }
          }
          return this.graveyard;
        }
        _getDefaultRange() {
          const t = this._getDefaultRoot();
          const e = this.model;
          const n = e.schema;
          const i = e.createPositionFromPath(t, [0]);
          const o = n.getNearestSelectionRange(i);
          return o || e.createRange(i);
        }
        _validateSelectionRange(t) {
          return Fk(t.start) && Fk(t.end);
        }
        _callPostFixers(t) {
          let e = false;
          do {
            for (const n of this._postFixers) {
              this.selection.refresh();
              e = n(t);
              if (e) {
                break;
              }
            }
          } while (e);
        }
      }
      function Fk(t) {
        const e = t.textNode;
        if (e) {
          const n = e.data;
          const i = t.offset - e.startOffset;
          return !pl(n, i) && !bl(n, i);
        }
        return true;
      }
      class Vk extends q() {
        constructor() {
          super();
          this._markers = new Map();
        }
        [Symbol.iterator]() {
          return this._markers.values();
        }
        has(t) {
          const e = t instanceof Hk ? t.name : t;
          return this._markers.has(e);
        }
        get(t) {
          return this._markers.get(t) || null;
        }
        _set(t, e, n = false, i = false) {
          const o = t instanceof Hk ? t.name : t;
          if (o.includes(",")) {
            throw new M("markercollection-incorrect-marker-name", this);
          }
          const r = this._markers.get(o);
          if (r) {
            const t = r.getData();
            const s = r.getRange();
            let a = false;
            if (!s.isEqual(e)) {
              r._attachLiveRange(Ff.fromRange(e));
              a = true;
            }
            if (n != r.managedUsingOperations) {
              r._managedUsingOperations = n;
              a = true;
            }
            if (typeof i === "boolean" && i != r.affectsData) {
              r._affectsData = i;
              a = true;
            }
            if (a) {
              this.fire(\`update:\${o}\`, r, s, e, t);
            }
            return r;
          }
          const s = Ff.fromRange(e);
          const a = new Hk(o, s, n, i);
          this._markers.set(o, a);
          this.fire(\`update:\${o}\`, a, null, e, { ...a.getData(), range: null });
          return a;
        }
        _remove(t) {
          const e = t instanceof Hk ? t.name : t;
          const n = this._markers.get(e);
          if (n) {
            this._markers.delete(e);
            this.fire(\`update:\${e}\`, n, n.getRange(), null, n.getData());
            this._destroyMarker(n);
            return true;
          }
          return false;
        }
        _refresh(t) {
          const e = t instanceof Hk ? t.name : t;
          const n = this._markers.get(e);
          if (!n) {
            throw new M("markercollection-refresh-marker-not-exists", this);
          }
          const i = n.getRange();
          this.fire(\`update:\${e}\`, n, i, i, n.getData());
        }
        *getMarkersAtPosition(t) {
          for (const e of this) {
            if (e.getRange().containsPosition(t)) {
              yield e;
            }
          }
        }
        *getMarkersIntersectingRange(t) {
          for (const e of this) {
            if (e.getRange().getIntersection(t) !== null) {
              yield e;
            }
          }
        }
        destroy() {
          for (const t of this._markers.values()) {
            this._destroyMarker(t);
          }
          this._markers = null;
          this.stopListening();
        }
        *getMarkersGroup(t) {
          for (const e of this._markers.values()) {
            if (e.name.startsWith(t + ":")) {
              yield e;
            }
          }
        }
        _destroyMarker(t) {
          t.stopListening();
          t._detachLiveRange();
        }
      }
      class Hk extends q(df) {
        constructor(t, e, n, i) {
          super();
          this.name = t;
          this._liveRange = this._attachLiveRange(e);
          this._managedUsingOperations = n;
          this._affectsData = i;
        }
        get managedUsingOperations() {
          if (!this._liveRange) {
            throw new M("marker-destroyed", this);
          }
          return this._managedUsingOperations;
        }
        get affectsData() {
          if (!this._liveRange) {
            throw new M("marker-destroyed", this);
          }
          return this._affectsData;
        }
        getData() {
          return {
            range: this.getRange(),
            affectsData: this.affectsData,
            managedUsingOperations: this.managedUsingOperations,
          };
        }
        getStart() {
          if (!this._liveRange) {
            throw new M("marker-destroyed", this);
          }
          return this._liveRange.start.clone();
        }
        getEnd() {
          if (!this._liveRange) {
            throw new M("marker-destroyed", this);
          }
          return this._liveRange.end.clone();
        }
        getRange() {
          if (!this._liveRange) {
            throw new M("marker-destroyed", this);
          }
          return this._liveRange.toRange();
        }
        _attachLiveRange(t) {
          if (this._liveRange) {
            this._detachLiveRange();
          }
          t.delegate("change:range").to(this);
          t.delegate("change:content").to(this);
          this._liveRange = t;
          return t;
        }
        _detachLiveRange() {
          this._liveRange.stopDelegating("change:range", this);
          this._liveRange.stopDelegating("change:content", this);
          this._liveRange.detach();
          this._liveRange = null;
        }
      }
      Hk.prototype.is = function (t) {
        return t === "marker" || t === "model:marker";
      };
      class Uk extends $b {
        constructor(t, e) {
          super(null);
          this.sourcePosition = t.clone();
          this.howMany = e;
        }
        get type() {
          return "detach";
        }
        toJSON() {
          const t = super.toJSON();
          t.sourcePosition = this.sourcePosition.toJSON();
          return t;
        }
        _validate() {
          if (this.sourcePosition.root.document) {
            throw new M("detach-operation-on-document-node", this);
          }
        }
        _execute() {
          Yb(Ef._createFromPositionAndShift(this.sourcePosition, this.howMany));
        }
        static get className() {
          return "DetachOperation";
        }
      }
      class qk extends df {
        constructor(t) {
          super();
          this.markers = new Map();
          this._children = new hf();
          if (t) {
            this._insertChild(0, t);
          }
        }
        [Symbol.iterator]() {
          return this.getChildren();
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get nextSibling() {
          return null;
        }
        get previousSibling() {
          return null;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        get document() {
          return null;
        }
        getAncestors() {
          return [];
        }
        getChild(t) {
          return this._children.getNode(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(t) {
          return this._children.getNodeIndex(t);
        }
        getChildStartOffset(t) {
          return this._children.getNodeStartOffset(t);
        }
        getPath() {
          return [];
        }
        getNodeByPath(t) {
          let e = this;
          for (const n of t) {
            e = e.getChild(e.offsetToIndex(n));
          }
          return e;
        }
        offsetToIndex(t) {
          return this._children.offsetToIndex(t);
        }
        toJSON() {
          const t = [];
          for (const e of this._children) {
            t.push(e.toJSON());
          }
          return t;
        }
        static fromJSON(t) {
          const e = [];
          for (const n of t) {
            if (n.name) {
              e.push(ff.fromJSON(n));
            } else {
              e.push(mf.fromJSON(n));
            }
          }
          return new qk(e);
        }
        _appendChild(t) {
          this._insertChild(this.childCount, t);
        }
        _insertChild(t, e) {
          const n = Wk(e);
          for (const t of n) {
            if (t.parent !== null) {
              t._remove();
            }
            t.parent = this;
          }
          this._children._insertNodes(t, n);
        }
        _removeChildren(t, e = 1) {
          const n = this._children._removeNodes(t, e);
          for (const t of n) {
            t.parent = null;
          }
          return n;
        }
      }
      qk.prototype.is = function (t) {
        return t === "documentFragment" || t === "model:documentFragment";
      };
      function Wk(t) {
        if (typeof t == "string") {
          return [new mf(t)];
        }
        if (!yt(t)) {
          t = [t];
        }
        return Array.from(t).map((t) => {
          if (typeof t == "string") {
            return new mf(t);
          }
          if (t instanceof gf) {
            return new mf(t.data, t.getAttributes());
          }
          return t;
        });
      }
      class Gk {
        constructor(t, e) {
          this.model = t;
          this.batch = e;
        }
        createText(t, e) {
          return new mf(t, e);
        }
        createElement(t, e) {
          return new ff(t, e);
        }
        createDocumentFragment() {
          return new qk();
        }
        cloneElement(t, e = true) {
          return t._clone(e);
        }
        insert(t, e, n = 0) {
          this._assertWriterUsedCorrectly();
          if (t instanceof mf && t.data == "") {
            return;
          }
          const i = wf._createAt(e, n);
          if (t.parent) {
            if (Qk(t.root, i.root)) {
              this.move(Ef._createOn(t), i);
              return;
            } else {
              if (t.root.document) {
                throw new M("model-writer-insert-forbidden-move", this);
              } else {
                this.remove(t);
              }
            }
          }
          const o = i.root.document ? i.root.document.version : null;
          const r = new ik(i, t, o);
          if (t instanceof mf) {
            r.shouldReceiveAttributes = true;
          }
          this.batch.addOperation(r);
          this.model.applyOperation(r);
          if (t instanceof qk) {
            for (const [e, n] of t.markers) {
              const t = wf._createAt(n.root, 0);
              const o = new Ef(
                n.start._getCombined(t, i),
                n.end._getCombined(t, i)
              );
              const r = { range: o, usingOperation: true, affectsData: true };
              if (this.model.markers.has(e)) {
                this.updateMarker(e, r);
              } else {
                this.addMarker(e, r);
              }
            }
          }
        }
        insertText(t, e, n, i) {
          if (e instanceof qk || e instanceof ff || e instanceof wf) {
            this.insert(this.createText(t), e, n);
          } else {
            this.insert(this.createText(t, e), n, i);
          }
        }
        insertElement(t, e, n, i) {
          if (e instanceof qk || e instanceof ff || e instanceof wf) {
            this.insert(this.createElement(t), e, n);
          } else {
            this.insert(this.createElement(t, e), n, i);
          }
        }
        append(t, e) {
          this.insert(t, e, "end");
        }
        appendText(t, e, n) {
          if (e instanceof qk || e instanceof ff) {
            this.insert(this.createText(t), e, "end");
          } else {
            this.insert(this.createText(t, e), n, "end");
          }
        }
        appendElement(t, e, n) {
          if (e instanceof qk || e instanceof ff) {
            this.insert(this.createElement(t), e, "end");
          } else {
            this.insert(this.createElement(t, e), n, "end");
          }
        }
        setAttribute(t, e, n) {
          this._assertWriterUsedCorrectly();
          if (n instanceof Ef) {
            const i = n.getMinimalFlatRanges();
            for (const n of i) {
              $k(this, t, e, n);
            }
          } else {
            Kk(this, t, e, n);
          }
        }
        setAttributes(t, e) {
          for (const [n, i] of dl(t)) {
            this.setAttribute(n, i, e);
          }
        }
        removeAttribute(t, e) {
          this._assertWriterUsedCorrectly();
          if (e instanceof Ef) {
            const n = e.getMinimalFlatRanges();
            for (const e of n) {
              $k(this, t, null, e);
            }
          } else {
            Kk(this, t, null, e);
          }
        }
        clearAttributes(t) {
          this._assertWriterUsedCorrectly();
          const e = (t) => {
            for (const e of t.getAttributeKeys()) {
              this.removeAttribute(e, t);
            }
          };
          if (!(t instanceof Ef)) {
            e(t);
          } else {
            for (const n of t.getItems()) {
              e(n);
            }
          }
        }
        move(t, e, n) {
          this._assertWriterUsedCorrectly();
          if (!(t instanceof Ef)) {
            throw new M("writer-move-invalid-range", this);
          }
          if (!t.isFlat) {
            throw new M("writer-move-range-not-flat", this);
          }
          const i = wf._createAt(e, n);
          if (i.isEqual(t.start)) {
            return;
          }
          this._addOperationForAffectedMarkers("move", t);
          if (!Qk(t.root, i.root)) {
            throw new M("writer-move-different-document", this);
          }
          const o = t.root.document ? t.root.document.version : null;
          const r = new nk(t.start, t.end.offset - t.start.offset, i, o);
          this.batch.addOperation(r);
          this.model.applyOperation(r);
        }
        remove(t) {
          this._assertWriterUsedCorrectly();
          const e = t instanceof Ef ? t : Ef._createOn(t);
          const n = e.getMinimalFlatRanges().reverse();
          for (const t of n) {
            this._addOperationForAffectedMarkers("move", t);
            Zk(t.start, t.end.offset - t.start.offset, this.batch, this.model);
          }
        }
        merge(t) {
          this._assertWriterUsedCorrectly();
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          this._addOperationForAffectedMarkers("merge", t);
          if (!(e instanceof ff)) {
            throw new M("writer-merge-no-element-before", this);
          }
          if (!(n instanceof ff)) {
            throw new M("writer-merge-no-element-after", this);
          }
          if (!t.root.document) {
            this._mergeDetached(t);
          } else {
            this._merge(t);
          }
        }
        createPositionFromPath(t, e, n) {
          return this.model.createPositionFromPath(t, e, n);
        }
        createPositionAt(t, e) {
          return this.model.createPositionAt(t, e);
        }
        createPositionAfter(t) {
          return this.model.createPositionAfter(t);
        }
        createPositionBefore(t) {
          return this.model.createPositionBefore(t);
        }
        createRange(t, e) {
          return this.model.createRange(t, e);
        }
        createRangeIn(t) {
          return this.model.createRangeIn(t);
        }
        createRangeOn(t) {
          return this.model.createRangeOn(t);
        }
        createSelection(...t) {
          return this.model.createSelection(...t);
        }
        _mergeDetached(t) {
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          this.move(Ef._createIn(n), wf._createAt(e, "end"));
          this.remove(n);
        }
        _merge(t) {
          const e = wf._createAt(t.nodeBefore, "end");
          const n = wf._createAt(t.nodeAfter, 0);
          const i = t.root.document.graveyard;
          const o = new wf(i, [0]);
          const r = t.root.document.version;
          const s = new uk(n, t.nodeAfter.maxOffset, e, o, r);
          this.batch.addOperation(s);
          this.model.applyOperation(s);
        }
        rename(t, e) {
          this._assertWriterUsedCorrectly();
          if (!(t instanceof ff)) {
            throw new M("writer-rename-not-element-instance", this);
          }
          const n = t.root.document ? t.root.document.version : null;
          const i = new lk(wf._createBefore(t), t.name, e, n);
          this.batch.addOperation(i);
          this.model.applyOperation(i);
        }
        split(t, e) {
          this._assertWriterUsedCorrectly();
          let n = t.parent;
          if (!n.parent) {
            throw new M("writer-split-element-no-parent", this);
          }
          if (!e) {
            e = n.parent;
          }
          if (!t.parent.getAncestors({ includeSelf: true }).includes(e)) {
            throw new M("writer-split-invalid-limit-element", this);
          }
          let i;
          let o;
          do {
            const e = n.root.document ? n.root.document.version : null;
            const r = n.maxOffset - t.offset;
            const s = hk.getInsertionPosition(t);
            const a = new hk(t, r, s, null, e);
            this.batch.addOperation(a);
            this.model.applyOperation(a);
            if (!i && !o) {
              i = n;
              o = t.parent.nextSibling;
            }
            t = this.createPositionAfter(t.parent);
            n = t.parent;
          } while (n !== e);
          return {
            position: t,
            range: new Ef(wf._createAt(i, "end"), wf._createAt(o, 0)),
          };
        }
        wrap(t, e) {
          this._assertWriterUsedCorrectly();
          if (!t.isFlat) {
            throw new M("writer-wrap-range-not-flat", this);
          }
          const n = e instanceof ff ? e : new ff(e);
          if (n.childCount > 0) {
            throw new M("writer-wrap-element-not-empty", this);
          }
          if (n.parent !== null) {
            throw new M("writer-wrap-element-attached", this);
          }
          this.insert(n, t.start);
          const i = new Ef(t.start.getShiftedBy(1), t.end.getShiftedBy(1));
          this.move(i, wf._createAt(n, 0));
        }
        unwrap(t) {
          this._assertWriterUsedCorrectly();
          if (t.parent === null) {
            throw new M("writer-unwrap-element-no-parent", this);
          }
          this.move(Ef._createIn(t), this.createPositionAfter(t));
          this.remove(t);
        }
        addMarker(t, e) {
          this._assertWriterUsedCorrectly();
          if (!e || typeof e.usingOperation != "boolean") {
            throw new M("writer-addmarker-no-usingoperation", this);
          }
          const n = e.usingOperation;
          const i = e.range;
          const o = e.affectsData === undefined ? false : e.affectsData;
          if (this.model.markers.has(t)) {
            throw new M("writer-addmarker-marker-exists", this);
          }
          if (!i) {
            throw new M("writer-addmarker-no-range", this);
          }
          if (!n) {
            return this.model.markers._set(t, i, n, o);
          }
          Yk(this, t, null, i, o);
          return this.model.markers.get(t);
        }
        updateMarker(t, e) {
          this._assertWriterUsedCorrectly();
          const n = typeof t == "string" ? t : t.name;
          const i = this.model.markers.get(n);
          if (!i) {
            throw new M("writer-updatemarker-marker-not-exists", this);
          }
          if (!e) {
            B("writer-updatemarker-reconvert-using-editingcontroller", {
              markerName: n,
            });
            this.model.markers._refresh(i);
            return;
          }
          const o = typeof e.usingOperation == "boolean";
          const r = typeof e.affectsData == "boolean";
          const s = r ? e.affectsData : i.affectsData;
          if (!o && !e.range && !r) {
            throw new M("writer-updatemarker-wrong-options", this);
          }
          const a = i.getRange();
          const c = e.range ? e.range : a;
          if (o && e.usingOperation !== i.managedUsingOperations) {
            if (e.usingOperation) {
              Yk(this, n, null, c, s);
            } else {
              Yk(this, n, a, null, s);
              this.model.markers._set(n, c, undefined, s);
            }
            return;
          }
          if (i.managedUsingOperations) {
            Yk(this, n, a, c, s);
          } else {
            this.model.markers._set(n, c, undefined, s);
          }
        }
        removeMarker(t) {
          this._assertWriterUsedCorrectly();
          const e = typeof t == "string" ? t : t.name;
          if (!this.model.markers.has(e)) {
            throw new M("writer-removemarker-no-marker", this);
          }
          const n = this.model.markers.get(e);
          if (!n.managedUsingOperations) {
            this.model.markers._remove(e);
            return;
          }
          const i = n.getRange();
          Yk(this, e, i, null, n.affectsData);
        }
        setSelection(...t) {
          this._assertWriterUsedCorrectly();
          this.model.document.selection._setTo(...t);
        }
        setSelectionFocus(t, e) {
          this._assertWriterUsedCorrectly();
          this.model.document.selection._setFocus(t, e);
        }
        setSelectionAttribute(t, e) {
          this._assertWriterUsedCorrectly();
          if (typeof t === "string") {
            this._setSelectionAttribute(t, e);
          } else {
            for (const [e, n] of dl(t)) {
              this._setSelectionAttribute(e, n);
            }
          }
        }
        removeSelectionAttribute(t) {
          this._assertWriterUsedCorrectly();
          if (typeof t === "string") {
            this._removeSelectionAttribute(t);
          } else {
            for (const e of t) {
              this._removeSelectionAttribute(e);
            }
          }
        }
        overrideSelectionGravity() {
          return this.model.document.selection._overrideGravity();
        }
        restoreSelectionGravity(t) {
          this.model.document.selection._restoreGravity(t);
        }
        _setSelectionAttribute(t, e) {
          const n = this.model.document.selection;
          if (n.isCollapsed && n.anchor.parent.isEmpty) {
            const i = Wf._getStoreAttributeKey(t);
            this.setAttribute(i, e, n.anchor.parent);
          }
          n._setAttribute(t, e);
        }
        _removeSelectionAttribute(t) {
          const e = this.model.document.selection;
          if (e.isCollapsed && e.anchor.parent.isEmpty) {
            const n = Wf._getStoreAttributeKey(t);
            this.removeAttribute(n, e.anchor.parent);
          }
          e._removeAttribute(t);
        }
        _assertWriterUsedCorrectly() {
          if (this.model._currentWriter !== this) {
            throw new M("writer-incorrect-use", this);
          }
        }
        _addOperationForAffectedMarkers(t, e) {
          for (const n of this.model.markers) {
            if (!n.managedUsingOperations) {
              continue;
            }
            const i = n.getRange();
            let o = false;
            if (t === "move") {
              const t = e;
              o =
                t.containsPosition(i.start) ||
                t.start.isEqual(i.start) ||
                t.containsPosition(i.end) ||
                t.end.isEqual(i.end);
            } else {
              const t = e;
              const n = t.nodeBefore;
              const r = t.nodeAfter;
              const s = i.start.parent == n && i.start.isAtEnd;
              const a = i.end.parent == r && i.end.offset == 0;
              const c = i.end.nodeAfter == r;
              const l = i.start.nodeAfter == r;
              o = s || a || c || l;
            }
            if (o) {
              this.updateMarker(n.name, { range: i });
            }
          }
        }
      }
      function $k(t, e, n, i) {
        const o = t.model;
        const r = o.document;
        let s = i.start;
        let a;
        let c;
        let l;
        for (const t of i.getWalker({ shallow: true })) {
          l = t.item.getAttribute(e);
          if (a && c != l) {
            if (c != n) {
              d();
            }
            s = a;
          }
          a = t.nextPosition;
          c = l;
        }
        if (a instanceof wf && a != s && c != n) {
          d();
        }
        function d() {
          const i = new Ef(s, a);
          const l = i.root.document ? r.version : null;
          const d = new ak(i, e, c, n, l);
          t.batch.addOperation(d);
          o.applyOperation(d);
        }
      }
      function Kk(t, e, n, i) {
        const o = t.model;
        const r = o.document;
        const s = i.getAttribute(e);
        let a, c;
        if (s != n) {
          const l = i.root === i;
          if (l) {
            const t = i.document ? r.version : null;
            c = new dk(i, e, s, n, t);
          } else {
            a = new Ef(wf._createBefore(i), t.createPositionAfter(i));
            const o = a.root.document ? r.version : null;
            c = new ak(a, e, s, n, o);
          }
          t.batch.addOperation(c);
          o.applyOperation(c);
        }
      }
      function Yk(t, e, n, i, o) {
        const r = t.model;
        const s = r.document;
        const a = new ok(e, n, i, r.markers, !!o, s.version);
        t.batch.addOperation(a);
        r.applyOperation(a);
      }
      function Zk(t, e, n, i) {
        let o;
        if (t.root.document) {
          const n = i.document;
          const r = new wf(n.graveyard, [0]);
          o = new nk(t, e, r, n.version);
        } else {
          o = new Uk(t, e);
        }
        n.addOperation(o);
        i.applyOperation(o);
      }
      function Qk(t, e) {
        if (t === e) {
          return true;
        }
        if (t instanceof Rk && e instanceof Rk) {
          return true;
        }
        return false;
      }
      function Jk(t) {
        t.document.registerPostFixer((e) => Xk(e, t));
      }
      function Xk(t, e) {
        const n = e.document.selection;
        const i = e.schema;
        const o = [];
        let r = false;
        for (const t of n.getRanges()) {
          const e = tw(t, i);
          if (e && !e.isEqual(t)) {
            o.push(e);
            r = true;
          } else {
            o.push(t);
          }
        }
        if (r) {
          t.setSelection(rw(o), { backward: n.isBackward });
        }
        return false;
      }
      function tw(t, e) {
        if (t.isCollapsed) {
          return ew(t, e);
        }
        return nw(t, e);
      }
      function ew(t, e) {
        const n = t.start;
        const i = e.getNearestSelectionRange(n);
        if (!i) {
          const t = n
            .getAncestors()
            .reverse()
            .find((t) => e.isObject(t));
          if (t) {
            return Ef._createOn(t);
          }
          return null;
        }
        if (!i.isCollapsed) {
          return i;
        }
        const o = i.start;
        if (n.isEqual(o)) {
          return null;
        }
        return new Ef(o);
      }
      function nw(t, e) {
        const { start: n, end: i } = t;
        const o = e.checkChild(n, "$text");
        const r = e.checkChild(i, "$text");
        const s = e.getLimitElement(n);
        const a = e.getLimitElement(i);
        if (s === a) {
          if (o && r) {
            return null;
          }
          if (ow(n, i, e)) {
            const t = n.nodeAfter && e.isSelectable(n.nodeAfter);
            const o = t ? null : e.getNearestSelectionRange(n, "forward");
            const r = i.nodeBefore && e.isSelectable(i.nodeBefore);
            const s = r ? null : e.getNearestSelectionRange(i, "backward");
            const a = o ? o.start : n;
            const c = s ? s.end : i;
            return new Ef(a, c);
          }
        }
        const c = s && !s.is("rootElement");
        const l = a && !a.is("rootElement");
        if (c || l) {
          const t =
            n.nodeAfter &&
            i.nodeBefore &&
            n.nodeAfter.parent === i.nodeBefore.parent;
          const o = c && (!t || !sw(n.nodeAfter, e));
          const r = l && (!t || !sw(i.nodeBefore, e));
          let d = n;
          let u = i;
          if (o) {
            d = wf._createBefore(iw(s, e));
          }
          if (r) {
            u = wf._createAfter(iw(a, e));
          }
          return new Ef(d, u);
        }
        return null;
      }
      function iw(t, e) {
        let n = t;
        let i = n;
        while (e.isLimit(i) && i.parent) {
          n = i;
          i = i.parent;
        }
        return n;
      }
      function ow(t, e, n) {
        const i =
          (t.nodeAfter && !n.isLimit(t.nodeAfter)) || n.checkChild(t, "$text");
        const o =
          (e.nodeBefore && !n.isLimit(e.nodeBefore)) ||
          n.checkChild(e, "$text");
        return i || o;
      }
      function rw(t) {
        const e = [...t];
        const n = new Set();
        let i = 1;
        while (i < e.length) {
          const t = e[i];
          const o = e.slice(0, i);
          for (const [r, s] of o.entries()) {
            if (n.has(r)) {
              continue;
            }
            if (t.isEqual(s)) {
              n.add(r);
            } else if (t.isIntersecting(s)) {
              n.add(r);
              n.add(i);
              const o = t.getJoined(s);
              e.push(o);
            }
          }
          i++;
        }
        const o = e.filter((t, e) => !n.has(e));
        return o;
      }
      function sw(t, e) {
        return t && e.isSelectable(t);
      }
      function aw(t, e, n = {}) {
        if (e.isCollapsed) {
          return;
        }
        const i = e.getFirstRange();
        if (i.root.rootName == "$graveyard") {
          return;
        }
        const o = t.schema;
        t.change((t) => {
          if (!n.doNotResetEntireContent && Aw(o, e)) {
            ww(t, e);
            return;
          }
          const r = {};
          if (!n.doNotAutoparagraph) {
            const t = e.getSelectedElement();
            if (t) {
              Object.assign(
                r,
                o.getAttributesWithProperty(t, "copyOnReplace", true)
              );
            }
          }
          const [s, a] = cw(i);
          if (!s.isTouching(a)) {
            t.remove(t.createRange(s, a));
          }
          if (!n.leaveUnmerged) {
            dw(t, s, a);
            o.removeDisallowedAttributes(s.parent.getChildren(), t);
          }
          Cw(t, e, s);
          if (!n.doNotAutoparagraph && pw(o, s)) {
            kw(t, s, e, r);
          }
          s.detach();
          a.detach();
        });
      }
      function cw(t) {
        const e = t.root.document.model;
        const n = t.start;
        let i = t.end;
        if (e.hasContent(t, { ignoreMarkers: true })) {
          const n = lw(i);
          if (n && i.isTouching(e.createPositionAt(n, 0))) {
            const n = e.createSelection(t);
            e.modifySelection(n, { direction: "backward" });
            const o = n.getLastPosition();
            const r = e.createRange(o, i);
            if (!e.hasContent(r, { ignoreMarkers: true })) {
              i = o;
            }
          }
        }
        return [Sk.fromPosition(n, "toPrevious"), Sk.fromPosition(i, "toNext")];
      }
      function lw(t) {
        const e = t.parent;
        const n = e.root.document.model.schema;
        const i = e.getAncestors({ parentFirst: true, includeSelf: true });
        for (const t of i) {
          if (n.isLimit(t)) {
            return null;
          }
          if (n.isBlock(t)) {
            return t;
          }
        }
      }
      function dw(t, e, n) {
        const i = t.model;
        if (!gw(t.model.schema, e, n)) {
          return;
        }
        const [o, r] = fw(e, n);
        if (!o || !r) {
          return;
        }
        if (
          !i.hasContent(o, { ignoreMarkers: true }) &&
          i.hasContent(r, { ignoreMarkers: true })
        ) {
          hw(t, e, n, o.parent);
        } else {
          uw(t, e, n, o.parent);
        }
      }
      function uw(t, e, n, i) {
        const o = e.parent;
        const r = n.parent;
        if (o == i || r == i) {
          return;
        }
        e = t.createPositionAfter(o);
        n = t.createPositionBefore(r);
        if (!n.isEqual(e)) {
          t.insert(r, e);
        }
        t.merge(e);
        while (n.parent.isEmpty) {
          const e = n.parent;
          n = t.createPositionBefore(e);
          t.remove(e);
        }
        if (!gw(t.model.schema, e, n)) {
          return;
        }
        uw(t, e, n, i);
      }
      function hw(t, e, n, i) {
        const o = e.parent;
        const r = n.parent;
        if (o == i || r == i) {
          return;
        }
        e = t.createPositionAfter(o);
        n = t.createPositionBefore(r);
        if (!n.isEqual(e)) {
          t.insert(o, n);
        }
        while (e.parent.isEmpty) {
          const n = e.parent;
          e = t.createPositionBefore(n);
          t.remove(n);
        }
        n = t.createPositionBefore(r);
        mw(t, n);
        if (!gw(t.model.schema, e, n)) {
          return;
        }
        hw(t, e, n, i);
      }
      function mw(t, e) {
        const n = e.nodeBefore;
        const i = e.nodeAfter;
        if (n.name != i.name) {
          t.rename(n, i.name);
        }
        t.clearAttributes(n);
        t.setAttributes(Object.fromEntries(i.getAttributes()), n);
        t.merge(e);
      }
      function gw(t, e, n) {
        const i = e.parent;
        const o = n.parent;
        if (i == o) {
          return false;
        }
        if (t.isLimit(i) || t.isLimit(o)) {
          return false;
        }
        return bw(e, n, t);
      }
      function fw(t, e) {
        const n = t.getAncestors();
        const i = e.getAncestors();
        let o = 0;
        while (n[o] && n[o] == i[o]) {
          o++;
        }
        return [n[o], i[o]];
      }
      function pw(t, e) {
        const n = t.checkChild(e, "$text");
        const i = t.checkChild(e, "paragraph");
        return !n && i;
      }
      function bw(t, e, n) {
        const i = new Ef(t, e);
        for (const t of i.getWalker()) {
          if (n.isLimit(t.item)) {
            return false;
          }
        }
        return true;
      }
      function kw(t, e, n, i = {}) {
        const o = t.createElement("paragraph");
        t.model.schema.setAllowedAttributes(o, i, t);
        t.insert(o, e);
        Cw(t, n, t.createPositionAt(o, 0));
      }
      function ww(t, e) {
        const n = t.model.schema.getLimitElement(e);
        t.remove(t.createRangeIn(n));
        kw(t, t.createPositionAt(n, 0), e);
      }
      function Aw(t, e) {
        const n = t.getLimitElement(e);
        if (!e.containsEntireContent(n)) {
          return false;
        }
        const i = e.getFirstRange();
        if (i.start.parent == i.end.parent) {
          return false;
        }
        return t.checkChild(n, "paragraph");
      }
      function Cw(t, e, n) {
        if (e instanceof Wf) {
          t.setSelection(n);
        } else {
          e.setTo(n);
        }
      }
      function _w(t, e) {
        return t.change((t) => {
          const n = t.createDocumentFragment();
          const i = e.getFirstRange();
          if (!i || i.isCollapsed) {
            return n;
          }
          const o = i.start.root;
          const r = i.start.getCommonPath(i.end);
          const s = o.getNodeByPath(r);
          let a;
          if (i.start.parent == i.end.parent) {
            a = i;
          } else {
            a = t.createRange(
              t.createPositionAt(s, i.start.path[r.length]),
              t.createPositionAt(s, i.end.path[r.length] + 1)
            );
          }
          const c = a.end.offset - a.start.offset;
          for (const e of a.getItems({ shallow: true })) {
            if (e.is("$textProxy")) {
              t.appendText(e.data, e.getAttributes(), n);
            } else {
              t.append(t.cloneElement(e, true), n);
            }
          }
          if (a != i) {
            const e = i._getTransformedByMove(
              a.start,
              t.createPositionAt(n, 0),
              c
            )[0];
            const o = t.createRange(t.createPositionAt(n, 0), e.start);
            const r = t.createRange(e.end, t.createPositionAt(n, "end"));
            vw(r, t);
            vw(o, t);
          }
          return n;
        });
      }
      function vw(t, e) {
        const n = [];
        Array.from(t.getItems({ direction: "backward" }))
          .map((t) => e.createRangeOn(t))
          .filter((e) => {
            const n =
              (e.start.isAfter(t.start) || e.start.isEqual(t.start)) &&
              (e.end.isBefore(t.end) || e.end.isEqual(t.end));
            return n;
          })
          .forEach((t) => {
            n.push(t.start.parent);
            e.remove(t);
          });
        n.forEach((t) => {
          let n = t;
          while (n.parent && n.isEmpty) {
            const t = e.createRangeOn(n);
            n = n.parent;
            e.remove(t);
          }
        });
      }
      function yw(t, e, n, i) {
        return t.change((o) => {
          let r;
          if (!n) {
            r = t.document.selection;
          } else if (n instanceof Nf || n instanceof Wf) {
            r = n;
          } else {
            r = o.createSelection(n, i);
          }
          if (!r.isCollapsed) {
            t.deleteContent(r, { doNotAutoparagraph: true });
          }
          const s = new xw(t, o, r.anchor);
          const a = [];
          let c;
          if (e.is("documentFragment")) {
            if (e.markers.size) {
              const t = [];
              for (const [n, i] of e.markers) {
                const { start: e, end: o } = i;
                const r = e.isEqual(o);
                t.push(
                  { position: e, name: n, isCollapsed: r },
                  { position: o, name: n, isCollapsed: r }
                );
              }
              t.sort(({ position: t }, { position: e }) =>
                t.isBefore(e) ? 1 : -1
              );
              for (const { position: n, name: i, isCollapsed: r } of t) {
                let t = null;
                let s = null;
                const c = n.parent === e && n.isAtStart;
                const l = n.parent === e && n.isAtEnd;
                if (!c && !l) {
                  t = o.createElement("$marker");
                  o.insert(t, n);
                } else if (r) {
                  s = c ? "start" : "end";
                }
                a.push({ name: i, element: t, collapsed: s });
              }
            }
            c = e.getChildren();
          } else {
            c = [e];
          }
          s.handleNodes(c);
          let l = s.getSelectionRange();
          if (e.is("documentFragment") && a.length) {
            const t = l ? Ff.fromRange(l) : null;
            const e = {};
            for (let t = a.length - 1; t >= 0; t--) {
              const { name: n, element: i, collapsed: r } = a[t];
              const c = !e[n];
              if (c) {
                e[n] = [];
              }
              if (i) {
                const t = o.createPositionAt(i, "before");
                e[n].push(t);
                o.remove(i);
              } else {
                const t = s.getAffectedRange();
                if (!t) {
                  if (r) {
                    e[n].push(s.position);
                  }
                  continue;
                }
                if (r) {
                  e[n].push(t[r]);
                } else {
                  e[n].push(c ? t.start : t.end);
                }
              }
            }
            for (const [t, [n, i]] of Object.entries(e)) {
              if (n && i && n.root === i.root) {
                o.addMarker(t, {
                  usingOperation: true,
                  affectsData: true,
                  range: new Ef(n, i),
                });
              }
            }
            if (t) {
              l = t.toRange();
              t.detach();
            }
          }
          if (l) {
            if (r instanceof Wf) {
              o.setSelection(l);
            } else {
              r.setTo(l);
            }
          } else {
          }
          const d = s.getAffectedRange() || t.createRange(r.anchor);
          s.destroy();
          return d;
        });
      }
      class xw {
        constructor(t, e, n) {
          this.model = t;
          this.writer = e;
          this.position = n;
          this.canMergeWith = new Set([this.position.parent]);
          this.schema = t.schema;
          this._documentFragment = e.createDocumentFragment();
          this._documentFragmentPosition = e.createPositionAt(
            this._documentFragment,
            0
          );
          this._firstNode = null;
          this._lastNode = null;
          this._lastAutoParagraph = null;
          this._filterAttributesOf = [];
          this._affectedStart = null;
          this._affectedEnd = null;
        }
        handleNodes(t) {
          for (const e of Array.from(t)) {
            this._handleNode(e);
          }
          this._insertPartialFragment();
          if (this._lastAutoParagraph) {
            this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph);
          }
          this._mergeOnRight();
          this.schema.removeDisallowedAttributes(
            this._filterAttributesOf,
            this.writer
          );
          this._filterAttributesOf = [];
        }
        _updateLastNodeFromAutoParagraph(t) {
          const e = this.writer.createPositionAfter(this._lastNode);
          const n = this.writer.createPositionAfter(t);
          if (n.isAfter(e)) {
            this._lastNode = t;
            if (this.position.parent != t || !this.position.isAtEnd) {
              throw new M("insertcontent-invalid-insertion-position", this);
            }
            this.position = n;
            this._setAffectedBoundaries(this.position);
          }
        }
        getSelectionRange() {
          if (this._nodeToSelect) {
            return Ef._createOn(this._nodeToSelect);
          }
          return this.model.schema.getNearestSelectionRange(this.position);
        }
        getAffectedRange() {
          if (!this._affectedStart) {
            return null;
          }
          return new Ef(this._affectedStart, this._affectedEnd);
        }
        destroy() {
          if (this._affectedStart) {
            this._affectedStart.detach();
          }
          if (this._affectedEnd) {
            this._affectedEnd.detach();
          }
        }
        _handleNode(t) {
          if (this.schema.isObject(t)) {
            this._handleObject(t);
            return;
          }
          let e = this._checkAndAutoParagraphToAllowedPosition(t);
          if (!e) {
            e = this._checkAndSplitToAllowedPosition(t);
            if (!e) {
              this._handleDisallowedNode(t);
              return;
            }
          }
          this._appendToFragment(t);
          if (!this._firstNode) {
            this._firstNode = t;
          }
          this._lastNode = t;
        }
        _insertPartialFragment() {
          if (this._documentFragment.isEmpty) {
            return;
          }
          const t = Sk.fromPosition(this.position, "toNext");
          this._setAffectedBoundaries(this.position);
          if (this._documentFragment.getChild(0) == this._firstNode) {
            this.writer.insert(this._firstNode, this.position);
            this._mergeOnLeft();
            this.position = t.toPosition();
          }
          if (!this._documentFragment.isEmpty) {
            this.writer.insert(this._documentFragment, this.position);
          }
          this._documentFragmentPosition = this.writer.createPositionAt(
            this._documentFragment,
            0
          );
          this.position = t.toPosition();
          t.detach();
        }
        _handleObject(t) {
          if (this._checkAndSplitToAllowedPosition(t)) {
            this._appendToFragment(t);
          } else {
            this._tryAutoparagraphing(t);
          }
        }
        _handleDisallowedNode(t) {
          if (t.is("element")) {
            this.handleNodes(t.getChildren());
          } else {
            this._tryAutoparagraphing(t);
          }
        }
        _appendToFragment(t) {
          if (!this.schema.checkChild(this.position, t)) {
            throw new M("insertcontent-wrong-position", this, {
              node: t,
              position: this.position,
            });
          }
          this.writer.insert(t, this._documentFragmentPosition);
          this._documentFragmentPosition =
            this._documentFragmentPosition.getShiftedBy(t.offsetSize);
          if (
            this.schema.isObject(t) &&
            !this.schema.checkChild(this.position, "$text")
          ) {
            this._nodeToSelect = t;
          } else {
            this._nodeToSelect = null;
          }
          this._filterAttributesOf.push(t);
        }
        _setAffectedBoundaries(t) {
          if (!this._affectedStart) {
            this._affectedStart = Sk.fromPosition(t, "toPrevious");
          }
          if (!this._affectedEnd || this._affectedEnd.isBefore(t)) {
            if (this._affectedEnd) {
              this._affectedEnd.detach();
            }
            this._affectedEnd = Sk.fromPosition(t, "toNext");
          }
        }
        _mergeOnLeft() {
          const t = this._firstNode;
          if (!(t instanceof ff)) {
            return;
          }
          if (!this._canMergeLeft(t)) {
            return;
          }
          const e = Sk._createBefore(t);
          e.stickiness = "toNext";
          const n = Sk.fromPosition(this.position, "toNext");
          if (this._affectedStart.isEqual(e)) {
            this._affectedStart.detach();
            this._affectedStart = Sk._createAt(
              e.nodeBefore,
              "end",
              "toPrevious"
            );
          }
          if (this._firstNode === this._lastNode) {
            this._firstNode = e.nodeBefore;
            this._lastNode = e.nodeBefore;
          }
          this.writer.merge(e);
          if (
            e.isEqual(this._affectedEnd) &&
            this._firstNode === this._lastNode
          ) {
            this._affectedEnd.detach();
            this._affectedEnd = Sk._createAt(e.nodeBefore, "end", "toNext");
          }
          this.position = n.toPosition();
          n.detach();
          this._filterAttributesOf.push(this.position.parent);
          e.detach();
        }
        _mergeOnRight() {
          const t = this._lastNode;
          if (!(t instanceof ff)) {
            return;
          }
          if (!this._canMergeRight(t)) {
            return;
          }
          const e = Sk._createAfter(t);
          e.stickiness = "toNext";
          if (!this.position.isEqual(e)) {
            throw new M("insertcontent-invalid-insertion-position", this);
          }
          this.position = wf._createAt(e.nodeBefore, "end");
          const n = Sk.fromPosition(this.position, "toPrevious");
          if (this._affectedEnd.isEqual(e)) {
            this._affectedEnd.detach();
            this._affectedEnd = Sk._createAt(e.nodeBefore, "end", "toNext");
          }
          if (this._firstNode === this._lastNode) {
            this._firstNode = e.nodeBefore;
            this._lastNode = e.nodeBefore;
          }
          this.writer.merge(e);
          if (
            e.getShiftedBy(-1).isEqual(this._affectedStart) &&
            this._firstNode === this._lastNode
          ) {
            this._affectedStart.detach();
            this._affectedStart = Sk._createAt(e.nodeBefore, 0, "toPrevious");
          }
          this.position = n.toPosition();
          n.detach();
          this._filterAttributesOf.push(this.position.parent);
          e.detach();
        }
        _canMergeLeft(t) {
          const e = t.previousSibling;
          return (
            e instanceof ff &&
            this.canMergeWith.has(e) &&
            this.model.schema.checkMerge(e, t)
          );
        }
        _canMergeRight(t) {
          const e = t.nextSibling;
          return (
            e instanceof ff &&
            this.canMergeWith.has(e) &&
            this.model.schema.checkMerge(t, e)
          );
        }
        _tryAutoparagraphing(t) {
          const e = this.writer.createElement("paragraph");
          if (
            this._getAllowedIn(this.position.parent, e) &&
            this.schema.checkChild(e, t)
          ) {
            e._appendChild(t);
            this._handleNode(e);
          }
        }
        _checkAndAutoParagraphToAllowedPosition(t) {
          if (this.schema.checkChild(this.position.parent, t)) {
            return true;
          }
          if (
            !this.schema.checkChild(this.position.parent, "paragraph") ||
            !this.schema.checkChild("paragraph", t)
          ) {
            return false;
          }
          this._insertPartialFragment();
          const e = this.writer.createElement("paragraph");
          this.writer.insert(e, this.position);
          this._setAffectedBoundaries(this.position);
          this._lastAutoParagraph = e;
          this.position = this.writer.createPositionAt(e, 0);
          return true;
        }
        _checkAndSplitToAllowedPosition(t) {
          const e = this._getAllowedIn(this.position.parent, t);
          if (!e) {
            return false;
          }
          if (e != this.position.parent) {
            this._insertPartialFragment();
          }
          while (e != this.position.parent) {
            if (this.position.isAtStart) {
              const t = this.position.parent;
              this.position = this.writer.createPositionBefore(t);
              if (t.isEmpty && t.parent === e) {
                this.writer.remove(t);
              }
            } else if (this.position.isAtEnd) {
              this.position = this.writer.createPositionAfter(
                this.position.parent
              );
            } else {
              const t = this.writer.createPositionAfter(this.position.parent);
              this._setAffectedBoundaries(this.position);
              this.writer.split(this.position);
              this.position = t;
              this.canMergeWith.add(this.position.nodeAfter);
            }
          }
          return true;
        }
        _getAllowedIn(t, e) {
          if (this.schema.checkChild(t, e)) {
            return t;
          }
          if (this.schema.isLimit(t)) {
            return null;
          }
          return this._getAllowedIn(t.parent, e);
        }
      }
      function Ew(t, e, n = "auto") {
        const i = t.getSelectedElement();
        if (i && e.schema.isObject(i) && !e.schema.isInline(i)) {
          if (n == "before" || n == "after") {
            return e.createRange(e.createPositionAt(i, n));
          }
          return e.createRangeOn(i);
        }
        const o = sl(t.getSelectedBlocks());
        if (!o) {
          return e.createRange(t.focus);
        }
        if (o.isEmpty) {
          return e.createRange(e.createPositionAt(o, 0));
        }
        const r = e.createPositionAfter(o);
        if (t.focus.isTouching(r)) {
          return e.createRange(r);
        }
        return e.createRange(e.createPositionBefore(o));
      }
      function Dw(t, e, n, i, o = {}) {
        if (!t.schema.isObject(e)) {
          throw new M("insertobject-element-not-an-object", t, { object: e });
        }
        let r;
        if (!n) {
          r = t.document.selection;
        } else if (n instanceof Nf || n instanceof Wf) {
          r = n;
        } else {
          r = t.createSelection(n, i);
        }
        let s = r;
        if (o.findOptimalPosition && t.schema.isBlock(e)) {
          s = t.createSelection(Ew(r, t, o.findOptimalPosition));
        }
        const a = sl(r.getSelectedBlocks());
        const c = {};
        if (a) {
          Object.assign(
            c,
            t.schema.getAttributesWithProperty(a, "copyOnReplace", true)
          );
        }
        return t.change((n) => {
          if (!s.isCollapsed) {
            t.deleteContent(s, { doNotAutoparagraph: true });
          }
          let i = e;
          const r = s.anchor.parent;
          if (
            !t.schema.checkChild(r, e) &&
            t.schema.checkChild(r, "paragraph") &&
            t.schema.checkChild("paragraph", e)
          ) {
            i = n.createElement("paragraph");
            n.insert(e, i);
          }
          t.schema.setAllowedAttributes(i, c, n);
          const a = t.insertContent(i, s);
          if (a.isCollapsed) {
            return a;
          }
          if (o.setSelection) {
            Sw(n, e, o.setSelection, c);
          }
          return a;
        });
      }
      function Sw(t, e, n, i) {
        const o = t.model;
        if (n == "on") {
          t.setSelection(e, "on");
          return;
        }
        if (n != "after") {
          throw new M("insertobject-invalid-place-parameter-value", o);
        }
        let r = e.nextSibling;
        if (o.schema.isInline(e)) {
          t.setSelection(e, "after");
          return;
        }
        const s = r && o.schema.checkChild(r, "$text");
        if (!s && o.schema.checkChild(e.parent, "paragraph")) {
          r = t.createElement("paragraph");
          o.schema.setAllowedAttributes(r, i, t);
          o.insertContent(r, t.createPositionAfter(e));
        }
        if (r) {
          t.setSelection(r, 0);
        }
      }
      const Tw = ' ,.?!:;"-()';
      function Iw(t, e, n = {}) {
        const i = t.schema;
        const o = n.direction != "backward";
        const r = n.unit ? n.unit : "character";
        const s = !!n.treatEmojiAsSingleUnit;
        const a = e.focus;
        const c = new bf({
          boundaries: Nw(a, o),
          singleCharacters: true,
          direction: o ? "forward" : "backward",
        });
        const l = {
          walker: c,
          schema: i,
          isForward: o,
          unit: r,
          treatEmojiAsSingleUnit: s,
        };
        let d;
        while ((d = c.next())) {
          if (d.done) {
            return;
          }
          const n = Mw(l, d.value);
          if (n) {
            if (e instanceof Wf) {
              t.change((t) => {
                t.setSelectionFocus(n);
              });
            } else {
              e.setFocus(n);
            }
            return;
          }
        }
      }
      function Mw(t, e) {
        const {
          isForward: n,
          walker: i,
          unit: o,
          schema: r,
          treatEmojiAsSingleUnit: s,
        } = t;
        const { type: a, item: c, nextPosition: l } = e;
        if (a == "text") {
          if (t.unit === "word") {
            return Lw(i, n);
          }
          return Bw(i, o, s);
        }
        if (a == (n ? "elementStart" : "elementEnd")) {
          if (r.isSelectable(c)) {
            return wf._createAt(c, n ? "after" : "before");
          }
          if (r.checkChild(l, "$text")) {
            return l;
          }
        } else {
          if (r.isLimit(c)) {
            i.skip(() => true);
            return;
          }
          if (r.checkChild(l, "$text")) {
            return l;
          }
        }
      }
      function Bw(t, e, n) {
        const i = t.position.textNode;
        if (i) {
          const o = i.data;
          let r = t.position.offset - i.startOffset;
          while (
            pl(o, r) ||
            (e == "character" && bl(o, r)) ||
            (n && wl(o, r))
          ) {
            t.next();
            r = t.position.offset - i.startOffset;
          }
        }
        return t.position;
      }
      function Lw(t, e) {
        let n = t.position.textNode;
        if (!n) {
          n = e ? t.position.nodeAfter : t.position.nodeBefore;
        }
        while (n && n.is("$text")) {
          const i = t.position.offset - n.startOffset;
          if (Pw(n, i, e)) {
            n = e ? t.position.nodeAfter : t.position.nodeBefore;
          } else if (zw(n.data, i, e)) {
            break;
          } else {
            t.next();
          }
        }
        return t.position;
      }
      function Nw(t, e) {
        const n = t.root;
        const i = wf._createAt(n, e ? "end" : 0);
        if (e) {
          return new Ef(t, i);
        } else {
          return new Ef(i, t);
        }
      }
      function zw(t, e, n) {
        const i = e + (n ? 0 : -1);
        return Tw.includes(t.charAt(i));
      }
      function Pw(t, e, n) {
        return e === (n ? t.offsetSize : 0);
      }
      class Rw extends dt() {
        constructor() {
          super();
          this.markers = new Vk();
          this.document = new jk(this);
          this.schema = new bb();
          this._pendingChanges = [];
          this._currentWriter = null;
          [
            "insertContent",
            "insertObject",
            "deleteContent",
            "modifySelection",
            "getSelectedContent",
            "applyOperation",
          ].forEach((t) => this.decorate(t));
          this.on(
            "applyOperation",
            (t, e) => {
              const n = e[0];
              n._validate();
            },
            { priority: "highest" }
          );
          this.schema.register("$root", { isLimit: true });
          this.schema.register("$container", {
            allowIn: ["$root", "$container"],
          });
          this.schema.register("$block", {
            allowIn: ["$root", "$container"],
            isBlock: true,
          });
          this.schema.register("$blockObject", {
            allowWhere: "$block",
            isBlock: true,
            isObject: true,
          });
          this.schema.register("$inlineObject", {
            allowWhere: "$text",
            allowAttributesOf: "$text",
            isInline: true,
            isObject: true,
          });
          this.schema.register("$text", {
            allowIn: "$block",
            isInline: true,
            isContent: true,
          });
          this.schema.register("$clipboardHolder", {
            allowContentOf: "$root",
            allowChildren: "$text",
            isLimit: true,
          });
          this.schema.register("$documentFragment", {
            allowContentOf: "$root",
            allowChildren: "$text",
            isLimit: true,
          });
          this.schema.register("$marker");
          this.schema.addChildCheck((t, e) => {
            if (e.name === "$marker") {
              return true;
            }
          });
          Jk(this);
          this.document.registerPostFixer(qp);
        }
        change(t) {
          try {
            if (this._pendingChanges.length === 0) {
              this._pendingChanges.push({ batch: new Mk(), callback: t });
              return this._runPendingChanges()[0];
            } else {
              return t(this._currentWriter);
            }
          } catch (t) {
            M.rethrowUnexpectedError(t, this);
          }
        }
        enqueueChange(t, e) {
          try {
            if (!t) {
              t = new Mk();
            } else if (typeof t === "function") {
              e = t;
              t = new Mk();
            } else if (!(t instanceof Mk)) {
              t = new Mk(t);
            }
            this._pendingChanges.push({ batch: t, callback: e });
            if (this._pendingChanges.length == 1) {
              this._runPendingChanges();
            }
          } catch (t) {
            M.rethrowUnexpectedError(t, this);
          }
        }
        applyOperation(t) {
          t._execute();
        }
        insertContent(t, e, n) {
          return yw(this, t, e, n);
        }
        insertObject(t, e, n, i) {
          return Dw(this, t, e, n, i);
        }
        deleteContent(t, e) {
          aw(this, t, e);
        }
        modifySelection(t, e) {
          Iw(this, t, e);
        }
        getSelectedContent(t) {
          return _w(this, t);
        }
        hasContent(t, e = {}) {
          const n = t instanceof Ef ? t : Ef._createIn(t);
          if (n.isCollapsed) {
            return false;
          }
          const { ignoreWhitespaces: i = false, ignoreMarkers: o = false } = e;
          if (!o) {
            for (const t of this.markers.getMarkersIntersectingRange(n)) {
              if (t.affectsData) {
                return true;
              }
            }
          }
          for (const t of n.getItems()) {
            if (this.schema.isContent(t)) {
              if (t.is("$textProxy")) {
                if (!i) {
                  return true;
                } else if (t.data.search(/\\S/) !== -1) {
                  return true;
                }
              } else {
                return true;
              }
            }
          }
          return false;
        }
        createPositionFromPath(t, e, n) {
          return new wf(t, e, n);
        }
        createPositionAt(t, e) {
          return wf._createAt(t, e);
        }
        createPositionAfter(t) {
          return wf._createAfter(t);
        }
        createPositionBefore(t) {
          return wf._createBefore(t);
        }
        createRange(t, e) {
          return new Ef(t, e);
        }
        createRangeIn(t) {
          return Ef._createIn(t);
        }
        createRangeOn(t) {
          return Ef._createOn(t);
        }
        createSelection(...t) {
          return new Nf(...t);
        }
        createBatch(t) {
          return new Mk(t);
        }
        createOperationFromJSON(t) {
          return gk.fromJSON(t, this.document);
        }
        destroy() {
          this.document.destroy();
          this.stopListening();
        }
        _runPendingChanges() {
          const t = [];
          this.fire("_beforeChanges");
          try {
            while (this._pendingChanges.length) {
              const e = this._pendingChanges[0].batch;
              this._currentWriter = new Gk(this, e);
              const n = this._pendingChanges[0].callback(this._currentWriter);
              t.push(n);
              this.document._handleChangeBlock(this._currentWriter);
              this._pendingChanges.shift();
              this._currentWriter = null;
            }
          } finally {
            this._pendingChanges.length = 0;
            this._currentWriter = null;
            this.fire("_afterChanges");
          }
          return t;
        }
      }
      class Ow extends Im {
        constructor(t) {
          super(t);
          this.domEventType = "click";
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
      }
      class jw extends Im {
        constructor(t) {
          super(t);
          this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"];
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
      }
      class Fw {
        constructor(t) {
          this.document = t;
        }
        createDocumentFragment(t) {
          return new Mh(this.document, t);
        }
        createElement(t, e, n) {
          return new Yu(this.document, t, e, n);
        }
        createText(t) {
          return new Yl(this.document, t);
        }
        clone(t, e = false) {
          return t._clone(e);
        }
        appendChild(t, e) {
          return e._appendChild(t);
        }
        insertChild(t, e, n) {
          return n._insertChild(t, e);
        }
        removeChildren(t, e, n) {
          return n._removeChildren(t, e);
        }
        remove(t) {
          const e = t.parent;
          if (e) {
            return this.removeChildren(e.getChildIndex(t), 1, e);
          }
          return [];
        }
        replace(t, e) {
          const n = t.parent;
          if (n) {
            const i = n.getChildIndex(t);
            this.removeChildren(i, 1, n);
            this.insertChild(i, e, n);
            return true;
          }
          return false;
        }
        unwrapElement(t) {
          const e = t.parent;
          if (e) {
            const n = e.getChildIndex(t);
            this.remove(t);
            this.insertChild(n, t.getChildren(), e);
          }
        }
        rename(t, e) {
          const n = new Yu(
            this.document,
            t,
            e.getAttributes(),
            e.getChildren()
          );
          return this.replace(e, n) ? n : null;
        }
        setAttribute(t, e, n) {
          n._setAttribute(t, e);
        }
        removeAttribute(t, e) {
          e._removeAttribute(t);
        }
        addClass(t, e) {
          e._addClass(t);
        }
        removeClass(t, e) {
          e._removeClass(t);
        }
        setStyle(t, e, n) {
          if (he(t) && n === undefined) {
            e._setStyle(t);
          } else {
            n._setStyle(t, e);
          }
        }
        removeStyle(t, e) {
          e._removeStyle(t);
        }
        setCustomProperty(t, e, n) {
          n._setCustomProperty(t, e);
        }
        removeCustomProperty(t, e) {
          return e._removeCustomProperty(t);
        }
        createPositionAt(t, e) {
          return rh._createAt(t, e);
        }
        createPositionAfter(t) {
          return rh._createAfter(t);
        }
        createPositionBefore(t) {
          return rh._createBefore(t);
        }
        createRange(t, e) {
          return new sh(t, e);
        }
        createRangeOn(t) {
          return sh._createOn(t);
        }
        createRangeIn(t) {
          return sh._createIn(t);
        }
        createSelection(...t) {
          return new ch(...t);
        }
      }
      const Vw = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
      const Hw = /^rgb\\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\\)$/i;
      const Uw =
        /^rgba\\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\\.?[0-9]+)\\)$/i;
      const qw =
        /^hsl\\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\\.?[0-9]+)?\\)$/i;
      const Ww =
        /^hsla\\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\\.?[0-9]+)\\)$/i;
      const Gw = new Set([
        "black",
        "silver",
        "gray",
        "white",
        "maroon",
        "red",
        "purple",
        "fuchsia",
        "green",
        "lime",
        "olive",
        "yellow",
        "navy",
        "blue",
        "teal",
        "aqua",
        "orange",
        "aliceblue",
        "antiquewhite",
        "aquamarine",
        "azure",
        "beige",
        "bisque",
        "blanchedalmond",
        "blueviolet",
        "brown",
        "burlywood",
        "cadetblue",
        "chartreuse",
        "chocolate",
        "coral",
        "cornflowerblue",
        "cornsilk",
        "crimson",
        "cyan",
        "darkblue",
        "darkcyan",
        "darkgoldenrod",
        "darkgray",
        "darkgreen",
        "darkgrey",
        "darkkhaki",
        "darkmagenta",
        "darkolivegreen",
        "darkorange",
        "darkorchid",
        "darkred",
        "darksalmon",
        "darkseagreen",
        "darkslateblue",
        "darkslategray",
        "darkslategrey",
        "darkturquoise",
        "darkviolet",
        "deeppink",
        "deepskyblue",
        "dimgray",
        "dimgrey",
        "dodgerblue",
        "firebrick",
        "floralwhite",
        "forestgreen",
        "gainsboro",
        "ghostwhite",
        "gold",
        "goldenrod",
        "greenyellow",
        "grey",
        "honeydew",
        "hotpink",
        "indianred",
        "indigo",
        "ivory",
        "khaki",
        "lavender",
        "lavenderblush",
        "lawngreen",
        "lemonchiffon",
        "lightblue",
        "lightcoral",
        "lightcyan",
        "lightgoldenrodyellow",
        "lightgray",
        "lightgreen",
        "lightgrey",
        "lightpink",
        "lightsalmon",
        "lightseagreen",
        "lightskyblue",
        "lightslategray",
        "lightslategrey",
        "lightsteelblue",
        "lightyellow",
        "limegreen",
        "linen",
        "magenta",
        "mediumaquamarine",
        "mediumblue",
        "mediumorchid",
        "mediumpurple",
        "mediumseagreen",
        "mediumslateblue",
        "mediumspringgreen",
        "mediumturquoise",
        "mediumvioletred",
        "midnightblue",
        "mintcream",
        "mistyrose",
        "moccasin",
        "navajowhite",
        "oldlace",
        "olivedrab",
        "orangered",
        "orchid",
        "palegoldenrod",
        "palegreen",
        "paleturquoise",
        "palevioletred",
        "papayawhip",
        "peachpuff",
        "peru",
        "pink",
        "plum",
        "powderblue",
        "rosybrown",
        "royalblue",
        "saddlebrown",
        "salmon",
        "sandybrown",
        "seagreen",
        "seashell",
        "sienna",
        "skyblue",
        "slateblue",
        "slategray",
        "slategrey",
        "snow",
        "springgreen",
        "steelblue",
        "tan",
        "thistle",
        "tomato",
        "turquoise",
        "violet",
        "wheat",
        "whitesmoke",
        "yellowgreen",
        "activeborder",
        "activecaption",
        "appworkspace",
        "background",
        "buttonface",
        "buttonhighlight",
        "buttonshadow",
        "buttontext",
        "captiontext",
        "graytext",
        "highlight",
        "highlighttext",
        "inactiveborder",
        "inactivecaption",
        "inactivecaptiontext",
        "infobackground",
        "infotext",
        "menu",
        "menutext",
        "scrollbar",
        "threeddarkshadow",
        "threedface",
        "threedhighlight",
        "threedlightshadow",
        "threedshadow",
        "window",
        "windowframe",
        "windowtext",
        "rebeccapurple",
        "currentcolor",
        "transparent",
      ]);
      function $w(t) {
        if (t.startsWith("#")) {
          return Vw.test(t);
        }
        if (t.startsWith("rgb")) {
          return Hw.test(t) || Uw.test(t);
        }
        if (t.startsWith("hsl")) {
          return qw.test(t) || Ww.test(t);
        }
        return Gw.has(t.toLowerCase());
      }
      const Kw = [
        "none",
        "hidden",
        "dotted",
        "dashed",
        "solid",
        "double",
        "groove",
        "ridge",
        "inset",
        "outset",
      ];
      function Yw(t) {
        return Kw.includes(t);
      }
      const Zw =
        /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;
      function Qw(t) {
        return Zw.test(t);
      }
      const Jw = /^[+-]?[0-9]*([.][0-9]+)?%$/;
      function Xw(t) {
        return Jw.test(t);
      }
      const tA = [
        "repeat-x",
        "repeat-y",
        "repeat",
        "space",
        "round",
        "no-repeat",
      ];
      function eA(t) {
        return tA.includes(t);
      }
      const nA = ["center", "top", "bottom", "left", "right"];
      function iA(t) {
        return nA.includes(t);
      }
      const oA = ["fixed", "scroll", "local"];
      function rA(t) {
        return oA.includes(t);
      }
      const sA = /^url\\(/;
      function aA(t) {
        return sA.test(t);
      }
      function cA(t = "") {
        if (t === "") {
          return {
            top: undefined,
            right: undefined,
            bottom: undefined,
            left: undefined,
          };
        }
        const e = hA(t);
        const n = e[0];
        const i = e[2] || n;
        const o = e[1] || n;
        const r = e[3] || o;
        return { top: n, bottom: i, right: o, left: r };
      }
      function lA(t) {
        return (e) => {
          const { top: n, right: i, bottom: o, left: r } = e;
          const s = [];
          if (![n, i, r, o].every((t) => !!t)) {
            if (n) {
              s.push([t + "-top", n]);
            }
            if (i) {
              s.push([t + "-right", i]);
            }
            if (o) {
              s.push([t + "-bottom", o]);
            }
            if (r) {
              s.push([t + "-left", r]);
            }
          } else {
            s.push([t, dA(e)]);
          }
          return s;
        };
      }
      function dA({ top: t, right: e, bottom: n, left: i }) {
        const o = [];
        if (i !== e) {
          o.push(t, e, n, i);
        } else if (n !== t) {
          o.push(t, e, n);
        } else if (e !== t) {
          o.push(t, e);
        } else {
          o.push(t);
        }
        return o.join(" ");
      }
      function uA(t) {
        return (e) => ({ path: t, value: cA(e) });
      }
      function hA(t) {
        return t
          .replace(/, /g, ",")
          .split(" ")
          .map((t) => t.replace(/,/g, ", "));
      }
      function mA(t) {
        t.setNormalizer("background", gA());
        t.setNormalizer("background-color", fA());
        t.setReducer("background", pA());
        t.setStyleRelation("background", ["background-color"]);
      }
      function gA() {
        return (t) => {
          const e = {};
          const n = hA(t);
          for (const t of n) {
            if (eA(t)) {
              e.repeat = e.repeat || [];
              e.repeat.push(t);
            } else if (iA(t)) {
              e.position = e.position || [];
              e.position.push(t);
            } else if (rA(t)) {
              e.attachment = t;
            } else if ($w(t)) {
              e.color = t;
            } else if (aA(t)) {
              e.image = t;
            }
          }
          return { path: "background", value: e };
        };
      }
      function fA() {
        return (t) => ({ path: "background.color", value: t });
      }
      function pA() {
        return (t) => {
          const e = [];
          e.push(["background-color", t.color]);
          return e;
        };
      }
      function bA(t) {
        t.setNormalizer("border", kA());
        t.setNormalizer("border-top", wA("top"));
        t.setNormalizer("border-right", wA("right"));
        t.setNormalizer("border-bottom", wA("bottom"));
        t.setNormalizer("border-left", wA("left"));
        t.setNormalizer("border-color", AA("color"));
        t.setNormalizer("border-width", AA("width"));
        t.setNormalizer("border-style", AA("style"));
        t.setNormalizer("border-top-color", _A("color", "top"));
        t.setNormalizer("border-top-style", _A("style", "top"));
        t.setNormalizer("border-top-width", _A("width", "top"));
        t.setNormalizer("border-right-color", _A("color", "right"));
        t.setNormalizer("border-right-style", _A("style", "right"));
        t.setNormalizer("border-right-width", _A("width", "right"));
        t.setNormalizer("border-bottom-color", _A("color", "bottom"));
        t.setNormalizer("border-bottom-style", _A("style", "bottom"));
        t.setNormalizer("border-bottom-width", _A("width", "bottom"));
        t.setNormalizer("border-left-color", _A("color", "left"));
        t.setNormalizer("border-left-style", _A("style", "left"));
        t.setNormalizer("border-left-width", _A("width", "left"));
        t.setExtractor("border-top", vA("top"));
        t.setExtractor("border-right", vA("right"));
        t.setExtractor("border-bottom", vA("bottom"));
        t.setExtractor("border-left", vA("left"));
        t.setExtractor("border-top-color", "border.color.top");
        t.setExtractor("border-right-color", "border.color.right");
        t.setExtractor("border-bottom-color", "border.color.bottom");
        t.setExtractor("border-left-color", "border.color.left");
        t.setExtractor("border-top-width", "border.width.top");
        t.setExtractor("border-right-width", "border.width.right");
        t.setExtractor("border-bottom-width", "border.width.bottom");
        t.setExtractor("border-left-width", "border.width.left");
        t.setExtractor("border-top-style", "border.style.top");
        t.setExtractor("border-right-style", "border.style.right");
        t.setExtractor("border-bottom-style", "border.style.bottom");
        t.setExtractor("border-left-style", "border.style.left");
        t.setReducer("border-color", lA("border-color"));
        t.setReducer("border-style", lA("border-style"));
        t.setReducer("border-width", lA("border-width"));
        t.setReducer("border-top", DA("top"));
        t.setReducer("border-right", DA("right"));
        t.setReducer("border-bottom", DA("bottom"));
        t.setReducer("border-left", DA("left"));
        t.setReducer("border", EA());
        t.setStyleRelation("border", [
          "border-color",
          "border-style",
          "border-width",
          "border-top",
          "border-right",
          "border-bottom",
          "border-left",
          "border-top-color",
          "border-right-color",
          "border-bottom-color",
          "border-left-color",
          "border-top-style",
          "border-right-style",
          "border-bottom-style",
          "border-left-style",
          "border-top-width",
          "border-right-width",
          "border-bottom-width",
          "border-left-width",
        ]);
        t.setStyleRelation("border-color", [
          "border-top-color",
          "border-right-color",
          "border-bottom-color",
          "border-left-color",
        ]);
        t.setStyleRelation("border-style", [
          "border-top-style",
          "border-right-style",
          "border-bottom-style",
          "border-left-style",
        ]);
        t.setStyleRelation("border-width", [
          "border-top-width",
          "border-right-width",
          "border-bottom-width",
          "border-left-width",
        ]);
        t.setStyleRelation("border-top", [
          "border-top-color",
          "border-top-style",
          "border-top-width",
        ]);
        t.setStyleRelation("border-right", [
          "border-right-color",
          "border-right-style",
          "border-right-width",
        ]);
        t.setStyleRelation("border-bottom", [
          "border-bottom-color",
          "border-bottom-style",
          "border-bottom-width",
        ]);
        t.setStyleRelation("border-left", [
          "border-left-color",
          "border-left-style",
          "border-left-width",
        ]);
      }
      function kA() {
        return (t) => {
          const { color: e, style: n, width: i } = xA(t);
          return {
            path: "border",
            value: { color: cA(e), style: cA(n), width: cA(i) },
          };
        };
      }
      function wA(t) {
        return (e) => {
          const { color: n, style: i, width: o } = xA(e);
          const r = {};
          if (n !== undefined) {
            r.color = { [t]: n };
          }
          if (i !== undefined) {
            r.style = { [t]: i };
          }
          if (o !== undefined) {
            r.width = { [t]: o };
          }
          return { path: "border", value: r };
        };
      }
      function AA(t) {
        return (e) => ({ path: "border", value: CA(e, t) });
      }
      function CA(t, e) {
        return { [e]: cA(t) };
      }
      function _A(t, e) {
        return (n) => ({ path: "border", value: { [t]: { [e]: n } } });
      }
      function vA(t) {
        return (e, n) => {
          if (n.border) {
            return yA(n.border, t);
          }
        };
      }
      function yA(t, e) {
        const n = {};
        if (t.width && t.width[e]) {
          n.width = t.width[e];
        }
        if (t.style && t.style[e]) {
          n.style = t.style[e];
        }
        if (t.color && t.color[e]) {
          n.color = t.color[e];
        }
        return n;
      }
      function xA(t) {
        const e = {};
        const n = hA(t);
        for (const t of n) {
          if (Qw(t) || /thin|medium|thick/.test(t)) {
            e.width = t;
          } else if (Yw(t)) {
            e.style = t;
          } else {
            e.color = t;
          }
        }
        return e;
      }
      function EA() {
        return (e) => {
          const n = yA(e, "top");
          const i = yA(e, "right");
          const o = yA(e, "bottom");
          const r = yA(e, "left");
          const s = [n, i, o, r];
          const a = {
            width: t(s, "width"),
            style: t(s, "style"),
            color: t(s, "color"),
          };
          const c = SA(a, "all");
          if (c.length) {
            return c;
          }
          const l = Object.entries(a).reduce((t, [e, n]) => {
            if (n) {
              t.push([\`border-\${e}\`, n]);
              s.forEach((t) => delete t[e]);
            }
            return t;
          }, []);
          return [
            ...l,
            ...SA(n, "top"),
            ...SA(i, "right"),
            ...SA(o, "bottom"),
            ...SA(r, "left"),
          ];
        };
        function t(t, e) {
          return t.map((t) => t[e]).reduce((t, e) => (t == e ? t : null));
        }
      }
      function DA(t) {
        return (e) => SA(e, t);
      }
      function SA(t, e) {
        const n = [];
        if (t && t.width) {
          n.push("width");
        }
        if (t && t.style) {
          n.push("style");
        }
        if (t && t.color) {
          n.push("color");
        }
        if (n.length == 3) {
          const i = n.map((e) => t[e]).join(" ");
          return [e == "all" ? ["border", i] : [\`border-\${e}\`, i]];
        }
        if (e == "all") {
          return [];
        }
        return n.map((n) => [\`border-\${e}-\${n}\`, t[n]]);
      }
      function TA(t) {
        t.setNormalizer("margin", uA("margin"));
        t.setNormalizer("margin-top", (t) => ({
          path: "margin.top",
          value: t,
        }));
        t.setNormalizer("margin-right", (t) => ({
          path: "margin.right",
          value: t,
        }));
        t.setNormalizer("margin-bottom", (t) => ({
          path: "margin.bottom",
          value: t,
        }));
        t.setNormalizer("margin-left", (t) => ({
          path: "margin.left",
          value: t,
        }));
        t.setReducer("margin", lA("margin"));
        t.setStyleRelation("margin", [
          "margin-top",
          "margin-right",
          "margin-bottom",
          "margin-left",
        ]);
      }
      function IA(t) {
        t.setNormalizer("padding", getPositionShorthandNormalizer("padding"));
        t.setNormalizer("padding-top", (t) => ({
          path: "padding.top",
          value: t,
        }));
        t.setNormalizer("padding-right", (t) => ({
          path: "padding.right",
          value: t,
        }));
        t.setNormalizer("padding-bottom", (t) => ({
          path: "padding.bottom",
          value: t,
        }));
        t.setNormalizer("padding-left", (t) => ({
          path: "padding.left",
          value: t,
        }));
        t.setReducer("padding", getBoxSidesValueReducer("padding"));
        t.setStyleRelation("padding", [
          "padding-top",
          "padding-right",
          "padding-bottom",
          "padding-left",
        ]);
      }
      class MA {
        constructor() {
          this._commands = new Map();
        }
        add(t, e) {
          this._commands.set(t, e);
        }
        get(t) {
          return this._commands.get(t);
        }
        execute(t, ...e) {
          const n = this.get(t);
          if (!n) {
            throw new M("commandcollection-command-not-found", this, {
              commandName: t,
            });
          }
          return n.execute(...e);
        }
        *names() {
          yield* this._commands.keys();
        }
        *commands() {
          yield* this._commands.values();
        }
        [Symbol.iterator]() {
          return this._commands[Symbol.iterator]();
        }
        destroy() {
          for (const t of this.commands()) {
            t.destroy();
          }
        }
      }
      class BA extends cl {
        constructor(t) {
          super();
          this.editor = t;
        }
        set(t, e, n = {}) {
          if (typeof e == "string") {
            const t = e;
            e = (e, n) => {
              this.editor.execute(t);
              n();
            };
          }
          super.set(t, e, n);
        }
      }
      class LA extends dt() {
        constructor(t = {}) {
          super();
          const e = this.constructor;
          const n = t.language || (e.defaultConfig && e.defaultConfig.language);
          this._context = t.context || new Dl({ language: n });
          this._context._addEditor(this, !t.context);
          const i = Array.from(e.builtinPlugins || []);
          this.config = new Ha(t, e.defaultConfig);
          this.config.define("plugins", i);
          this.config.define(this._context._getEditorConfig());
          this.plugins = new El(this, i, this._context.plugins);
          this.locale = this._context.locale;
          this.t = this.locale.t;
          this._readOnlyLocks = new Set();
          this.commands = new MA();
          this.set("state", "initializing");
          this.once("ready", () => (this.state = "ready"), {
            priority: "high",
          });
          this.once("destroy", () => (this.state = "destroyed"), {
            priority: "high",
          });
          this.model = new Rw();
          const o = new Wu();
          this.data = new Hb(this.model, o);
          this.editing = new mb(this.model, o);
          this.editing.view.document.bind("isReadOnly").to(this);
          this.conversion = new qb(
            [this.editing.downcastDispatcher, this.data.downcastDispatcher],
            this.data.upcastDispatcher
          );
          this.conversion.addAlias(
            "dataDowncast",
            this.data.downcastDispatcher
          );
          this.conversion.addAlias(
            "editingDowncast",
            this.editing.downcastDispatcher
          );
          this.keystrokes = new BA(this);
          this.keystrokes.listenTo(this.editing.view.document);
        }
        get isReadOnly() {
          return this._readOnlyLocks.size > 0;
        }
        set isReadOnly(t) {
          throw new M("editor-isreadonly-has-no-setter");
        }
        enableReadOnlyMode(t) {
          if (typeof t !== "string" && typeof t !== "symbol") {
            throw new M("editor-read-only-lock-id-invalid", null, {
              lockId: t,
            });
          }
          if (this._readOnlyLocks.has(t)) {
            return;
          }
          this._readOnlyLocks.add(t);
          if (this._readOnlyLocks.size === 1) {
            this.fire("change:isReadOnly", "isReadOnly", true, false);
          }
        }
        disableReadOnlyMode(t) {
          if (typeof t !== "string" && typeof t !== "symbol") {
            throw new M("editor-read-only-lock-id-invalid", null, {
              lockId: t,
            });
          }
          if (!this._readOnlyLocks.has(t)) {
            return;
          }
          this._readOnlyLocks.delete(t);
          if (this._readOnlyLocks.size === 0) {
            this.fire("change:isReadOnly", "isReadOnly", false, true);
          }
        }
        initPlugins() {
          const t = this.config;
          const e = t.get("plugins");
          const n = t.get("removePlugins") || [];
          const i = t.get("extraPlugins") || [];
          const o = t.get("substitutePlugins") || [];
          return this.plugins.init(e.concat(i), n, o);
        }
        destroy() {
          let t = Promise.resolve();
          if (this.state == "initializing") {
            t = new Promise((t) => this.once("ready", t));
          }
          return t
            .then(() => {
              this.fire("destroy");
              this.stopListening();
              this.commands.destroy();
            })
            .then(() => this.plugins.destroy())
            .then(() => {
              this.model.destroy();
              this.data.destroy();
              this.editing.destroy();
              this.keystrokes.destroy();
            })
            .then(() => this._context._removeEditor(this));
        }
        execute(t, ...e) {
          try {
            return this.commands.execute(t, ...e);
          } catch (t) {
            M.rethrowUnexpectedError(t, this);
          }
        }
        focus() {
          this.editing.view.focus();
        }
      }
      class NA {
        constructor(t) {
          this.editor = t;
          this._components = new Map();
        }
        *names() {
          for (const t of this._components.values()) {
            yield t.originalName;
          }
        }
        add(t, e) {
          this._components.set(zA(t), { callback: e, originalName: t });
        }
        create(t) {
          if (!this.has(t)) {
            throw new M("componentfactory-item-missing", this, { name: t });
          }
          return this._components.get(zA(t)).callback(this.editor.locale);
        }
        has(t) {
          return this._components.has(zA(t));
        }
      }
      function zA(t) {
        return String(t).toLowerCase();
      }
      class PA extends rl {
        constructor(t = []) {
          super(t, { idProperty: "viewUid" });
          this.on("add", (t, e, n) => {
            this._renderViewIntoCollectionParent(e, n);
          });
          this.on("remove", (t, e) => {
            if (e.element && this._parentElement) {
              e.element.remove();
            }
          });
          this._parentElement = null;
        }
        destroy() {
          this.map((t) => t.destroy());
        }
        setParent(t) {
          this._parentElement = t;
          for (const t of this) {
            this._renderViewIntoCollectionParent(t);
          }
        }
        delegate(...t) {
          if (!t.length || !RA(t)) {
            throw new M("ui-viewcollection-delegate-wrong-events", this);
          }
          return {
            to: (e) => {
              for (const n of this) {
                for (const i of t) {
                  n.delegate(i).to(e);
                }
              }
              this.on("add", (n, i) => {
                for (const n of t) {
                  i.delegate(n).to(e);
                }
              });
              this.on("remove", (n, i) => {
                for (const n of t) {
                  i.stopDelegating(n, e);
                }
              });
            },
          };
        }
        _renderViewIntoCollectionParent(t, e) {
          if (!t.isRendered) {
            t.render();
          }
          if (t.element && this._parentElement) {
            this._parentElement.insertBefore(
              t.element,
              this._parentElement.children[e]
            );
          }
        }
      }
      function RA(t) {
        return t.every((t) => typeof t == "string");
      }
      const OA = "http://www.w3.org/1999/xhtml";
      class jA extends q() {
        constructor(t) {
          super();
          Object.assign(this, ZA(YA(t)));
          this._isRendered = false;
          this._revertData = null;
        }
        render() {
          const t = this._renderNode({ intoFragment: true });
          this._isRendered = true;
          return t;
        }
        apply(t) {
          this._revertData = dC();
          this._renderNode({
            node: t,
            intoFragment: false,
            isApplying: true,
            revertData: this._revertData,
          });
          return t;
        }
        revert(t) {
          if (!this._revertData) {
            throw new M("ui-template-revert-not-applied", [this, t]);
          }
          this._revertTemplateFromNode(t, this._revertData);
        }
        *getViews() {
          function* t(e) {
            if (e.children) {
              for (const n of e.children) {
                if (sC(n)) {
                  yield n;
                } else if (aC(n)) {
                  yield* t(n);
                }
              }
            }
          }
          yield* t(this);
        }
        static bind(t, e) {
          return {
            to(n, i) {
              return new VA({
                eventNameOrFunction: n,
                attribute: n,
                observable: t,
                emitter: e,
                callback: i,
              });
            },
            if(n, i, o) {
              return new HA({
                observable: t,
                emitter: e,
                attribute: n,
                valueIfTrue: i,
                callback: o,
              });
            },
          };
        }
        static extend(t, e) {
          if (t._isRendered) {
            throw new M("template-extend-render", [this, t]);
          }
          oC(t, ZA(YA(e)));
        }
        _renderNode(t) {
          let e;
          if (t.node) {
            e = this.tag && this.text;
          } else {
            e = this.tag ? this.text : !this.text;
          }
          if (e) {
            throw new M("ui-template-wrong-syntax", this);
          }
          if (this.text) {
            return this._renderText(t);
          } else {
            return this._renderElement(t);
          }
        }
        _renderElement(t) {
          let e = t.node;
          if (!e) {
            e = t.node = document.createElementNS(this.ns || OA, this.tag);
          }
          this._renderAttributes(t);
          this._renderElementChildren(t);
          this._setUpListeners(t);
          return e;
        }
        _renderText(t) {
          let e = t.node;
          if (e) {
            t.revertData.text = e.textContent;
          } else {
            e = t.node = document.createTextNode("");
          }
          if (UA(this.text)) {
            this._bindToObservable({
              schema: this.text,
              updater: GA(e),
              data: t,
            });
          } else {
            e.textContent = this.text.join("");
          }
          return e;
        }
        _renderAttributes(t) {
          if (!this.attributes) {
            return;
          }
          const e = t.node;
          const n = t.revertData;
          for (const i in this.attributes) {
            const o = e.getAttribute(i);
            const r = this.attributes[i];
            if (n) {
              n.attributes[i] = o;
            }
            const s = lC(r) ? r[0].ns : null;
            if (UA(r)) {
              const a = lC(r) ? r[0].value : r;
              if (n && uC(i)) {
                a.unshift(o);
              }
              this._bindToObservable({
                schema: a,
                updater: $A(e, i, s),
                data: t,
              });
            } else if (i == "style" && typeof r[0] !== "string") {
              this._renderStyleAttribute(r[0], t);
            } else {
              if (n && o && uC(i)) {
                r.unshift(o);
              }
              const t = r
                .map((t) => (t ? t.value || t : t))
                .reduce((t, e) => t.concat(e), [])
                .reduce(nC, "");
              if (!rC(t)) {
                e.setAttributeNS(s, i, t);
              }
            }
          }
        }
        _renderStyleAttribute(t, e) {
          const n = e.node;
          for (const i in t) {
            const o = t[i];
            if (UA(o)) {
              this._bindToObservable({
                schema: [o],
                updater: KA(n, i),
                data: e,
              });
            } else {
              n.style[i] = o;
            }
          }
        }
        _renderElementChildren(t) {
          const e = t.node;
          const n = t.intoFragment ? document.createDocumentFragment() : e;
          const i = t.isApplying;
          let o = 0;
          for (const r of this.children) {
            if (cC(r)) {
              if (!i) {
                r.setParent(e);
                for (const t of r) {
                  n.appendChild(t.element);
                }
              }
            } else if (sC(r)) {
              if (!i) {
                if (!r.isRendered) {
                  r.render();
                }
                n.appendChild(r.element);
              }
            } else if (Wa(r)) {
              n.appendChild(r);
            } else {
              if (i) {
                const e = t.revertData;
                const i = dC();
                e.children.push(i);
                r._renderNode({
                  intoFragment: false,
                  node: n.childNodes[o++],
                  isApplying: true,
                  revertData: i,
                });
              } else {
                n.appendChild(r.render());
              }
            }
          }
          if (t.intoFragment) {
            e.appendChild(n);
          }
        }
        _setUpListeners(t) {
          if (!this.eventListeners) {
            return;
          }
          for (const e in this.eventListeners) {
            const n = this.eventListeners[e].map((n) => {
              const [i, o] = e.split("@");
              return n.activateDomEventListener(i, o, t);
            });
            if (t.revertData) {
              t.revertData.bindings.push(n);
            }
          }
        }
        _bindToObservable({ schema: t, updater: e, data: n }) {
          const i = n.revertData;
          WA(t, e, n);
          const o = t
            .filter((t) => !rC(t))
            .filter((t) => t.observable)
            .map((i) => i.activateAttributeListener(t, e, n));
          if (i) {
            i.bindings.push(o);
          }
        }
        _revertTemplateFromNode(t, e) {
          for (const t of e.bindings) {
            for (const e of t) {
              e();
            }
          }
          if (e.text) {
            t.textContent = e.text;
            return;
          }
          const n = t;
          for (const t in e.attributes) {
            const i = e.attributes[t];
            if (i === null) {
              n.removeAttribute(t);
            } else {
              n.setAttribute(t, i);
            }
          }
          for (let t = 0; t < e.children.length; ++t) {
            this._revertTemplateFromNode(n.childNodes[t], e.children[t]);
          }
        }
      }
      class FA {
        constructor(t) {
          this.attribute = t.attribute;
          this.observable = t.observable;
          this.emitter = t.emitter;
          this.callback = t.callback;
        }
        getValue(t) {
          const e = this.observable[this.attribute];
          return this.callback ? this.callback(e, t) : e;
        }
        activateAttributeListener(t, e, n) {
          const i = () => WA(t, e, n);
          this.emitter.listenTo(this.observable, \`change:\${this.attribute}\`, i);
          return () => {
            this.emitter.stopListening(
              this.observable,
              \`change:\${this.attribute}\`,
              i
            );
          };
        }
      }
      class VA extends FA {
        constructor(t) {
          super(t);
          this.eventNameOrFunction = t.eventNameOrFunction;
        }
        activateDomEventListener(t, e, n) {
          const i = (t, n) => {
            if (!e || n.target.matches(e)) {
              if (typeof this.eventNameOrFunction == "function") {
                this.eventNameOrFunction(n);
              } else {
                this.observable.fire(this.eventNameOrFunction, n);
              }
            }
          };
          this.emitter.listenTo(n.node, t, i);
          return () => {
            this.emitter.stopListening(n.node, t, i);
          };
        }
      }
      class HA extends FA {
        constructor(t) {
          super(t);
          this.valueIfTrue = t.valueIfTrue;
        }
        getValue(t) {
          const e = super.getValue(t);
          return rC(e) ? false : this.valueIfTrue || true;
        }
      }
      function UA(t) {
        if (!t) {
          return false;
        }
        if (t.value) {
          t = t.value;
        }
        if (Array.isArray(t)) {
          return t.some(UA);
        } else if (t instanceof FA) {
          return true;
        }
        return false;
      }
      function qA(t, e) {
        return t.map((t) => {
          if (t instanceof FA) {
            return t.getValue(e);
          }
          return t;
        });
      }
      function WA(t, e, { node: n }) {
        const i = qA(t, n);
        let o;
        if (t.length == 1 && t[0] instanceof HA) {
          o = i[0];
        } else {
          o = i.reduce(nC, "");
        }
        if (rC(o)) {
          e.remove();
        } else {
          e.set(o);
        }
      }
      function GA(t) {
        return {
          set(e) {
            t.textContent = e;
          },
          remove() {
            t.textContent = "";
          },
        };
      }
      function $A(t, e, n) {
        return {
          set(i) {
            t.setAttributeNS(n, e, i);
          },
          remove() {
            t.removeAttributeNS(n, e);
          },
        };
      }
      function KA(t, e) {
        return {
          set(n) {
            t.style[e] = n;
          },
          remove() {
            t.style[e] = null;
          },
        };
      }
      function YA(t) {
        const e = ja(t, (t) => {
          if (t && (t instanceof FA || aC(t) || sC(t) || cC(t))) {
            return t;
          }
        });
        return e;
      }
      function ZA(t) {
        if (typeof t == "string") {
          t = XA(t);
        } else if (t.text) {
          tC(t);
        }
        if (t.on) {
          t.eventListeners = JA(t.on);
          delete t.on;
        }
        if (!t.text) {
          if (t.attributes) {
            QA(t.attributes);
          }
          const e = [];
          if (t.children) {
            if (cC(t.children)) {
              e.push(t.children);
            } else {
              for (const n of t.children) {
                if (aC(n) || sC(n) || Wa(n)) {
                  e.push(n);
                } else {
                  e.push(new jA(n));
                }
              }
            }
          }
          t.children = e;
        }
        return t;
      }
      function QA(t) {
        for (const e in t) {
          if (t[e].value) {
            t[e].value = Yc(t[e].value);
          }
          eC(t, e);
        }
      }
      function JA(t) {
        for (const e in t) {
          eC(t, e);
        }
        return t;
      }
      function XA(t) {
        return { text: [t] };
      }
      function tC(t) {
        t.text = Yc(t.text);
      }
      function eC(t, e) {
        t[e] = Yc(t[e]);
      }
      function nC(t, e) {
        if (rC(e)) {
          return t;
        } else if (rC(t)) {
          return e;
        } else {
          return \`\${t} \${e}\`;
        }
      }
      function iC(t, e) {
        for (const n in e) {
          if (t[n]) {
            t[n].push(...e[n]);
          } else {
            t[n] = e[n];
          }
        }
      }
      function oC(t, e) {
        if (e.attributes) {
          if (!t.attributes) {
            t.attributes = {};
          }
          iC(t.attributes, e.attributes);
        }
        if (e.eventListeners) {
          if (!t.eventListeners) {
            t.eventListeners = {};
          }
          iC(t.eventListeners, e.eventListeners);
        }
        if (e.text) {
          t.text.push(...e.text);
        }
        if (e.children && e.children.length) {
          if (t.children.length != e.children.length) {
            throw new M("ui-template-extend-children-mismatch", t);
          }
          let n = 0;
          for (const i of e.children) {
            oC(t.children[n++], i);
          }
        }
      }
      function rC(t) {
        return !t && t !== 0;
      }
      function sC(t) {
        return t instanceof pC;
      }
      function aC(t) {
        return t instanceof jA;
      }
      function cC(t) {
        return t instanceof PA;
      }
      function lC(t) {
        return it(t[0]) && t[0].ns;
      }
      function dC() {
        return { children: [], bindings: [], attributes: {} };
      }
      function uC(t) {
        return t == "class" || t == "style";
      }
      var hC = n(6150);
      var mC = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      mC.insert = "head";
      mC.singleton = true;
      var gC = Il()(hC.Z, mC);
      const fC = hC.Z.locals || {};
      class pC extends Ka(dt()) {
        constructor(t) {
          super();
          this.element = null;
          this.isRendered = false;
          this.locale = t;
          this.t = t && t.t;
          this._viewCollections = new rl();
          this._unboundChildren = this.createCollection();
          this._viewCollections.on("add", (e, n) => {
            n.locale = t;
            n.t = t && t.t;
          });
          this.decorate("render");
        }
        get bindTemplate() {
          if (this._bindTemplate) {
            return this._bindTemplate;
          }
          return (this._bindTemplate = jA.bind(this, this));
        }
        createCollection(t) {
          const e = new PA(t);
          this._viewCollections.add(e);
          return e;
        }
        registerChild(t) {
          if (!yt(t)) {
            t = [t];
          }
          for (const e of t) {
            this._unboundChildren.add(e);
          }
        }
        deregisterChild(t) {
          if (!yt(t)) {
            t = [t];
          }
          for (const e of t) {
            this._unboundChildren.remove(e);
          }
        }
        setTemplate(t) {
          this.template = new jA(t);
        }
        extendTemplate(t) {
          jA.extend(this.template, t);
        }
        render() {
          if (this.isRendered) {
            throw new M("ui-view-render-already-rendered", this);
          }
          if (this.template) {
            this.element = this.template.render();
            this.registerChild(this.template.getViews());
          }
          this.isRendered = true;
        }
        destroy() {
          this.stopListening();
          this._viewCollections.map((t) => t.destroy());
          if (this.template && this.template._revertData) {
            this.template.revert(this.element);
          }
        }
      }
      var bC = n(8245);
      var kC = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      kC.insert = "head";
      kC.singleton = true;
      var wC = Il()(bC.Z, kC);
      const AC = bC.Z.locals || {};
      const CC = hc("px");
      const _C = Xa.document.body;
      class vC extends pC {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set("top", 0);
          this.set("left", 0);
          this.set("position", "arrow_nw");
          this.set("isVisible", false);
          this.set("withArrow", true);
          this.set("class", undefined);
          this._pinWhenIsVisibleCallback = null;
          this.content = this.createCollection();
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-balloon-panel",
                e.to("position", (t) => \`ck-balloon-panel_\${t}\`),
                e.if("isVisible", "ck-balloon-panel_visible"),
                e.if("withArrow", "ck-balloon-panel_with-arrow"),
                e.to("class"),
              ],
              style: { top: e.to("top", CC), left: e.to("left", CC) },
            },
            children: this.content,
          });
        }
        show() {
          this.isVisible = true;
        }
        hide() {
          this.isVisible = false;
        }
        attachTo(t) {
          this.show();
          const e = vC.defaultPositions;
          const n = Object.assign(
            {},
            {
              element: this.element,
              positions: [
                e.southArrowNorth,
                e.southArrowNorthMiddleWest,
                e.southArrowNorthMiddleEast,
                e.southArrowNorthWest,
                e.southArrowNorthEast,
                e.northArrowSouth,
                e.northArrowSouthMiddleWest,
                e.northArrowSouthMiddleEast,
                e.northArrowSouthWest,
                e.northArrowSouthEast,
                e.viewportStickyNorth,
              ],
              limiter: _C,
              fitInViewport: true,
            },
            t
          );
          const i = vC._getOptimalPosition(n);
          const o = parseInt(i.left);
          const r = parseInt(i.top);
          const s = i.name;
          const a = i.config || {};
          const { withArrow: c = true } = a;
          this.top = r;
          this.left = o;
          this.position = s;
          this.withArrow = c;
        }
        pin(t) {
          this.unpin();
          this._pinWhenIsVisibleCallback = () => {
            if (this.isVisible) {
              this._startPinning(t);
            } else {
              this._stopPinning();
            }
          };
          this._startPinning(t);
          this.listenTo(
            this,
            "change:isVisible",
            this._pinWhenIsVisibleCallback
          );
        }
        unpin() {
          if (this._pinWhenIsVisibleCallback) {
            this._stopPinning();
            this.stopListening(
              this,
              "change:isVisible",
              this._pinWhenIsVisibleCallback
            );
            this._pinWhenIsVisibleCallback = null;
            this.hide();
          }
        }
        _startPinning(t) {
          this.attachTo(t);
          const e = yC(t.target);
          const n = t.limiter ? yC(t.limiter) : _C;
          this.listenTo(
            Xa.document,
            "scroll",
            (i, o) => {
              const r = o.target;
              const s = e && r.contains(e);
              const a = n && r.contains(n);
              if (s || a || !e || !n) {
                this.attachTo(t);
              }
            },
            { useCapture: true }
          );
          this.listenTo(Xa.window, "resize", () => {
            this.attachTo(t);
          });
        }
        _stopPinning() {
          this.stopListening(Xa.document, "scroll");
          this.stopListening(Xa.window, "resize");
        }
      }
      vC.arrowSideOffset = 25;
      vC.arrowHeightOffset = 10;
      vC.stickyVerticalOffset = 20;
      vC._getOptimalPosition = kc;
      vC.defaultPositions = xC();
      function yC(t) {
        if (Va(t)) {
          return t;
        }
        if (ic(t)) {
          return t.commonAncestorContainer;
        }
        if (typeof t == "function") {
          return yC(t());
        }
        return null;
      }
      function xC(t = {}) {
        const {
          sideOffset: e = vC.arrowSideOffset,
          heightOffset: n = vC.arrowHeightOffset,
          stickyVerticalOffset: i = vC.stickyVerticalOffset,
          config: o,
        } = t;
        return {
          northWestArrowSouthWest: (t, n) => ({
            top: r(t, n),
            left: t.left - e,
            name: "arrow_sw",
            ...(o && { config: o }),
          }),
          northWestArrowSouthMiddleWest: (t, n) => ({
            top: r(t, n),
            left: t.left - n.width * 0.25 - e,
            name: "arrow_smw",
            ...(o && { config: o }),
          }),
          northWestArrowSouth: (t, e) => ({
            top: r(t, e),
            left: t.left - e.width / 2,
            name: "arrow_s",
            ...(o && { config: o }),
          }),
          northWestArrowSouthMiddleEast: (t, n) => ({
            top: r(t, n),
            left: t.left - n.width * 0.75 + e,
            name: "arrow_sme",
            ...(o && { config: o }),
          }),
          northWestArrowSouthEast: (t, n) => ({
            top: r(t, n),
            left: t.left - n.width + e,
            name: "arrow_se",
            ...(o && { config: o }),
          }),
          northArrowSouthWest: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - e,
            name: "arrow_sw",
            ...(o && { config: o }),
          }),
          northArrowSouthMiddleWest: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - n.width * 0.25 - e,
            name: "arrow_smw",
            ...(o && { config: o }),
          }),
          northArrowSouth: (t, e) => ({
            top: r(t, e),
            left: t.left + t.width / 2 - e.width / 2,
            name: "arrow_s",
            ...(o && { config: o }),
          }),
          northArrowSouthMiddleEast: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - n.width * 0.75 + e,
            name: "arrow_sme",
            ...(o && { config: o }),
          }),
          northArrowSouthEast: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - n.width + e,
            name: "arrow_se",
            ...(o && { config: o }),
          }),
          northEastArrowSouthWest: (t, n) => ({
            top: r(t, n),
            left: t.right - e,
            name: "arrow_sw",
            ...(o && { config: o }),
          }),
          northEastArrowSouthMiddleWest: (t, n) => ({
            top: r(t, n),
            left: t.right - n.width * 0.25 - e,
            name: "arrow_smw",
            ...(o && { config: o }),
          }),
          northEastArrowSouth: (t, e) => ({
            top: r(t, e),
            left: t.right - e.width / 2,
            name: "arrow_s",
            ...(o && { config: o }),
          }),
          northEastArrowSouthMiddleEast: (t, n) => ({
            top: r(t, n),
            left: t.right - n.width * 0.75 + e,
            name: "arrow_sme",
            ...(o && { config: o }),
          }),
          northEastArrowSouthEast: (t, n) => ({
            top: r(t, n),
            left: t.right - n.width + e,
            name: "arrow_se",
            ...(o && { config: o }),
          }),
          southWestArrowNorthWest: (t) => ({
            top: s(t),
            left: t.left - e,
            name: "arrow_nw",
            ...(o && { config: o }),
          }),
          southWestArrowNorthMiddleWest: (t, n) => ({
            top: s(t),
            left: t.left - n.width * 0.25 - e,
            name: "arrow_nmw",
            ...(o && { config: o }),
          }),
          southWestArrowNorth: (t, e) => ({
            top: s(t),
            left: t.left - e.width / 2,
            name: "arrow_n",
            ...(o && { config: o }),
          }),
          southWestArrowNorthMiddleEast: (t, n) => ({
            top: s(t),
            left: t.left - n.width * 0.75 + e,
            name: "arrow_nme",
            ...(o && { config: o }),
          }),
          southWestArrowNorthEast: (t, n) => ({
            top: s(t),
            left: t.left - n.width + e,
            name: "arrow_ne",
            ...(o && { config: o }),
          }),
          southArrowNorthWest: (t) => ({
            top: s(t),
            left: t.left + t.width / 2 - e,
            name: "arrow_nw",
            ...(o && { config: o }),
          }),
          southArrowNorthMiddleWest: (t, n) => ({
            top: s(t),
            left: t.left + t.width / 2 - n.width * 0.25 - e,
            name: "arrow_nmw",
            ...(o && { config: o }),
          }),
          southArrowNorth: (t, e) => ({
            top: s(t),
            left: t.left + t.width / 2 - e.width / 2,
            name: "arrow_n",
            ...(o && { config: o }),
          }),
          southArrowNorthMiddleEast: (t, n) => ({
            top: s(t),
            left: t.left + t.width / 2 - n.width * 0.75 + e,
            name: "arrow_nme",
            ...(o && { config: o }),
          }),
          southArrowNorthEast: (t, n) => ({
            top: s(t),
            left: t.left + t.width / 2 - n.width + e,
            name: "arrow_ne",
            ...(o && { config: o }),
          }),
          southEastArrowNorthWest: (t) => ({
            top: s(t),
            left: t.right - e,
            name: "arrow_nw",
            ...(o && { config: o }),
          }),
          southEastArrowNorthMiddleWest: (t, n) => ({
            top: s(t),
            left: t.right - n.width * 0.25 - e,
            name: "arrow_nmw",
            ...(o && { config: o }),
          }),
          southEastArrowNorth: (t, e) => ({
            top: s(t),
            left: t.right - e.width / 2,
            name: "arrow_n",
            ...(o && { config: o }),
          }),
          southEastArrowNorthMiddleEast: (t, n) => ({
            top: s(t),
            left: t.right - n.width * 0.75 + e,
            name: "arrow_nme",
            ...(o && { config: o }),
          }),
          southEastArrowNorthEast: (t, n) => ({
            top: s(t),
            left: t.right - n.width + e,
            name: "arrow_ne",
            ...(o && { config: o }),
          }),
          westArrowEast: (t, e) => ({
            top: t.top + t.height / 2 - e.height / 2,
            left: t.left - e.width - n,
            name: "arrow_e",
            ...(o && { config: o }),
          }),
          eastArrowWest: (t, e) => ({
            top: t.top + t.height / 2 - e.height / 2,
            left: t.right + n,
            name: "arrow_w",
            ...(o && { config: o }),
          }),
          viewportStickyNorth: (t, e, n) => {
            if (!t.getIntersection(n)) {
              return null;
            }
            return {
              top: n.top + i,
              left: t.left + t.width / 2 - e.width / 2,
              name: "arrowless",
              config: { withArrow: false, ...o },
            };
          },
        };
        function r(t, e) {
          return t.top - e.height - n;
        }
        function s(t) {
          return t.bottom + n;
        }
      }
      var EC = n(9948);
      var DC = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      DC.insert = "head";
      DC.singleton = true;
      var SC = Il()(EC.Z, DC);
      const TC = EC.Z.locals || {};
      const IC = "ck-tooltip";
      class MC extends Ka() {
        constructor(t) {
          super();
          MC._editors.add(t);
          if (MC._instance) {
            return MC._instance;
          }
          MC._instance = this;
          this.tooltipTextView = new pC(t.locale);
          this.tooltipTextView.set("text", "");
          this.tooltipTextView.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-tooltip__text"] },
            children: [{ text: this.tooltipTextView.bindTemplate.to("text") }],
          });
          this.balloonPanelView = new vC(t.locale);
          this.balloonPanelView.class = IC;
          this.balloonPanelView.content.add(this.tooltipTextView);
          this._resizeObserver = null;
          this._currentElementWithTooltip = null;
          this._currentTooltipPosition = null;
          this._pinTooltipDebounced = Qm(this._pinTooltip, 600);
          this.listenTo(
            Xa.document,
            "mouseenter",
            this._onEnterOrFocus.bind(this),
            { useCapture: true }
          );
          this.listenTo(
            Xa.document,
            "mouseleave",
            this._onLeaveOrBlur.bind(this),
            { useCapture: true }
          );
          this.listenTo(Xa.document, "focus", this._onEnterOrFocus.bind(this), {
            useCapture: true,
          });
          this.listenTo(Xa.document, "blur", this._onLeaveOrBlur.bind(this), {
            useCapture: true,
          });
          this.listenTo(Xa.document, "scroll", this._onScroll.bind(this), {
            useCapture: true,
          });
          this._watchdogExcluded = true;
        }
        destroy(t) {
          const e = t.ui.view && t.ui.view.body;
          MC._editors.delete(t);
          this.stopListening(t.ui);
          if (e && e.has(this.balloonPanelView)) {
            e.remove(this.balloonPanelView);
          }
          if (!MC._editors.size) {
            this._unpinTooltip();
            this.balloonPanelView.destroy();
            this.stopListening();
            MC._instance = null;
          }
        }
        static getPositioningFunctions(t) {
          const e = MC.defaultBalloonPositions;
          return {
            s: [
              e.southArrowNorth,
              e.southArrowNorthEast,
              e.southArrowNorthWest,
            ],
            n: [e.northArrowSouth],
            e: [e.eastArrowWest],
            w: [e.westArrowEast],
            sw: [e.southArrowNorthEast],
            se: [e.southArrowNorthWest],
          }[t];
        }
        _onEnterOrFocus(t, { target: e }) {
          const n = BC(e);
          if (!n) {
            return;
          }
          if (n === this._currentElementWithTooltip) {
            return;
          }
          this._unpinTooltip();
          this._pinTooltipDebounced(n, LC(n));
        }
        _onLeaveOrBlur(t, { target: e, relatedTarget: n }) {
          if (t.name === "mouseleave") {
            if (!Va(e)) {
              return;
            }
            if (
              this._currentElementWithTooltip &&
              e !== this._currentElementWithTooltip
            ) {
              return;
            }
            const t = BC(e);
            const i = BC(n);
            if (t && t !== i) {
              this._unpinTooltip();
            }
          } else {
            if (
              this._currentElementWithTooltip &&
              e !== this._currentElementWithTooltip
            ) {
              return;
            }
            this._unpinTooltip();
          }
        }
        _onScroll(t, { target: e }) {
          if (!this._currentElementWithTooltip) {
            return;
          }
          if (
            e.contains(this.balloonPanelView.element) &&
            e.contains(this._currentElementWithTooltip)
          ) {
            return;
          }
          this._unpinTooltip();
        }
        _pinTooltip(t, { text: e, position: n, cssClass: i }) {
          const o = sl(MC._editors.values()).ui.view.body;
          if (!o.has(this.balloonPanelView)) {
            o.add(this.balloonPanelView);
          }
          this.tooltipTextView.text = e;
          this.balloonPanelView.pin({
            target: t,
            positions: MC.getPositioningFunctions(n),
          });
          this._resizeObserver = new dc(t, () => {
            if (!pc(t)) {
              this._unpinTooltip();
            }
          });
          this.balloonPanelView.class = [IC, i].filter((t) => t).join(" ");
          for (const t of MC._editors) {
            this.listenTo(
              t.ui,
              "update",
              this._updateTooltipPosition.bind(this),
              { priority: "low" }
            );
          }
          this._currentElementWithTooltip = t;
          this._currentTooltipPosition = n;
        }
        _unpinTooltip() {
          this._pinTooltipDebounced.cancel();
          this.balloonPanelView.unpin();
          for (const t of MC._editors) {
            this.stopListening(t.ui, "update");
          }
          this._currentElementWithTooltip = null;
          this._currentTooltipPosition = null;
          if (this._resizeObserver) {
            this._resizeObserver.destroy();
          }
        }
        _updateTooltipPosition() {
          if (!pc(this._currentElementWithTooltip)) {
            this._unpinTooltip();
            return;
          }
          this.balloonPanelView.pin({
            target: this._currentElementWithTooltip,
            positions: MC.getPositioningFunctions(this._currentTooltipPosition),
          });
        }
      }
      MC.defaultBalloonPositions = xC({ heightOffset: 5, sideOffset: 13 });
      MC._editors = new Set();
      MC._instance = null;
      function BC(t) {
        if (!Va(t)) {
          return null;
        }
        return t.closest(
          "[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])"
        );
      }
      function LC(t) {
        return {
          text: t.dataset.ckeTooltipText,
          position: t.dataset.ckeTooltipPosition || "s",
          cssClass: t.dataset.ckeTooltipClass || "",
        };
      }
      class NC extends dt() {
        constructor(t) {
          super();
          this.editor = t;
          this.componentFactory = new NA(t);
          this.focusTracker = new al();
          this.tooltipManager = new MC(t);
          this.set("viewportOffset", this._readViewportOffsetFromConfig());
          this.isReady = false;
          this.once("ready", () => {
            this.isReady = true;
          });
          this._editableElementsMap = new Map();
          this._focusableToolbarDefinitions = [];
          this.listenTo(t.editing.view.document, "layoutChanged", () =>
            this.update()
          );
          this._initFocusTracking();
        }
        get element() {
          return null;
        }
        update() {
          this.fire("update");
        }
        destroy() {
          this.stopListening();
          this.focusTracker.destroy();
          this.tooltipManager.destroy(this.editor);
          for (const t of this._editableElementsMap.values()) {
            t.ckeditorInstance = null;
          }
          this._editableElementsMap = new Map();
          this._focusableToolbarDefinitions = [];
        }
        setEditableElement(t, e) {
          this._editableElementsMap.set(t, e);
          if (!e.ckeditorInstance) {
            e.ckeditorInstance = this.editor;
          }
          this.focusTracker.add(e);
          const n = () => {
            if (this.editor.editing.view.getDomRoot(t)) {
              return;
            }
            this.editor.keystrokes.listenTo(e);
          };
          if (this.isReady) {
            n();
          } else {
            this.once("ready", n);
          }
        }
        getEditableElement(t = "main") {
          return this._editableElementsMap.get(t);
        }
        getEditableElementsNames() {
          return this._editableElementsMap.keys();
        }
        addToolbar(t, e = {}) {
          if (t.isRendered) {
            this.focusTracker.add(t.element);
            this.editor.keystrokes.listenTo(t.element);
          } else {
            t.once("render", () => {
              this.focusTracker.add(t.element);
              this.editor.keystrokes.listenTo(t.element);
            });
          }
          this._focusableToolbarDefinitions.push({
            toolbarView: t,
            options: e,
          });
        }
        get _editableElements() {
          console.warn(
            "editor-ui-deprecated-editable-elements: " +
              "The EditorUI#_editableElements property has been deprecated and will be removed in the near future.",
            { editorUI: this }
          );
          return this._editableElementsMap;
        }
        _readViewportOffsetFromConfig() {
          const t = this.editor;
          const e = t.config.get("ui.viewportOffset");
          if (e) {
            return e;
          }
          const n = t.config.get("toolbar.viewportTopOffset");
          if (n) {
            console.warn(
              "editor-ui-deprecated-viewport-offset-config: " +
                "The \`toolbar.vieportTopOffset\` configuration option is deprecated. " +
                "It will be removed from future CKEditor versions. Use \`ui.viewportOffset.top\` instead."
            );
            return { top: n };
          }
          return { top: 0 };
        }
        _initFocusTracking() {
          const t = this.editor;
          const e = t.editing.view;
          let n;
          let i;
          t.keystrokes.set("Alt+F10", (t, o) => {
            const r = this.focusTracker.focusedElement;
            if (
              Array.from(this._editableElementsMap.values()).includes(r) &&
              !Array.from(e.domRoots.values()).includes(r)
            ) {
              n = r;
            }
            const s = this._getCurrentFocusedToolbarDefinition();
            if (!s || !i) {
              i = this._getFocusableCandidateToolbarDefinitions();
            }
            for (let t = 0; t < i.length; t++) {
              const t = i.shift();
              i.push(t);
              if (t !== s && this._focusFocusableCandidateToolbar(t)) {
                if (s && s.options.afterBlur) {
                  s.options.afterBlur();
                }
                break;
              }
            }
            o();
          });
          t.keystrokes.set("Esc", (e, i) => {
            const o = this._getCurrentFocusedToolbarDefinition();
            if (!o) {
              return;
            }
            if (n) {
              n.focus();
              n = null;
            } else {
              t.editing.view.focus();
            }
            if (o.options.afterBlur) {
              o.options.afterBlur();
            }
            i();
          });
        }
        _getFocusableCandidateToolbarDefinitions() {
          const t = [];
          for (const e of this._focusableToolbarDefinitions) {
            const { toolbarView: n, options: i } = e;
            if (pc(n.element) || i.beforeFocus) {
              t.push(e);
            }
          }
          t.sort((t, e) => zC(t) - zC(e));
          return t;
        }
        _getCurrentFocusedToolbarDefinition() {
          for (const t of this._focusableToolbarDefinitions) {
            if (
              t.toolbarView.element &&
              t.toolbarView.element.contains(this.focusTracker.focusedElement)
            ) {
              return t;
            }
          }
          return null;
        }
        _focusFocusableCandidateToolbar(t) {
          const {
            toolbarView: e,
            options: { beforeFocus: n },
          } = t;
          if (n) {
            n();
          }
          if (!pc(e.element)) {
            return false;
          }
          e.focus();
          return true;
        }
      }
      function zC(t) {
        const { toolbarView: e, options: n } = t;
        let i = 10;
        if (pc(e.element)) {
          i--;
        }
        if (n.isContextual) {
          i--;
        }
        return i;
      }
      function PC(t) {
        if (!qe(t.updateSourceElement)) {
          throw new M("attachtoform-missing-elementapi-interface", t);
        }
        const e = t.sourceElement;
        if (RC(e) && e.form) {
          let n;
          const i = e.form;
          const o = () => t.updateSourceElement();
          if (qe(i.submit)) {
            n = i.submit;
            i.submit = () => {
              o();
              n.apply(i);
            };
          }
          i.addEventListener("submit", o);
          t.on("destroy", () => {
            i.removeEventListener("submit", o);
            if (n) {
              i.submit = n;
            }
          });
        }
      }
      function RC(t) {
        return !!t && t.tagName.toLowerCase() === "textarea";
      }
      function OC(t) {
        class e extends t {
          setData(t) {
            this.data.set(t);
          }
          getData(t) {
            return this.data.get(t);
          }
        }
        return e;
      }
      {
        const t = OC(Object);
        OC.setData = t.prototype.setData;
        OC.getData = t.prototype.getData;
      }
      function jC(t) {
        class e extends t {
          updateSourceElement(t = this.data.get()) {
            if (!this.sourceElement) {
              throw new M("editor-missing-sourceelement", this);
            }
            const e = this.config.get("updateSourceElementOnDestroy");
            const n = this.sourceElement instanceof HTMLTextAreaElement;
            if (!e && !n) {
              uc(this.sourceElement, "");
              return;
            }
            uc(this.sourceElement, t);
          }
        }
        return e;
      }
      jC.updateSourceElement = jC(Object).prototype.updateSourceElement;
      function FC(t) {
        const e = t.sourceElement;
        if (!e) {
          return;
        }
        if (e.ckeditorInstance) {
          throw new M("editor-source-element-already-used", t);
        }
        e.ckeditorInstance = t;
        t.once("destroy", () => {
          delete e.ckeditorInstance;
        });
      }
      class VC extends Sl {
        static get pluginName() {
          return "PendingActions";
        }
        init() {
          this.set("hasAny", false);
          this._actions = new rl({ idProperty: "_id" });
          this._actions.delegate("add", "remove").to(this);
        }
        add(t) {
          if (typeof t !== "string") {
            throw new M("pendingactions-add-invalid-message", this);
          }
          const e = new (dt())();
          e.set("message", t);
          this._actions.add(e);
          this.hasAny = true;
          return e;
        }
        remove(t) {
          this._actions.remove(t);
          this.hasAny = !!this._actions.length;
        }
        get first() {
          return this._actions.get(0);
        }
        [Symbol.iterator]() {
          return this._actions[Symbol.iterator]();
        }
      }
      const HC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>';
      const UC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>';
      const qC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>';
      const WC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>';
      const GC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>';
      const $C =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>';
      const KC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>';
      const YC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>';
      const ZC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>';
      const QC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>';
      const JC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
      const XC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>';
      const t_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>';
      const e_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
      const n_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
      const i_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>';
      const o_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';
      const r_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>';
      const s_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
      const a_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
      const c_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';
      const l_ =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>';
      const d_ =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>';
      const u_ =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>';
      const h_ =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>';
      const m_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>';
      const g_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>';
      const f_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>';
      const p_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
      const b_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>';
      const k_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>';
      const w_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>';
      const A_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path clip-rule="evenodd" d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>';
      const C_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path clip-rule="evenodd" d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>';
      const __ = {
        bold: b_,
        cancel: HC,
        caption: UC,
        check: qC,
        cog: WC,
        eraser: GC,
        image: KC,
        lowVision: $C,
        importExport: C_,
        paragraph: k_,
        plus: w_,
        text: A_,
        alignBottom: YC,
        alignMiddle: ZC,
        alignTop: QC,
        alignLeft: JC,
        alignCenter: XC,
        alignRight: t_,
        alignJustify: e_,
        objectLeft: a_,
        objectCenter: i_,
        objectRight: c_,
        objectFullWidth: r_,
        objectInline: s_,
        objectBlockLeft: n_,
        objectBlockRight: o_,
        objectSizeFull: l_,
        objectSizeLarge: d_,
        objectSizeSmall: u_,
        objectSizeMedium: h_,
        pencil: m_,
        pilcrow: g_,
        quote: f_,
        threeVerticalDots: p_,
      };
      function v_({
        emitter: t,
        activator: e,
        callback: n,
        contextElements: i,
      }) {
        t.listenTo(document, "mousedown", (t, o) => {
          if (!e()) {
            return;
          }
          const r = typeof o.composedPath == "function" ? o.composedPath() : [];
          for (const t of i) {
            if (t.contains(o.target) || r.includes(t)) {
              return;
            }
          }
          n();
        });
      }
      function y_(t) {
        const e = t;
        e.set("_isCssTransitionsDisabled", false);
        e.disableCssTransitions = () => {
          e._isCssTransitionsDisabled = true;
        };
        e.enableCssTransitions = () => {
          e._isCssTransitionsDisabled = false;
        };
        e.extendTemplate({
          attributes: {
            class: [
              e.bindTemplate.if(
                "_isCssTransitionsDisabled",
                "ck-transitions-disabled"
              ),
            ],
          },
        });
      }
      function x_({ view: t }) {
        t.listenTo(
          t.element,
          "submit",
          (e, n) => {
            n.preventDefault();
            t.fire("submit");
          },
          { useCapture: true }
        );
      }
      function E_({
        keystrokeHandler: t,
        focusTracker: e,
        gridItems: n,
        numberOfColumns: i,
        uiLanguageDirection: o,
      }) {
        const r = typeof i === "number" ? () => i : i;
        t.set(
          "arrowright",
          s((t, e) => (o === "rtl" ? c(t, e.length) : a(t, e.length)))
        );
        t.set(
          "arrowleft",
          s((t, e) => (o === "rtl" ? a(t, e.length) : c(t, e.length)))
        );
        t.set(
          "arrowup",
          s((t, e) => {
            let n = t - r();
            if (n < 0) {
              n = t + r() * Math.floor(e.length / r());
              if (n > e.length - 1) {
                n -= r();
              }
            }
            return n;
          })
        );
        t.set(
          "arrowdown",
          s((t, e) => {
            let n = t + r();
            if (n > e.length - 1) {
              n = t % r();
            }
            return n;
          })
        );
        function s(t) {
          return (i) => {
            const o = n.find((t) => t.element === e.focusedElement);
            const r = n.getIndex(o);
            const s = t(r, n);
            n.get(s).focus();
            i.stopPropagation();
            i.preventDefault();
          };
        }
        function a(t, e) {
          if (t === e - 1) {
            return 0;
          } else {
            return t + 1;
          }
        }
        function c(t, e) {
          if (t === 0) {
            return e - 1;
          } else {
            return t - 1;
          }
        }
      }
      class D_ extends PA {
        constructor(t, e = []) {
          super(e);
          this.locale = t;
        }
        attachToDom() {
          this._bodyCollectionContainer = new jA({
            tag: "div",
            attributes: {
              class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
              dir: this.locale.uiLanguageDirection,
            },
            children: this,
          }).render();
          let t = document.querySelector(".ck-body-wrapper");
          if (!t) {
            t = te(document, "div", { class: "ck-body-wrapper" });
            document.body.appendChild(t);
          }
          t.appendChild(this._bodyCollectionContainer);
        }
        detachFromDom() {
          super.destroy();
          if (this._bodyCollectionContainer) {
            this._bodyCollectionContainer.remove();
          }
          const t = document.querySelector(".ck-body-wrapper");
          if (t && t.childElementCount == 0) {
            t.remove();
          }
        }
      }
      var S_ = n(1174);
      var T_ = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      T_.insert = "head";
      T_.singleton = true;
      var I_ = Il()(S_.Z, T_);
      const M_ = S_.Z.locals || {};
      class B_ extends pC {
        constructor() {
          super();
          const t = this.bindTemplate;
          this.set("content", "");
          this.set("viewBox", "0 0 20 20");
          this.set("fillColor", "");
          this.set("isColorInherited", true);
          this.setTemplate({
            tag: "svg",
            ns: "http://www.w3.org/2000/svg",
            attributes: {
              class: [
                "ck",
                "ck-icon",
                "ck-reset_all-excluded",
                t.if("isColorInherited", "ck-icon_inherit-color"),
              ],
              viewBox: t.to("viewBox"),
            },
          });
        }
        render() {
          super.render();
          this._updateXMLContent();
          this._colorFillPaths();
          this.on("change:content", () => {
            this._updateXMLContent();
            this._colorFillPaths();
          });
          this.on("change:fillColor", () => {
            this._colorFillPaths();
          });
        }
        _updateXMLContent() {
          if (this.content) {
            const t = new DOMParser().parseFromString(
              this.content.trim(),
              "image/svg+xml"
            );
            const e = t.querySelector("svg");
            const n = e.getAttribute("viewBox");
            if (n) {
              this.viewBox = n;
            }
            for (const { name: t, value: n } of Array.from(e.attributes)) {
              if (B_.presentationalAttributeNames.includes(t)) {
                this.element.setAttribute(t, n);
              }
            }
            while (this.element.firstChild) {
              this.element.removeChild(this.element.firstChild);
            }
            while (e.childNodes.length > 0) {
              this.element.appendChild(e.childNodes[0]);
            }
          }
        }
        _colorFillPaths() {
          if (this.fillColor) {
            this.element.querySelectorAll(".ck-icon__fill").forEach((t) => {
              t.style.fill = this.fillColor;
            });
          }
        }
      }
      B_.presentationalAttributeNames = [
        "alignment-baseline",
        "baseline-shift",
        "clip-path",
        "clip-rule",
        "color",
        "color-interpolation",
        "color-interpolation-filters",
        "color-rendering",
        "cursor",
        "direction",
        "display",
        "dominant-baseline",
        "fill",
        "fill-opacity",
        "fill-rule",
        "filter",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "mask",
        "opacity",
        "overflow",
        "paint-order",
        "pointer-events",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "stroke",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-overflow",
        "text-rendering",
        "transform",
        "unicode-bidi",
        "vector-effect",
        "visibility",
        "white-space",
        "word-spacing",
        "writing-mode",
      ];
      var L_ = n(4499);
      var N_ = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      N_.insert = "head";
      N_.singleton = true;
      var z_ = Il()(L_.Z, N_);
      const P_ = L_.Z.locals || {};
      class R_ extends pC {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          const n = E();
          this.set("class", undefined);
          this.set("labelStyle", undefined);
          this.set("icon", undefined);
          this.set("isEnabled", true);
          this.set("isOn", false);
          this.set("isVisible", true);
          this.set("isToggleable", false);
          this.set("keystroke", undefined);
          this.set("label", undefined);
          this.set("tabindex", -1);
          this.set("tooltip", false);
          this.set("tooltipPosition", "s");
          this.set("type", "button");
          this.set("withText", false);
          this.set("withKeystroke", false);
          this.children = this.createCollection();
          this.labelView = this._createLabelView(n);
          this.iconView = new B_();
          this.iconView.extendTemplate({
            attributes: { class: "ck-button__icon" },
          });
          this.keystrokeView = this._createKeystrokeView();
          this.bind("_tooltipString").to(
            this,
            "tooltip",
            this,
            "label",
            this,
            "keystroke",
            this._getTooltipString.bind(this)
          );
          const i = {
            tag: "button",
            attributes: {
              class: [
                "ck",
                "ck-button",
                e.to("class"),
                e.if("isEnabled", "ck-disabled", (t) => !t),
                e.if("isVisible", "ck-hidden", (t) => !t),
                e.to("isOn", (t) => (t ? "ck-on" : "ck-off")),
                e.if("withText", "ck-button_with-text"),
                e.if("withKeystroke", "ck-button_with-keystroke"),
              ],
              type: e.to("type", (t) => (t ? t : "button")),
              tabindex: e.to("tabindex"),
              "aria-labelledby": \`ck-editor__aria-label_\${n}\`,
              "aria-disabled": e.if("isEnabled", true, (t) => !t),
              "aria-pressed": e.to("isOn", (t) =>
                this.isToggleable ? String(!!t) : false
              ),
              "data-cke-tooltip-text": e.to("_tooltipString"),
              "data-cke-tooltip-position": e.to("tooltipPosition"),
            },
            children: this.children,
            on: {
              click: e.to((t) => {
                if (this.isEnabled) {
                  this.fire("execute");
                } else {
                  t.preventDefault();
                }
              }),
            },
          };
          if (r.isSafari) {
            i.on.mousedown = e.to((t) => {
              this.focus();
              t.preventDefault();
            });
          }
          this.setTemplate(i);
        }
        render() {
          super.render();
          if (this.icon) {
            this.iconView.bind("content").to(this, "icon");
            this.children.add(this.iconView);
          }
          this.children.add(this.labelView);
          if (this.withKeystroke && this.keystroke) {
            this.children.add(this.keystrokeView);
          }
        }
        focus() {
          this.element.focus();
        }
        _createLabelView(t) {
          const e = new pC();
          const n = this.bindTemplate;
          e.setTemplate({
            tag: "span",
            attributes: {
              class: ["ck", "ck-button__label"],
              style: n.to("labelStyle"),
              id: \`ck-editor__aria-label_\${t}\`,
            },
            children: [{ text: this.bindTemplate.to("label") }],
          });
          return e;
        }
        _createKeystrokeView() {
          const t = new pC();
          t.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-button__keystroke"] },
            children: [
              { text: this.bindTemplate.to("keystroke", (t) => Hc(t)) },
            ],
          });
          return t;
        }
        _getTooltipString(t, e, n) {
          if (t) {
            if (typeof t == "string") {
              return t;
            } else {
              if (n) {
                n = Hc(n);
              }
              if (t instanceof Function) {
                return t(e, n);
              } else {
                return \`\${e}\${n ? \` (\${n})\` : ""}\`;
              }
            }
          }
          return "";
        }
      }
      var O_ = n(9681);
      var j_ = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      j_.insert = "head";
      j_.singleton = true;
      var F_ = Il()(O_.Z, j_);
      const V_ = O_.Z.locals || {};
      class H_ extends R_ {
        constructor(t) {
          super(t);
          this.isToggleable = true;
          this.toggleSwitchView = this._createToggleView();
          this.extendTemplate({ attributes: { class: "ck-switchbutton" } });
        }
        render() {
          super.render();
          this.children.add(this.toggleSwitchView);
        }
        _createToggleView() {
          const t = new pC();
          t.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-button__toggle"] },
            children: [
              {
                tag: "span",
                attributes: { class: ["ck", "ck-button__toggle__inner"] },
              },
            ],
          });
          return t;
        }
      }
      function U_(t, e) {
        const n = t.t;
        const i = {
          Black: n("Black"),
          "Dim grey": n("Dim grey"),
          Grey: n("Grey"),
          "Light grey": n("Light grey"),
          White: n("White"),
          Red: n("Red"),
          Orange: n("Orange"),
          Yellow: n("Yellow"),
          "Light green": n("Light green"),
          Green: n("Green"),
          Aquamarine: n("Aquamarine"),
          Turquoise: n("Turquoise"),
          "Light blue": n("Light blue"),
          Blue: n("Blue"),
          Purple: n("Purple"),
        };
        return e.map((t) => {
          const e = i[t.label];
          if (e && e != t.label) {
            t.label = e;
          }
          return t;
        });
      }
      function q_(t) {
        return t.map(W_).filter((t) => !!t);
      }
      function W_(t) {
        if (typeof t === "string") {
          return {
            model: t,
            label: t,
            hasBorder: false,
            view: { name: "span", styles: { color: t } },
          };
        } else {
          return {
            model: t.color,
            label: t.label || t.color,
            hasBorder: t.hasBorder === undefined ? false : t.hasBorder,
            view: { name: "span", styles: { color: \`\${t.color}\` } },
          };
        }
      }
      const G_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>';
      class $_ extends R_ {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set("color", undefined);
          this.set("hasBorder", false);
          this.icon = G_;
          this.extendTemplate({
            attributes: {
              style: { backgroundColor: e.to("color") },
              class: [
                "ck",
                "ck-color-grid__tile",
                e.if("hasBorder", "ck-color-table__color-tile_bordered"),
              ],
            },
          });
        }
        render() {
          super.render();
          this.iconView.fillColor = "hsl(0, 0%, 100%)";
        }
      }
      var K_ = n(4923);
      var Y_ = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Y_.insert = "head";
      Y_.singleton = true;
      var Z_ = Il()(K_.Z, Y_);
      const Q_ = K_.Z.locals || {};
      class J_ extends pC {
        constructor(t, e) {
          super(t);
          const n = (e && e.colorDefinitions) || [];
          this.columns = e && e.columns ? e.columns : 5;
          const i = { gridTemplateColumns: \`repeat( \${this.columns}, 1fr)\` };
          this.set("selectedColor", undefined);
          this.items = this.createCollection();
          this.focusTracker = new al();
          this.keystrokes = new cl();
          this.items.on("add", (t, e) => {
            e.isOn = e.color === this.selectedColor;
          });
          n.forEach((t) => {
            const e = new $_();
            e.set({
              color: t.color,
              label: t.label,
              tooltip: true,
              hasBorder: t.options.hasBorder,
            });
            e.on("execute", () => {
              this.fire("execute", {
                value: t.color,
                hasBorder: t.options.hasBorder,
                label: t.label,
              });
            });
            this.items.add(e);
          });
          this.setTemplate({
            tag: "div",
            children: this.items,
            attributes: { class: ["ck", "ck-color-grid"], style: i },
          });
          this.on("change:selectedColor", (t, e, n) => {
            for (const t of this.items) {
              t.isOn = t.color === n;
            }
          });
        }
        focus() {
          if (this.items.length) {
            this.items.first.focus();
          }
        }
        focusLast() {
          if (this.items.length) {
            this.items.last.focus();
          }
        }
        render() {
          super.render();
          for (const t of this.items) {
            this.focusTracker.add(t.element);
          }
          this.items.on("add", (t, e) => {
            this.focusTracker.add(e.element);
          });
          this.items.on("remove", (t, e) => {
            this.focusTracker.remove(e.element);
          });
          this.keystrokes.listenTo(this.element);
          E_({
            keystrokeHandler: this.keystrokes,
            focusTracker: this.focusTracker,
            gridItems: this.items,
            numberOfColumns: this.columns,
            uiLanguageDirection: this.locale && this.locale.uiLanguageDirection,
          });
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
      }
      const X_ =
        '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
      class tv extends R_ {
        constructor(t) {
          super(t);
          this.arrowView = this._createArrowView();
          this.extendTemplate({
            attributes: {
              "aria-haspopup": true,
              "aria-expanded": this.bindTemplate.to("isOn", (t) => String(t)),
            },
          });
          this.delegate("execute").to(this, "open");
        }
        render() {
          super.render();
          this.children.add(this.arrowView);
        }
        _createArrowView() {
          const t = new B_();
          t.content = X_;
          t.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } });
          return t;
        }
      }
      var ev = n(66);
      var nv = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      nv.insert = "head";
      nv.singleton = true;
      var iv = Il()(ev.Z, nv);
      const ov = ev.Z.locals || {};
      class rv extends pC {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set("class", undefined);
          this.set("labelStyle", undefined);
          this.set("icon", undefined);
          this.set("isEnabled", true);
          this.set("isOn", false);
          this.set("isToggleable", false);
          this.set("isVisible", true);
          this.set("keystroke", undefined);
          this.set("withKeystroke", false);
          this.set("label", undefined);
          this.set("tabindex", -1);
          this.set("tooltip", false);
          this.set("tooltipPosition", "s");
          this.set("type", "button");
          this.set("withText", false);
          this.children = this.createCollection();
          this.actionView = this._createActionView();
          this.arrowView = this._createArrowView();
          this.keystrokes = new cl();
          this.focusTracker = new al();
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-splitbutton",
                e.to("class"),
                e.if("isVisible", "ck-hidden", (t) => !t),
                this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open"),
              ],
            },
            children: this.children,
          });
        }
        render() {
          super.render();
          this.children.add(this.actionView);
          this.children.add(this.arrowView);
          this.focusTracker.add(this.actionView.element);
          this.focusTracker.add(this.arrowView.element);
          this.keystrokes.listenTo(this.element);
          this.keystrokes.set("arrowright", (t, e) => {
            if (this.focusTracker.focusedElement === this.actionView.element) {
              this.arrowView.focus();
              e();
            }
          });
          this.keystrokes.set("arrowleft", (t, e) => {
            if (this.focusTracker.focusedElement === this.arrowView.element) {
              this.actionView.focus();
              e();
            }
          });
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this.actionView.focus();
        }
        _createActionView() {
          const t = new R_();
          t.bind(
            "icon",
            "isEnabled",
            "isOn",
            "isToggleable",
            "keystroke",
            "label",
            "tabindex",
            "tooltip",
            "tooltipPosition",
            "type",
            "withText"
          ).to(this);
          t.extendTemplate({ attributes: { class: "ck-splitbutton__action" } });
          t.delegate("execute").to(this);
          return t;
        }
        _createArrowView() {
          const t = new R_();
          const e = t.bindTemplate;
          t.icon = X_;
          t.extendTemplate({
            attributes: {
              class: ["ck-splitbutton__arrow"],
              "data-cke-tooltip-disabled": e.to("isOn"),
              "aria-haspopup": true,
              "aria-expanded": e.to("isOn", (t) => String(t)),
            },
          });
          t.bind("isEnabled").to(this);
          t.bind("label").to(this);
          t.bind("tooltip").to(this);
          t.delegate("execute").to(this, "open");
          return t;
        }
      }
      class sv extends pC {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set("isVisible", false);
          this.set("position", "se");
          this.children = this.createCollection();
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-reset",
                "ck-dropdown__panel",
                e.to("position", (t) => \`ck-dropdown__panel_\${t}\`),
                e.if("isVisible", "ck-dropdown__panel-visible"),
              ],
            },
            children: this.children,
            on: { selectstart: e.to((t) => t.preventDefault()) },
          });
        }
        focus() {
          if (this.children.length) {
            const t = this.children.first;
            if (typeof t.focus === "function") {
              t.focus();
            } else {
              B("ui-dropdown-panel-focus-child-missing-focus", {
                childView: this.children.first,
                dropdownPanel: this,
              });
            }
          }
        }
        focusLast() {
          if (this.children.length) {
            const t = this.children.last;
            if (typeof t.focusLast === "function") {
              t.focusLast();
            } else {
              t.focus();
            }
          }
        }
      }
      var av = n(3488);
      var cv = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      cv.insert = "head";
      cv.singleton = true;
      var lv = Il()(av.Z, cv);
      const dv = av.Z.locals || {};
      class uv extends pC {
        constructor(t, e, n) {
          super(t);
          const i = this.bindTemplate;
          this.buttonView = e;
          this.panelView = n;
          this.set("isOpen", false);
          this.set("isEnabled", true);
          this.set("class", undefined);
          this.set("id", undefined);
          this.set("panelPosition", "auto");
          this.keystrokes = new cl();
          this.focusTracker = new al();
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-dropdown",
                i.to("class"),
                i.if("isEnabled", "ck-disabled", (t) => !t),
              ],
              id: i.to("id"),
              "aria-describedby": i.to("ariaDescribedById"),
            },
            children: [e, n],
          });
          e.extendTemplate({
            attributes: {
              class: ["ck-dropdown__button"],
              "data-cke-tooltip-disabled": i.to("isOpen"),
            },
          });
        }
        render() {
          super.render();
          this.focusTracker.add(this.buttonView.element);
          this.focusTracker.add(this.panelView.element);
          this.listenTo(this.buttonView, "open", () => {
            this.isOpen = !this.isOpen;
          });
          this.panelView.bind("isVisible").to(this, "isOpen");
          this.on("change:isOpen", (t, e, n) => {
            if (!n) {
              return;
            }
            if (this.panelPosition === "auto") {
              this.panelView.position = uv._getOptimalPosition({
                element: this.panelView.element,
                target: this.buttonView.element,
                fitInViewport: true,
                positions: this._panelPositions,
              }).name;
            } else {
              this.panelView.position = this.panelPosition;
            }
          });
          this.keystrokes.listenTo(this.element);
          const t = (t, e) => {
            if (this.isOpen) {
              this.isOpen = false;
              e();
            }
          };
          this.keystrokes.set("arrowdown", (t, e) => {
            if (this.buttonView.isEnabled && !this.isOpen) {
              this.isOpen = true;
              e();
            }
          });
          this.keystrokes.set("arrowright", (t, e) => {
            if (this.isOpen) {
              e();
            }
          });
          this.keystrokes.set("arrowleft", t);
          this.keystrokes.set("esc", t);
        }
        focus() {
          this.buttonView.focus();
        }
        get _panelPositions() {
          const {
            south: t,
            north: e,
            southEast: n,
            southWest: i,
            northEast: o,
            northWest: r,
            southMiddleEast: s,
            southMiddleWest: a,
            northMiddleEast: c,
            northMiddleWest: l,
          } = uv.defaultPanelPositions;
          if (this.locale.uiLanguageDirection !== "rtl") {
            return [n, i, s, a, t, o, r, c, l, e];
          } else {
            return [i, n, a, s, t, r, o, l, c, e];
          }
        }
      }
      uv.defaultPanelPositions = {
        south: (t, e) => ({
          top: t.bottom,
          left: t.left - (e.width - t.width) / 2,
          name: "s",
        }),
        southEast: (t) => ({ top: t.bottom, left: t.left, name: "se" }),
        southWest: (t, e) => ({
          top: t.bottom,
          left: t.left - e.width + t.width,
          name: "sw",
        }),
        southMiddleEast: (t, e) => ({
          top: t.bottom,
          left: t.left - (e.width - t.width) / 4,
          name: "sme",
        }),
        southMiddleWest: (t, e) => ({
          top: t.bottom,
          left: t.left - ((e.width - t.width) * 3) / 4,
          name: "smw",
        }),
        north: (t, e) => ({
          top: t.top - e.height,
          left: t.left - (e.width - t.width) / 2,
          name: "n",
        }),
        northEast: (t, e) => ({
          top: t.top - e.height,
          left: t.left,
          name: "ne",
        }),
        northWest: (t, e) => ({
          top: t.top - e.height,
          left: t.left - e.width + t.width,
          name: "nw",
        }),
        northMiddleEast: (t, e) => ({
          top: t.top - e.height,
          left: t.left - (e.width - t.width) / 4,
          name: "nme",
        }),
        northMiddleWest: (t, e) => ({
          top: t.top - e.height,
          left: t.left - ((e.width - t.width) * 3) / 4,
          name: "nmw",
        }),
      };
      uv._getOptimalPosition = kc;
      class hv {
        constructor(t) {
          this.focusables = t.focusables;
          this.focusTracker = t.focusTracker;
          this.keystrokeHandler = t.keystrokeHandler;
          this.actions = t.actions;
          if (t.actions && t.keystrokeHandler) {
            for (const e in t.actions) {
              let n = t.actions[e];
              if (typeof n == "string") {
                n = [n];
              }
              for (const i of n) {
                t.keystrokeHandler.set(i, (t, n) => {
                  this[e]();
                  n();
                });
              }
            }
          }
        }
        get first() {
          return this.focusables.find(mv) || null;
        }
        get last() {
          return this.focusables.filter(mv).slice(-1)[0] || null;
        }
        get next() {
          return this._getFocusableItem(1);
        }
        get previous() {
          return this._getFocusableItem(-1);
        }
        get current() {
          let t = null;
          if (this.focusTracker.focusedElement === null) {
            return null;
          }
          this.focusables.find((e, n) => {
            const i = e.element === this.focusTracker.focusedElement;
            if (i) {
              t = n;
            }
            return i;
          });
          return t;
        }
        focusFirst() {
          this._focus(this.first);
        }
        focusLast() {
          this._focus(this.last);
        }
        focusNext() {
          this._focus(this.next);
        }
        focusPrevious() {
          this._focus(this.previous);
        }
        _focus(t) {
          if (t) {
            t.focus();
          }
        }
        _getFocusableItem(t) {
          const e = this.current;
          const n = this.focusables.length;
          if (!n) {
            return null;
          }
          if (e === null) {
            return this[t === 1 ? "first" : "last"];
          }
          let i = (e + n + t) % n;
          do {
            const e = this.focusables.get(i);
            if (mv(e)) {
              return e;
            }
            i = (i + n + t) % n;
          } while (i !== e);
          return null;
        }
      }
      function mv(t) {
        return !!(t.focus && pc(t.element));
      }
      class gv extends pC {
        constructor(t) {
          super(t);
          this.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-toolbar__separator"] },
          });
        }
      }
      class fv extends pC {
        constructor(t) {
          super(t);
          this.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-toolbar__line-break"] },
          });
        }
      }
      function pv(t) {
        return t.bindTemplate.to((e) => {
          if (e.target === t.element) {
            e.preventDefault();
          }
        });
      }
      function bv(t) {
        if (Array.isArray(t)) {
          return { items: t, removeItems: [] };
        }
        if (!t) {
          return { items: [], removeItems: [] };
        }
        return Object.assign({ items: [], removeItems: [] }, t);
      }
      var kv = n(5571);
      var wv = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      wv.insert = "head";
      wv.singleton = true;
      var Av = Il()(kv.Z, wv);
      const Cv = kv.Z.locals || {};
      const { threeVerticalDots: _v } = __;
      const vv = {
        alignLeft: __.alignLeft,
        bold: __.bold,
        importExport: __.importExport,
        paragraph: __.paragraph,
        plus: __.plus,
        text: __.text,
        threeVerticalDots: __.threeVerticalDots,
      };
      class yv extends pC {
        constructor(t, e) {
          super(t);
          const n = this.bindTemplate;
          const i = this.t;
          this.options = e || {};
          this.set("ariaLabel", i("Editor toolbar"));
          this.set("maxWidth", "auto");
          this.items = this.createCollection();
          this.focusTracker = new al();
          this.keystrokes = new cl();
          this.set("class", undefined);
          this.set("isCompact", false);
          this.itemsView = new xv(t);
          this.children = this.createCollection();
          this.children.add(this.itemsView);
          this.focusables = this.createCollection();
          const o = t.uiLanguageDirection === "rtl";
          this._focusCycler = new hv({
            focusables: this.focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
              focusPrevious: [o ? "arrowright" : "arrowleft", "arrowup"],
              focusNext: [o ? "arrowleft" : "arrowright", "arrowdown"],
            },
          });
          const r = [
            "ck",
            "ck-toolbar",
            n.to("class"),
            n.if("isCompact", "ck-toolbar_compact"),
          ];
          if (this.options.shouldGroupWhenFull && this.options.isFloating) {
            r.push("ck-toolbar_floating");
          }
          this.setTemplate({
            tag: "div",
            attributes: {
              class: r,
              role: "toolbar",
              "aria-label": n.to("ariaLabel"),
              style: { maxWidth: n.to("maxWidth") },
            },
            children: this.children,
            on: { mousedown: pv(this) },
          });
          this._behavior = this.options.shouldGroupWhenFull
            ? new Dv(this)
            : new Ev(this);
        }
        render() {
          super.render();
          for (const t of this.items) {
            this.focusTracker.add(t.element);
          }
          this.items.on("add", (t, e) => {
            this.focusTracker.add(e.element);
          });
          this.items.on("remove", (t, e) => {
            this.focusTracker.remove(e.element);
          });
          this.keystrokes.listenTo(this.element);
          this._behavior.render(this);
        }
        destroy() {
          this._behavior.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
          return super.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        fillFromConfig(t, e, n) {
          const i = bv(t);
          const o = n || i.removeItems;
          const r = this._cleanItemsConfiguration(i.items, e, o)
            .map((t) => {
              if (it(t)) {
                return this._createNestedToolbarDropdown(t, e, o);
              } else if (t === "|") {
                return new gv();
              } else if (t === "-") {
                return new fv();
              }
              return e.create(t);
            })
            .filter((t) => !!t);
          this.items.addMany(r);
        }
        _cleanItemsConfiguration(t, e, n) {
          const i = t.filter((t, i, o) => {
            if (t === "|") {
              return true;
            }
            if (n.indexOf(t) !== -1) {
              return false;
            }
            if (t === "-") {
              if (this.options.shouldGroupWhenFull) {
                B("toolbarview-line-break-ignored-when-grouping-items", o);
                return false;
              }
              return true;
            }
            if (!it(t) && !e.has(t)) {
              B("toolbarview-item-unavailable", { item: t });
              return false;
            }
            return true;
          });
          return this._cleanSeparatorsAndLineBreaks(i);
        }
        _cleanSeparatorsAndLineBreaks(t) {
          const e = (t) => t !== "-" && t !== "|";
          const n = t.length;
          const i = t.findIndex(e);
          if (i === -1) {
            return [];
          }
          const o = n - t.slice().reverse().findIndex(e);
          return t.slice(i, o).filter((t, n, i) => {
            if (e(t)) {
              return true;
            }
            const o = n > 0 && i[n - 1] === t;
            return !o;
          });
        }
        _createNestedToolbarDropdown(t, e, n) {
          let {
            label: i,
            icon: o,
            items: r,
            tooltip: s = true,
            withText: a = false,
          } = t;
          r = this._cleanItemsConfiguration(r, e, n);
          if (!r.length) {
            return null;
          }
          const c = this.locale;
          const l = Uv(c);
          if (!i) {
            B("toolbarview-nested-toolbar-dropdown-missing-label", t);
          }
          l.class = "ck-toolbar__nested-toolbar-dropdown";
          l.buttonView.set({ label: i, tooltip: s, withText: !!a });
          if (o !== false) {
            l.buttonView.icon = vv[o] || o || _v;
          } else {
            l.buttonView.withText = true;
          }
          qv(l, []);
          l.toolbarView.fillFromConfig(r, e, n);
          return l;
        }
      }
      class xv extends pC {
        constructor(t) {
          super(t);
          this.children = this.createCollection();
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-toolbar__items"] },
            children: this.children,
          });
        }
      }
      class Ev {
        constructor(t) {
          const e = t.bindTemplate;
          t.set("isVertical", false);
          t.itemsView.children.bindTo(t.items).using((t) => t);
          t.focusables.bindTo(t.items).using((t) => t);
          t.extendTemplate({
            attributes: { class: [e.if("isVertical", "ck-toolbar_vertical")] },
          });
        }
        render() {}
        destroy() {}
      }
      class Dv {
        constructor(t) {
          this.view = t;
          this.viewChildren = t.children;
          this.viewFocusables = t.focusables;
          this.viewItemsView = t.itemsView;
          this.viewFocusTracker = t.focusTracker;
          this.viewLocale = t.locale;
          this.ungroupedItems = t.createCollection();
          this.groupedItems = t.createCollection();
          this.groupedItemsDropdown = this._createGroupedItemsDropdown();
          this.resizeObserver = null;
          this.cachedPadding = null;
          this.shouldUpdateGroupingOnNextResize = false;
          t.itemsView.children.bindTo(this.ungroupedItems).using((t) => t);
          this.ungroupedItems.on(
            "change",
            this._updateFocusCycleableItems.bind(this)
          );
          t.children.on("change", this._updateFocusCycleableItems.bind(this));
          t.items.on("change", (t, e) => {
            const n = e.index;
            const i = Array.from(e.added);
            for (const t of e.removed) {
              if (n >= this.ungroupedItems.length) {
                this.groupedItems.remove(t);
              } else {
                this.ungroupedItems.remove(t);
              }
            }
            for (let t = n; t < n + i.length; t++) {
              const e = i[t - n];
              if (t > this.ungroupedItems.length) {
                this.groupedItems.add(e, t - this.ungroupedItems.length);
              } else {
                this.ungroupedItems.add(e, t);
              }
            }
            this._updateGrouping();
          });
          t.extendTemplate({ attributes: { class: ["ck-toolbar_grouping"] } });
        }
        render(t) {
          this.viewElement = t.element;
          this._enableGroupingOnResize();
          this._enableGroupingOnMaxWidthChange(t);
        }
        destroy() {
          this.groupedItemsDropdown.destroy();
          this.resizeObserver.destroy();
        }
        _updateGrouping() {
          if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
            return;
          }
          if (!pc(this.viewElement)) {
            this.shouldUpdateGroupingOnNextResize = true;
            return;
          }
          const t = this.groupedItems.length;
          let e;
          while (this._areItemsOverflowing) {
            this._groupLastItem();
            e = true;
          }
          if (!e && this.groupedItems.length) {
            while (this.groupedItems.length && !this._areItemsOverflowing) {
              this._ungroupFirstItem();
            }
            if (this._areItemsOverflowing) {
              this._groupLastItem();
            }
          }
          if (this.groupedItems.length !== t) {
            this.view.fire("groupedItemsUpdate");
          }
        }
        get _areItemsOverflowing() {
          if (!this.ungroupedItems.length) {
            return false;
          }
          const t = this.viewElement;
          const e = this.viewLocale.uiLanguageDirection;
          const n = new sc(t.lastChild);
          const i = new sc(t);
          if (!this.cachedPadding) {
            const n = Xa.window.getComputedStyle(t);
            const i = e === "ltr" ? "paddingRight" : "paddingLeft";
            this.cachedPadding = Number.parseInt(n[i]);
          }
          if (e === "ltr") {
            return n.right > i.right - this.cachedPadding;
          } else {
            return n.left < i.left + this.cachedPadding;
          }
        }
        _enableGroupingOnResize() {
          let t;
          this.resizeObserver = new dc(this.viewElement, (e) => {
            if (
              !t ||
              t !== e.contentRect.width ||
              this.shouldUpdateGroupingOnNextResize
            ) {
              this.shouldUpdateGroupingOnNextResize = false;
              this._updateGrouping();
              t = e.contentRect.width;
            }
          });
          this._updateGrouping();
        }
        _enableGroupingOnMaxWidthChange(t) {
          t.on("change:maxWidth", () => {
            this._updateGrouping();
          });
        }
        _groupLastItem() {
          if (!this.groupedItems.length) {
            this.viewChildren.add(new gv());
            this.viewChildren.add(this.groupedItemsDropdown);
            this.viewFocusTracker.add(this.groupedItemsDropdown.element);
          }
          this.groupedItems.add(
            this.ungroupedItems.remove(this.ungroupedItems.last),
            0
          );
        }
        _ungroupFirstItem() {
          this.ungroupedItems.add(
            this.groupedItems.remove(this.groupedItems.first)
          );
          if (!this.groupedItems.length) {
            this.viewChildren.remove(this.groupedItemsDropdown);
            this.viewChildren.remove(this.viewChildren.last);
            this.viewFocusTracker.remove(this.groupedItemsDropdown.element);
          }
        }
        _createGroupedItemsDropdown() {
          const t = this.viewLocale;
          const e = t.t;
          const n = Uv(t);
          n.class = "ck-toolbar__grouped-dropdown";
          n.panelPosition = t.uiLanguageDirection === "ltr" ? "sw" : "se";
          qv(n, []);
          n.buttonView.set({
            label: e("Show more items"),
            tooltip: true,
            tooltipPosition: t.uiLanguageDirection === "rtl" ? "se" : "sw",
            icon: _v,
          });
          n.toolbarView.items.bindTo(this.groupedItems).using((t) => t);
          return n;
        }
        _updateFocusCycleableItems() {
          this.viewFocusables.clear();
          this.ungroupedItems.map((t) => {
            this.viewFocusables.add(t);
          });
          if (this.groupedItems.length) {
            this.viewFocusables.add(this.groupedItemsDropdown);
          }
        }
      }
      var Sv = n(1162);
      var Tv = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Tv.insert = "head";
      Tv.singleton = true;
      var Iv = Il()(Sv.Z, Tv);
      const Mv = Sv.Z.locals || {};
      class Bv extends pC {
        constructor(t) {
          super(t);
          this.items = this.createCollection();
          this.focusTracker = new al();
          this.keystrokes = new cl();
          this._focusCycler = new hv({
            focusables: this.items,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "arrowup", focusNext: "arrowdown" },
          });
          this.setTemplate({
            tag: "ul",
            attributes: { class: ["ck", "ck-reset", "ck-list"] },
            children: this.items,
          });
        }
        render() {
          super.render();
          for (const t of this.items) {
            this.focusTracker.add(t.element);
          }
          this.items.on("add", (t, e) => {
            this.focusTracker.add(e.element);
          });
          this.items.on("remove", (t, e) => {
            this.focusTracker.remove(e.element);
          });
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
      }
      class Lv extends pC {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set("isVisible", true);
          this.children = this.createCollection();
          this.setTemplate({
            tag: "li",
            attributes: {
              class: [
                "ck",
                "ck-list__item",
                e.if("isVisible", "ck-hidden", (t) => !t),
              ],
            },
            children: this.children,
          });
        }
        focus() {
          this.children.first.focus();
        }
      }
      class Nv extends pC {
        constructor(t) {
          super(t);
          this.setTemplate({
            tag: "li",
            attributes: { class: ["ck", "ck-list__separator"] },
          });
        }
      }
      var zv = n(5075);
      var Pv = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Pv.insert = "head";
      Pv.singleton = true;
      var Rv = Il()(zv.Z, Pv);
      const Ov = zv.Z.locals || {};
      var jv = n(6875);
      var Fv = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Fv.insert = "head";
      Fv.singleton = true;
      var Vv = Il()(jv.Z, Fv);
      const Hv = jv.Z.locals || {};
      function Uv(t, e = tv) {
        const n = new e(t);
        const i = new sv(t);
        const o = new uv(t, n, i);
        n.bind("isEnabled").to(o);
        if (n instanceof rv) {
          n.arrowView.bind("isOn").to(o, "isOpen");
        } else {
          n.bind("isOn").to(o, "isOpen");
        }
        $v(o);
        return o;
      }
      function qv(t, e, n = {}) {
        const i = t.locale;
        const o = i.t;
        const r = (t.toolbarView = new yv(i));
        r.set("ariaLabel", o("Dropdown toolbar"));
        t.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } });
        e.map((t) => r.items.add(t));
        if (n.enableActiveItemFocusOnDropdownOpen) {
          Gv(t, () => r.items.find((t) => t.isOn));
        }
        t.panelView.children.add(r);
        r.items.delegate("execute").to(t);
      }
      function Wv(t, e) {
        const n = t.locale;
        const i = (t.listView = new Bv(n));
        i.items.bindTo(e).using((t) => {
          if (t.type === "separator") {
            return new Nv(n);
          } else if (t.type === "button" || t.type === "switchbutton") {
            const e = new Lv(n);
            let i;
            if (t.type === "button") {
              i = new R_(n);
            } else {
              i = new H_(n);
            }
            i.bind(...Object.keys(t.model)).to(t.model);
            i.delegate("execute").to(e);
            e.children.add(i);
            return e;
          }
          return null;
        });
        t.panelView.children.add(i);
        i.items.delegate("execute").to(t);
        Gv(t, () =>
          i.items.find((t) => {
            if (t instanceof Lv) {
              return t.children.first.isOn;
            }
            return false;
          })
        );
      }
      function Gv(t, e) {
        t.on(
          "change:isOpen",
          () => {
            if (!t.isOpen) {
              return;
            }
            const n = e();
            if (!n) {
              return;
            }
            if (typeof n.focus === "function") {
              n.focus();
            } else {
              B("ui-dropdown-focus-child-on-open-child-missing-focus", {
                view: n,
              });
            }
          },
          { priority: S.low - 10 }
        );
      }
      function $v(t) {
        Kv(t);
        Yv(t);
        Zv(t);
        Qv(t);
        Jv(t);
        Xv(t);
      }
      function Kv(t) {
        t.on("render", () => {
          v_({
            emitter: t,
            activator: () => t.isOpen,
            callback: () => {
              t.isOpen = false;
            },
            contextElements: [t.element],
          });
        });
      }
      function Yv(t) {
        t.on("execute", (e) => {
          if (e.source instanceof H_) {
            return;
          }
          t.isOpen = false;
        });
      }
      function Zv(t) {
        t.focusTracker.on("change:isFocused", (e, n, i) => {
          if (t.isOpen && !i) {
            t.isOpen = false;
          }
        });
      }
      function Qv(t) {
        t.keystrokes.set("arrowdown", (e, n) => {
          if (t.isOpen) {
            t.panelView.focus();
            n();
          }
        });
        t.keystrokes.set("arrowup", (e, n) => {
          if (t.isOpen) {
            t.panelView.focusLast();
            n();
          }
        });
      }
      function Jv(t) {
        t.on("change:isOpen", (e, n, i) => {
          if (i) {
            return;
          }
          if (t.panelView.element.contains(Xa.document.activeElement)) {
            t.buttonView.focus();
          }
        });
      }
      function Xv(t) {
        t.on(
          "change:isOpen",
          (e, n, i) => {
            if (!i) {
              return;
            }
            t.panelView.focus();
          },
          { priority: "low" }
        );
      }
      var ty = n(4547);
      var ey = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      ey.insert = "head";
      ey.singleton = true;
      var ny = Il()(ty.Z, ey);
      const iy = ty.Z.locals || {};
      class oy extends pC {
        constructor(t) {
          super(t);
          this.body = new D_(t);
        }
        render() {
          super.render();
          this.body.attachToDom();
        }
        destroy() {
          this.body.detachFromDom();
          return super.destroy();
        }
      }
      var ry = n(2751);
      var sy = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      sy.insert = "head";
      sy.singleton = true;
      var ay = Il()(ry.Z, sy);
      const cy = ry.Z.locals || {};
      class ly extends pC {
        constructor(t) {
          super(t);
          this.set("text", undefined);
          this.set("for", undefined);
          this.id = \`ck-editor__label_\${E()}\`;
          const e = this.bindTemplate;
          this.setTemplate({
            tag: "label",
            attributes: {
              class: ["ck", "ck-label"],
              id: this.id,
              for: e.to("for"),
            },
            children: [{ text: e.to("text") }],
          });
        }
      }
      class dy extends (null && EditorUIView) {
        constructor(t) {
          super(t);
          this.top = this.createCollection();
          this.main = this.createCollection();
          this._voiceLabelView = this._createVoiceLabel();
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"],
              role: "application",
              dir: t.uiLanguageDirection,
              lang: t.uiLanguage,
              "aria-labelledby": this._voiceLabelView.id,
            },
            children: [
              this._voiceLabelView,
              {
                tag: "div",
                attributes: {
                  class: ["ck", "ck-editor__top", "ck-reset_all"],
                  role: "presentation",
                },
                children: this.top,
              },
              {
                tag: "div",
                attributes: {
                  class: ["ck", "ck-editor__main"],
                  role: "presentation",
                },
                children: this.main,
              },
            ],
          });
        }
        _createVoiceLabel() {
          const t = this.t;
          const e = new LabelView();
          e.text = t("Rich Text Editor");
          e.extendTemplate({ attributes: { class: "ck-voice-label" } });
          return e;
        }
      }
      class uy extends pC {
        constructor(t, e, n) {
          super(t);
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-content",
                "ck-editor__editable",
                "ck-rounded-corners",
              ],
              lang: t.contentLanguage,
              dir: t.contentLanguageDirection,
            },
          });
          this.name = null;
          this.set("isFocused", false);
          this._editableElement = n;
          this._hasExternalElement = !!this._editableElement;
          this._editingView = e;
        }
        render() {
          super.render();
          if (this._hasExternalElement) {
            this.template.apply((this.element = this._editableElement));
          } else {
            this._editableElement = this.element;
          }
          this.on("change:isFocused", () => this._updateIsFocusedClasses());
          this._updateIsFocusedClasses();
        }
        destroy() {
          if (this._hasExternalElement) {
            this.template.revert(this._editableElement);
          }
          super.destroy();
        }
        _updateIsFocusedClasses() {
          const t = this._editingView;
          if (t.isRenderingInProgress) {
            n(this);
          } else {
            e(this);
          }
          function e(e) {
            t.change((n) => {
              const i = t.document.getRoot(e.name);
              n.addClass(e.isFocused ? "ck-focused" : "ck-blurred", i);
              n.removeClass(e.isFocused ? "ck-blurred" : "ck-focused", i);
            });
          }
          function n(i) {
            t.once("change:isRenderingInProgress", (t, o, r) => {
              if (!r) {
                e(i);
              } else {
                n(i);
              }
            });
          }
        }
      }
      class hy extends uy {
        constructor(t, e, n, i = {}) {
          super(t, e, n);
          const o = t.t;
          this.extendTemplate({
            attributes: {
              role: "textbox",
              class: "ck-editor__editable_inline",
            },
          });
          this._generateLabel =
            i.label || (() => o("Editor editing area: %0", this.name));
        }
        render() {
          super.render();
          const t = this._editingView;
          t.change((e) => {
            const n = t.document.getRoot(this.name);
            e.setAttribute("aria-label", this._generateLabel(this), n);
          });
        }
      }
      var my = n(5523);
      var gy = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      gy.insert = "head";
      gy.singleton = true;
      var fy = Il()(my.Z, gy);
      const py = my.Z.locals || {};
      class by extends pC {
        constructor(t, e = {}) {
          super(t);
          const n = this.bindTemplate;
          this.set("label", e.label || "");
          this.set("class", e.class || null);
          this.children = this.createCollection();
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-form__header", n.to("class")] },
            children: this.children,
          });
          const i = new pC(t);
          i.setTemplate({
            tag: "h2",
            attributes: { class: ["ck", "ck-form__header__label"] },
            children: [{ text: n.to("label") }],
          });
          this.children.add(i);
        }
      }
      var ky = n(6985);
      var wy = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      wy.insert = "head";
      wy.singleton = true;
      var Ay = Il()(ky.Z, wy);
      const Cy = ky.Z.locals || {};
      class _y extends pC {
        constructor(t) {
          super(t);
          this.set("value", undefined);
          this.set("id", undefined);
          this.set("placeholder", undefined);
          this.set("isReadOnly", false);
          this.set("hasError", false);
          this.set("ariaDescribedById", undefined);
          this.focusTracker = new al();
          this.bind("isFocused").to(this.focusTracker);
          this.set("isEmpty", true);
          this.set("inputMode", "text");
          const e = this.bindTemplate;
          this.setTemplate({
            tag: "input",
            attributes: {
              class: [
                "ck",
                "ck-input",
                e.if("isFocused", "ck-input_focused"),
                e.if("isEmpty", "ck-input-text_empty"),
                e.if("hasError", "ck-error"),
              ],
              id: e.to("id"),
              placeholder: e.to("placeholder"),
              readonly: e.to("isReadOnly"),
              inputmode: e.to("inputMode"),
              "aria-invalid": e.if("hasError", true),
              "aria-describedby": e.to("ariaDescribedById"),
            },
            on: {
              input: e.to((...t) => {
                this.fire("input", ...t);
                this._updateIsEmpty();
              }),
              change: e.to(this._updateIsEmpty.bind(this)),
            },
          });
        }
        render() {
          super.render();
          this.focusTracker.add(this.element);
          this._setDomElementValue(this.value);
          this._updateIsEmpty();
          this.on("change:value", (t, e, n) => {
            this._setDomElementValue(n);
            this._updateIsEmpty();
          });
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
        }
        select() {
          this.element.select();
        }
        focus() {
          this.element.focus();
        }
        _updateIsEmpty() {
          this.isEmpty = vy(this.element);
        }
        _setDomElementValue(t) {
          this.element.value = !t && t !== 0 ? "" : t;
        }
      }
      function vy(t) {
        return !t.value;
      }
      class yy extends _y {
        constructor(t) {
          super(t);
          this.extendTemplate({
            attributes: { type: "text", class: ["ck-input-text"] },
          });
        }
      }
      class xy extends (null && InputView) {
        constructor(t, { min: e, max: n, step: i } = {}) {
          super(t);
          const o = this.bindTemplate;
          this.set("min", e);
          this.set("max", n);
          this.set("step", i);
          this.extendTemplate({
            attributes: {
              type: "number",
              class: ["ck-input-number"],
              min: o.to("min"),
              max: o.to("max"),
              step: o.to("step"),
            },
          });
        }
      }
      class Ey extends (null && View) {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.setTemplate({
            tag: "iframe",
            attributes: {
              class: ["ck", "ck-reset_all"],
              sandbox: "allow-same-origin allow-scripts",
            },
            on: { load: e.to("loaded") },
          });
        }
        render() {
          return new Promise((t) => {
            this.on("loaded", t);
            return super.render();
          });
        }
      }
      var Dy = n(8111);
      var Sy = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Sy.insert = "head";
      Sy.singleton = true;
      var Ty = Il()(Dy.Z, Sy);
      const Iy = Dy.Z.locals || {};
      class My extends pC {
        constructor(t, e) {
          super(t);
          const n = \`ck-labeled-field-view-\${E()}\`;
          const i = \`ck-labeled-field-view-status-\${E()}\`;
          this.fieldView = e(this, n, i);
          this.set("label", undefined);
          this.set("isEnabled", true);
          this.set("isEmpty", true);
          this.set("isFocused", false);
          this.set("errorText", null);
          this.set("infoText", null);
          this.set("class", undefined);
          this.set("placeholder", undefined);
          this.labelView = this._createLabelView(n);
          this.statusView = this._createStatusView(i);
          this.fieldWrapperChildren = this.createCollection([
            this.fieldView,
            this.labelView,
          ]);
          this.bind("_statusText").to(
            this,
            "errorText",
            this,
            "infoText",
            (t, e) => t || e
          );
          const o = this.bindTemplate;
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-labeled-field-view",
                o.to("class"),
                o.if("isEnabled", "ck-disabled", (t) => !t),
                o.if("isEmpty", "ck-labeled-field-view_empty"),
                o.if("isFocused", "ck-labeled-field-view_focused"),
                o.if("placeholder", "ck-labeled-field-view_placeholder"),
                o.if("errorText", "ck-error"),
              ],
            },
            children: [
              {
                tag: "div",
                attributes: {
                  class: ["ck", "ck-labeled-field-view__input-wrapper"],
                },
                children: this.fieldWrapperChildren,
              },
              this.statusView,
            ],
          });
        }
        _createLabelView(t) {
          const e = new ly(this.locale);
          e.for = t;
          e.bind("text").to(this, "label");
          return e;
        }
        _createStatusView(t) {
          const e = new pC(this.locale);
          const n = this.bindTemplate;
          e.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-labeled-field-view__status",
                n.if("errorText", "ck-labeled-field-view__status_error"),
                n.if("_statusText", "ck-hidden", (t) => !t),
              ],
              id: t,
              role: n.if("errorText", "alert"),
            },
            children: [{ text: n.to("_statusText") }],
          });
          return e;
        }
        focus() {
          this.fieldView.focus();
        }
      }
      function By(t, e, n) {
        const i = new yy(t.locale);
        i.set({ id: e, ariaDescribedById: n });
        i.bind("isReadOnly").to(t, "isEnabled", (t) => !t);
        i.bind("hasError").to(t, "errorText", (t) => !!t);
        i.on("input", () => {
          t.errorText = null;
        });
        t.bind("isEmpty", "isFocused", "placeholder").to(i);
        return i;
      }
      function Ly(t, e, n) {
        const i = new InputNumberView(t.locale);
        i.set({ id: e, ariaDescribedById: n, inputMode: "numeric" });
        i.bind("isReadOnly").to(t, "isEnabled", (t) => !t);
        i.bind("hasError").to(t, "errorText", (t) => !!t);
        i.on("input", () => {
          t.errorText = null;
        });
        t.bind("isEmpty", "isFocused", "placeholder").to(i);
        return i;
      }
      function Ny(t, e, n) {
        const i = Uv(t.locale);
        i.set({ id: e, ariaDescribedById: n });
        i.bind("isEnabled").to(t);
        return i;
      }
      class zy extends Sl {
        static get pluginName() {
          return "Notification";
        }
        init() {
          this.on(
            "show:warning",
            (t, e) => {
              window.alert(e.message);
            },
            { priority: "lowest" }
          );
        }
        showSuccess(t, e = {}) {
          this._showNotification({
            message: t,
            type: "success",
            namespace: e.namespace,
            title: e.title,
          });
        }
        showInfo(t, e = {}) {
          this._showNotification({
            message: t,
            type: "info",
            namespace: e.namespace,
            title: e.title,
          });
        }
        showWarning(t, e = {}) {
          this._showNotification({
            message: t,
            type: "warning",
            namespace: e.namespace,
            title: e.title,
          });
        }
        _showNotification(t) {
          const e = t.namespace
            ? \`show:\${t.type}:\${t.namespace}\`
            : \`show:\${t.type}\`;
          this.fire(e, {
            message: t.message,
            type: t.type,
            title: t.title || "",
          });
        }
      }
      class Py extends dt() {
        constructor(t, e) {
          super();
          if (e) {
            Sm(this, e);
          }
          if (t) {
            this.set(t);
          }
        }
      }
      const Ry =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';
      const Oy =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>';
      var jy = n(1757);
      var Fy = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Fy.insert = "head";
      Fy.singleton = true;
      var Vy = Il()(jy.Z, Fy);
      const Hy = jy.Z.locals || {};
      var Uy = n(3553);
      var qy = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      qy.insert = "head";
      qy.singleton = true;
      var Wy = Il()(Uy.Z, qy);
      const Gy = Uy.Z.locals || {};
      const $y = hc("px");
      class Ky extends Cl {
        static get pluginName() {
          return "ContextualBalloon";
        }
        constructor(t) {
          super(t);
          this.positionLimiter = () => {
            const t = this.editor.editing.view;
            const e = t.document;
            const n = e.selection.editableElement;
            if (n) {
              return t.domConverter.mapViewToDom(n.root);
            }
            return null;
          };
          this.set("visibleView", null);
          this.view = new vC(t.locale);
          t.ui.view.body.add(this.view);
          t.ui.focusTracker.add(this.view.element);
          this._viewToStack = new Map();
          this._idToStack = new Map();
          this.set("_numberOfStacks", 0);
          this.set("_singleViewMode", false);
          this._rotatorView = this._createRotatorView();
          this._fakePanelsView = this._createFakePanelsView();
        }
        destroy() {
          super.destroy();
          this.view.destroy();
          this._rotatorView.destroy();
          this._fakePanelsView.destroy();
        }
        hasView(t) {
          return Array.from(this._viewToStack.keys()).includes(t);
        }
        add(t) {
          if (this.hasView(t.view)) {
            throw new M("contextualballoon-add-view-exist", [this, t]);
          }
          const e = t.stackId || "main";
          if (!this._idToStack.has(e)) {
            this._idToStack.set(e, new Map([[t.view, t]]));
            this._viewToStack.set(t.view, this._idToStack.get(e));
            this._numberOfStacks = this._idToStack.size;
            if (!this._visibleStack || t.singleViewMode) {
              this.showStack(e);
            }
            return;
          }
          const n = this._idToStack.get(e);
          if (t.singleViewMode) {
            this.showStack(e);
          }
          n.set(t.view, t);
          this._viewToStack.set(t.view, n);
          if (n === this._visibleStack) {
            this._showView(t);
          }
        }
        remove(t) {
          if (!this.hasView(t)) {
            throw new M("contextualballoon-remove-view-not-exist", [this, t]);
          }
          const e = this._viewToStack.get(t);
          if (this._singleViewMode && this.visibleView === t) {
            this._singleViewMode = false;
          }
          if (this.visibleView === t) {
            if (e.size === 1) {
              if (this._idToStack.size > 1) {
                this._showNextStack();
              } else {
                this.view.hide();
                this.visibleView = null;
                this._rotatorView.hideView();
              }
            } else {
              this._showView(Array.from(e.values())[e.size - 2]);
            }
          }
          if (e.size === 1) {
            this._idToStack.delete(this._getStackId(e));
            this._numberOfStacks = this._idToStack.size;
          } else {
            e.delete(t);
          }
          this._viewToStack.delete(t);
        }
        updatePosition(t) {
          if (t) {
            this._visibleStack.get(this.visibleView).position = t;
          }
          this.view.pin(this._getBalloonPosition());
          this._fakePanelsView.updatePosition();
        }
        showStack(t) {
          this.visibleStack = t;
          const e = this._idToStack.get(t);
          if (!e) {
            throw new M("contextualballoon-showstack-stack-not-exist", this);
          }
          if (this._visibleStack === e) {
            return;
          }
          this._showView(Array.from(e.values()).pop());
        }
        get _visibleStack() {
          return this._viewToStack.get(this.visibleView);
        }
        _getStackId(t) {
          const e = Array.from(this._idToStack.entries()).find(
            (e) => e[1] === t
          );
          return e[0];
        }
        _showNextStack() {
          const t = Array.from(this._idToStack.values());
          let e = t.indexOf(this._visibleStack) + 1;
          if (!t[e]) {
            e = 0;
          }
          this.showStack(this._getStackId(t[e]));
        }
        _showPrevStack() {
          const t = Array.from(this._idToStack.values());
          let e = t.indexOf(this._visibleStack) - 1;
          if (!t[e]) {
            e = t.length - 1;
          }
          this.showStack(this._getStackId(t[e]));
        }
        _createRotatorView() {
          const t = new Yy(this.editor.locale);
          const e = this.editor.locale.t;
          this.view.content.add(t);
          t.bind("isNavigationVisible").to(
            this,
            "_numberOfStacks",
            this,
            "_singleViewMode",
            (t, e) => !e && t > 1
          );
          t.on("change:isNavigationVisible", () => this.updatePosition(), {
            priority: "low",
          });
          t.bind("counter").to(
            this,
            "visibleView",
            this,
            "_numberOfStacks",
            (t, n) => {
              if (n < 2) {
                return "";
              }
              const i =
                Array.from(this._idToStack.values()).indexOf(
                  this._visibleStack
                ) + 1;
              return e("%0 of %1", [i, n]);
            }
          );
          t.buttonNextView.on("execute", () => {
            if (t.focusTracker.isFocused) {
              this.editor.editing.view.focus();
            }
            this._showNextStack();
          });
          t.buttonPrevView.on("execute", () => {
            if (t.focusTracker.isFocused) {
              this.editor.editing.view.focus();
            }
            this._showPrevStack();
          });
          return t;
        }
        _createFakePanelsView() {
          const t = new Zy(this.editor.locale, this.view);
          t.bind("numberOfPanels").to(
            this,
            "_numberOfStacks",
            this,
            "_singleViewMode",
            (t, e) => {
              const n = !e && t >= 2;
              return n ? Math.min(t - 1, 2) : 0;
            }
          );
          t.listenTo(this.view, "change:top", () => t.updatePosition());
          t.listenTo(this.view, "change:left", () => t.updatePosition());
          this.editor.ui.view.body.add(t);
          return t;
        }
        _showView({
          view: t,
          balloonClassName: e = "",
          withArrow: n = true,
          singleViewMode: i = false,
        }) {
          this.view.class = e;
          this.view.withArrow = n;
          this._rotatorView.showView(t);
          this.visibleView = t;
          this.view.pin(this._getBalloonPosition());
          this._fakePanelsView.updatePosition();
          if (i) {
            this._singleViewMode = true;
          }
        }
        _getBalloonPosition() {
          let t = Array.from(this._visibleStack.values()).pop().position;
          if (t) {
            if (!t.limiter) {
              t = Object.assign({}, t, { limiter: this.positionLimiter });
            }
            t = Object.assign({}, t, {
              viewportOffsetConfig: this.editor.ui.viewportOffset,
            });
          }
          return t;
        }
      }
      class Yy extends pC {
        constructor(t) {
          super(t);
          const e = t.t;
          const n = this.bindTemplate;
          this.set("isNavigationVisible", true);
          this.focusTracker = new al();
          this.buttonPrevView = this._createButtonView(e("Previous"), Ry);
          this.buttonNextView = this._createButtonView(e("Next"), Oy);
          this.content = this.createCollection();
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck", "ck-balloon-rotator"],
              "z-index": "-1",
            },
            children: [
              {
                tag: "div",
                attributes: {
                  class: [
                    "ck-balloon-rotator__navigation",
                    n.to("isNavigationVisible", (t) => (t ? "" : "ck-hidden")),
                  ],
                },
                children: [
                  this.buttonPrevView,
                  {
                    tag: "span",
                    attributes: { class: ["ck-balloon-rotator__counter"] },
                    children: [{ text: n.to("counter") }],
                  },
                  this.buttonNextView,
                ],
              },
              {
                tag: "div",
                attributes: { class: "ck-balloon-rotator__content" },
                children: this.content,
              },
            ],
          });
        }
        render() {
          super.render();
          this.focusTracker.add(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
        }
        showView(t) {
          this.hideView();
          this.content.add(t);
        }
        hideView() {
          this.content.clear();
        }
        _createButtonView(t, e) {
          const n = new R_(this.locale);
          n.set({ label: t, icon: e, tooltip: true });
          return n;
        }
      }
      class Zy extends pC {
        constructor(t, e) {
          super(t);
          const n = this.bindTemplate;
          this.set("top", 0);
          this.set("left", 0);
          this.set("height", 0);
          this.set("width", 0);
          this.set("numberOfPanels", 0);
          this.content = this.createCollection();
          this._balloonPanelView = e;
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck-fake-panel",
                n.to("numberOfPanels", (t) => (t ? "" : "ck-hidden")),
              ],
              style: {
                top: n.to("top", $y),
                left: n.to("left", $y),
                width: n.to("width", $y),
                height: n.to("height", $y),
              },
            },
            children: this.content,
          });
          this.on("change:numberOfPanels", (t, e, n, i) => {
            if (n > i) {
              this._addPanels(n - i);
            } else {
              this._removePanels(i - n);
            }
            this.updatePosition();
          });
        }
        _addPanels(t) {
          while (t--) {
            const t = new pC();
            t.setTemplate({ tag: "div" });
            this.content.add(t);
            this.registerChild(t);
          }
        }
        _removePanels(t) {
          while (t--) {
            const t = this.content.last;
            this.content.remove(t);
            this.deregisterChild(t);
            t.destroy();
          }
        }
        updatePosition() {
          if (this.numberOfPanels) {
            const { top: t, left: e } = this._balloonPanelView;
            const { width: n, height: i } = new sc(
              this._balloonPanelView.element
            );
            Object.assign(this, { top: t, left: e, width: n, height: i });
          }
        }
      }
      var Qy = n(3609);
      var Jy = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Jy.insert = "head";
      Jy.singleton = true;
      var Xy = Il()(Qy.Z, Jy);
      const tx = Qy.Z.locals || {};
      const ex = hc("px");
      class nx extends (null && View) {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set("isActive", false);
          this.set("isSticky", false);
          this.set("limiterElement", null);
          this.set("limiterBottomOffset", 50);
          this.set("viewportTopOffset", 0);
          this.set("_marginLeft", null);
          this.set("_isStickyToTheLimiter", false);
          this.set("_hasViewportTopOffset", false);
          this.content = this.createCollection();
          this._contentPanelPlaceholder = new Template({
            tag: "div",
            attributes: {
              class: ["ck", "ck-sticky-panel__placeholder"],
              style: {
                display: e.to("isSticky", (t) => (t ? "block" : "none")),
                height: e.to("isSticky", (t) =>
                  t ? ex(this._panelRect.height) : null
                ),
              },
            },
          }).render();
          this._contentPanel = new Template({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-sticky-panel__content",
                e.if("isSticky", "ck-sticky-panel__content_sticky"),
                e.if(
                  "_isStickyToTheLimiter",
                  "ck-sticky-panel__content_sticky_bottom-limit"
                ),
              ],
              style: {
                width: e.to("isSticky", (t) =>
                  t
                    ? ex(
                        this._contentPanelPlaceholder.getBoundingClientRect()
                          .width
                      )
                    : null
                ),
                top: e.to("_hasViewportTopOffset", (t) =>
                  t ? ex(this.viewportTopOffset) : null
                ),
                bottom: e.to("_isStickyToTheLimiter", (t) =>
                  t ? ex(this.limiterBottomOffset) : null
                ),
                marginLeft: e.to("_marginLeft"),
              },
            },
            children: this.content,
          }).render();
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-sticky-panel"] },
            children: [this._contentPanelPlaceholder, this._contentPanel],
          });
        }
        render() {
          super.render();
          this._checkIfShouldBeSticky();
          this.listenTo(global.window, "scroll", () => {
            this._checkIfShouldBeSticky();
          });
          this.listenTo(this, "change:isActive", () => {
            this._checkIfShouldBeSticky();
          });
        }
        _checkIfShouldBeSticky() {
          const t = (this._panelRect =
            this._contentPanel.getBoundingClientRect());
          let e;
          if (!this.limiterElement) {
            this.isSticky = false;
          } else {
            e = this._limiterRect = this.limiterElement.getBoundingClientRect();
            this.isSticky =
              this.isActive &&
              e.top < this.viewportTopOffset &&
              this._panelRect.height + this.limiterBottomOffset < e.height;
          }
          if (this.isSticky) {
            this._isStickyToTheLimiter =
              e.bottom <
              t.height + this.limiterBottomOffset + this.viewportTopOffset;
            this._hasViewportTopOffset =
              !this._isStickyToTheLimiter && !!this.viewportTopOffset;
            this._marginLeft = this._isStickyToTheLimiter
              ? null
              : ex(-global.window.scrollX);
          } else {
            this._isStickyToTheLimiter = false;
            this._hasViewportTopOffset = false;
            this._marginLeft = null;
          }
        }
      }
      const ix = hc("px");
      class ox extends Cl {
        static get pluginName() {
          return "BalloonToolbar";
        }
        static get requires() {
          return [Ky];
        }
        constructor(t) {
          super(t);
          this._balloonConfig = bv(t.config.get("balloonToolbar"));
          this.toolbarView = this._createToolbarView();
          this.focusTracker = new al();
          t.ui.once("ready", () => {
            this.focusTracker.add(t.ui.getEditableElement());
            this.focusTracker.add(this.toolbarView.element);
          });
          t.ui.addToolbar(this.toolbarView, {
            beforeFocus: () => this.show(true),
            afterBlur: () => this.hide(),
            isContextual: true,
          });
          this._resizeObserver = null;
          this._balloon = t.plugins.get(Ky);
          this._fireSelectionChangeDebounced = Qm(
            () => this.fire("_selectionChangeDebounced"),
            200
          );
          this.decorate("show");
        }
        init() {
          const t = this.editor;
          const e = t.model.document.selection;
          this.listenTo(this.focusTracker, "change:isFocused", (t, e, n) => {
            const i = this._balloon.visibleView === this.toolbarView;
            if (!n && i) {
              this.hide();
            } else if (n) {
              this.show();
            }
          });
          this.listenTo(e, "change:range", (t, n) => {
            if (n.directChange || e.isCollapsed) {
              this.hide();
            }
            this._fireSelectionChangeDebounced();
          });
          this.listenTo(this, "_selectionChangeDebounced", () => {
            if (this.editor.editing.view.document.isFocused) {
              this.show();
            }
          });
          if (!this._balloonConfig.shouldNotGroupWhenFull) {
            this.listenTo(t, "ready", () => {
              const e = t.ui.view.editable.element;
              this._resizeObserver = new dc(e, () => {
                this.toolbarView.maxWidth = ix(new sc(e).width * 0.9);
              });
            });
          }
          this.listenTo(this.toolbarView, "groupedItemsUpdate", () => {
            this._updatePosition();
          });
        }
        afterInit() {
          const t = this.editor.ui.componentFactory;
          this.toolbarView.fillFromConfig(this._balloonConfig, t);
        }
        _createToolbarView() {
          const t = this.editor.locale.t;
          const e = !this._balloonConfig.shouldNotGroupWhenFull;
          const n = new yv(this.editor.locale, {
            shouldGroupWhenFull: e,
            isFloating: true,
          });
          n.ariaLabel = t("Editor contextual toolbar");
          n.render();
          return n;
        }
        show(t = false) {
          const e = this.editor;
          const n = e.model.document.selection;
          const i = e.model.schema;
          if (this._balloon.hasView(this.toolbarView)) {
            return;
          }
          if (n.isCollapsed && !t) {
            return;
          }
          if (rx(n, i)) {
            return;
          }
          if (
            Array.from(this.toolbarView.items).every(
              (t) => t.isEnabled !== undefined && !t.isEnabled
            )
          ) {
            return;
          }
          this.listenTo(this.editor.ui, "update", () => {
            this._updatePosition();
          });
          this._balloon.add({
            view: this.toolbarView,
            position: this._getBalloonPositionData(),
            balloonClassName: "ck-toolbar-container",
          });
        }
        hide() {
          if (this._balloon.hasView(this.toolbarView)) {
            this.stopListening(this.editor.ui, "update");
            this._balloon.remove(this.toolbarView);
          }
        }
        _getBalloonPositionData() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          const i = n.selection;
          const o = n.selection.isBackward;
          return {
            target: () => {
              const t = o ? i.getFirstRange() : i.getLastRange();
              const n = sc.getDomRangeRects(e.domConverter.viewRangeToDom(t));
              if (o) {
                return n[0];
              } else {
                if (n.length > 1 && n[n.length - 1].width === 0) {
                  n.pop();
                }
                return n[n.length - 1];
              }
            },
            positions: this._getBalloonPositions(o),
          };
        }
        _updatePosition() {
          this._balloon.updatePosition(this._getBalloonPositionData());
        }
        destroy() {
          super.destroy();
          this.stopListening();
          this._fireSelectionChangeDebounced.cancel();
          this.toolbarView.destroy();
          this.focusTracker.destroy();
          if (this._resizeObserver) {
            this._resizeObserver.destroy();
          }
        }
        _getBalloonPositions(t) {
          const e = r.isSafari && r.isiOS;
          const n = e
            ? xC({
                heightOffset: Math.max(
                  vC.arrowHeightOffset,
                  Math.round(20 / Xa.window.visualViewport.scale)
                ),
              })
            : vC.defaultPositions;
          return t
            ? [
                n.northWestArrowSouth,
                n.northWestArrowSouthWest,
                n.northWestArrowSouthEast,
                n.northWestArrowSouthMiddleEast,
                n.northWestArrowSouthMiddleWest,
                n.southWestArrowNorth,
                n.southWestArrowNorthWest,
                n.southWestArrowNorthEast,
                n.southWestArrowNorthMiddleWest,
                n.southWestArrowNorthMiddleEast,
              ]
            : [
                n.southEastArrowNorth,
                n.southEastArrowNorthEast,
                n.southEastArrowNorthWest,
                n.southEastArrowNorthMiddleEast,
                n.southEastArrowNorthMiddleWest,
                n.northEastArrowSouth,
                n.northEastArrowSouthEast,
                n.northEastArrowSouthWest,
                n.northEastArrowSouthMiddleEast,
                n.northEastArrowSouthMiddleWest,
              ];
        }
      }
      function rx(t, e) {
        if (t.rangeCount === 1) {
          return false;
        }
        return [...t.getRanges()].every((t) => {
          const n = t.getContainedElement();
          return n && e.isSelectable(n);
        });
      }
      var sx = n(6706);
      var ax = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      ax.insert = "head";
      ax.singleton = true;
      var cx = Il()(sx.Z, ax);
      const lx = sx.Z.locals || {};
      const dx = hc("px");
      class ux extends R_ {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.isVisible = false;
          this.isToggleable = true;
          this.set("top", 0);
          this.set("left", 0);
          this.extendTemplate({
            attributes: {
              class: "ck-block-toolbar-button",
              style: {
                top: e.to("top", (t) => dx(t)),
                left: e.to("left", (t) => dx(t)),
              },
            },
          });
        }
      }
      const hx = hc("px");
      const { pilcrow: mx } = __;
      class gx extends Cl {
        static get pluginName() {
          return "BlockToolbar";
        }
        constructor(t) {
          super(t);
          this._blockToolbarConfig = bv(this.editor.config.get("blockToolbar"));
          this.toolbarView = this._createToolbarView();
          this.panelView = this._createPanelView();
          this.buttonView = this._createButtonView();
          this._resizeObserver = null;
          v_({
            emitter: this.panelView,
            contextElements: [this.panelView.element, this.buttonView.element],
            activator: () => this.panelView.isVisible,
            callback: () => this._hidePanel(),
          });
        }
        init() {
          const t = this.editor;
          this.listenTo(t.model.document.selection, "change:range", (t, e) => {
            if (e.directChange) {
              this._hidePanel();
            }
          });
          this.listenTo(t.ui, "update", () => this._updateButton());
          this.listenTo(t, "change:isReadOnly", () => this._updateButton(), {
            priority: "low",
          });
          this.listenTo(t.ui.focusTracker, "change:isFocused", () =>
            this._updateButton()
          );
          this.listenTo(this.buttonView, "change:isVisible", (t, e, n) => {
            if (n) {
              this.buttonView.listenTo(window, "resize", () =>
                this._updateButton()
              );
            } else {
              this.buttonView.stopListening(window, "resize");
              this._hidePanel();
            }
          });
          t.ui.addToolbar(this.toolbarView, {
            beforeFocus: () => this._showPanel(),
            afterBlur: () => this._hidePanel(),
          });
        }
        afterInit() {
          const t = this.editor.ui.componentFactory;
          const e = this._blockToolbarConfig;
          this.toolbarView.fillFromConfig(e, t);
          for (const t of this.toolbarView.items) {
            t.on("execute", () => this._hidePanel(true), { priority: "high" });
          }
          if (!e.shouldNotGroupWhenFull) {
            this.listenTo(this.editor, "ready", () => {
              const t = this.editor.ui.view.editable.element;
              this._resizeObserver = new dc(t, () => {
                this.toolbarView.maxWidth = this._getToolbarMaxWidth();
              });
            });
          }
        }
        destroy() {
          super.destroy();
          this.panelView.destroy();
          this.buttonView.destroy();
          this.toolbarView.destroy();
          if (this._resizeObserver) {
            this._resizeObserver.destroy();
          }
        }
        _createToolbarView() {
          const t = this.editor.locale.t;
          const e = !this._blockToolbarConfig.shouldNotGroupWhenFull;
          const n = new yv(this.editor.locale, {
            shouldGroupWhenFull: e,
            isFloating: true,
          });
          n.ariaLabel = t("Editor block content toolbar");
          n.focusTracker.on("change:isFocused", (t, e, n) => {
            if (!n) {
              this._hidePanel();
            }
          });
          return n;
        }
        _createPanelView() {
          const t = this.editor;
          const e = new vC(t.locale);
          e.content.add(this.toolbarView);
          e.class = "ck-toolbar-container";
          t.ui.view.body.add(e);
          t.ui.focusTracker.add(e.element);
          this.toolbarView.keystrokes.set("Esc", (t, e) => {
            this._hidePanel(true);
            e();
          });
          return e;
        }
        _createButtonView() {
          const t = this.editor;
          const e = t.t;
          const n = new ux(t.locale);
          const i = n.bindTemplate;
          n.set({ label: e("Edit block"), icon: mx, withText: false });
          n.extendTemplate({
            on: {
              mousedown: i.to((t) => {
                if (r.isSafari && this.panelView.isVisible) {
                  this.toolbarView.focus();
                }
                t.preventDefault();
              }),
            },
          });
          n.bind("isOn").to(this.panelView, "isVisible");
          n.bind("tooltip").to(this.panelView, "isVisible", (t) => !t);
          this.listenTo(n, "execute", () => {
            if (!this.panelView.isVisible) {
              this._showPanel();
            } else {
              this._hidePanel(true);
            }
          });
          t.ui.view.body.add(n);
          t.ui.focusTracker.add(n.element);
          return n;
        }
        _updateButton() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          if (!t.ui.focusTracker.isFocused) {
            this._hideButton();
            return;
          }
          if (t.isReadOnly) {
            this._hideButton();
            return;
          }
          const i = Array.from(e.document.selection.getSelectedBlocks())[0];
          if (
            !i ||
            Array.from(this.toolbarView.items).every((t) => !t.isEnabled)
          ) {
            this._hideButton();
            return;
          }
          const o = n.domConverter.mapViewToDom(
            t.editing.mapper.toViewElement(i)
          );
          this.buttonView.isVisible = true;
          this._attachButtonToElement(o);
          if (this.panelView.isVisible) {
            this._showPanel();
          }
        }
        _hideButton() {
          this.buttonView.isVisible = false;
        }
        _showPanel() {
          if (!this.buttonView.isVisible) {
            return;
          }
          const t = this.panelView.isVisible;
          this.panelView.show();
          this.toolbarView.maxWidth = this._getToolbarMaxWidth();
          this.panelView.pin({
            target: this.buttonView.element,
            limiter: this.editor.ui.getEditableElement(),
          });
          if (!t) {
            this.toolbarView.items.get(0).focus();
          }
        }
        _hidePanel(t) {
          this.panelView.isVisible = false;
          if (t) {
            this.editor.editing.view.focus();
          }
        }
        _attachButtonToElement(t) {
          const e = window.getComputedStyle(t);
          const n = new sc(this.editor.ui.getEditableElement());
          const i = parseInt(e.paddingTop, 10);
          const o =
            parseInt(e.lineHeight, 10) || parseInt(e.fontSize, 10) * 1.2;
          const r = kc({
            element: this.buttonView.element,
            target: t,
            positions: [
              (t, e) => {
                let r;
                if (this.editor.locale.uiLanguageDirection === "ltr") {
                  r = n.left - e.width;
                } else {
                  r = n.right;
                }
                return { top: t.top + i + (o - e.height) / 2, left: r };
              },
            ],
          });
          this.buttonView.top = r.top;
          this.buttonView.left = r.left;
        }
        _getToolbarMaxWidth() {
          const t = this.editor.ui.view.editable.element;
          const e = new sc(t);
          const n = new sc(this.buttonView.element);
          const i = this.editor.locale.uiLanguageDirection === "rtl";
          const o = i ? n.left - e.right + n.width : e.left - n.left;
          return hx(e.width + o);
        }
      }
      class fx extends NC {
        constructor(t, e) {
          super(t);
          this.view = e;
        }
        get element() {
          return this.view.editable.element;
        }
        init() {
          const t = this.editor;
          const e = this.view;
          const n = t.editing.view;
          const i = e.editable;
          const o = n.document.getRoot();
          i.name = o.rootName;
          e.render();
          const r = i.element;
          this.setEditableElement(i.name, r);
          i.bind("isFocused").to(this.focusTracker);
          n.attachDomRoot(r);
          this._initPlaceholder();
          this.fire("ready");
        }
        destroy() {
          super.destroy();
          const t = this.view;
          const e = this.editor.editing.view;
          e.detachDomRoot(t.editable.name);
          t.destroy();
        }
        _initPlaceholder() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document.getRoot();
          const i = t.sourceElement;
          const o =
            t.config.get("placeholder") ||
            (i &&
              i.tagName.toLowerCase() === "textarea" &&
              i.getAttribute("placeholder"));
          if (o) {
            Pl({
              view: e,
              element: n,
              text: o,
              isDirectHost: false,
              keepOnFocus: true,
            });
          }
        }
      }
      class px extends oy {
        constructor(t, e, n) {
          super(t);
          const i = t.t;
          this.editable = new hy(t, e, n, {
            label: (t) => i("Rich Text Editor. Editing area: %0", t.name),
          });
        }
        render() {
          super.render();
          this.registerChild(this.editable);
        }
      }
      class bx extends OC(jC(LA)) {
        constructor(t, e = {}) {
          if (!wx(t) && e.initialData !== undefined) {
            throw new M("editor-create-initial-data", null);
          }
          super(e);
          if (this.config.get("initialData") === undefined) {
            this.config.set("initialData", kx(t));
          }
          if (wx(t)) {
            this.sourceElement = t;
            FC(this);
          }
          const n = this.config.get("plugins");
          n.push(ox);
          this.config.set("plugins", n);
          this.config.define("balloonToolbar", this.config.get("toolbar"));
          this.model.document.createRoot();
          const i = new px(this.locale, this.editing.view, this.sourceElement);
          this.ui = new fx(this, i);
          PC(this);
        }
        destroy() {
          const t = this.getData();
          this.ui.destroy();
          return super.destroy().then(() => {
            if (this.sourceElement) {
              this.updateSourceElement(t);
            }
          });
        }
        static create(t, e = {}) {
          return new Promise((n) => {
            if (wx(t) && t.tagName === "TEXTAREA") {
              throw new M("editor-wrong-element", null);
            }
            const i = new this(t, e);
            n(
              i
                .initPlugins()
                .then(() => i.ui.init())
                .then(() => i.data.init(i.config.get("initialData")))
                .then(() => i.fire("ready"))
                .then(() => i)
            );
          });
        }
      }
      function kx(t) {
        return wx(t) ? ec(t) : t;
      }
      function wx(t) {
        return Va(t);
      }
      const Ax = ["left", "right", "center", "justify"];
      function Cx(t) {
        return Ax.includes(t);
      }
      function _x(t, e) {
        if (e.contentLanguageDirection == "rtl") {
          return t === "right";
        } else {
          return t === "left";
        }
      }
      function vx(t) {
        const e = t
          .map((t) => {
            let e;
            if (typeof t == "string") {
              e = { name: t };
            } else {
              e = t;
            }
            return e;
          })
          .filter((t) => {
            const e = !!Ax.includes(t.name);
            if (!e) {
              B("alignment-config-name-not-recognized", { option: t });
            }
            return e;
          });
        const n = e.filter((t) => !!t.className).length;
        if (n && n < e.length) {
          throw new M("alignment-config-classnames-are-missing", {
            configuredOptions: t,
          });
        }
        e.forEach((e, n, i) => {
          const o = i.slice(n + 1);
          const r = o.some((t) => t.name == e.name);
          if (r) {
            throw new M("alignment-config-name-already-defined", {
              option: e,
              configuredOptions: t,
            });
          }
          if (e.className) {
            const n = o.some((t) => t.className == e.className);
            if (n) {
              throw new M("alignment-config-classname-already-defined", {
                option: e,
                configuredOptions: t,
              });
            }
          }
        });
        return e;
      }
      const yx = "alignment";
      class xx extends vl {
        refresh() {
          const t = this.editor;
          const e = t.locale;
          const n = sl(
            this.editor.model.document.selection.getSelectedBlocks()
          );
          this.isEnabled = !!n && this._canBeAligned(n);
          if (this.isEnabled && n.hasAttribute("alignment")) {
            this.value = n.getAttribute("alignment");
          } else {
            this.value =
              e.contentLanguageDirection === "rtl" ? "right" : "left";
          }
        }
        execute(t = {}) {
          const e = this.editor;
          const n = e.locale;
          const i = e.model;
          const o = i.document;
          const r = t.value;
          i.change((t) => {
            const e = Array.from(o.selection.getSelectedBlocks()).filter((t) =>
              this._canBeAligned(t)
            );
            const i = e[0].getAttribute("alignment");
            const s = _x(r, n) || i === r || !r;
            if (s) {
              Ex(e, t);
            } else {
              Dx(e, t, r);
            }
          });
        }
        _canBeAligned(t) {
          return this.editor.model.schema.checkAttribute(t, yx);
        }
      }
      function Ex(t, e) {
        for (const n of t) {
          e.removeAttribute(yx, n);
        }
      }
      function Dx(t, e, n) {
        for (const i of t) {
          e.setAttribute(yx, n, i);
        }
      }
      class Sx extends Cl {
        static get pluginName() {
          return "AlignmentEditing";
        }
        constructor(t) {
          super(t);
          t.config.define("alignment", {
            options: [...Ax.map((t) => ({ name: t }))],
          });
        }
        init() {
          const t = this.editor;
          const e = t.locale;
          const n = t.model.schema;
          const i = vx(t.config.get("alignment.options"));
          const o = i.filter((t) => Cx(t.name) && !_x(t.name, e));
          const r = o.some((t) => !!t.className);
          n.extend("$block", { allowAttributes: "alignment" });
          t.model.schema.setAttributeProperties("alignment", {
            isFormatting: true,
          });
          if (r) {
            t.conversion.attributeToAttribute(Bx(o));
          } else {
            t.conversion.for("downcast").attributeToAttribute(Tx(o));
          }
          const s = Ix(o);
          for (const e of s) {
            t.conversion.for("upcast").attributeToAttribute(e);
          }
          const a = Mx(o);
          for (const e of a) {
            t.conversion.for("upcast").attributeToAttribute(e);
          }
          t.commands.add("alignment", new xx(t));
        }
      }
      function Tx(t) {
        const e = {
          model: { key: "alignment", values: t.map((t) => t.name) },
          view: {},
        };
        for (const { name: n } of t) {
          e.view[n] = { key: "style", value: { "text-align": n } };
        }
        return e;
      }
      function Ix(t) {
        const e = [];
        for (const { name: n } of t) {
          e.push({
            view: { key: "style", value: { "text-align": n } },
            model: { key: "alignment", value: n },
          });
        }
        return e;
      }
      function Mx(t) {
        const e = [];
        for (const { name: n } of t) {
          e.push({
            view: { key: "align", value: n },
            model: { key: "alignment", value: n },
          });
        }
        return e;
      }
      function Bx(t) {
        const e = {
          model: { key: "alignment", values: t.map((t) => t.name) },
          view: {},
        };
        for (const n of t) {
          e.view[n.name] = { key: "class", value: n.className };
        }
        return e;
      }
      const Lx = new Map([
        ["left", __.alignLeft],
        ["right", __.alignRight],
        ["center", __.alignCenter],
        ["justify", __.alignJustify],
      ]);
      class Nx extends Cl {
        get localizedOptionTitles() {
          const t = this.editor.t;
          return {
            left: t("Align left"),
            right: t("Align right"),
            center: t("Align center"),
            justify: t("Justify"),
          };
        }
        static get pluginName() {
          return "AlignmentUI";
        }
        init() {
          const t = this.editor;
          const e = t.ui.componentFactory;
          const n = t.t;
          const i = vx(t.config.get("alignment.options"));
          i.map((t) => t.name)
            .filter(Cx)
            .forEach((t) => this._addButton(t));
          e.add("alignment", (o) => {
            const r = Uv(o);
            const s = i.map((t) => e.create(\`alignment:\${t.name}\`));
            qv(r, s, { enableActiveItemFocusOnDropdownOpen: true });
            r.buttonView.set({ label: n("Text alignment"), tooltip: true });
            r.toolbarView.isVertical = true;
            r.toolbarView.ariaLabel = n("Text alignment toolbar");
            r.extendTemplate({
              attributes: { class: "ck-alignment-dropdown" },
            });
            const a =
              o.contentLanguageDirection === "rtl"
                ? Lx.get("right")
                : Lx.get("left");
            r.buttonView.bind("icon").toMany(s, "isOn", (...t) => {
              const e = t.findIndex((t) => t);
              if (e < 0) {
                return a;
              }
              return s[e].icon;
            });
            r.bind("isEnabled").toMany(s, "isEnabled", (...t) =>
              t.some((t) => t)
            );
            this.listenTo(r, "execute", () => {
              t.editing.view.focus();
            });
            return r;
          });
        }
        _addButton(t) {
          const e = this.editor;
          e.ui.componentFactory.add(\`alignment:\${t}\`, (n) => {
            const i = e.commands.get("alignment");
            const o = new R_(n);
            o.set({
              label: this.localizedOptionTitles[t],
              icon: Lx.get(t),
              tooltip: true,
              isToggleable: true,
            });
            o.bind("isEnabled").to(i);
            o.bind("isOn").to(i, "value", (e) => e === t);
            this.listenTo(o, "execute", () => {
              e.execute("alignment", { value: t });
              e.editing.view.focus();
            });
            return o;
          });
        }
      }
      class zx extends Cl {
        static get requires() {
          return [Sx, Nx];
        }
        static get pluginName() {
          return "Alignment";
        }
      }
      class Px {
        constructor(t, e = 20) {
          this._batch = null;
          this.model = t;
          this._size = 0;
          this.limit = e;
          this._isLocked = false;
          this._changeCallback = (t, e) => {
            if (e.isLocal && e.isUndoable && e !== this._batch) {
              this._reset(true);
            }
          };
          this._selectionChangeCallback = () => {
            this._reset();
          };
          this.model.document.on("change", this._changeCallback);
          this.model.document.selection.on(
            "change:range",
            this._selectionChangeCallback
          );
          this.model.document.selection.on(
            "change:attribute",
            this._selectionChangeCallback
          );
        }
        get batch() {
          if (!this._batch) {
            this._batch = this.model.createBatch({ isTyping: true });
          }
          return this._batch;
        }
        get size() {
          return this._size;
        }
        input(t) {
          this._size += t;
          if (this._size >= this.limit) {
            this._reset(true);
          }
        }
        get isLocked() {
          return this._isLocked;
        }
        lock() {
          this._isLocked = true;
        }
        unlock() {
          this._isLocked = false;
        }
        destroy() {
          this.model.document.off("change", this._changeCallback);
          this.model.document.selection.off(
            "change:range",
            this._selectionChangeCallback
          );
          this.model.document.selection.off(
            "change:attribute",
            this._selectionChangeCallback
          );
        }
        _reset(t = false) {
          if (!this.isLocked || t) {
            this._batch = null;
            this._size = 0;
          }
        }
      }
      class Rx extends vl {
        constructor(t, e) {
          super(t);
          this._buffer = new Px(t.model, e);
        }
        get buffer() {
          return this._buffer;
        }
        destroy() {
          super.destroy();
          this._buffer.destroy();
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const i = t.text || "";
          const o = i.length;
          let r = n.selection;
          if (t.selection) {
            r = t.selection;
          } else if (t.range) {
            r = e.createSelection(t.range);
          }
          const s = t.resultRange;
          e.enqueueChange(this._buffer.batch, (t) => {
            this._buffer.lock();
            e.deleteContent(r);
            if (i) {
              e.insertContent(t.createText(i, n.selection.getAttributes()), r);
            }
            if (s) {
              t.setSelection(s);
            } else if (!r.is("documentSelection")) {
              t.setSelection(r);
            }
            this._buffer.unlock();
            this._buffer.input(o);
          });
        }
      }
      const Ox = ["insertText", "insertReplacementText"];
      class jx extends Em {
        constructor(t) {
          super(t);
          if (r.isAndroid) {
            Ox.push("insertCompositionText");
          }
          const e = t.document;
          e.on("beforeinput", (n, i) => {
            if (!this.isEnabled) {
              return;
            }
            const { data: o, targetRanges: r, inputType: s, domEvent: a } = i;
            if (!Ox.includes(s)) {
              return;
            }
            const c = new y(e, "insertText");
            e.fire(
              c,
              new Tm(t, a, { text: o, selection: t.createSelection(r) })
            );
            if (c.stop.called) {
              n.stop();
            }
          });
          e.on(
            "compositionend",
            (n, { data: i, domEvent: o }) => {
              if (!this.isEnabled || r.isAndroid) {
                return;
              }
              if (!i) {
                return;
              }
              e.fire(
                "insertText",
                new Tm(t, o, { text: i, selection: e.selection })
              );
            },
            { priority: "lowest" }
          );
        }
        observe() {}
      }
      class Fx extends Cl {
        static get pluginName() {
          return "Input";
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const i = e.document.selection;
          n.addObserver(jx);
          const o = new Rx(t, t.config.get("typing.undoStep") || 20);
          t.commands.add("insertText", o);
          t.commands.add("input", o);
          this.listenTo(n.document, "insertText", (i, o) => {
            if (!n.document.isComposing) {
              o.preventDefault();
            }
            const { text: s, selection: a, resultRange: c } = o;
            const l = Array.from(a.getRanges()).map((e) =>
              t.editing.mapper.toModelRange(e)
            );
            let d = s;
            if (r.isAndroid) {
              const t = Array.from(l[0].getItems()).reduce(
                (t, e) => t + (e.is("$textProxy") ? e.data : ""),
                ""
              );
              if (t) {
                if (t.length <= d.length) {
                  if (d.startsWith(t)) {
                    d = d.substring(t.length);
                    l[0].start = l[0].start.getShiftedBy(t.length);
                  }
                } else {
                  if (t.startsWith(d)) {
                    l[0].start = l[0].start.getShiftedBy(d.length);
                    d = "";
                  }
                }
              }
            }
            const u = { text: d, selection: e.createSelection(l) };
            if (c) {
              u.resultRange = t.editing.mapper.toModelRange(c);
            }
            t.execute("insertText", u);
          });
          if (r.isAndroid) {
            this.listenTo(n.document, "keydown", (t, r) => {
              if (
                i.isCollapsed ||
                r.keyCode != 229 ||
                !n.document.isComposing
              ) {
                return;
              }
              Vx(e, o);
            });
          } else {
            this.listenTo(n.document, "compositionstart", () => {
              if (i.isCollapsed) {
                return;
              }
              Vx(e, o);
            });
          }
        }
      }
      function Vx(t, e) {
        if (!e.isEnabled) {
          return;
        }
        const n = e.buffer;
        n.lock();
        t.enqueueChange(n.batch, () => {
          t.deleteContent(t.document.selection);
        });
        n.unlock();
      }
      class Hx extends vl {
        constructor(t, e) {
          super(t);
          this.direction = e;
          this._buffer = new Px(t.model, t.config.get("typing.undoStep"));
        }
        get buffer() {
          return this._buffer;
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          e.enqueueChange(this._buffer.batch, (i) => {
            this._buffer.lock();
            const o = i.createSelection(t.selection || n.selection);
            const r = t.sequence || 1;
            const s = o.isCollapsed;
            if (o.isCollapsed) {
              e.modifySelection(o, {
                direction: this.direction,
                unit: t.unit,
                treatEmojiAsSingleUnit: true,
              });
            }
            if (this._shouldEntireContentBeReplacedWithParagraph(r)) {
              this._replaceEntireContentWithParagraph(i);
              return;
            }
            if (this._shouldReplaceFirstBlockWithParagraph(o, r)) {
              this.editor.execute("paragraph", { selection: o });
              return;
            }
            if (o.isCollapsed) {
              return;
            }
            let a = 0;
            o.getFirstRange()
              .getMinimalFlatRanges()
              .forEach((t) => {
                a += _t(
                  t.getWalker({
                    singleCharacters: true,
                    ignoreElementEnd: true,
                    shallow: true,
                  })
                );
              });
            e.deleteContent(o, {
              doNotResetEntireContent: s,
              direction: this.direction,
            });
            this._buffer.input(a);
            i.setSelection(o);
            this._buffer.unlock();
          });
        }
        _shouldEntireContentBeReplacedWithParagraph(t) {
          if (t > 1) {
            return false;
          }
          const e = this.editor.model;
          const n = e.document;
          const i = n.selection;
          const o = e.schema.getLimitElement(i);
          const r = i.isCollapsed && i.containsEntireContent(o);
          if (!r) {
            return false;
          }
          if (!e.schema.checkChild(o, "paragraph")) {
            return false;
          }
          const s = o.getChild(0);
          if (s && s.is("element", "paragraph")) {
            return false;
          }
          return true;
        }
        _replaceEntireContentWithParagraph(t) {
          const e = this.editor.model;
          const n = e.document;
          const i = n.selection;
          const o = e.schema.getLimitElement(i);
          const r = t.createElement("paragraph");
          t.remove(t.createRangeIn(o));
          t.insert(r, o);
          t.setSelection(r, 0);
        }
        _shouldReplaceFirstBlockWithParagraph(t, e) {
          const n = this.editor.model;
          if (e > 1 || this.direction != "backward") {
            return false;
          }
          if (!t.isCollapsed) {
            return false;
          }
          const i = t.getFirstPosition();
          const o = n.schema.getLimitElement(i);
          const r = o.getChild(0);
          if (i.parent != r) {
            return false;
          }
          if (!t.containsEntireContent(r)) {
            return false;
          }
          if (!n.schema.checkChild(o, "paragraph")) {
            return false;
          }
          if (r.name == "paragraph") {
            return false;
          }
          return true;
        }
      }
      const Ux = "character";
      const qx = "word";
      const Wx = "codePoint";
      const Gx = "selection";
      const $x = "backward";
      const Kx = "forward";
      const Yx = {
        deleteContent: { unit: Gx, direction: $x },
        deleteContentBackward: { unit: Wx, direction: $x },
        deleteWordBackward: { unit: qx, direction: $x },
        deleteHardLineBackward: { unit: Gx, direction: $x },
        deleteSoftLineBackward: { unit: Gx, direction: $x },
        deleteContentForward: { unit: Ux, direction: Kx },
        deleteWordForward: { unit: qx, direction: Kx },
        deleteHardLineForward: { unit: Gx, direction: Kx },
        deleteSoftLineForward: { unit: Gx, direction: Kx },
      };
      class Zx extends Em {
        constructor(t) {
          super(t);
          const e = t.document;
          let n = 0;
          e.on("keydown", () => {
            n++;
          });
          e.on("keyup", () => {
            n = 0;
          });
          e.on("beforeinput", (i, o) => {
            if (!this.isEnabled) {
              return;
            }
            const { targetRanges: s, domEvent: a, inputType: c } = o;
            const l = Yx[c];
            if (!l) {
              return;
            }
            const d = { direction: l.direction, unit: l.unit, sequence: n };
            if (d.unit == Gx) {
              d.selectionToRemove = t.createSelection(s[0]);
            }
            if (r.isAndroid && c === "deleteContentBackward") {
              d.sequence = 1;
              if (
                s.length == 1 &&
                (s[0].start.parent != s[0].end.parent ||
                  s[0].start.offset + 1 != s[0].end.offset)
              ) {
                d.unit = Gx;
                d.selectionToRemove = t.createSelection(s);
              }
            }
            const u = new dh(e, "delete", s[0]);
            e.fire(u, new Tm(t, a, d));
            if (u.stop.called) {
              i.stop();
            }
          });
          if (r.isBlink) {
            Qx(this);
          }
        }
        observe() {}
      }
      function Qx(t) {
        const e = t.view;
        const n = e.document;
        let i = null;
        let o = false;
        n.on("keydown", (t, { keyCode: e }) => {
          i = e;
          o = false;
        });
        n.on("keyup", (a, { keyCode: c, domEvent: l }) => {
          const d = n.selection;
          const u = t.isEnabled && c == i && r(c) && !d.isCollapsed && !o;
          i = null;
          if (u) {
            const t = d.getFirstRange();
            const i = new dh(n, "delete", t);
            const o = { unit: Gx, direction: s(c), selectionToRemove: d };
            n.fire(i, new Tm(e, l, o));
          }
        });
        n.on(
          "beforeinput",
          (t, { inputType: e }) => {
            const n = Yx[e];
            const a = r(i) && n && n.direction == s(i);
            if (a) {
              o = true;
            }
          },
          { priority: "high" }
        );
        n.on(
          "beforeinput",
          (t, { inputType: e, data: n }) => {
            const o = i == Oc["delete"] && e == "insertText" && n == "";
            if (o) {
              t.stop();
            }
          },
          { priority: "high" }
        );
        function r(t) {
          return t == Oc.backspace || t == Oc["delete"];
        }
        function s(t) {
          return t == Oc.backspace ? $x : Kx;
        }
      }
      class Jx extends Cl {
        static get pluginName() {
          return "Delete";
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          const i = t.model.document;
          e.addObserver(Zx);
          this._undoOnBackspace = false;
          const o = new Hx(t, "forward");
          t.commands.add("deleteForward", o);
          t.commands.add("forwardDelete", o);
          t.commands.add("delete", new Hx(t, "backward"));
          this.listenTo(
            n,
            "delete",
            (i, o) => {
              if (!n.isComposing) {
                o.preventDefault();
              }
              const {
                direction: r,
                sequence: s,
                selectionToRemove: a,
                unit: c,
              } = o;
              const l = r === "forward" ? "deleteForward" : "delete";
              const d = { sequence: s };
              if (c == "selection") {
                const e = Array.from(a.getRanges()).map((e) =>
                  t.editing.mapper.toModelRange(e)
                );
                d.selection = t.model.createSelection(e);
              } else {
                d.unit = c;
              }
              t.execute(l, d);
              e.scrollToTheSelection();
            },
            { priority: "low" }
          );
          if (this.editor.plugins.has("UndoEditing")) {
            this.listenTo(
              n,
              "delete",
              (e, n) => {
                if (
                  this._undoOnBackspace &&
                  n.direction == "backward" &&
                  n.sequence == 1 &&
                  n.unit == "codePoint"
                ) {
                  this._undoOnBackspace = false;
                  t.execute("undo");
                  n.preventDefault();
                  e.stop();
                }
              },
              { context: "$capture" }
            );
            this.listenTo(i, "change", () => {
              this._undoOnBackspace = false;
            });
          }
        }
        requestUndoOnBackspace() {
          if (this.editor.plugins.has("UndoEditing")) {
            this._undoOnBackspace = true;
          }
        }
      }
      class Xx extends Cl {
        static get requires() {
          return [Fx, Jx];
        }
        static get pluginName() {
          return "Typing";
        }
      }
      function tE(t, e) {
        let n = t.start;
        const i = Array.from(t.getItems()).reduce((t, i) => {
          if (!(i.is("$text") || i.is("$textProxy"))) {
            n = e.createPositionAfter(i);
            return "";
          }
          return t + i.data;
        }, "");
        return { text: i, range: e.createRange(n, t.end) };
      }
      class eE extends dt() {
        constructor(t, e) {
          super();
          this.model = t;
          this.testCallback = e;
          this._hasMatch = false;
          this.set("isEnabled", true);
          this.on("change:isEnabled", () => {
            if (this.isEnabled) {
              this._startListening();
            } else {
              this.stopListening(t.document.selection);
              this.stopListening(t.document);
            }
          });
          this._startListening();
        }
        get hasMatch() {
          return this._hasMatch;
        }
        _startListening() {
          const t = this.model;
          const e = t.document;
          this.listenTo(
            e.selection,
            "change:range",
            (t, { directChange: n }) => {
              if (!n) {
                return;
              }
              if (!e.selection.isCollapsed) {
                if (this.hasMatch) {
                  this.fire("unmatched");
                  this._hasMatch = false;
                }
                return;
              }
              this._evaluateTextBeforeSelection("selection");
            }
          );
          this.listenTo(e, "change:data", (t, e) => {
            if (e.isUndo || !e.isLocal) {
              return;
            }
            this._evaluateTextBeforeSelection("data", { batch: e });
          });
        }
        _evaluateTextBeforeSelection(t, e = {}) {
          const n = this.model;
          const i = n.document;
          const o = i.selection;
          const r = n.createRange(
            n.createPositionAt(o.focus.parent, 0),
            o.focus
          );
          const { text: s, range: a } = tE(r, n);
          const c = this.testCallback(s);
          if (!c && this.hasMatch) {
            this.fire("unmatched");
          }
          this._hasMatch = !!c;
          if (c) {
            const n = Object.assign(e, { text: s, range: a });
            if (typeof c == "object") {
              Object.assign(n, c);
            }
            this.fire(\`matched:\${t}\`, n);
          }
        }
      }
      class nE extends Cl {
        static get pluginName() {
          return "TwoStepCaretMovement";
        }
        constructor(t) {
          super(t);
          this.attributes = new Set();
          this._overrideUid = null;
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const i = t.locale;
          const o = e.document.selection;
          this.listenTo(
            n.document,
            "arrowKey",
            (t, e) => {
              if (!o.isCollapsed) {
                return;
              }
              if (e.shiftKey || e.altKey || e.ctrlKey) {
                return;
              }
              const n = e.keyCode == Oc.arrowright;
              const r = e.keyCode == Oc.arrowleft;
              if (!n && !r) {
                return;
              }
              const s = i.contentLanguageDirection;
              let a = false;
              if ((s === "ltr" && n) || (s === "rtl" && r)) {
                a = this._handleForwardMovement(e);
              } else {
                a = this._handleBackwardMovement(e);
              }
              if (a === true) {
                t.stop();
              }
            },
            { context: "$text", priority: "highest" }
          );
          this._isNextGravityRestorationSkipped = false;
          this.listenTo(o, "change:range", (t, e) => {
            if (this._isNextGravityRestorationSkipped) {
              this._isNextGravityRestorationSkipped = false;
              return;
            }
            if (!this._isGravityOverridden) {
              return;
            }
            if (!e.directChange && aE(o.getFirstPosition(), this.attributes)) {
              return;
            }
            this._restoreGravity();
          });
        }
        registerAttribute(t) {
          this.attributes.add(t);
        }
        _handleForwardMovement(t) {
          const e = this.attributes;
          const n = this.editor.model;
          const i = n.document.selection;
          const o = i.getFirstPosition();
          if (this._isGravityOverridden) {
            return false;
          }
          if (o.isAtStart && iE(i, e)) {
            return false;
          }
          if (aE(o, e)) {
            rE(t);
            this._overrideGravity();
            return true;
          }
          return false;
        }
        _handleBackwardMovement(t) {
          const e = this.attributes;
          const n = this.editor.model;
          const i = n.document.selection;
          const o = i.getFirstPosition();
          if (this._isGravityOverridden) {
            rE(t);
            this._restoreGravity();
            oE(n, e, o);
            return true;
          } else {
            if (o.isAtStart) {
              if (iE(i, e)) {
                rE(t);
                oE(n, e, o);
                return true;
              }
              return false;
            }
            if (sE(o, e)) {
              if (o.isAtEnd && !iE(i, e) && aE(o, e)) {
                rE(t);
                oE(n, e, o);
                return true;
              }
              this._isNextGravityRestorationSkipped = true;
              this._overrideGravity();
              return false;
            }
          }
          return false;
        }
        get _isGravityOverridden() {
          return !!this._overrideUid;
        }
        _overrideGravity() {
          this._overrideUid = this.editor.model.change((t) =>
            t.overrideSelectionGravity()
          );
        }
        _restoreGravity() {
          this.editor.model.change((t) => {
            t.restoreSelectionGravity(this._overrideUid);
            this._overrideUid = null;
          });
        }
      }
      function iE(t, e) {
        for (const n of e) {
          if (t.hasAttribute(n)) {
            return true;
          }
        }
        return false;
      }
      function oE(t, e, n) {
        const i = n.nodeBefore;
        t.change((t) => {
          if (i) {
            t.setSelectionAttribute(i.getAttributes());
          } else {
            t.removeSelectionAttribute(e);
          }
        });
      }
      function rE(t) {
        t.preventDefault();
      }
      function sE(t, e) {
        const n = t.getShiftedBy(-1);
        return aE(n, e);
      }
      function aE(t, e) {
        const { nodeBefore: n, nodeAfter: i } = t;
        for (const t of e) {
          const e = n ? n.getAttribute(t) : undefined;
          const o = i ? i.getAttribute(t) : undefined;
          if (o !== e) {
            return true;
          }
        }
        return false;
      }
      var cE = /[\\\\^$.*+?()[\\]{}|]/g,
        lE = RegExp(cE.source);
      function dE(t) {
        t = Bd(t);
        return t && lE.test(t) ? t.replace(cE, "\\\\$&") : t;
      }
      const uE = dE;
      const hE = {
        copyright: { from: "(c)", to: "" },
        registeredTrademark: { from: "(r)", to: "" },
        trademark: { from: "(tm)", to: "" },
        oneHalf: {
          from: /(^|[^/a-z0-9])(1\\/2)([^/a-z0-9])$/i,
          to: [null, "", null],
        },
        oneThird: {
          from: /(^|[^/a-z0-9])(1\\/3)([^/a-z0-9])$/i,
          to: [null, "", null],
        },
        twoThirds: {
          from: /(^|[^/a-z0-9])(2\\/3)([^/a-z0-9])$/i,
          to: [null, "", null],
        },
        oneForth: {
          from: /(^|[^/a-z0-9])(1\\/4)([^/a-z0-9])$/i,
          to: [null, "", null],
        },
        threeQuarters: {
          from: /(^|[^/a-z0-9])(3\\/4)([^/a-z0-9])$/i,
          to: [null, "", null],
        },
        lessThanOrEqual: { from: "<=", to: "" },
        greaterThanOrEqual: { from: ">=", to: "" },
        notEqual: { from: "!=", to: "" },
        arrowLeft: { from: "<-", to: "" },
        arrowRight: { from: "->", to: "" },
        horizontalEllipsis: { from: "...", to: "" },
        enDash: { from: /(^| )(--)( )$/, to: [null, "", null] },
        emDash: { from: /(^| )(---)( )$/, to: [null, "", null] },
        quotesPrimary: { from: wE('"'), to: [null, "", null, ""] },
        quotesSecondary: { from: wE("'"), to: [null, "", null, ""] },
        quotesPrimaryEnGb: { from: wE("'"), to: [null, "", null, ""] },
        quotesSecondaryEnGb: { from: wE('"'), to: [null, "", null, ""] },
        quotesPrimaryPl: { from: wE('"'), to: [null, "", null, ""] },
        quotesSecondaryPl: { from: wE("'"), to: [null, "", null, ""] },
      };
      const mE = {
        symbols: ["copyright", "registeredTrademark", "trademark"],
        mathematical: [
          "oneHalf",
          "oneThird",
          "twoThirds",
          "oneForth",
          "threeQuarters",
          "lessThanOrEqual",
          "greaterThanOrEqual",
          "notEqual",
          "arrowLeft",
          "arrowRight",
        ],
        typography: ["horizontalEllipsis", "enDash", "emDash"],
        quotes: ["quotesPrimary", "quotesSecondary"],
      };
      const gE = ["symbols", "mathematical", "typography", "quotes"];
      class fE extends Cl {
        static get requires() {
          return ["Delete", "Input"];
        }
        static get pluginName() {
          return "TextTransformation";
        }
        constructor(t) {
          super(t);
          t.config.define("typing", { transformations: { include: gE } });
        }
        init() {
          const t = this.editor.model;
          const e = t.document.selection;
          e.on("change:range", () => {
            this.isEnabled = !e.anchor.parent.is("element", "codeBlock");
          });
          this._enableTransformationWatchers();
        }
        _enableTransformationWatchers() {
          const t = this.editor;
          const e = t.model;
          const n = t.plugins.get("Delete");
          const i = AE(t.config.get("typing.transformations"));
          const o = (t) => {
            for (const e of i) {
              const n = e.from;
              const i = n.test(t);
              if (i) {
                return { normalizedTransformation: e };
              }
            }
          };
          const r = new eE(t.model, o);
          r.on("matched:data", (t, i) => {
            if (!i.batch.isTyping) {
              return;
            }
            const { from: o, to: r } = i.normalizedTransformation;
            const s = o.exec(i.text);
            const a = r(s.slice(1));
            const c = i.range;
            let l = s.index;
            e.enqueueChange((t) => {
              for (let n = 1; n < s.length; n++) {
                const i = s[n];
                const o = a[n - 1];
                if (o == null) {
                  l += i.length;
                  continue;
                }
                const r = c.start.getShiftedBy(l);
                const d = e.createRange(r, r.getShiftedBy(i.length));
                const u = kE(r);
                e.insertContent(t.createText(o, u), d);
                l += o.length;
              }
              e.enqueueChange(() => {
                n.requestUndoOnBackspace();
              });
            });
          });
          r.bind("isEnabled").to(this);
        }
      }
      function pE(t) {
        if (typeof t == "string") {
          return new RegExp(\`(\${uE(t)})$\`);
        }
        return t;
      }
      function bE(t) {
        if (typeof t == "string") {
          return () => [t];
        } else if (t instanceof Array) {
          return () => t;
        }
        return t;
      }
      function kE(t) {
        const e = t.textNode ? t.textNode : t.nodeAfter;
        return e.getAttributes();
      }
      function wE(t) {
        return new RegExp(\`(^|\\\\s)(\${t})([^\${t}]*)(\${t})$\`);
      }
      function AE(t) {
        const e = t.extra || [];
        const n = t.remove || [];
        const i = (t) => !n.includes(t);
        const o = t.include.concat(e).filter(i);
        return CE(o)
          .filter(i)
          .map((t) => (typeof t == "string" && hE[t] ? hE[t] : t))
          .filter((t) => typeof t === "object")
          .map((t) => ({ from: pE(t.from), to: bE(t.to) }));
      }
      function CE(t) {
        const e = new Set();
        for (const n of t) {
          if (typeof n == "string" && mE[n]) {
            for (const t of mE[n]) {
              e.add(t);
            }
          } else {
            e.add(n);
          }
        }
        return Array.from(e);
      }
      function _E(t, e, n, i) {
        return i.createRange(vE(t, e, n, true, i), vE(t, e, n, false, i));
      }
      function vE(t, e, n, i, o) {
        let r = t.textNode || (i ? t.nodeBefore : t.nodeAfter);
        let s = null;
        while (r && r.getAttribute(e) == n) {
          s = r;
          r = i ? r.previousSibling : r.nextSibling;
        }
        return s ? o.createPositionAt(s, i ? "before" : "after") : t;
      }
      function yE(t, e, n, i) {
        const o = t.editing.view;
        const r = new Set();
        o.document.registerPostFixer((o) => {
          const s = t.model.document.selection;
          let a = false;
          if (s.hasAttribute(e)) {
            const c = _E(s.getFirstPosition(), e, s.getAttribute(e), t.model);
            const l = t.editing.mapper.toViewRange(c);
            for (const t of l.getItems()) {
              if (t.is("element", n) && !t.hasClass(i)) {
                o.addClass(i, t);
                r.add(t);
                a = true;
              }
            }
          }
          return a;
        });
        t.conversion.for("editingDowncast").add((t) => {
          t.on("insert", e, { priority: "highest" });
          t.on("remove", e, { priority: "highest" });
          t.on("attribute", e, { priority: "highest" });
          t.on("selection", e, { priority: "highest" });
          function e() {
            o.change((t) => {
              for (const e of r.values()) {
                t.removeClass(i, e);
                r.delete(e);
              }
            });
          }
        });
      }
      function xE(t, e, n, i) {
        let o;
        let r = null;
        if (typeof i == "function") {
          o = i;
        } else {
          r = t.commands.get(i);
          o = () => {
            t.execute(i);
          };
        }
        t.model.document.on("change:data", (s, a) => {
          if ((r && !r.isEnabled) || !e.isEnabled) {
            return;
          }
          const c = sl(t.model.document.selection.getRanges());
          if (!c.isCollapsed) {
            return;
          }
          if (a.isUndo || !a.isLocal) {
            return;
          }
          const l = Array.from(t.model.document.differ.getChanges());
          const d = l[0];
          if (
            l.length != 1 ||
            d.type !== "insert" ||
            d.name != "$text" ||
            d.length != 1
          ) {
            return;
          }
          const u = d.position.parent;
          if (u.is("element", "codeBlock")) {
            return;
          }
          if (
            u.is("element", "listItem") &&
            typeof i !== "function" &&
            !["numberedList", "bulletedList", "todoList"].includes(i)
          ) {
            return;
          }
          if (r && r.value === true) {
            return;
          }
          const h = u.getChild(0);
          const m = t.model.createRangeOn(h);
          if (!m.containsRange(c) && !c.end.isEqual(m.end)) {
            return;
          }
          const g = n.exec(h.data.substr(0, c.end.offset));
          if (!g) {
            return;
          }
          t.model.enqueueChange((e) => {
            const n = e.createPositionAt(u, 0);
            const i = e.createPositionAt(u, g[0].length);
            const r = new Ff(n, i);
            const s = o({ match: g });
            if (s !== false) {
              e.remove(r);
              const n = t.model.document.selection.getFirstRange();
              const i = e.createRangeIn(u);
              if (u.isEmpty && !i.isEqual(n) && !i.containsRange(n, true)) {
                e.remove(u);
              }
            }
            r.detach();
            t.model.enqueueChange(() => {
              t.plugins.get("Delete").requestUndoOnBackspace();
            });
          });
        });
      }
      function EE(t, e, n, i) {
        let o;
        let r;
        if (n instanceof RegExp) {
          o = n;
        } else {
          r = n;
        }
        r =
          r ||
          ((t) => {
            let e;
            const n = [];
            const i = [];
            while ((e = o.exec(t)) !== null) {
              if (e && e.length < 4) {
                break;
              }
              let { index: t, 1: o, 2: r, 3: s } = e;
              const a = o + r + s;
              t += e[0].length - a.length;
              const c = [t, t + o.length];
              const l = [
                t + o.length + r.length,
                t + o.length + r.length + s.length,
              ];
              n.push(c);
              n.push(l);
              i.push([t + o.length, t + o.length + r.length]);
            }
            return { remove: n, format: i };
          });
        t.model.document.on("change:data", (n, o) => {
          if (o.isUndo || !o.isLocal || !e.isEnabled) {
            return;
          }
          const s = t.model;
          const a = s.document.selection;
          if (!a.isCollapsed) {
            return;
          }
          const c = Array.from(s.document.differ.getChanges());
          const l = c[0];
          if (
            c.length != 1 ||
            l.type !== "insert" ||
            l.name != "$text" ||
            l.length != 1
          ) {
            return;
          }
          const d = a.focus;
          const u = d.parent;
          const { text: h, range: m } = SE(
            s.createRange(s.createPositionAt(u, 0), d),
            s
          );
          const g = r(h);
          const f = DE(m.start, g.format, s);
          const p = DE(m.start, g.remove, s);
          if (!(f.length && p.length)) {
            return;
          }
          s.enqueueChange((e) => {
            const n = i(e, f);
            if (n === false) {
              return;
            }
            for (const t of p.reverse()) {
              e.remove(t);
            }
            s.enqueueChange(() => {
              t.plugins.get("Delete").requestUndoOnBackspace();
            });
          });
        });
      }
      function DE(t, e, n) {
        return e
          .filter((t) => t[0] !== undefined && t[1] !== undefined)
          .map((e) =>
            n.createRange(t.getShiftedBy(e[0]), t.getShiftedBy(e[1]))
          );
      }
      function SE(t, e) {
        let n = t.start;
        const i = Array.from(t.getItems()).reduce((t, i) => {
          if (
            !(i.is("$text") || i.is("$textProxy")) ||
            i.getAttribute("code")
          ) {
            n = e.createPositionAfter(i);
            return "";
          }
          return t + i.data;
        }, "");
        return { text: i, range: e.createRange(n, t.end) };
      }
      class TE extends Cl {
        static get requires() {
          return [Jx];
        }
        static get pluginName() {
          return "Autoformat";
        }
        afterInit() {
          this._addListAutoformats();
          this._addBasicStylesAutoformats();
          this._addHeadingAutoformats();
          this._addBlockQuoteAutoformats();
          this._addCodeBlockAutoformats();
          this._addHorizontalLineAutoformats();
        }
        _addListAutoformats() {
          const t = this.editor.commands;
          if (t.get("bulletedList")) {
            xE(this.editor, this, /^[*-]\\s$/, "bulletedList");
          }
          if (t.get("numberedList")) {
            xE(this.editor, this, /^1[.|)]\\s$/, "numberedList");
          }
          if (t.get("todoList")) {
            xE(this.editor, this, /^\\[\\s?\\]\\s$/, "todoList");
          }
          if (t.get("checkTodoList")) {
            xE(this.editor, this, /^\\[\\s?x\\s?\\]\\s$/, () => {
              this.editor.execute("todoList");
              this.editor.execute("checkTodoList");
            });
          }
        }
        _addBasicStylesAutoformats() {
          const t = this.editor.commands;
          if (t.get("bold")) {
            const t = IE(this.editor, "bold");
            EE(this.editor, this, /(?:^|\\s)(\\*\\*)([^*]+)(\\*\\*)$/g, t);
            EE(this.editor, this, /(?:^|\\s)(__)([^_]+)(__)$/g, t);
          }
          if (t.get("italic")) {
            const t = IE(this.editor, "italic");
            EE(this.editor, this, /(?:^|\\s)(\\*)([^*_]+)(\\*)$/g, t);
            EE(this.editor, this, /(?:^|\\s)(_)([^_]+)(_)$/g, t);
          }
          if (t.get("code")) {
            const t = IE(this.editor, "code");
            EE(this.editor, this, /(\`)([^\`]+)(\`)$/g, t);
          }
          if (t.get("strikethrough")) {
            const t = IE(this.editor, "strikethrough");
            EE(this.editor, this, /(~~)([^~]+)(~~)$/g, t);
          }
        }
        _addHeadingAutoformats() {
          const t = this.editor.commands.get("heading");
          if (t) {
            t.modelElements
              .filter((t) => t.match(/^heading[1-6]$/))
              .forEach((e) => {
                const n = e[7];
                const i = new RegExp(\`^(#{\${n}})\\\\s$\`);
                xE(this.editor, this, i, () => {
                  if (!t.isEnabled || t.value === e) {
                    return false;
                  }
                  this.editor.execute("heading", { value: e });
                });
              });
          }
        }
        _addBlockQuoteAutoformats() {
          if (this.editor.commands.get("blockQuote")) {
            xE(this.editor, this, /^>\\s$/, "blockQuote");
          }
        }
        _addCodeBlockAutoformats() {
          const t = this.editor;
          const e = t.model.document.selection;
          if (t.commands.get("codeBlock")) {
            xE(t, this, /^\`\`\`$/, () => {
              if (e.getFirstPosition().parent.is("element", "listItem")) {
                return false;
              }
              this.editor.execute("codeBlock", {
                usePreviousLanguageChoice: true,
              });
            });
          }
        }
        _addHorizontalLineAutoformats() {
          if (this.editor.commands.get("horizontalLine")) {
            xE(this.editor, this, /^---$/, "horizontalLine");
          }
        }
      }
      function IE(t, e) {
        return (n, i) => {
          const o = t.commands.get(e);
          if (!o.isEnabled) {
            return false;
          }
          const r = t.model.schema.getValidRanges(i, e);
          for (const t of r) {
            n.setAttribute(e, true, t);
          }
          n.removeSelectionAttribute(e);
        };
      }
      class ME extends Im {
        constructor(t) {
          super(t);
          const e = this.document;
          this.domEventType = [
            "paste",
            "copy",
            "cut",
            "drop",
            "dragover",
            "dragstart",
            "dragend",
            "dragenter",
            "dragleave",
          ];
          this.listenTo(e, "paste", n("clipboardInput"), { priority: "low" });
          this.listenTo(e, "drop", n("clipboardInput"), { priority: "low" });
          this.listenTo(e, "dragover", n("dragging"), { priority: "low" });
          function n(t) {
            return (n, i) => {
              i.preventDefault();
              const o = i.dropRange ? [i.dropRange] : null;
              const r = new y(e, t);
              e.fire(r, {
                dataTransfer: i.dataTransfer,
                method: n.name,
                targetRanges: o,
                target: i.target,
              });
              if (r.stop.called) {
                i.stopPropagation();
              }
            };
          }
        }
        onDomEvent(t) {
          const e = {
            dataTransfer: new of(
              "clipboardData" in t ? t.clipboardData : t.dataTransfer
            ),
          };
          if (t.type == "drop" || t.type == "dragover") {
            e.dropRange = BE(this.view, t);
          }
          this.fire(t.type, t, e);
        }
      }
      function BE(t, e) {
        const n = e.target.ownerDocument;
        const i = e.clientX;
        const o = e.clientY;
        let r;
        if (n.caretRangeFromPoint && n.caretRangeFromPoint(i, o)) {
          r = n.caretRangeFromPoint(i, o);
        } else if (e.rangeParent) {
          r = n.createRange();
          r.setStart(e.rangeParent, e.rangeOffset);
          r.collapse(true);
        }
        if (r) {
          return t.domConverter.domRangeToView(r);
        }
        return null;
      }
      function LE(t) {
        t = t
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\\r?\\n\\r?\\n/g, "</p><p>")
          .replace(/\\r?\\n/g, "<br>")
          .replace(/\\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;")
          .replace(/^\\s/, "&nbsp;")
          .replace(/\\s$/, "&nbsp;")
          .replace(/\\s\\s/g, " &nbsp;");
        if (t.includes("</p><p>") || t.includes("<br>")) {
          t = \`<p>\${t}</p>\`;
        }
        return t;
      }
      function NE(t) {
        return t
          .replace(
            /<span(?: class="Apple-converted-space"|)>(\\s+)<\\/span>/g,
            (t, e) => {
              if (e.length == 1) {
                return " ";
              }
              return e;
            }
          )
          .replace(/<!--[\\s\\S]*?-->/g, "");
      }
      const zE = ["figcaption", "li"];
      function PE(t) {
        let e = "";
        if (t.is("$text") || t.is("$textProxy")) {
          e = t.data;
        } else if (t.is("element", "img") && t.hasAttribute("alt")) {
          e = t.getAttribute("alt");
        } else if (t.is("element", "br")) {
          e = "\\n";
        } else {
          let n = null;
          for (const i of t.getChildren()) {
            const t = PE(i);
            if (n && (n.is("containerElement") || i.is("containerElement"))) {
              if (zE.includes(n.name) || zE.includes(i.name)) {
                e += "\\n";
              } else {
                e += "\\n\\n";
              }
            }
            e += t;
            n = i;
          }
        }
        return e;
      }
      class RE extends Cl {
        static get pluginName() {
          return "ClipboardPipeline";
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          e.addObserver(ME);
          this._setupPasteDrop();
          this._setupCopyCut();
        }
        _setupPasteDrop() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const i = n.document;
          this.listenTo(
            i,
            "clipboardInput",
            (e) => {
              if (t.isReadOnly) {
                e.stop();
              }
            },
            { priority: "highest" }
          );
          this.listenTo(
            i,
            "clipboardInput",
            (t, e) => {
              const i = e.dataTransfer;
              let o;
              if (e.content) {
                o = e.content;
              } else {
                let t = "";
                if (i.getData("text/html")) {
                  t = NE(i.getData("text/html"));
                } else if (i.getData("text/plain")) {
                  t = LE(i.getData("text/plain"));
                }
                o = this.editor.data.htmlProcessor.toView(t);
              }
              const r = new y(this, "inputTransformation");
              this.fire(r, {
                content: o,
                dataTransfer: i,
                targetRanges: e.targetRanges,
                method: e.method,
              });
              if (r.stop.called) {
                t.stop();
              }
              n.scrollToTheSelection();
            },
            { priority: "low" }
          );
          this.listenTo(
            this,
            "inputTransformation",
            (t, n) => {
              if (n.content.isEmpty) {
                return;
              }
              const i = this.editor.data;
              const o = i.toModel(n.content, "$clipboardHolder");
              if (o.childCount == 0) {
                return;
              }
              t.stop();
              e.change(() => {
                this.fire("contentInsertion", {
                  content: o,
                  method: n.method,
                  dataTransfer: n.dataTransfer,
                  targetRanges: n.targetRanges,
                });
              });
            },
            { priority: "low" }
          );
          this.listenTo(
            this,
            "contentInsertion",
            (t, n) => {
              n.resultRange = e.insertContent(n.content);
            },
            { priority: "low" }
          );
        }
        _setupCopyCut() {
          const t = this.editor;
          const e = t.model.document;
          const n = t.editing.view;
          const i = n.document;
          const o = (n, o) => {
            const r = o.dataTransfer;
            o.preventDefault();
            const s = t.data.toView(t.model.getSelectedContent(e.selection));
            i.fire("clipboardOutput", {
              dataTransfer: r,
              content: s,
              method: n.name,
            });
          };
          this.listenTo(i, "copy", o, { priority: "low" });
          this.listenTo(
            i,
            "cut",
            (e, n) => {
              if (t.isReadOnly) {
                n.preventDefault();
              } else {
                o(e, n);
              }
            },
            { priority: "low" }
          );
          this.listenTo(
            i,
            "clipboardOutput",
            (n, i) => {
              if (!i.content.isEmpty) {
                i.dataTransfer.setData(
                  "text/html",
                  this.editor.data.htmlProcessor.toData(i.content)
                );
                i.dataTransfer.setData("text/plain", PE(i.content));
              }
              if (i.method == "cut") {
                t.model.deleteContent(e.selection);
              }
            },
            { priority: "low" }
          );
        }
      }
      function* OE(t, e) {
        for (const n of e) {
          if (n && t.getAttributeProperties(n[0]).copyOnEnter) {
            yield n;
          }
        }
      }
      class jE extends vl {
        execute() {
          this.editor.model.change((t) => {
            this.enterBlock(t);
            this.fire("afterExecute", { writer: t });
          });
        }
        enterBlock(t) {
          const e = this.editor.model;
          const n = e.document.selection;
          const i = e.schema;
          const o = n.isCollapsed;
          const r = n.getFirstRange();
          const s = r.start.parent;
          const a = r.end.parent;
          if (i.isLimit(s) || i.isLimit(a)) {
            if (!o && s == a) {
              e.deleteContent(n);
            }
            return false;
          }
          if (o) {
            const e = OE(t.model.schema, n.getAttributes());
            FE(t, r.start);
            t.setSelectionAttribute(e);
            return true;
          } else {
            const i = !(r.start.isAtStart && r.end.isAtEnd);
            const o = s == a;
            e.deleteContent(n, { leaveUnmerged: i });
            if (i) {
              if (o) {
                FE(t, n.focus);
                return true;
              } else {
                t.setSelection(a, 0);
              }
            }
          }
          return false;
        }
      }
      function FE(t, e) {
        t.split(e);
        t.setSelection(e.parent.nextSibling, 0);
      }
      const VE = {
        insertParagraph: { isSoft: false },
        insertLineBreak: { isSoft: true },
      };
      class HE extends Em {
        constructor(t) {
          super(t);
          const e = this.document;
          e.on("beforeinput", (n, i) => {
            if (!this.isEnabled) {
              return;
            }
            const o = i.domEvent;
            const r = VE[i.inputType];
            if (!r) {
              return;
            }
            const s = new dh(e, "enter", i.targetRanges[0]);
            e.fire(s, new Tm(t, o, { isSoft: r.isSoft }));
            if (s.stop.called) {
              n.stop();
            }
          });
        }
        observe() {}
      }
      class UE extends Cl {
        static get pluginName() {
          return "Enter";
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          e.addObserver(HE);
          t.commands.add("enter", new jE(t));
          this.listenTo(
            n,
            "enter",
            (i, o) => {
              if (!n.isComposing) {
                o.preventDefault();
              }
              if (o.isSoft) {
                return;
              }
              t.execute("enter");
              e.scrollToTheSelection();
            },
            { priority: "low" }
          );
        }
      }
      class qE extends vl {
        execute() {
          const t = this.editor.model;
          const e = t.document;
          t.change((n) => {
            GE(t, n, e.selection);
            this.fire("afterExecute", { writer: n });
          });
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.isEnabled = WE(t.schema, e.selection);
        }
      }
      function WE(t, e) {
        if (e.rangeCount > 1) {
          return false;
        }
        const n = e.anchor;
        if (!n || !t.checkChild(n, "softBreak")) {
          return false;
        }
        const i = e.getFirstRange();
        const o = i.start.parent;
        const r = i.end.parent;
        if ((KE(o, t) || KE(r, t)) && o !== r) {
          return false;
        }
        return true;
      }
      function GE(t, e, n) {
        const i = n.isCollapsed;
        const o = n.getFirstRange();
        const r = o.start.parent;
        const s = o.end.parent;
        const a = r == s;
        if (i) {
          const i = OE(t.schema, n.getAttributes());
          $E(t, e, o.end);
          e.removeSelectionAttribute(n.getAttributeKeys());
          e.setSelectionAttribute(i);
        } else {
          const i = !(o.start.isAtStart && o.end.isAtEnd);
          t.deleteContent(n, { leaveUnmerged: i });
          if (a) {
            $E(t, e, n.focus);
          } else {
            if (i) {
              e.setSelection(s, 0);
            }
          }
        }
      }
      function $E(t, e, n) {
        const i = e.createElement("softBreak");
        t.insertContent(i, n);
        e.setSelection(i, "after");
      }
      function KE(t, e) {
        if (t.is("rootElement")) {
          return false;
        }
        return e.isLimit(t) || KE(t.parent, e);
      }
      class YE extends Cl {
        static get pluginName() {
          return "ShiftEnter";
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.conversion;
          const i = t.editing.view;
          const o = i.document;
          e.register("softBreak", { allowWhere: "$text", isInline: true });
          n.for("upcast").elementToElement({ model: "softBreak", view: "br" });
          n.for("downcast").elementToElement({
            model: "softBreak",
            view: (t, { writer: e }) => e.createEmptyElement("br"),
          });
          i.addObserver(HE);
          t.commands.add("shiftEnter", new qE(t));
          this.listenTo(
            o,
            "enter",
            (e, n) => {
              if (!o.isComposing) {
                n.preventDefault();
              }
              if (!n.isSoft) {
                return;
              }
              t.execute("shiftEnter");
              i.scrollToTheSelection();
            },
            { priority: "low" }
          );
        }
      }
      class ZE extends q() {
        constructor() {
          super();
          this._stack = [];
        }
        add(t, e) {
          const n = this._stack;
          const i = n[0];
          this._insertDescriptor(t);
          const o = n[0];
          if (i !== o && !QE(i, o)) {
            this.fire("change:top", {
              oldDescriptor: i,
              newDescriptor: o,
              writer: e,
            });
          }
        }
        remove(t, e) {
          const n = this._stack;
          const i = n[0];
          this._removeDescriptor(t);
          const o = n[0];
          if (i !== o && !QE(i, o)) {
            this.fire("change:top", {
              oldDescriptor: i,
              newDescriptor: o,
              writer: e,
            });
          }
        }
        _insertDescriptor(t) {
          const e = this._stack;
          const n = e.findIndex((e) => e.id === t.id);
          if (QE(t, e[n])) {
            return;
          }
          if (n > -1) {
            e.splice(n, 1);
          }
          let i = 0;
          while (e[i] && JE(e[i], t)) {
            i++;
          }
          e.splice(i, 0, t);
        }
        _removeDescriptor(t) {
          const e = this._stack;
          const n = e.findIndex((e) => e.id === t);
          if (n > -1) {
            e.splice(n, 1);
          }
        }
      }
      function QE(t, e) {
        return (
          t && e && t.priority == e.priority && XE(t.classes) == XE(e.classes)
        );
      }
      function JE(t, e) {
        if (t.priority > e.priority) {
          return true;
        } else if (t.priority < e.priority) {
          return false;
        }
        return XE(t.classes) > XE(e.classes);
      }
      function XE(t) {
        return Array.isArray(t) ? t.sort().join(",") : t;
      }
      const tD =
        '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>';
      const eD = "ck-widget";
      const nD = "ck-widget_selected";
      function iD(t) {
        if (!t.is("element")) {
          return false;
        }
        return !!t.getCustomProperty("widget");
      }
      function oD(t, e, n = {}) {
        if (!t.is("containerElement")) {
          throw new M("widget-to-widget-wrong-element-type", null, {
            element: t,
          });
        }
        e.setAttribute("contenteditable", "false", t);
        e.addClass(eD, t);
        e.setCustomProperty("widget", true, t);
        t.getFillerOffset = mD;
        e.setCustomProperty("widgetLabel", [], t);
        if (n.label) {
          cD(t, n.label);
        }
        if (n.hasSelectionHandle) {
          gD(t, e);
        }
        aD(t, e);
        return t;
      }
      function rD(t, e, n) {
        if (e.classes) {
          n.addClass(Yc(e.classes), t);
        }
        if (e.attributes) {
          for (const i in e.attributes) {
            n.setAttribute(i, e.attributes[i], t);
          }
        }
      }
      function sD(t, e, n) {
        if (e.classes) {
          n.removeClass(Yc(e.classes), t);
        }
        if (e.attributes) {
          for (const i in e.attributes) {
            n.removeAttribute(i, t);
          }
        }
      }
      function aD(t, e, n = rD, i = sD) {
        const o = new ZE();
        o.on("change:top", (e, o) => {
          if (o.oldDescriptor) {
            i(t, o.oldDescriptor, o.writer);
          }
          if (o.newDescriptor) {
            n(t, o.newDescriptor, o.writer);
          }
        });
        const r = (t, e, n) => o.add(e, n);
        const s = (t, e, n) => o.remove(e, n);
        e.setCustomProperty("addHighlight", r, t);
        e.setCustomProperty("removeHighlight", s, t);
      }
      function cD(t, e) {
        const n = t.getCustomProperty("widgetLabel");
        n.push(e);
      }
      function lD(t) {
        const e = t.getCustomProperty("widgetLabel");
        return e.reduce((t, e) => {
          if (typeof e === "function") {
            return t ? t + ". " + e() : e();
          } else {
            return t ? t + ". " + e : e;
          }
        }, "");
      }
      function dD(t, e, n = {}) {
        e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t);
        e.setAttribute("role", "textbox", t);
        if (n.label) {
          e.setAttribute("aria-label", n.label, t);
        }
        e.setAttribute("contenteditable", t.isReadOnly ? "false" : "true", t);
        t.on("change:isReadOnly", (n, i, o) => {
          e.setAttribute("contenteditable", o ? "false" : "true", t);
        });
        t.on("change:isFocused", (n, i, o) => {
          if (o) {
            e.addClass("ck-editor__nested-editable_focused", t);
          } else {
            e.removeClass("ck-editor__nested-editable_focused", t);
          }
        });
        aD(t, e);
        return t;
      }
      function uD(t, e) {
        const n = t.getSelectedElement();
        if (n) {
          const i = AD(t);
          if (i) {
            return e.createRange(e.createPositionAt(n, i));
          }
        }
        return Ew(t, e);
      }
      function hD(t, e) {
        return (n, i) => {
          const { mapper: o, viewPosition: r } = i;
          const s = o.findMappedViewAncestor(r);
          if (!e(s)) {
            return;
          }
          const a = o.toModelElement(s);
          i.modelPosition = t.createPositionAt(
            a,
            r.isAtStart ? "before" : "after"
          );
        };
      }
      function mD() {
        return null;
      }
      function gD(t, e) {
        const n = e.createUIElement(
          "div",
          { class: "ck ck-widget__selection-handle" },
          function (t) {
            const e = this.toDomElement(t);
            const n = new B_();
            n.set("content", tD);
            n.render();
            e.appendChild(n.element);
            return e;
          }
        );
        e.insert(e.createPositionAt(t, 0), n);
        e.addClass(["ck-widget_with-selection-handle"], t);
      }
      const fD = "widget-type-around";
      function pD(t, e, n) {
        return !!t && iD(t) && !n.isInline(e);
      }
      function bD(t) {
        return t.closest(".ck-widget__type-around__button");
      }
      function kD(t) {
        return t.classList.contains("ck-widget__type-around__button_before")
          ? "before"
          : "after";
      }
      function wD(t, e) {
        const n = t.closest(".ck-widget");
        return e.mapDomToView(n);
      }
      function AD(t) {
        return t.getAttribute(fD);
      }
      const CD =
        '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>';
      var _D = n(5137);
      var vD = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      vD.insert = "head";
      vD.singleton = true;
      var yD = Il()(_D.Z, vD);
      const xD = _D.Z.locals || {};
      const ED = ["before", "after"];
      const DD = new DOMParser().parseFromString(
        CD,
        "image/svg+xml"
      ).firstChild;
      const SD = "ck-widget__type-around_disabled";
      class TD extends Cl {
        static get pluginName() {
          return "WidgetTypeAround";
        }
        static get requires() {
          return [UE, Jx];
        }
        constructor(t) {
          super(t);
          this._currentFakeCaretModelElement = null;
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          this.on("change:isEnabled", (n, i, o) => {
            e.change((t) => {
              for (const n of e.document.roots) {
                if (o) {
                  t.removeClass(SD, n);
                } else {
                  t.addClass(SD, n);
                }
              }
            });
            if (!o) {
              t.model.change((t) => {
                t.removeSelectionAttribute(fD);
              });
            }
          });
          this._enableTypeAroundUIInjection();
          this._enableInsertingParagraphsOnButtonClick();
          this._enableInsertingParagraphsOnEnterKeypress();
          this._enableInsertingParagraphsOnTypingKeystroke();
          this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();
          this._enableDeleteIntegration();
          this._enableInsertContentIntegration();
          this._enableInsertObjectIntegration();
          this._enableDeleteContentIntegration();
        }
        destroy() {
          super.destroy();
          this._currentFakeCaretModelElement = null;
        }
        _insertParagraph(t, e) {
          const n = this.editor;
          const i = n.editing.view;
          const o = n.model.schema.getAttributesWithProperty(
            t,
            "copyOnReplace",
            true
          );
          n.execute("insertParagraph", {
            position: n.model.createPositionAt(t, e),
            attributes: o,
          });
          i.focus();
          i.scrollToTheSelection();
        }
        _listenToIfEnabled(t, e, n, i) {
          this.listenTo(
            t,
            e,
            (...t) => {
              if (this.isEnabled) {
                n(...t);
              }
            },
            i
          );
        }
        _insertParagraphAccordingToFakeCaretPosition() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          const i = AD(n);
          if (!i) {
            return false;
          }
          const o = n.getSelectedElement();
          this._insertParagraph(o, i);
          return true;
        }
        _enableTypeAroundUIInjection() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.locale.t;
          const i = {
            before: n("Insert paragraph before block"),
            after: n("Insert paragraph after block"),
          };
          t.editing.downcastDispatcher.on(
            "insert",
            (t, o, r) => {
              const s = r.mapper.toViewElement(o.item);
              if (!s) {
                return;
              }
              if (pD(s, o.item, e)) {
                ID(r.writer, i, s);
                const t = s.getCustomProperty("widgetLabel");
                t.push(() =>
                  this.isEnabled
                    ? n(
                        "Press Enter to type after or press Shift + Enter to type before the widget"
                      )
                    : ""
                );
              }
            },
            { priority: "low" }
          );
        }
        _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          const i = e.schema;
          const o = t.editing.view;
          this._listenToIfEnabled(
            o.document,
            "arrowKey",
            (t, e) => {
              this._handleArrowKeyPress(t, e);
            },
            { context: [iD, "$text"], priority: "high" }
          );
          this._listenToIfEnabled(n, "change:range", (e, n) => {
            if (!n.directChange) {
              return;
            }
            t.model.change((t) => {
              t.removeSelectionAttribute(fD);
            });
          });
          this._listenToIfEnabled(e.document, "change:data", () => {
            const e = n.getSelectedElement();
            if (e) {
              const n = t.editing.mapper.toViewElement(e);
              if (pD(n, e, i)) {
                return;
              }
            }
            t.model.change((t) => {
              t.removeSelectionAttribute(fD);
            });
          });
          this._listenToIfEnabled(
            t.editing.downcastDispatcher,
            "selection",
            (t, e, n) => {
              const o = n.writer;
              if (this._currentFakeCaretModelElement) {
                const t = n.mapper.toViewElement(
                  this._currentFakeCaretModelElement
                );
                if (t) {
                  o.removeClass(ED.map(r), t);
                  this._currentFakeCaretModelElement = null;
                }
              }
              const s = e.selection.getSelectedElement();
              if (!s) {
                return;
              }
              const a = n.mapper.toViewElement(s);
              if (!pD(a, s, i)) {
                return;
              }
              const c = AD(e.selection);
              if (!c) {
                return;
              }
              o.addClass(r(c), a);
              this._currentFakeCaretModelElement = s;
            }
          );
          this._listenToIfEnabled(
            t.ui.focusTracker,
            "change:isFocused",
            (e, n, i) => {
              if (!i) {
                t.model.change((t) => {
                  t.removeSelectionAttribute(fD);
                });
              }
            }
          );
          function r(t) {
            return \`ck-widget_type-around_show-fake-caret_\${t}\`;
          }
        }
        _handleArrowKeyPress(t, e) {
          const n = this.editor;
          const i = n.model;
          const o = i.document.selection;
          const r = i.schema;
          const s = n.editing.view;
          const a = e.keyCode;
          const c = Gc(a, n.locale.contentLanguageDirection);
          const l = s.document.selection.getSelectedElement();
          const d = n.editing.mapper.toModelElement(l);
          let u;
          if (pD(l, d, r)) {
            u = this._handleArrowKeyPressOnSelectedWidget(c);
          } else if (o.isCollapsed) {
            u = this._handleArrowKeyPressWhenSelectionNextToAWidget(c);
          } else if (!e.shiftKey) {
            u = this._handleArrowKeyPressWhenNonCollapsedSelection(c);
          }
          if (u) {
            e.preventDefault();
            t.stop();
          }
        }
        _handleArrowKeyPressOnSelectedWidget(t) {
          const e = this.editor;
          const n = e.model;
          const i = n.document.selection;
          const o = AD(i);
          return n.change((e) => {
            if (o) {
              const n = o === (t ? "after" : "before");
              if (!n) {
                e.removeSelectionAttribute(fD);
                return true;
              }
            } else {
              e.setSelectionAttribute(fD, t ? "after" : "before");
              return true;
            }
            return false;
          });
        }
        _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
          const e = this.editor;
          const n = e.model;
          const i = n.schema;
          const o = e.plugins.get("Widget");
          const r = o._getObjectElementNextToSelection(t);
          const s = e.editing.mapper.toViewElement(r);
          if (pD(s, r, i)) {
            n.change((e) => {
              o._setSelectionOverElement(r);
              e.setSelectionAttribute(fD, t ? "before" : "after");
            });
            return true;
          }
          return false;
        }
        _handleArrowKeyPressWhenNonCollapsedSelection(t) {
          const e = this.editor;
          const n = e.model;
          const i = n.schema;
          const o = e.editing.mapper;
          const r = n.document.selection;
          const s = t
            ? r.getLastPosition().nodeBefore
            : r.getFirstPosition().nodeAfter;
          const a = o.toViewElement(s);
          if (pD(a, s, i)) {
            n.change((e) => {
              e.setSelection(s, "on");
              e.setSelectionAttribute(fD, t ? "after" : "before");
            });
            return true;
          }
          return false;
        }
        _enableInsertingParagraphsOnButtonClick() {
          const t = this.editor;
          const e = t.editing.view;
          this._listenToIfEnabled(e.document, "mousedown", (n, i) => {
            const o = bD(i.domTarget);
            if (!o) {
              return;
            }
            const r = kD(o);
            const s = wD(o, e.domConverter);
            const a = t.editing.mapper.toModelElement(s);
            this._insertParagraph(a, r);
            i.preventDefault();
            n.stop();
          });
        }
        _enableInsertingParagraphsOnEnterKeypress() {
          const t = this.editor;
          const e = t.model.document.selection;
          const n = t.editing.view;
          this._listenToIfEnabled(
            n.document,
            "enter",
            (n, i) => {
              if (n.eventPhase != "atTarget") {
                return;
              }
              const o = e.getSelectedElement();
              const r = t.editing.mapper.toViewElement(o);
              const s = t.model.schema;
              let a;
              if (this._insertParagraphAccordingToFakeCaretPosition()) {
                a = true;
              } else if (pD(r, o, s)) {
                this._insertParagraph(o, i.isSoft ? "before" : "after");
                a = true;
              }
              if (a) {
                i.preventDefault();
                n.stop();
              }
            },
            { context: iD }
          );
        }
        _enableInsertingParagraphsOnTypingKeystroke() {
          const t = this.editor;
          const e = t.editing.view.document;
          this._listenToIfEnabled(
            e,
            "insertText",
            (t, n) => {
              if (this._insertParagraphAccordingToFakeCaretPosition()) {
                n.selection = e.selection;
              }
            },
            { priority: "high" }
          );
          if (r.isAndroid) {
            this._listenToIfEnabled(e, "keydown", (t, e) => {
              if (e.keyCode == 229) {
                this._insertParagraphAccordingToFakeCaretPosition();
              }
            });
          } else {
            this._listenToIfEnabled(
              e,
              "compositionstart",
              () => {
                this._insertParagraphAccordingToFakeCaretPosition();
              },
              { priority: "high" }
            );
          }
        }
        _enableDeleteIntegration() {
          const t = this.editor;
          const e = t.editing.view;
          const n = t.model;
          const i = n.schema;
          this._listenToIfEnabled(
            e.document,
            "delete",
            (e, o) => {
              if (e.eventPhase != "atTarget") {
                return;
              }
              const r = AD(n.document.selection);
              if (!r) {
                return;
              }
              const s = o.direction;
              const a = n.document.selection.getSelectedElement();
              const c = r === "before";
              const l = s == "forward";
              const d = c === l;
              if (d) {
                t.execute("delete", { selection: n.createSelection(a, "on") });
              } else {
                const e = i.getNearestSelectionRange(
                  n.createPositionAt(a, r),
                  s
                );
                if (e) {
                  if (!e.isCollapsed) {
                    n.change((n) => {
                      n.setSelection(e);
                      t.execute(l ? "deleteForward" : "delete");
                    });
                  } else {
                    const o = n.createSelection(e.start);
                    n.modifySelection(o, { direction: s });
                    if (!o.focus.isEqual(e.start)) {
                      n.change((n) => {
                        n.setSelection(e);
                        t.execute(l ? "deleteForward" : "delete");
                      });
                    } else {
                      const t = LD(i, e.start.parent);
                      n.deleteContent(n.createSelection(t, "on"), {
                        doNotAutoparagraph: true,
                      });
                    }
                  }
                }
              }
              o.preventDefault();
              e.stop();
            },
            { context: iD }
          );
        }
        _enableInsertContentIntegration() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          this._listenToIfEnabled(
            t.model,
            "insertContent",
            (t, [i, o]) => {
              if (o && !o.is("documentSelection")) {
                return;
              }
              const r = AD(n);
              if (!r) {
                return;
              }
              t.stop();
              return e.change((t) => {
                const o = n.getSelectedElement();
                const s = e.createPositionAt(o, r);
                const a = t.createSelection(s);
                const c = e.insertContent(i, a);
                t.setSelection(a);
                return c;
              });
            },
            { priority: "high" }
          );
        }
        _enableInsertObjectIntegration() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          this._listenToIfEnabled(
            t.model,
            "insertObject",
            (t, e) => {
              const [, i, , o = {}] = e;
              if (i && !i.is("documentSelection")) {
                return;
              }
              const r = AD(n);
              if (!r) {
                return;
              }
              o.findOptimalPosition = r;
              e[3] = o;
            },
            { priority: "high" }
          );
        }
        _enableDeleteContentIntegration() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          this._listenToIfEnabled(
            t.model,
            "deleteContent",
            (t, [e]) => {
              if (e && !e.is("documentSelection")) {
                return;
              }
              const i = AD(n);
              if (i) {
                t.stop();
              }
            },
            { priority: "high" }
          );
        }
      }
      function ID(t, e, n) {
        const i = t.createUIElement(
          "div",
          { class: "ck ck-reset_all ck-widget__type-around" },
          function (t) {
            const n = this.toDomElement(t);
            MD(n, e);
            BD(n);
            return n;
          }
        );
        t.insert(t.createPositionAt(n, "end"), i);
      }
      function MD(t, e) {
        for (const n of ED) {
          const i = new jA({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-widget__type-around__button",
                \`ck-widget__type-around__button_\${n}\`,
              ],
              title: e[n],
              "aria-hidden": "true",
            },
            children: [t.ownerDocument.importNode(DD, true)],
          });
          t.appendChild(i.render());
        }
      }
      function BD(t) {
        const e = new jA({
          tag: "div",
          attributes: { class: ["ck", "ck-widget__type-around__fake-caret"] },
        });
        t.appendChild(e.render());
      }
      function LD(t, e) {
        let n = e;
        for (const i of e.getAncestors({ parentFirst: true })) {
          if (i.childCount > 1 || t.isLimit(i)) {
            break;
          }
          n = i;
        }
        return n;
      }
      function ND(t) {
        const e = t.model;
        return (n, i) => {
          const o = i.keyCode == Oc.arrowup;
          const r = i.keyCode == Oc.arrowdown;
          const s = i.shiftKey;
          const a = e.document.selection;
          if (!o && !r) {
            return;
          }
          const c = r;
          if (s && jD(a, c)) {
            return;
          }
          const l = zD(t, a, c);
          if (!l) {
            return;
          }
          if (l.isCollapsed) {
            if (a.isCollapsed) {
              return;
            } else if (s) {
              return;
            }
          }
          if (l.isCollapsed || OD(t, l, c)) {
            e.change((t) => {
              const n = c ? l.end : l.start;
              if (s) {
                const i = e.createSelection(a.anchor);
                i.setFocus(n);
                t.setSelection(i);
              } else {
                t.setSelection(n);
              }
            });
            n.stop();
            i.preventDefault();
            i.stopPropagation();
          }
        };
      }
      function zD(t, e, n) {
        const i = t.model;
        if (n) {
          const t = e.isCollapsed ? e.focus : e.getLastPosition();
          const n = PD(i, t, "forward");
          if (!n) {
            return null;
          }
          const o = i.createRange(t, n);
          const r = RD(i.schema, o, "backward");
          if (r) {
            return i.createRange(t, r);
          }
          return null;
        } else {
          const t = e.isCollapsed ? e.focus : e.getFirstPosition();
          const n = PD(i, t, "backward");
          if (!n) {
            return null;
          }
          const o = i.createRange(n, t);
          const r = RD(i.schema, o, "forward");
          if (r) {
            return i.createRange(r, t);
          }
          return null;
        }
      }
      function PD(t, e, n) {
        const i = t.schema;
        const o = t.createRangeIn(e.root);
        const r = n == "forward" ? "elementStart" : "elementEnd";
        for (const { previousPosition: t, item: s, type: a } of o.getWalker({
          startPosition: e,
          direction: n,
        })) {
          if (i.isLimit(s) && !i.isInline(s)) {
            return t;
          }
          if (a == r && i.isBlock(s)) {
            return null;
          }
        }
        return null;
      }
      function RD(t, e, n) {
        const i = n == "backward" ? e.end : e.start;
        if (t.checkChild(i, "$text")) {
          return i;
        }
        for (const { nextPosition: i } of e.getWalker({ direction: n })) {
          if (t.checkChild(i, "$text")) {
            return i;
          }
        }
        return null;
      }
      function OD(t, e, n) {
        const i = t.model;
        const o = t.view.domConverter;
        if (n) {
          const t = i.createSelection(e.start);
          i.modifySelection(t);
          if (!t.focus.isAtEnd && !e.start.isEqual(t.focus)) {
            e = i.createRange(t.focus, e.end);
          }
        }
        const r = t.mapper.toViewRange(e);
        const s = o.viewRangeToDom(r);
        const a = sc.getDomRangeRects(s);
        let c;
        for (const t of a) {
          if (c === undefined) {
            c = Math.round(t.bottom);
            continue;
          }
          if (Math.round(t.top) >= c) {
            return false;
          }
          c = Math.max(c, Math.round(t.bottom));
        }
        return true;
      }
      function jD(t, e) {
        return !t.isCollapsed && t.isBackward == e;
      }
      var FD = n(6507);
      var VD = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      VD.insert = "head";
      VD.singleton = true;
      var HD = Il()(FD.Z, VD);
      const UD = FD.Z.locals || {};
      class qD extends Cl {
        static get pluginName() {
          return "Widget";
        }
        static get requires() {
          return [TD, Jx];
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          this._previouslySelected = new Set();
          this.editor.editing.downcastDispatcher.on("selection", (e, n, i) => {
            const o = i.writer;
            const r = n.selection;
            if (r.isCollapsed) {
              return;
            }
            const s = r.getSelectedElement();
            if (!s) {
              return;
            }
            const a = t.editing.mapper.toViewElement(s);
            if (!iD(a)) {
              return;
            }
            if (!i.consumable.consume(r, "selection")) {
              return;
            }
            o.setSelection(o.createRangeOn(a), { fake: true, label: lD(a) });
          });
          this.editor.editing.downcastDispatcher.on(
            "selection",
            (t, e, n) => {
              this._clearPreviouslySelectedWidgets(n.writer);
              const i = n.writer;
              const o = i.document.selection;
              let r = null;
              for (const t of o.getRanges()) {
                for (const e of t) {
                  const t = e.item;
                  if (iD(t) && !GD(t, r)) {
                    i.addClass(nD, t);
                    this._previouslySelected.add(t);
                    r = t;
                  }
                }
              }
            },
            { priority: "low" }
          );
          e.addObserver(jw);
          this.listenTo(n, "mousedown", (...t) => this._onMousedown(...t));
          this.listenTo(
            n,
            "arrowKey",
            (...t) => {
              this._handleSelectionChangeOnArrowKeyPress(...t);
            },
            { context: [iD, "$text"] }
          );
          this.listenTo(
            n,
            "arrowKey",
            (...t) => {
              this._preventDefaultOnArrowKeyPress(...t);
            },
            { context: "$root" }
          );
          this.listenTo(n, "arrowKey", ND(this.editor.editing), {
            context: "$text",
          });
          this.listenTo(
            n,
            "delete",
            (t, e) => {
              if (this._handleDelete(e.direction == "forward")) {
                e.preventDefault();
                t.stop();
              }
            },
            { context: "$root" }
          );
        }
        _onMousedown(t, e) {
          const n = this.editor;
          const i = n.editing.view;
          const o = i.document;
          let s = e.target;
          if (WD(s)) {
            if ((r.isSafari || r.isGecko) && e.domEvent.detail >= 3) {
              const t = n.editing.mapper;
              const i = s.is("attributeElement")
                ? s.findAncestor((t) => !t.is("attributeElement"))
                : s;
              const o = t.toModelElement(i);
              e.preventDefault();
              this.editor.model.change((t) => {
                t.setSelection(o, "in");
              });
            }
            return;
          }
          if (!iD(s)) {
            s = s.findAncestor(iD);
            if (!s) {
              return;
            }
          }
          if (r.isAndroid) {
            e.preventDefault();
          }
          if (!o.isFocused) {
            i.focus();
          }
          const a = n.editing.mapper.toModelElement(s);
          this._setSelectionOverElement(a);
        }
        _handleSelectionChangeOnArrowKeyPress(t, e) {
          const n = e.keyCode;
          const i = this.editor.model;
          const o = i.schema;
          const r = i.document.selection;
          const s = r.getSelectedElement();
          const a = qc(n, this.editor.locale.contentLanguageDirection);
          const c = a == "down" || a == "right";
          const l = a == "up" || a == "down";
          if (s && o.isObject(s)) {
            const n = c ? r.getLastPosition() : r.getFirstPosition();
            const s = o.getNearestSelectionRange(n, c ? "forward" : "backward");
            if (s) {
              i.change((t) => {
                t.setSelection(s);
              });
              e.preventDefault();
              t.stop();
            }
            return;
          }
          if (!r.isCollapsed && !e.shiftKey) {
            const n = r.getFirstPosition();
            const s = r.getLastPosition();
            const a = n.nodeAfter;
            const l = s.nodeBefore;
            if ((a && o.isObject(a)) || (l && o.isObject(l))) {
              i.change((t) => {
                t.setSelection(c ? s : n);
              });
              e.preventDefault();
              t.stop();
            }
            return;
          }
          if (!r.isCollapsed) {
            return;
          }
          const d = this._getObjectElementNextToSelection(c);
          if (d && o.isObject(d)) {
            if (o.isInline(d) && l) {
              return;
            }
            this._setSelectionOverElement(d);
            e.preventDefault();
            t.stop();
          }
        }
        _preventDefaultOnArrowKeyPress(t, e) {
          const n = this.editor.model;
          const i = n.schema;
          const o = n.document.selection.getSelectedElement();
          if (o && i.isObject(o)) {
            e.preventDefault();
            t.stop();
          }
        }
        _handleDelete(t) {
          if (this.editor.isReadOnly) {
            return;
          }
          const e = this.editor.model.document;
          const n = e.selection;
          if (!n.isCollapsed) {
            return;
          }
          const i = this._getObjectElementNextToSelection(t);
          if (i) {
            this.editor.model.change((t) => {
              let e = n.anchor.parent;
              while (e.isEmpty) {
                const n = e;
                e = n.parent;
                t.remove(n);
              }
              this._setSelectionOverElement(i);
            });
            return true;
          }
        }
        _setSelectionOverElement(t) {
          this.editor.model.change((e) => {
            e.setSelection(e.createRangeOn(t));
          });
        }
        _getObjectElementNextToSelection(t) {
          const e = this.editor.model;
          const n = e.schema;
          const i = e.document.selection;
          const o = e.createSelection(i);
          e.modifySelection(o, { direction: t ? "forward" : "backward" });
          if (o.isEqual(i)) {
            return null;
          }
          const r = t ? o.focus.nodeBefore : o.focus.nodeAfter;
          if (!!r && n.isObject(r)) {
            return r;
          }
          return null;
        }
        _clearPreviouslySelectedWidgets(t) {
          for (const e of this._previouslySelected) {
            t.removeClass(nD, e);
          }
          this._previouslySelected.clear();
        }
      }
      function WD(t) {
        let e = t;
        while (e) {
          if (e.is("editableElement") && !e.is("rootElement")) {
            return true;
          }
          if (iD(e)) {
            return false;
          }
          e = e.parent;
        }
        return false;
      }
      function GD(t, e) {
        if (!e) {
          return false;
        }
        return Array.from(t.getAncestors()).includes(e);
      }
      class $D extends Cl {
        static get requires() {
          return [Ky];
        }
        static get pluginName() {
          return "WidgetToolbarRepository";
        }
        init() {
          const t = this.editor;
          if (t.plugins.has("BalloonToolbar")) {
            const e = t.plugins.get("BalloonToolbar");
            this.listenTo(
              e,
              "show",
              (e) => {
                if (ZD(t.editing.view.document.selection)) {
                  e.stop();
                }
              },
              { priority: "high" }
            );
          }
          this._toolbarDefinitions = new Map();
          this._balloon = this.editor.plugins.get("ContextualBalloon");
          this.on("change:isEnabled", () => {
            this._updateToolbarsVisibility();
          });
          this.listenTo(t.ui, "update", () => {
            this._updateToolbarsVisibility();
          });
          this.listenTo(
            t.ui.focusTracker,
            "change:isFocused",
            () => {
              this._updateToolbarsVisibility();
            },
            { priority: "low" }
          );
        }
        destroy() {
          super.destroy();
          for (const t of this._toolbarDefinitions.values()) {
            t.view.destroy();
          }
        }
        register(
          t,
          {
            ariaLabel: e,
            items: n,
            getRelatedElement: i,
            balloonClassName: o = "ck-toolbar-container",
          }
        ) {
          if (!n.length) {
            B("widget-toolbar-no-items", { toolbarId: t });
            return;
          }
          const r = this.editor;
          const s = r.t;
          const a = new yv(r.locale);
          a.ariaLabel = e || s("Widget toolbar");
          if (this._toolbarDefinitions.has(t)) {
            throw new M("widget-toolbar-duplicated", this, { toolbarId: t });
          }
          a.fillFromConfig(n, r.ui.componentFactory);
          const c = { view: a, getRelatedElement: i, balloonClassName: o };
          r.ui.addToolbar(a, {
            isContextual: true,
            beforeFocus: () => {
              const t = i(r.editing.view.document.selection);
              if (t) {
                this._showToolbar(c, t);
              }
            },
            afterBlur: () => {
              this._hideToolbar(c);
            },
          });
          this._toolbarDefinitions.set(t, c);
        }
        _updateToolbarsVisibility() {
          let t = 0;
          let e = null;
          let n = null;
          for (const i of this._toolbarDefinitions.values()) {
            const o = i.getRelatedElement(
              this.editor.editing.view.document.selection
            );
            if (!this.isEnabled || !o) {
              if (this._isToolbarInBalloon(i)) {
                this._hideToolbar(i);
              }
            } else if (!this.editor.ui.focusTracker.isFocused) {
              if (this._isToolbarVisible(i)) {
                this._hideToolbar(i);
              }
            } else {
              const r = o.getAncestors().length;
              if (r > t) {
                t = r;
                e = o;
                n = i;
              }
            }
          }
          if (n) {
            this._showToolbar(n, e);
          }
        }
        _hideToolbar(t) {
          this._balloon.remove(t.view);
          this.stopListening(this._balloon, "change:visibleView");
        }
        _showToolbar(t, e) {
          if (this._isToolbarVisible(t)) {
            KD(this.editor, e);
          } else if (!this._isToolbarInBalloon(t)) {
            this._balloon.add({
              view: t.view,
              position: YD(this.editor, e),
              balloonClassName: t.balloonClassName,
            });
            this.listenTo(this._balloon, "change:visibleView", () => {
              for (const t of this._toolbarDefinitions.values()) {
                if (this._isToolbarVisible(t)) {
                  const e = t.getRelatedElement(
                    this.editor.editing.view.document.selection
                  );
                  KD(this.editor, e);
                }
              }
            });
          }
        }
        _isToolbarVisible(t) {
          return this._balloon.visibleView === t.view;
        }
        _isToolbarInBalloon(t) {
          return this._balloon.hasView(t.view);
        }
      }
      function KD(t, e) {
        const n = t.plugins.get("ContextualBalloon");
        const i = YD(t, e);
        n.updatePosition(i);
      }
      function YD(t, e) {
        const n = t.editing.view;
        const i = vC.defaultPositions;
        return {
          target: n.domConverter.mapViewToDom(e),
          positions: [
            i.northArrowSouth,
            i.northArrowSouthWest,
            i.northArrowSouthEast,
            i.southArrowNorth,
            i.southArrowNorthWest,
            i.southArrowNorthEast,
            i.viewportStickyNorth,
          ],
        };
      }
      function ZD(t) {
        const e = t.getSelectedElement();
        return !!(e && iD(e));
      }
      class QD extends dt() {
        constructor(t) {
          super();
          this.set("activeHandlePosition", null);
          this.set("proposedWidthPercents", null);
          this.set("proposedWidth", null);
          this.set("proposedHeight", null);
          this.set("proposedHandleHostWidth", null);
          this.set("proposedHandleHostHeight", null);
          this._options = t;
          this._referenceCoordinates = null;
        }
        get originalWidth() {
          return this._originalWidth;
        }
        get originalHeight() {
          return this._originalHeight;
        }
        get originalWidthPercents() {
          return this._originalWidthPercents;
        }
        get aspectRatio() {
          return this._aspectRatio;
        }
        begin(t, e, n) {
          const i = new sc(e);
          this.activeHandlePosition = eS(t);
          this._referenceCoordinates = XD(e, nS(this.activeHandlePosition));
          this._originalWidth = i.width;
          this._originalHeight = i.height;
          this._aspectRatio = i.width / i.height;
          const o = n.style.width;
          if (o && o.match(/^\\d+(\\.\\d*)?%$/)) {
            this._originalWidthPercents = parseFloat(o);
          } else {
            this._originalWidthPercents = JD(n, i);
          }
        }
        update(t) {
          this.proposedWidth = t.width;
          this.proposedHeight = t.height;
          this.proposedWidthPercents = t.widthPercents;
          this.proposedHandleHostWidth = t.handleHostWidth;
          this.proposedHandleHostHeight = t.handleHostHeight;
        }
      }
      function JD(t, e) {
        const n = t.parentElement;
        const i = parseFloat(
          n.ownerDocument.defaultView.getComputedStyle(n).width
        );
        return (e.width / i) * 100;
      }
      function XD(t, e) {
        const n = new sc(t);
        const i = e.split("-");
        const o = {
          x: i[1] == "right" ? n.right : n.left,
          y: i[0] == "bottom" ? n.bottom : n.top,
        };
        o.x += t.ownerDocument.defaultView.scrollX;
        o.y += t.ownerDocument.defaultView.scrollY;
        return o;
      }
      function tS(t) {
        return \`ck-widget__resizer__handle-\${t}\`;
      }
      function eS(t) {
        const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
        for (const n of e) {
          if (t.classList.contains(tS(n))) {
            return n;
          }
        }
      }
      function nS(t) {
        const e = t.split("-");
        const n = {
          top: "bottom",
          bottom: "top",
          left: "right",
          right: "left",
        };
        return \`\${n[e[0]]}-\${n[e[1]]}\`;
      }
      class iS extends pC {
        constructor() {
          super();
          const t = this.bindTemplate;
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-size-view",
                t.to("_viewPosition", (t) => (t ? \`ck-orientation-\${t}\` : "")),
              ],
              style: { display: t.if("_isVisible", "none", (t) => !t) },
            },
            children: [{ text: t.to("_label") }],
          });
        }
        _bindToState(t, e) {
          this.bind("_isVisible").to(
            e,
            "proposedWidth",
            e,
            "proposedHeight",
            (t, e) => t !== null && e !== null
          );
          this.bind("_label").to(
            e,
            "proposedHandleHostWidth",
            e,
            "proposedHandleHostHeight",
            e,
            "proposedWidthPercents",
            (e, n, i) => {
              if (t.unit === "px") {
                return \`\${e}\${n}\`;
              } else {
                return \`\${i}%\`;
              }
            }
          );
          this.bind("_viewPosition").to(
            e,
            "activeHandlePosition",
            e,
            "proposedHandleHostWidth",
            e,
            "proposedHandleHostHeight",
            (t, e, n) => (e < 50 || n < 50 ? "above-center" : t)
          );
        }
        _dismiss() {
          this.unbind();
          this._isVisible = false;
        }
      }
      class oS extends dt() {
        constructor(t) {
          super();
          this._options = t;
          this._viewResizerWrapper = null;
          this.set("isEnabled", true);
          this.set("isSelected", false);
          this.bind("isVisible").to(
            this,
            "isEnabled",
            this,
            "isSelected",
            (t, e) => t && e
          );
          this.decorate("begin");
          this.decorate("cancel");
          this.decorate("commit");
          this.decorate("updateSize");
          this.on(
            "commit",
            (t) => {
              if (
                !this.state.proposedWidth &&
                !this.state.proposedWidthPercents
              ) {
                this._cleanup();
                t.stop();
              }
            },
            { priority: "high" }
          );
        }
        get state() {
          return this._state;
        }
        show() {
          const t = this._options.editor.editing.view;
          t.change((t) => {
            t.removeClass("ck-hidden", this._viewResizerWrapper);
          });
        }
        hide() {
          const t = this._options.editor.editing.view;
          t.change((t) => {
            t.addClass("ck-hidden", this._viewResizerWrapper);
          });
        }
        attach() {
          const t = this;
          const e = this._options.viewElement;
          const n = this._options.editor.editing.view;
          n.change((n) => {
            const i = n.createUIElement(
              "div",
              { class: "ck ck-reset_all ck-widget__resizer" },
              function (e) {
                const n = this.toDomElement(e);
                t._appendHandles(n);
                t._appendSizeUI(n);
                return n;
              }
            );
            n.insert(n.createPositionAt(e, "end"), i);
            n.addClass("ck-widget_with-resizer", e);
            this._viewResizerWrapper = i;
            if (!this.isVisible) {
              this.hide();
            }
          });
          this.on("change:isVisible", () => {
            if (this.isVisible) {
              this.show();
              this.redraw();
            } else {
              this.hide();
            }
          });
        }
        begin(t) {
          this._state = new QD(this._options);
          this._sizeView._bindToState(this._options, this.state);
          this._initialViewWidth = this._options.viewElement.getStyle("width");
          this.state.begin(t, this._getHandleHost(), this._getResizeHost());
        }
        updateSize(t) {
          const e = this._proposeNewSize(t);
          const n = this._options.editor.editing.view;
          n.change((t) => {
            const n = this._options.unit || "%";
            const i = (n === "%" ? e.widthPercents : e.width) + n;
            t.setStyle("width", i, this._options.viewElement);
          });
          const i = this._getHandleHost();
          const o = new sc(i);
          const r = Math.round(o.width);
          const s = Math.round(o.height);
          const a = new sc(i);
          e.width = Math.round(a.width);
          e.height = Math.round(a.height);
          this.redraw(o);
          this.state.update({ ...e, handleHostWidth: r, handleHostHeight: s });
        }
        commit() {
          const t = this._options.unit || "%";
          const e =
            (t === "%"
              ? this.state.proposedWidthPercents
              : this.state.proposedWidth) + t;
          this._options.editor.editing.view.change(() => {
            this._cleanup();
            this._options.onCommit(e);
          });
        }
        cancel() {
          this._cleanup();
        }
        destroy() {
          this.cancel();
        }
        redraw(t) {
          const e = this._domResizerWrapper;
          if (!aS(e)) {
            return;
          }
          const n = e.parentElement;
          const i = this._getHandleHost();
          const o = this._viewResizerWrapper;
          const r = [
            o.getStyle("width"),
            o.getStyle("height"),
            o.getStyle("left"),
            o.getStyle("top"),
          ];
          let s;
          if (n.isSameNode(i)) {
            const e = t || new sc(i);
            s = [e.width + "px", e.height + "px", undefined, undefined];
          } else {
            s = [
              i.offsetWidth + "px",
              i.offsetHeight + "px",
              i.offsetLeft + "px",
              i.offsetTop + "px",
            ];
          }
          if (vt(r, s) !== "same") {
            this._options.editor.editing.view.change((t) => {
              t.setStyle(
                { width: s[0], height: s[1], left: s[2], top: s[3] },
                o
              );
            });
          }
        }
        containsHandle(t) {
          return this._domResizerWrapper.contains(t);
        }
        static isResizeHandle(t) {
          return t.classList.contains("ck-widget__resizer__handle");
        }
        _cleanup() {
          this._sizeView._dismiss();
          const t = this._options.editor.editing.view;
          t.change((t) => {
            t.setStyle(
              "width",
              this._initialViewWidth,
              this._options.viewElement
            );
          });
        }
        _proposeNewSize(t) {
          const e = this.state;
          const n = sS(t);
          const i = this._options.isCentered
            ? this._options.isCentered(this)
            : true;
          const o = {
            x: e._referenceCoordinates.x - (n.x + e.originalWidth),
            y: n.y - e.originalHeight - e._referenceCoordinates.y,
          };
          if (i && e.activeHandlePosition.endsWith("-right")) {
            o.x = n.x - (e._referenceCoordinates.x + e.originalWidth);
          }
          if (i) {
            o.x *= 2;
          }
          let r = Math.abs(e.originalWidth + o.x);
          let s = Math.abs(e.originalHeight + o.y);
          const a = r / e.aspectRatio > s ? "width" : "height";
          if (a == "width") {
            s = r / e.aspectRatio;
          } else {
            r = s * e.aspectRatio;
          }
          return {
            width: Math.round(r),
            height: Math.round(s),
            widthPercents: Math.min(
              Math.round(
                (e.originalWidthPercents / e.originalWidth) * r * 100
              ) / 100,
              100
            ),
          };
        }
        _getResizeHost() {
          const t = this._domResizerWrapper.parentElement;
          return this._options.getResizeHost(t);
        }
        _getHandleHost() {
          const t = this._domResizerWrapper.parentElement;
          return this._options.getHandleHost(t);
        }
        get _domResizerWrapper() {
          return this._options.editor.editing.view.domConverter.mapViewToDom(
            this._viewResizerWrapper
          );
        }
        _appendHandles(t) {
          const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
          for (const n of e) {
            t.appendChild(
              new jA({
                tag: "div",
                attributes: { class: \`ck-widget__resizer__handle \${rS(n)}\` },
              }).render()
            );
          }
        }
        _appendSizeUI(t) {
          this._sizeView = new iS();
          this._sizeView.render();
          t.appendChild(this._sizeView.element);
        }
      }
      function rS(t) {
        return \`ck-widget__resizer__handle-\${t}\`;
      }
      function sS(t) {
        return { x: t.pageX, y: t.pageY };
      }
      function aS(t) {
        return t && t.ownerDocument && t.ownerDocument.contains(t);
      }
      var cS = "Expected a function";
      function lS(t, e, n) {
        var i = true,
          o = true;
        if (typeof t != "function") {
          throw new TypeError(cS);
        }
        if (it(n)) {
          i = "leading" in n ? !!n.leading : i;
          o = "trailing" in n ? !!n.trailing : o;
        }
        return Qm(t, e, { leading: i, maxWait: e, trailing: o });
      }
      const dS = lS;
      var uS = n(2263);
      var hS = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      hS.insert = "head";
      hS.singleton = true;
      var mS = Il()(uS.Z, hS);
      const gS = uS.Z.locals || {};
      class fS extends Cl {
        static get pluginName() {
          return "WidgetResize";
        }
        init() {
          const t = this.editor.editing;
          const e = Xa.window.document;
          this.set("selectedResizer", null);
          this.set("_activeResizer", null);
          this._resizers = new Map();
          t.view.addObserver(jw);
          this._observer = new (Ka())();
          this.listenTo(
            t.view.document,
            "mousedown",
            this._mouseDownListener.bind(this),
            { priority: "high" }
          );
          this._observer.listenTo(
            e,
            "mousemove",
            this._mouseMoveListener.bind(this)
          );
          this._observer.listenTo(
            e,
            "mouseup",
            this._mouseUpListener.bind(this)
          );
          this._redrawSelectedResizerThrottled = dS(
            () => this.redrawSelectedResizer(),
            200
          );
          this.editor.ui.on("update", this._redrawSelectedResizerThrottled);
          this.editor.model.document.on(
            "change",
            () => {
              for (const [t, e] of this._resizers) {
                if (!t.isAttached()) {
                  this._resizers.delete(t);
                  e.destroy();
                }
              }
            },
            { priority: "lowest" }
          );
          this._observer.listenTo(
            Xa.window,
            "resize",
            this._redrawSelectedResizerThrottled
          );
          const n = this.editor.editing.view.document.selection;
          n.on("change", () => {
            const t = n.getSelectedElement();
            const e = this.getResizerByViewElement(t) || null;
            if (e) {
              this.select(e);
            } else {
              this.deselect();
            }
          });
        }
        redrawSelectedResizer() {
          if (this.selectedResizer && this.selectedResizer.isVisible) {
            this.selectedResizer.redraw();
          }
        }
        destroy() {
          super.destroy();
          this._observer.stopListening();
          for (const t of this._resizers.values()) {
            t.destroy();
          }
          this._redrawSelectedResizerThrottled.cancel();
        }
        select(t) {
          this.deselect();
          this.selectedResizer = t;
          this.selectedResizer.isSelected = true;
        }
        deselect() {
          if (this.selectedResizer) {
            this.selectedResizer.isSelected = false;
          }
          this.selectedResizer = null;
        }
        attachTo(t) {
          const e = new oS(t);
          const n = this.editor.plugins;
          e.attach();
          if (n.has("WidgetToolbarRepository")) {
            const t = n.get("WidgetToolbarRepository");
            e.on(
              "begin",
              () => {
                t.forceDisabled("resize");
              },
              { priority: "lowest" }
            );
            e.on(
              "cancel",
              () => {
                t.clearForceDisabled("resize");
              },
              { priority: "highest" }
            );
            e.on(
              "commit",
              () => {
                t.clearForceDisabled("resize");
              },
              { priority: "highest" }
            );
          }
          this._resizers.set(t.viewElement, e);
          const i = this.editor.editing.view.document.selection;
          const o = i.getSelectedElement();
          if (this.getResizerByViewElement(o) == e) {
            this.select(e);
          }
          return e;
        }
        getResizerByViewElement(t) {
          return this._resizers.get(t);
        }
        _getResizerByHandle(t) {
          for (const e of this._resizers.values()) {
            if (e.containsHandle(t)) {
              return e;
            }
          }
        }
        _mouseDownListener(t, e) {
          const n = e.domTarget;
          if (!oS.isResizeHandle(n)) {
            return;
          }
          this._activeResizer = this._getResizerByHandle(n) || null;
          if (this._activeResizer) {
            this._activeResizer.begin(n);
            t.stop();
            e.preventDefault();
          }
        }
        _mouseMoveListener(t, e) {
          if (this._activeResizer) {
            this._activeResizer.updateSize(e);
          }
        }
        _mouseUpListener() {
          if (this._activeResizer) {
            this._activeResizer.commit();
            this._activeResizer = null;
          }
        }
      }
      var pS = n(390);
      var bS = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      bS.insert = "head";
      bS.singleton = true;
      var kS = Il()(pS.Z, bS);
      const wS = pS.Z.locals || {};
      class AS extends Cl {
        static get pluginName() {
          return "DragDrop";
        }
        static get requires() {
          return [RE, qD];
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          this._draggedRange = null;
          this._draggingUid = "";
          this._draggableElement = null;
          this._updateDropMarkerThrottled = dS(
            (t) => this._updateDropMarker(t),
            40
          );
          this._removeDropMarkerDelayed = SS(
            () => this._removeDropMarker(),
            40
          );
          this._clearDraggableAttributesDelayed = SS(
            () => this._clearDraggableAttributes(),
            40
          );
          e.addObserver(ME);
          e.addObserver(jw);
          this._setupDragging();
          this._setupContentInsertionIntegration();
          this._setupClipboardInputIntegration();
          this._setupDropMarker();
          this._setupDraggableAttributeHandling();
          this.listenTo(t, "change:isReadOnly", (t, e, n) => {
            if (n) {
              this.forceDisabled("readOnlyMode");
            } else {
              this.clearForceDisabled("readOnlyMode");
            }
          });
          this.on("change:isEnabled", (t, e, n) => {
            if (!n) {
              this._finalizeDragging(false);
            }
          });
          if (r.isAndroid) {
            this.forceDisabled("noAndroidSupport");
          }
        }
        destroy() {
          if (this._draggedRange) {
            this._draggedRange.detach();
            this._draggedRange = null;
          }
          this._updateDropMarkerThrottled.cancel();
          this._removeDropMarkerDelayed.cancel();
          this._clearDraggableAttributesDelayed.cancel();
          return super.destroy();
        }
        _setupDragging() {
          const t = this.editor;
          const e = t.model;
          const n = e.document;
          const i = t.editing.view;
          const o = i.document;
          this.listenTo(
            o,
            "dragstart",
            (i, r) => {
              const s = n.selection;
              if (r.target && r.target.is("editableElement")) {
                r.preventDefault();
                return;
              }
              const a = r.target ? TS(r.target) : null;
              if (a) {
                const n = t.editing.mapper.toModelElement(a);
                this._draggedRange = Ff.fromRange(e.createRangeOn(n));
                if (t.plugins.has("WidgetToolbarRepository")) {
                  t.plugins
                    .get("WidgetToolbarRepository")
                    .forceDisabled("dragDrop");
                }
              } else if (!o.selection.isCollapsed) {
                const t = o.selection.getSelectedElement();
                if (!t || !iD(t)) {
                  this._draggedRange = Ff.fromRange(s.getFirstRange());
                }
              }
              if (!this._draggedRange) {
                r.preventDefault();
                return;
              }
              this._draggingUid = E();
              r.dataTransfer.effectAllowed = this.isEnabled
                ? "copyMove"
                : "copy";
              r.dataTransfer.setData(
                "application/ckeditor5-dragging-uid",
                this._draggingUid
              );
              const c = e.createSelection(this._draggedRange.toRange());
              const l = t.data.toView(e.getSelectedContent(c));
              o.fire("clipboardOutput", {
                dataTransfer: r.dataTransfer,
                content: l,
                method: "dragstart",
              });
              if (!this.isEnabled) {
                this._draggedRange.detach();
                this._draggedRange = null;
                this._draggingUid = "";
              }
            },
            { priority: "low" }
          );
          this.listenTo(
            o,
            "dragend",
            (t, e) => {
              this._finalizeDragging(
                !e.dataTransfer.isCanceled &&
                  e.dataTransfer.dropEffect == "move"
              );
            },
            { priority: "low" }
          );
          this.listenTo(o, "dragenter", () => {
            if (!this.isEnabled) {
              return;
            }
            i.focus();
          });
          this.listenTo(o, "dragleave", () => {
            this._removeDropMarkerDelayed();
          });
          this.listenTo(
            o,
            "dragging",
            (e, n) => {
              if (!this.isEnabled) {
                n.dataTransfer.dropEffect = "none";
                return;
              }
              this._removeDropMarkerDelayed.cancel();
              const i = CS(t, n.targetRanges, n.target);
              if (!this._draggedRange) {
                n.dataTransfer.dropEffect = "copy";
              }
              if (!r.isGecko) {
                if (n.dataTransfer.effectAllowed == "copy") {
                  n.dataTransfer.dropEffect = "copy";
                } else if (
                  ["all", "copyMove"].includes(n.dataTransfer.effectAllowed)
                ) {
                  n.dataTransfer.dropEffect = "move";
                }
              }
              if (i) {
                this._updateDropMarkerThrottled(i);
              }
            },
            { priority: "low" }
          );
        }
        _setupClipboardInputIntegration() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          this.listenTo(
            n,
            "clipboardInput",
            (e, n) => {
              if (n.method != "drop") {
                return;
              }
              const i = CS(t, n.targetRanges, n.target);
              this._removeDropMarker();
              if (!i) {
                this._finalizeDragging(false);
                e.stop();
                return;
              }
              if (
                this._draggedRange &&
                this._draggingUid !=
                  n.dataTransfer.getData("application/ckeditor5-dragging-uid")
              ) {
                this._draggedRange.detach();
                this._draggedRange = null;
                this._draggingUid = "";
              }
              const o = DS(n.dataTransfer) == "move";
              if (
                o &&
                this._draggedRange &&
                this._draggedRange.containsRange(i, true)
              ) {
                this._finalizeDragging(false);
                e.stop();
                return;
              }
              n.targetRanges = [t.editing.mapper.toViewRange(i)];
            },
            { priority: "high" }
          );
        }
        _setupContentInsertionIntegration() {
          const t = this.editor.plugins.get(RE);
          t.on(
            "contentInsertion",
            (t, e) => {
              if (!this.isEnabled || e.method !== "drop") {
                return;
              }
              const n = e.targetRanges.map((t) =>
                this.editor.editing.mapper.toModelRange(t)
              );
              this.editor.model.change((t) => t.setSelection(n));
            },
            { priority: "high" }
          );
          t.on(
            "contentInsertion",
            (t, e) => {
              if (!this.isEnabled || e.method !== "drop") {
                return;
              }
              const n = DS(e.dataTransfer) == "move";
              const i = !e.resultRange || !e.resultRange.isCollapsed;
              this._finalizeDragging(i && n);
            },
            { priority: "lowest" }
          );
        }
        _setupDraggableAttributeHandling() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          this.listenTo(n, "mousedown", (i, o) => {
            if (r.isAndroid || !o) {
              return;
            }
            this._clearDraggableAttributesDelayed.cancel();
            let s = TS(o.target);
            if (r.isBlink && !t.isReadOnly && !s && !n.selection.isCollapsed) {
              const t = n.selection.getSelectedElement();
              if (!t || !iD(t)) {
                s = n.selection.editableElement;
              }
            }
            if (s) {
              e.change((t) => {
                t.setAttribute("draggable", "true", s);
              });
              this._draggableElement = t.editing.mapper.toModelElement(s);
            }
          });
          this.listenTo(n, "mouseup", () => {
            if (!r.isAndroid) {
              this._clearDraggableAttributesDelayed();
            }
          });
        }
        _clearDraggableAttributes() {
          const t = this.editor.editing;
          t.view.change((e) => {
            if (
              this._draggableElement &&
              this._draggableElement.root.rootName != "$graveyard"
            ) {
              e.removeAttribute(
                "draggable",
                t.mapper.toViewElement(this._draggableElement)
              );
            }
            this._draggableElement = null;
          });
        }
        _setupDropMarker() {
          const t = this.editor;
          t.conversion.for("editingDowncast").markerToHighlight({
            model: "drop-target",
            view: { classes: ["ck-clipboard-drop-target-range"] },
          });
          t.conversion.for("editingDowncast").markerToElement({
            model: "drop-target",
            view: (e, { writer: n }) => {
              const i = t.model.schema.checkChild(e.markerRange.start, "$text");
              if (!i) {
                return;
              }
              return n.createUIElement(
                "span",
                { class: "ck ck-clipboard-drop-target-position" },
                function (t) {
                  const e = this.toDomElement(t);
                  e.append("", t.createElement("span"), "");
                  return e;
                }
              );
            },
          });
        }
        _updateDropMarker(t) {
          const e = this.editor;
          const n = e.model.markers;
          e.model.change((e) => {
            if (n.has("drop-target")) {
              if (!n.get("drop-target").getRange().isEqual(t)) {
                e.updateMarker("drop-target", { range: t });
              }
            } else {
              e.addMarker("drop-target", {
                range: t,
                usingOperation: false,
                affectsData: false,
              });
            }
          });
        }
        _removeDropMarker() {
          const t = this.editor.model;
          this._removeDropMarkerDelayed.cancel();
          this._updateDropMarkerThrottled.cancel();
          if (t.markers.has("drop-target")) {
            t.change((t) => {
              t.removeMarker("drop-target");
            });
          }
        }
        _finalizeDragging(t) {
          const e = this.editor;
          const n = e.model;
          this._removeDropMarker();
          this._clearDraggableAttributes();
          if (e.plugins.has("WidgetToolbarRepository")) {
            e.plugins
              .get("WidgetToolbarRepository")
              .clearForceDisabled("dragDrop");
          }
          this._draggingUid = "";
          if (!this._draggedRange) {
            return;
          }
          if (t && this.isEnabled) {
            n.deleteContent(n.createSelection(this._draggedRange), {
              doNotAutoparagraph: true,
            });
          }
          this._draggedRange.detach();
          this._draggedRange = null;
        }
      }
      function CS(t, e, n) {
        const i = t.model;
        const o = t.editing.mapper;
        let s = null;
        const a = e ? e[0].start : null;
        if (n.is("uiElement")) {
          n = n.parent;
        }
        s = _S(t, n);
        if (s) {
          return s;
        }
        const c = ES(t, n);
        const l = a ? o.toModelPosition(a) : null;
        if (!l) {
          return vS(t, c);
        }
        s = yS(t, l, c);
        if (s) {
          return s;
        }
        s = i.schema.getNearestSelectionRange(
          l,
          r.isGecko ? "forward" : "backward"
        );
        if (s) {
          return s;
        }
        return xS(t, l.parent);
      }
      function _S(t, e) {
        const n = t.model;
        const i = t.editing.mapper;
        if (iD(e)) {
          return n.createRangeOn(i.toModelElement(e));
        }
        if (!e.is("editableElement")) {
          const t = e.findAncestor((t) => iD(t) || t.is("editableElement"));
          if (iD(t)) {
            return n.createRangeOn(i.toModelElement(t));
          }
        }
        return null;
      }
      function vS(t, e) {
        const n = t.model;
        const i = n.schema;
        const o = n.createPositionAt(e, 0);
        return i.getNearestSelectionRange(o, "forward");
      }
      function yS(t, e, n) {
        const i = t.model;
        if (!i.schema.checkChild(n, "$block")) {
          return null;
        }
        const o = i.createPositionAt(n, 0);
        const r = e.path.slice(0, o.path.length);
        const s = i.createPositionFromPath(e.root, r);
        const a = s.nodeAfter;
        if (a && i.schema.isObject(a)) {
          return i.createRangeOn(a);
        }
        return null;
      }
      function xS(t, e) {
        const n = t.model;
        let i = e;
        while (i) {
          if (n.schema.isObject(i)) {
            return n.createRangeOn(i);
          }
          i = i.parent;
        }
        return null;
      }
      function ES(t, e) {
        const n = t.editing.mapper;
        const i = t.editing.view;
        const o = n.toModelElement(e);
        if (o) {
          return o;
        }
        const r = i.createPositionBefore(e);
        const s = n.findMappedViewAncestor(r);
        return n.toModelElement(s);
      }
      function DS(t) {
        if (r.isGecko) {
          return t.dropEffect;
        }
        return ["all", "copyMove"].includes(t.effectAllowed) ? "move" : "copy";
      }
      function SS(t, e) {
        let n;
        function i(...o) {
          i.cancel();
          n = setTimeout(() => t(...o), e);
        }
        i.cancel = () => {
          clearTimeout(n);
        };
        return i;
      }
      function TS(t) {
        if (t.is("editableElement")) {
          return null;
        }
        if (t.hasClass("ck-widget__selection-handle")) {
          return t.findAncestor(iD);
        }
        if (iD(t)) {
          return t;
        }
        const e = t.findAncestor((t) => iD(t) || t.is("editableElement"));
        if (iD(e)) {
          return e;
        }
        return null;
      }
      class IS extends Cl {
        static get pluginName() {
          return "PastePlainText";
        }
        static get requires() {
          return [RE];
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const i = n.document;
          const o = e.document.selection;
          let r = false;
          n.addObserver(ME);
          this.listenTo(i, "keydown", (t, e) => {
            r = e.shiftKey;
          });
          t.plugins.get(RE).on("contentInsertion", (t, n) => {
            if (!r && !MS(n.content, e.schema)) {
              return;
            }
            e.change((t) => {
              const i = Array.from(o.getAttributes()).filter(
                ([t]) => e.schema.getAttributeProperties(t).isFormatting
              );
              if (!o.isCollapsed) {
                e.deleteContent(o, { doNotAutoparagraph: true });
              }
              i.push(...o.getAttributes());
              const r = t.createRangeIn(n.content);
              for (const e of r.getItems()) {
                if (e.is("$textProxy")) {
                  t.setAttributes(i, e);
                }
              }
            });
          });
        }
      }
      function MS(t, e) {
        if (t.childCount > 1) {
          return false;
        }
        const n = t.getChild(0);
        if (e.isObject(n)) {
          return false;
        }
        return Array.from(n.getAttributeKeys()).length == 0;
      }
      class BS extends Cl {
        static get pluginName() {
          return "Clipboard";
        }
        static get requires() {
          return [RE, AS, IS];
        }
      }
      class LS extends vl {
        constructor(t) {
          super(t);
          this._stack = [];
          this._createdBatches = new WeakSet();
          this.refresh();
          this.listenTo(
            t.data,
            "set",
            (t, e) => {
              e[1] = { ...e[1] };
              const n = e[1];
              if (!n.batchType) {
                n.batchType = { isUndoable: false };
              }
            },
            { priority: "high" }
          );
          this.listenTo(t.data, "set", (t, e) => {
            const n = e[1];
            if (!n.batchType.isUndoable) {
              this.clearStack();
            }
          });
        }
        refresh() {
          this.isEnabled = this._stack.length > 0;
        }
        addBatch(t) {
          const e = this.editor.model.document.selection;
          const n = {
            ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [],
            isBackward: e.isBackward,
          };
          this._stack.push({ batch: t, selection: n });
          this.refresh();
        }
        clearStack() {
          this._stack = [];
          this.refresh();
        }
        _restoreSelection(t, e, n) {
          const i = this.editor.model;
          const o = i.document;
          const r = [];
          const s = t.map((t) => t.getTransformedByOperations(n));
          const a = s.flat();
          for (const t of s) {
            const e = t
              .filter((t) => t.root != o.graveyard)
              .filter((t) => !zS(t, a));
            if (!e.length) {
              continue;
            }
            NS(e);
            r.push(e[0]);
          }
          if (r.length) {
            i.change((t) => {
              t.setSelection(r, { backward: e });
            });
          }
        }
        _undo(t, e) {
          const n = this.editor.model;
          const i = n.document;
          this._createdBatches.add(e);
          const o = t.operations.slice().filter((t) => t.isDocumentOperation);
          o.reverse();
          for (const t of o) {
            const o = t.baseVersion + 1;
            const r = Array.from(i.history.getOperations(o));
            const s = Ak([t.getReversed()], r, {
              useRelations: true,
              document: this.editor.model.document,
              padWithNoOps: false,
              forceWeakRemove: true,
            });
            const a = s.operationsA;
            for (const o of a) {
              e.addOperation(o);
              n.applyOperation(o);
              i.history.setOperationAsUndone(t, o);
            }
          }
        }
      }
      function NS(t) {
        t.sort((t, e) => (t.start.isBefore(e.start) ? -1 : 1));
        for (let e = 1; e < t.length; e++) {
          const n = t[e - 1];
          const i = n.getJoined(t[e], true);
          if (i) {
            e--;
            t.splice(e, 2, i);
          }
        }
      }
      function zS(t, e) {
        return e.some((e) => e !== t && e.containsRange(t, true));
      }
      class PS extends LS {
        execute(t = null) {
          const e = t
            ? this._stack.findIndex((e) => e.batch == t)
            : this._stack.length - 1;
          const n = this._stack.splice(e, 1)[0];
          const i = this.editor.model.createBatch({ isUndo: true });
          this.editor.model.enqueueChange(i, () => {
            this._undo(n.batch, i);
            const t = this.editor.model.document.history.getOperations(
              n.batch.baseVersion
            );
            this._restoreSelection(
              n.selection.ranges,
              n.selection.isBackward,
              t
            );
            this.fire("revert", n.batch, i);
          });
          this.refresh();
        }
      }
      class RS extends LS {
        execute() {
          const t = this._stack.pop();
          const e = this.editor.model.createBatch({ isUndo: true });
          this.editor.model.enqueueChange(e, () => {
            const n = t.batch.operations[t.batch.operations.length - 1];
            const i = n.baseVersion + 1;
            const o = this.editor.model.document.history.getOperations(i);
            this._restoreSelection(
              t.selection.ranges,
              t.selection.isBackward,
              o
            );
            this._undo(t.batch, e);
          });
          this.refresh();
        }
      }
      class OS extends Cl {
        static get pluginName() {
          return "UndoEditing";
        }
        constructor(t) {
          super(t);
          this._batchRegistry = new WeakSet();
        }
        init() {
          const t = this.editor;
          this._undoCommand = new PS(t);
          this._redoCommand = new RS(t);
          t.commands.add("undo", this._undoCommand);
          t.commands.add("redo", this._redoCommand);
          this.listenTo(
            t.model,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              if (!n.isDocumentOperation) {
                return;
              }
              const i = n.batch;
              const o = this._redoCommand._createdBatches.has(i);
              const r = this._undoCommand._createdBatches.has(i);
              const s = this._batchRegistry.has(i);
              if (s) {
                return;
              }
              this._batchRegistry.add(i);
              if (!i.isUndoable) {
                return;
              }
              if (o) {
                this._undoCommand.addBatch(i);
              } else if (!r) {
                this._undoCommand.addBatch(i);
                this._redoCommand.clearStack();
              }
            },
            { priority: "highest" }
          );
          this.listenTo(this._undoCommand, "revert", (t, e, n) => {
            this._redoCommand.addBatch(n);
          });
          t.keystrokes.set("CTRL+Z", "undo");
          t.keystrokes.set("CTRL+Y", "redo");
          t.keystrokes.set("CTRL+SHIFT+Z", "redo");
        }
      }
      const jS =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>';
      const FS =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
      class VS extends Cl {
        static get pluginName() {
          return "UndoUI";
        }
        init() {
          const t = this.editor;
          const e = t.locale;
          const n = t.t;
          const i = e.uiLanguageDirection == "ltr" ? jS : FS;
          const o = e.uiLanguageDirection == "ltr" ? FS : jS;
          this._addButton("undo", n("Undo"), "CTRL+Z", i);
          this._addButton("redo", n("Redo"), "CTRL+Y", o);
        }
        _addButton(t, e, n, i) {
          const o = this.editor;
          o.ui.componentFactory.add(t, (r) => {
            const s = o.commands.get(t);
            const a = new R_(r);
            a.set({ label: e, icon: i, keystroke: n, tooltip: true });
            a.bind("isEnabled").to(s, "isEnabled");
            this.listenTo(a, "execute", () => {
              o.execute(t);
              o.editing.view.focus();
            });
            return a;
          });
        }
      }
      class HS extends Cl {
        static get requires() {
          return [OS, VS];
        }
        static get pluginName() {
          return "Undo";
        }
      }
      function US(t) {
        return t.createContainerElement(
          "span",
          { class: "image-inline" },
          t.createEmptyElement("img")
        );
      }
      function qS(t) {
        return t.createContainerElement("figure", { class: "image" }, [
          t.createEmptyElement("img"),
          t.createSlot(),
        ]);
      }
      function WS(t, e) {
        const n = t.plugins.get("ImageUtils");
        const i =
          t.plugins.has("ImageInlineEditing") &&
          t.plugins.has("ImageBlockEditing");
        return (t) => {
          if (!n.isInlineImageView(t)) {
            return null;
          }
          if (!i) {
            return o(t);
          }
          const r =
            t.getStyle("display") == "block" ||
            t.findAncestor(n.isBlockImageView)
              ? "imageBlock"
              : "imageInline";
          if (r !== e) {
            return null;
          }
          return o(t);
        };
        function o(t) {
          const e = { name: true };
          if (t.hasAttribute("src")) {
            e.attributes = ["src"];
          }
          return e;
        }
      }
      function GS(t, e) {
        const n = sl(e.getSelectedBlocks());
        if (!n || t.isObject(n)) {
          return "imageBlock";
        }
        if (n.isEmpty && n.name != "listItem") {
          return "imageBlock";
        }
        return "imageInline";
      }
      class $S extends Cl {
        static get pluginName() {
          return "ImageUtils";
        }
        isImage(t) {
          return this.isInlineImage(t) || this.isBlockImage(t);
        }
        isInlineImageView(t) {
          return !!t && t.is("element", "img");
        }
        isBlockImageView(t) {
          return !!t && t.is("element", "figure") && t.hasClass("image");
        }
        insertImage(t = {}, e = null, n = null) {
          const i = this.editor;
          const o = i.model;
          const r = o.document.selection;
          n = QS(i, e || r, n);
          t = { ...Object.fromEntries(r.getAttributes()), ...t };
          for (const e in t) {
            if (!o.schema.checkAttribute(n, e)) {
              delete t[e];
            }
          }
          return o.change((i) => {
            const r = i.createElement(n, t);
            o.insertObject(r, e, null, {
              setSelection: "on",
              findOptimalPosition: !e && n != "imageInline",
            });
            if (r.parent) {
              return r;
            }
            return null;
          });
        }
        getClosestSelectedImageWidget(t) {
          const e = t.getFirstPosition();
          if (!e) {
            return null;
          }
          const n = t.getSelectedElement();
          if (n && this.isImageWidget(n)) {
            return n;
          }
          let i = e.parent;
          while (i) {
            if (i.is("element") && this.isImageWidget(i)) {
              return i;
            }
            i = i.parent;
          }
          return null;
        }
        getClosestSelectedImageElement(t) {
          const e = t.getSelectedElement();
          return this.isImage(e)
            ? e
            : t.getFirstPosition().findAncestor("imageBlock");
        }
        isImageAllowed() {
          const t = this.editor.model;
          const e = t.document.selection;
          return KS(this.editor, e) && YS(e);
        }
        toImageWidget(t, e, n) {
          e.setCustomProperty("image", true, t);
          const i = () => {
            const e = this.findViewImgElement(t);
            const i = e.getAttribute("alt");
            return i ? \`\${i} \${n}\` : n;
          };
          return oD(t, e, { label: i });
        }
        isImageWidget(t) {
          return !!t.getCustomProperty("image") && iD(t);
        }
        isBlockImage(t) {
          return !!t && t.is("element", "imageBlock");
        }
        isInlineImage(t) {
          return !!t && t.is("element", "imageInline");
        }
        findViewImgElement(t) {
          if (this.isInlineImageView(t)) {
            return t;
          }
          const e = this.editor.editing.view;
          for (const { item: n } of e.createRangeIn(t)) {
            if (this.isInlineImageView(n)) {
              return n;
            }
          }
        }
      }
      function KS(t, e) {
        const n = QS(t, e);
        if (n == "imageBlock") {
          const n = ZS(e, t.model);
          if (t.model.schema.checkChild(n, "imageBlock")) {
            return true;
          }
        } else if (t.model.schema.checkChild(e.focus, "imageInline")) {
          return true;
        }
        return false;
      }
      function YS(t) {
        return [...t.focus.getAncestors()].every(
          (t) => !t.is("element", "imageBlock")
        );
      }
      function ZS(t, e) {
        const n = uD(t, e);
        const i = n.start.parent;
        if (i.isEmpty && !i.is("element", "$root")) {
          return i.parent;
        }
        return i;
      }
      function QS(t, e, n) {
        const i = t.model.schema;
        const o = t.config.get("image.insert.type");
        if (!t.plugins.has("ImageBlockEditing")) {
          return "imageInline";
        }
        if (!t.plugins.has("ImageInlineEditing")) {
          return "imageBlock";
        }
        if (n) {
          return n;
        }
        if (o === "inline") {
          return "imageInline";
        }
        if (o === "block") {
          return "imageBlock";
        }
        if (e.is("selection")) {
          return GS(i, e);
        }
        return i.checkChild(e, "imageInline") ? "imageInline" : "imageBlock";
      }
      const JS = new RegExp(
        String(
          /^(http(s)?:\\/\\/)?[\\w-]+\\.[\\w.~:/[\\]@!$&'()*+,;=%-]+/.source +
            /\\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)/.source +
            /(\\?[\\w.~:/[\\]@!$&'()*+,;=%-]*)?/.source +
            /(#[\\w.~:/[\\]@!$&'()*+,;=%-]*)?$/.source
        )
      );
      class XS extends Cl {
        static get requires() {
          return [BS, $S, HS, Jx];
        }
        static get pluginName() {
          return "AutoImage";
        }
        constructor(t) {
          super(t);
          this._timeoutId = null;
          this._positionToInsert = null;
        }
        init() {
          const t = this.editor;
          const e = t.model.document;
          this.listenTo(
            t.plugins.get("ClipboardPipeline"),
            "inputTransformation",
            () => {
              const t = e.selection.getFirstRange();
              const n = Sk.fromPosition(t.start);
              n.stickiness = "toPrevious";
              const i = Sk.fromPosition(t.end);
              i.stickiness = "toNext";
              e.once(
                "change:data",
                () => {
                  this._embedImageBetweenPositions(n, i);
                  n.detach();
                  i.detach();
                },
                { priority: "high" }
              );
            }
          );
          t.commands.get("undo").on(
            "execute",
            () => {
              if (this._timeoutId) {
                Xa.window.clearTimeout(this._timeoutId);
                this._positionToInsert.detach();
                this._timeoutId = null;
                this._positionToInsert = null;
              }
            },
            { priority: "high" }
          );
        }
        _embedImageBetweenPositions(t, e) {
          const n = this.editor;
          const i = new Ff(t, e);
          const o = i.getWalker({ ignoreElementEnd: true });
          const r = Object.fromEntries(
            n.model.document.selection.getAttributes()
          );
          const s = this.editor.plugins.get("ImageUtils");
          let a = "";
          for (const t of o) {
            if (t.item.is("$textProxy")) {
              a += t.item.data;
            }
          }
          a = a.trim();
          if (!a.match(JS)) {
            i.detach();
            return;
          }
          this._positionToInsert = Sk.fromPosition(t);
          this._timeoutId = Xa.window.setTimeout(() => {
            const t = n.commands.get("insertImage");
            if (!t.isEnabled) {
              i.detach();
              return;
            }
            n.model.change((t) => {
              this._timeoutId = null;
              t.remove(i);
              i.detach();
              let e;
              if (this._positionToInsert.root.rootName !== "$graveyard") {
                e = this._positionToInsert.toPosition();
              }
              s.insertImage({ ...r, src: a }, e);
              this._positionToInsert.detach();
              this._positionToInsert = null;
            });
            n.plugins.get("Delete").requestUndoOnBackspace();
          }, 100);
        }
      }
      function tT(t, e, n) {
        var i = t.length;
        n = n === undefined ? i : n;
        return !e && n >= i ? t : Ud(t, e, n);
      }
      const eT = tT;
      var nT = "\\\\ud800-\\\\udfff",
        iT = "\\\\u0300-\\\\u036f",
        oT = "\\\\ufe20-\\\\ufe2f",
        rT = "\\\\u20d0-\\\\u20ff",
        sT = iT + oT + rT,
        aT = "\\\\ufe0e\\\\ufe0f";
      var cT = "\\\\u200d";
      var lT = RegExp("[" + cT + nT + sT + aT + "]");
      function dT(t) {
        return lT.test(t);
      }
      const uT = dT;
      function hT(t) {
        return t.split("");
      }
      const mT = hT;
      var gT = "\\\\ud800-\\\\udfff",
        fT = "\\\\u0300-\\\\u036f",
        pT = "\\\\ufe20-\\\\ufe2f",
        bT = "\\\\u20d0-\\\\u20ff",
        kT = fT + pT + bT,
        wT = "\\\\ufe0e\\\\ufe0f";
      var AT = "[" + gT + "]",
        CT = "[" + kT + "]",
        _T = "\\\\ud83c[\\\\udffb-\\\\udfff]",
        vT = "(?:" + CT + "|" + _T + ")",
        yT = "[^" + gT + "]",
        xT = "(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}",
        ET = "[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]",
        DT = "\\\\u200d";
      var ST = vT + "?",
        TT = "[" + wT + "]?",
        IT = "(?:" + DT + "(?:" + [yT, xT, ET].join("|") + ")" + TT + ST + ")*",
        MT = TT + ST + IT,
        BT = "(?:" + [yT + CT + "?", CT, xT, ET, AT].join("|") + ")";
      var LT = RegExp(_T + "(?=" + _T + ")|" + BT + MT, "g");
      function NT(t) {
        return t.match(LT) || [];
      }
      const zT = NT;
      function PT(t) {
        return uT(t) ? zT(t) : mT(t);
      }
      const RT = PT;
      function OT(t) {
        return function (e) {
          e = Bd(e);
          var n = uT(e) ? RT(e) : undefined;
          var i = n ? n[0] : e.charAt(0);
          var o = n ? eT(n, 1).join("") : e.slice(1);
          return i[t]() + o;
        };
      }
      const jT = OT;
      var FT = jT("toUpperCase");
      const VT = FT;
      const HT = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g;
      const UT =
        /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
      const qT =
        /^[\\S]+@((?![-_])(?:[-\\w\\u00a1-\\uffff]{0,63}[^-_]\\.))+(?:[a-z\\u00a1-\\uffff]{2,})$/i;
      const WT = /^((\\w+:(\\/{2,})?)|(\\W))/i;
      const GT = "Ctrl+K";
      function $T(t) {
        return t.is("attributeElement") && !!t.getCustomProperty("link");
      }
      function KT(t, { writer: e }) {
        const n = e.createAttributeElement("a", { href: t }, { priority: 5 });
        e.setCustomProperty("link", true, n);
        return n;
      }
      function YT(t) {
        t = String(t);
        return ZT(t) ? t : "#";
      }
      function ZT(t) {
        const e = t.replace(HT, "");
        return e.match(UT);
      }
      function QT(t, e) {
        const n = {
          "Open in a new tab": t("Open in a new tab"),
          Downloadable: t("Downloadable"),
        };
        e.forEach((t) => {
          if (t.label && n[t.label]) {
            t.label = n[t.label];
          }
          return t;
        });
        return e;
      }
      function JT(t) {
        const e = [];
        if (t) {
          for (const [n, i] of Object.entries(t)) {
            const t = Object.assign({}, i, { id: \`link\${VT(n)}\` });
            e.push(t);
          }
        }
        return e;
      }
      function XT(t, e) {
        if (!t) {
          return false;
        }
        return e.checkAttribute(t.name, "linkHref");
      }
      function tI(t) {
        return qT.test(t);
      }
      function eI(t, e) {
        const n = tI(t) ? "mailto:" : e;
        const i = !!n && !nI(t);
        return t && i ? n + t : t;
      }
      function nI(t) {
        return WT.test(t);
      }
      function iI(t) {
        window.open(t, "_blank", "noopener");
      }
      const oI = 4;
      const rI = new RegExp(
        "(^|\\\\s)" +
          "(" +
          "(" +
          "(?:(?:(?:https?|ftp):)?\\\\/\\\\/)" +
          "(?:\\\\S+(?::\\\\S*)?@)?" +
          "(?:" +
          "(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])" +
          "(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}" +
          "(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))" +
          "|" +
          "(" +
          "((?!www\\\\.)|(www\\\\.))" +
          "(?![-_])(?:[-_a-z0-9\\\\u00a1-\\\\uffff]{1,63}\\\\.)+" +
          "(?:[a-z\\\\u00a1-\\\\uffff]{2,63})" +
          ")" +
          ")" +
          "(?::\\\\d{2,5})?" +
          "(?:[/?#]\\\\S*)?" +
          ")" +
          "|" +
          "(" +
          "(www.|(\\\\S+@))" +
          "((?![-_])(?:[-_a-z0-9\\\\u00a1-\\\\uffff]{1,63}\\\\.))+" +
          "(?:[a-z\\\\u00a1-\\\\uffff]{2,63})" +
          ")" +
          ")$",
        "i"
      );
      const sI = 2;
      class aI extends Cl {
        static get requires() {
          return [Jx];
        }
        static get pluginName() {
          return "AutoLink";
        }
        init() {
          const t = this.editor;
          const e = t.model.document.selection;
          e.on("change:range", () => {
            this.isEnabled = !e.anchor.parent.is("element", "codeBlock");
          });
          this._enableTypingHandling();
        }
        afterInit() {
          this._enableEnterHandling();
          this._enableShiftEnterHandling();
        }
        _enableTypingHandling() {
          const t = this.editor;
          const e = new eE(t.model, (t) => {
            if (!cI(t)) {
              return;
            }
            const e = lI(t.substr(0, t.length - 1));
            if (e) {
              return { url: e };
            }
          });
          e.on("matched:data", (e, n) => {
            const { batch: i, range: o, url: r } = n;
            if (!i.isTyping) {
              return;
            }
            const s = o.end.getShiftedBy(-1);
            const a = s.getShiftedBy(-r.length);
            const c = t.model.createRange(a, s);
            this._applyAutoLink(r, c);
          });
          e.bind("isEnabled").to(this);
        }
        _enableEnterHandling() {
          const t = this.editor;
          const e = t.model;
          const n = t.commands.get("enter");
          if (!n) {
            return;
          }
          n.on("execute", () => {
            const t = e.document.selection.getFirstPosition();
            if (!t.parent.previousSibling) {
              return;
            }
            const n = e.createRangeIn(t.parent.previousSibling);
            this._checkAndApplyAutoLinkOnRange(n);
          });
        }
        _enableShiftEnterHandling() {
          const t = this.editor;
          const e = t.model;
          const n = t.commands.get("shiftEnter");
          if (!n) {
            return;
          }
          n.on("execute", () => {
            const t = e.document.selection.getFirstPosition();
            const n = e.createRange(
              e.createPositionAt(t.parent, 0),
              t.getShiftedBy(-1)
            );
            this._checkAndApplyAutoLinkOnRange(n);
          });
        }
        _checkAndApplyAutoLinkOnRange(t) {
          const e = this.editor.model;
          const { text: n, range: i } = tE(t, e);
          const o = lI(n);
          if (o) {
            const t = e.createRange(i.end.getShiftedBy(-o.length), i.end);
            this._applyAutoLink(o, t);
          }
        }
        _applyAutoLink(t, e) {
          const n = this.editor.model;
          const i = this.editor.config.get("link.defaultProtocol");
          const o = eI(t, i);
          if (!this.isEnabled || !dI(e, n) || !nI(o) || uI(e)) {
            return;
          }
          this._persistAutoLink(o, e);
        }
        _persistAutoLink(t, e) {
          const n = this.editor.model;
          const i = this.editor.plugins.get("Delete");
          n.enqueueChange((o) => {
            o.setAttribute("linkHref", t, e);
            n.enqueueChange(() => {
              i.requestUndoOnBackspace();
            });
          });
        }
      }
      function cI(t) {
        return (
          t.length > oI && t[t.length - 1] === " " && t[t.length - 2] !== " "
        );
      }
      function lI(t) {
        const e = rI.exec(t);
        return e ? e[sI] : null;
      }
      function dI(t, e) {
        return e.schema.checkAttributeInSelection(
          e.createSelection(t),
          "linkHref"
        );
      }
      function uI(t) {
        const e = t.start.nodeAfter;
        return e && e.hasAttribute("linkHref");
      }
      class hI extends dt() {
        constructor() {
          super();
          const t = new window.FileReader();
          this._reader = t;
          this._data = undefined;
          this.set("loaded", 0);
          t.onprogress = (t) => {
            this.loaded = t.loaded;
          };
        }
        get error() {
          return this._reader.error;
        }
        get data() {
          return this._data;
        }
        read(t) {
          const e = this._reader;
          this.total = t.size;
          return new Promise((n, i) => {
            e.onload = () => {
              const t = e.result;
              this._data = t;
              n(t);
            };
            e.onerror = () => {
              i("error");
            };
            e.onabort = () => {
              i("aborted");
            };
            this._reader.readAsDataURL(t);
          });
        }
        abort() {
          this._reader.abort();
        }
      }
      class mI extends Cl {
        static get pluginName() {
          return "FileRepository";
        }
        static get requires() {
          return [VC];
        }
        init() {
          this.loaders = new rl();
          this.loaders.on("change", () => this._updatePendingAction());
          this._loadersMap = new Map();
          this._pendingAction = null;
          this.set("uploaded", 0);
          this.set("uploadTotal", null);
          this.bind("uploadedPercent").to(
            this,
            "uploaded",
            this,
            "uploadTotal",
            (t, e) => (e ? (t / e) * 100 : 0)
          );
        }
        getLoader(t) {
          return this._loadersMap.get(t) || null;
        }
        createLoader(t) {
          if (!this.createUploadAdapter) {
            B("filerepository-no-upload-adapter");
            return null;
          }
          const e = new gI(Promise.resolve(t), this.createUploadAdapter);
          this.loaders.add(e);
          this._loadersMap.set(t, e);
          if (t instanceof Promise) {
            e.file
              .then((t) => {
                this._loadersMap.set(t, e);
              })
              .catch(() => {});
          }
          e.on("change:uploaded", () => {
            let t = 0;
            for (const e of this.loaders) {
              t += e.uploaded;
            }
            this.uploaded = t;
          });
          e.on("change:uploadTotal", () => {
            let t = 0;
            for (const e of this.loaders) {
              if (e.uploadTotal) {
                t += e.uploadTotal;
              }
            }
            this.uploadTotal = t;
          });
          return e;
        }
        destroyLoader(t) {
          const e = t instanceof gI ? t : this.getLoader(t);
          e._destroy();
          this.loaders.remove(e);
          this._loadersMap.forEach((t, n) => {
            if (t === e) {
              this._loadersMap.delete(n);
            }
          });
        }
        _updatePendingAction() {
          const t = this.editor.plugins.get(VC);
          if (this.loaders.length) {
            if (!this._pendingAction) {
              const e = this.editor.t;
              const n = (t) => \`\${e("Upload in progress")} \${parseInt(t)}%.\`;
              this._pendingAction = t.add(n(this.uploadedPercent));
              this._pendingAction
                .bind("message")
                .to(this, "uploadedPercent", n);
            }
          } else {
            t.remove(this._pendingAction);
            this._pendingAction = null;
          }
        }
      }
      class gI extends dt() {
        constructor(t, e) {
          super();
          this.id = E();
          this._filePromiseWrapper = this._createFilePromiseWrapper(t);
          this._adapter = e(this);
          this._reader = new hI();
          this.set("status", "idle");
          this.set("uploaded", 0);
          this.set("uploadTotal", null);
          this.bind("uploadedPercent").to(
            this,
            "uploaded",
            this,
            "uploadTotal",
            (t, e) => (e ? (t / e) * 100 : 0)
          );
          this.set("uploadResponse", null);
        }
        get file() {
          if (!this._filePromiseWrapper) {
            return Promise.resolve(null);
          } else {
            return this._filePromiseWrapper.promise.then((t) =>
              this._filePromiseWrapper ? t : null
            );
          }
        }
        get data() {
          return this._reader.data;
        }
        read() {
          if (this.status != "idle") {
            throw new M("filerepository-read-wrong-status", this);
          }
          this.status = "reading";
          return this.file
            .then((t) => this._reader.read(t))
            .then((t) => {
              if (this.status !== "reading") {
                throw this.status;
              }
              this.status = "idle";
              return t;
            })
            .catch((t) => {
              if (t === "aborted") {
                this.status = "aborted";
                throw "aborted";
              }
              this.status = "error";
              throw this._reader.error ? this._reader.error : t;
            });
        }
        upload() {
          if (this.status != "idle") {
            throw new M("filerepository-upload-wrong-status", this);
          }
          this.status = "uploading";
          return this.file
            .then(() => this._adapter.upload())
            .then((t) => {
              this.uploadResponse = t;
              this.status = "idle";
              return t;
            })
            .catch((t) => {
              if (this.status === "aborted") {
                throw "aborted";
              }
              this.status = "error";
              throw t;
            });
        }
        abort() {
          const t = this.status;
          this.status = "aborted";
          if (!this._filePromiseWrapper.isFulfilled) {
            this._filePromiseWrapper.promise.catch(() => {});
            this._filePromiseWrapper.rejecter("aborted");
          } else if (t == "reading") {
            this._reader.abort();
          } else if (t == "uploading" && this._adapter.abort) {
            this._adapter.abort();
          }
          this._destroy();
        }
        _destroy() {
          this._filePromiseWrapper = undefined;
          this._reader = undefined;
          this._adapter = undefined;
          this.uploadResponse = undefined;
        }
        _createFilePromiseWrapper(t) {
          const e = {};
          e.promise = new Promise((n, i) => {
            e.rejecter = i;
            e.isFulfilled = false;
            t.then((t) => {
              e.isFulfilled = true;
              n(t);
            }).catch((t) => {
              e.isFulfilled = true;
              i(t);
            });
          });
          return e;
        }
      }
      class fI extends Cl {
        static get requires() {
          return [mI];
        }
        static get pluginName() {
          return "Base64UploadAdapter";
        }
        init() {
          this.editor.plugins.get(mI).createUploadAdapter = (t) => new pI(t);
        }
      }
      class pI {
        constructor(t) {
          this.loader = t;
        }
        upload() {
          return new Promise((t, e) => {
            const n = (this.reader = new window.FileReader());
            n.addEventListener("load", () => {
              t({ default: n.result });
            });
            n.addEventListener("error", (t) => {
              e(t);
            });
            n.addEventListener("abort", () => {
              e();
            });
            this.loader.file.then((t) => {
              n.readAsDataURL(t);
            });
          });
        }
        abort() {
          this.reader.abort();
        }
      }
      class bI extends vl {
        refresh() {
          this.value = this._getValue();
          this.isEnabled = this._checkEnabled();
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.schema;
          const i = e.document.selection;
          const o = Array.from(i.getSelectedBlocks());
          const r = t.forceValue === undefined ? !this.value : t.forceValue;
          e.change((t) => {
            if (!r) {
              this._removeQuote(t, o.filter(kI));
            } else {
              const e = o.filter((t) => kI(t) || AI(n, t));
              this._applyQuote(t, e);
            }
          });
        }
        _getValue() {
          const t = this.editor.model.document.selection;
          const e = sl(t.getSelectedBlocks());
          return !!(e && kI(e));
        }
        _checkEnabled() {
          if (this.value) {
            return true;
          }
          const t = this.editor.model.document.selection;
          const e = this.editor.model.schema;
          const n = sl(t.getSelectedBlocks());
          if (!n) {
            return false;
          }
          return AI(e, n);
        }
        _removeQuote(t, e) {
          wI(t, e)
            .reverse()
            .forEach((e) => {
              if (e.start.isAtStart && e.end.isAtEnd) {
                t.unwrap(e.start.parent);
                return;
              }
              if (e.start.isAtStart) {
                const n = t.createPositionBefore(e.start.parent);
                t.move(e, n);
                return;
              }
              if (!e.end.isAtEnd) {
                t.split(e.end);
              }
              const n = t.createPositionAfter(e.end.parent);
              t.move(e, n);
            });
        }
        _applyQuote(t, e) {
          const n = [];
          wI(t, e)
            .reverse()
            .forEach((e) => {
              let i = kI(e.start);
              if (!i) {
                i = t.createElement("blockQuote");
                t.wrap(e, i);
              }
              n.push(i);
            });
          n.reverse().reduce((e, n) => {
            if (e.nextSibling == n) {
              t.merge(t.createPositionAfter(e));
              return e;
            }
            return n;
          });
        }
      }
      function kI(t) {
        return t.parent.name == "blockQuote" ? t.parent : null;
      }
      function wI(t, e) {
        let n;
        let i = 0;
        const o = [];
        while (i < e.length) {
          const r = e[i];
          const s = e[i + 1];
          if (!n) {
            n = t.createPositionBefore(r);
          }
          if (!s || r.nextSibling != s) {
            o.push(t.createRange(n, t.createPositionAfter(r)));
            n = null;
          }
          i++;
        }
        return o;
      }
      function AI(t, e) {
        const n = t.checkChild(e.parent, "blockQuote");
        const i = t.checkChild(["$root", "blockQuote"], e);
        return n && i;
      }
      class CI extends Cl {
        static get pluginName() {
          return "BlockQuoteEditing";
        }
        static get requires() {
          return [UE, Jx];
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          t.commands.add("blockQuote", new bI(t));
          e.register("blockQuote", { inheritAllFrom: "$container" });
          t.conversion.elementToElement({
            model: "blockQuote",
            view: "blockquote",
          });
          t.model.document.registerPostFixer((n) => {
            const i = t.model.document.differ.getChanges();
            for (const t of i) {
              if (t.type == "insert") {
                const i = t.position.nodeAfter;
                if (!i) {
                  continue;
                }
                if (i.is("element", "blockQuote") && i.isEmpty) {
                  n.remove(i);
                  return true;
                } else if (
                  i.is("element", "blockQuote") &&
                  !e.checkChild(t.position, i)
                ) {
                  n.unwrap(i);
                  return true;
                } else if (i.is("element")) {
                  const t = n.createRangeIn(i);
                  for (const i of t.getItems()) {
                    if (
                      i.is("element", "blockQuote") &&
                      !e.checkChild(n.createPositionBefore(i), i)
                    ) {
                      n.unwrap(i);
                      return true;
                    }
                  }
                }
              } else if (t.type == "remove") {
                const e = t.position.parent;
                if (e.is("element", "blockQuote") && e.isEmpty) {
                  n.remove(e);
                  return true;
                }
              }
            }
            return false;
          });
          const n = this.editor.editing.view.document;
          const i = t.model.document.selection;
          const o = t.commands.get("blockQuote");
          this.listenTo(
            n,
            "enter",
            (e, n) => {
              if (!i.isCollapsed || !o.value) {
                return;
              }
              const r = i.getLastPosition().parent;
              if (r.isEmpty) {
                t.execute("blockQuote");
                t.editing.view.scrollToTheSelection();
                n.preventDefault();
                e.stop();
              }
            },
            { context: "blockquote" }
          );
          this.listenTo(
            n,
            "delete",
            (e, n) => {
              if (n.direction != "backward" || !i.isCollapsed || !o.value) {
                return;
              }
              const r = i.getLastPosition().parent;
              if (r.isEmpty && !r.previousSibling) {
                t.execute("blockQuote");
                t.editing.view.scrollToTheSelection();
                n.preventDefault();
                e.stop();
              }
            },
            { context: "blockquote" }
          );
        }
      }
      var _I = n(636);
      var vI = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      vI.insert = "head";
      vI.singleton = true;
      var yI = Il()(_I.Z, vI);
      const xI = _I.Z.locals || {};
      class EI extends Cl {
        static get pluginName() {
          return "BlockQuoteUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add("blockQuote", (n) => {
            const i = t.commands.get("blockQuote");
            const o = new R_(n);
            o.set({
              label: e("Block quote"),
              icon: __.quote,
              tooltip: true,
              isToggleable: true,
            });
            o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
            this.listenTo(o, "execute", () => {
              t.execute("blockQuote");
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class DI extends Cl {
        static get requires() {
          return [CI, EI];
        }
        static get pluginName() {
          return "BlockQuote";
        }
      }
      class SI extends vl {
        constructor(t, e) {
          super(t);
          this.attributeKey = e;
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.value = this._getValueFromFirstAllowedNode();
          this.isEnabled = t.schema.checkAttributeInSelection(
            e.selection,
            this.attributeKey
          );
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const i = n.selection;
          const o = t.forceValue === undefined ? !this.value : t.forceValue;
          e.change((t) => {
            if (i.isCollapsed) {
              if (o) {
                t.setSelectionAttribute(this.attributeKey, true);
              } else {
                t.removeSelectionAttribute(this.attributeKey);
              }
            } else {
              const n = e.schema.getValidRanges(
                i.getRanges(),
                this.attributeKey
              );
              for (const e of n) {
                if (o) {
                  t.setAttribute(this.attributeKey, o, e);
                } else {
                  t.removeAttribute(this.attributeKey, e);
                }
              }
            }
          });
        }
        _getValueFromFirstAllowedNode() {
          const t = this.editor.model;
          const e = t.schema;
          const n = t.document.selection;
          if (n.isCollapsed) {
            return n.hasAttribute(this.attributeKey);
          }
          for (const t of n.getRanges()) {
            for (const n of t.getItems()) {
              if (e.checkAttribute(n, this.attributeKey)) {
                return n.hasAttribute(this.attributeKey);
              }
            }
          }
          return false;
        }
      }
      const TI = "bold";
      class II extends Cl {
        static get pluginName() {
          return "BoldEditing";
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: TI });
          t.model.schema.setAttributeProperties(TI, {
            isFormatting: true,
            copyOnEnter: true,
          });
          t.conversion.attributeToElement({
            model: TI,
            view: "strong",
            upcastAlso: [
              "b",
              (t) => {
                const e = t.getStyle("font-weight");
                if (!e) {
                  return null;
                }
                if (e == "bold" || Number(e) >= 600) {
                  return { name: true, styles: ["font-weight"] };
                }
              },
            ],
          });
          t.commands.add(TI, new SI(t, TI));
          t.keystrokes.set("CTRL+B", TI);
        }
      }
      const MI = "bold";
      class BI extends Cl {
        static get pluginName() {
          return "BoldUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(MI, (n) => {
            const i = t.commands.get(MI);
            const o = new R_(n);
            o.set({
              label: e("Bold"),
              icon: __.bold,
              keystroke: "CTRL+B",
              tooltip: true,
              isToggleable: true,
            });
            o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
            this.listenTo(o, "execute", () => {
              t.execute(MI);
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class LI extends Cl {
        static get requires() {
          return [II, BI];
        }
        static get pluginName() {
          return "Bold";
        }
      }
      const NI = { autoRefresh: true };
      const zI = 36e5;
      class PI {
        constructor(t, e = NI) {
          if (!t) {
            throw new M("token-missing-token-url", this);
          }
          if (e.initValue) {
            this._validateTokenValue(e.initValue);
          }
          this.set("value", e.initValue);
          if (typeof t === "function") {
            this._refresh = t;
          } else {
            this._refresh = () => RI(t);
          }
          this._options = Object.assign({}, NI, e);
        }
        init() {
          return new Promise((t, e) => {
            if (!this.value) {
              this.refreshToken().then(t).catch(e);
              return;
            }
            if (this._options.autoRefresh) {
              this._registerRefreshTokenTimeout();
            }
            t(this);
          });
        }
        refreshToken() {
          return this._refresh()
            .then((t) => {
              this._validateTokenValue(t);
              this.set("value", t);
              if (this._options.autoRefresh) {
                this._registerRefreshTokenTimeout();
              }
            })
            .then(() => this);
        }
        destroy() {
          clearTimeout(this._tokenRefreshTimeout);
        }
        _validateTokenValue(t) {
          const e = typeof t === "string";
          const n = !/^".*"$/.test(t);
          const i = e && t.split(".").length === 3;
          if (!(n && i)) {
            throw new M("token-not-in-jwt-format", this);
          }
        }
        _registerRefreshTokenTimeout() {
          const t = this._getTokenRefreshTimeoutTime();
          clearTimeout(this._tokenRefreshTimeout);
          this._tokenRefreshTimeout = setTimeout(() => {
            this.refreshToken();
          }, t);
        }
        _getTokenRefreshTimeoutTime() {
          try {
            const [, t] = this.value.split(".");
            const { exp: e } = JSON.parse(atob(t));
            if (!e) {
              return zI;
            }
            const n = Math.floor((e * 1e3 - Date.now()) / 2);
            return n;
          } catch (t) {
            return zI;
          }
        }
        static create(t, e = NI) {
          const n = new PI(t, e);
          return n.init();
        }
      }
      C(PI, dt);
      function RI(t) {
        return new Promise((e, n) => {
          const i = new XMLHttpRequest();
          i.open("GET", t);
          i.addEventListener("load", () => {
            const t = i.status;
            const o = i.response;
            if (t < 200 || t > 299) {
              return n(new M("token-cannot-download-new-token", null));
            }
            return e(o);
          });
          i.addEventListener("error", () => n(new Error("Network Error")));
          i.addEventListener("abort", () => n(new Error("Abort")));
          i.send();
        });
      }
      const OI = PI;
      const jI = /^data:(\\S*?);base64,/;
      class FI {
        constructor(t, e, n) {
          if (!t) {
            throw new M("fileuploader-missing-file", null);
          }
          if (!e) {
            throw new M("fileuploader-missing-token", null);
          }
          if (!n) {
            throw new M("fileuploader-missing-api-address", null);
          }
          this.file = HI(t) ? VI(t) : t;
          this._token = e;
          this._apiAddress = n;
        }
        onProgress(t) {
          this.on("progress", (e, n) => t(n));
          return this;
        }
        onError(t) {
          this.once("error", (e, n) => t(n));
          return this;
        }
        abort() {
          this.xhr.abort();
        }
        send() {
          this._prepareRequest();
          this._attachXHRListeners();
          return this._sendRequest();
        }
        _prepareRequest() {
          const t = new XMLHttpRequest();
          t.open("POST", this._apiAddress);
          t.setRequestHeader("Authorization", this._token.value);
          t.responseType = "json";
          this.xhr = t;
        }
        _attachXHRListeners() {
          const t = this;
          const e = this.xhr;
          e.addEventListener("error", n("Network Error"));
          e.addEventListener("abort", n("Abort"));
          if (e.upload) {
            e.upload.addEventListener("progress", (t) => {
              if (t.lengthComputable) {
                this.fire("progress", { total: t.total, uploaded: t.loaded });
              }
            });
          }
          e.addEventListener("load", () => {
            const t = e.status;
            const n = e.response;
            if (t < 200 || t > 299) {
              return this.fire("error", n.message || n.error);
            }
          });
          function n(e) {
            return () => t.fire("error", e);
          }
        }
        _sendRequest() {
          const t = new FormData();
          const e = this.xhr;
          t.append("file", this.file);
          return new Promise((n, i) => {
            e.addEventListener("load", () => {
              const t = e.status;
              const o = e.response;
              if (t < 200 || t > 299) {
                if (o.message) {
                  return i(
                    new M("fileuploader-uploading-data-failed", this, {
                      message: o.message,
                    })
                  );
                }
                return i(o.error);
              }
              return n(o);
            });
            e.addEventListener("error", () => i(new Error("Network Error")));
            e.addEventListener("abort", () => i(new Error("Abort")));
            e.send(t);
          });
        }
      }
      C(FI, q);
      function VI(t, e = 512) {
        try {
          const n = t.match(jI)[1];
          const i = atob(t.replace(jI, ""));
          const o = [];
          for (let t = 0; t < i.length; t += e) {
            const n = i.slice(t, t + e);
            const r = new Array(n.length);
            for (let t = 0; t < n.length; t++) {
              r[t] = n.charCodeAt(t);
            }
            o.push(new Uint8Array(r));
          }
          return new Blob(o, { type: n });
        } catch (t) {
          throw new M("fileuploader-decoding-image-data-error", null);
        }
      }
      function HI(t) {
        if (typeof t !== "string") {
          return false;
        }
        const e = t.match(jI);
        return !!(e && e.length);
      }
      class UI {
        constructor(t, e) {
          if (!t) {
            throw new M("uploadgateway-missing-token", null);
          }
          if (!e) {
            throw new M("uploadgateway-missing-api-address", null);
          }
          this._token = t;
          this._apiAddress = e;
        }
        upload(t) {
          return new FI(t, this._token, this._apiAddress);
        }
      }
      class qI extends Sl {
        static get pluginName() {
          return "CloudServicesCore";
        }
        createToken(t, e) {
          return new OI(t, e);
        }
        createUploadGateway(t, e) {
          return new UI(t, e);
        }
      }
      class WI extends Sl {
        static get pluginName() {
          return "CloudServices";
        }
        static get requires() {
          return [qI];
        }
        init() {
          const t = this.context.config;
          const e = t.get("cloudServices") || {};
          for (const t in e) {
            this[t] = e[t];
          }
          this._tokens = new Map();
          if (!this.tokenUrl) {
            this.token = null;
            return;
          }
          this.token = this.context.plugins
            .get("CloudServicesCore")
            .createToken(this.tokenUrl);
          this._tokens.set(this.tokenUrl, this.token);
          return this.token.init();
        }
        registerTokenUrl(t) {
          if (this._tokens.has(t)) {
            return Promise.resolve(this.getTokenFor(t));
          }
          const e = this.context.plugins
            .get("CloudServicesCore")
            .createToken(t);
          this._tokens.set(t, e);
          return e.init();
        }
        getTokenFor(t) {
          const e = this._tokens.get(t);
          if (!e) {
            throw new M("cloudservices-token-not-registered", this);
          }
          return e;
        }
        destroy() {
          super.destroy();
          for (const t of this._tokens.values()) {
            t.destroy();
          }
        }
      }
      const GI = "code";
      const $I = "ck-code_selected";
      class KI extends Cl {
        static get pluginName() {
          return "CodeEditing";
        }
        static get requires() {
          return [nE];
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: GI });
          t.model.schema.setAttributeProperties(GI, {
            isFormatting: true,
            copyOnEnter: false,
          });
          t.conversion.attributeToElement({
            model: GI,
            view: "code",
            upcastAlso: { styles: { "word-wrap": "break-word" } },
          });
          t.commands.add(GI, new SI(t, GI));
          t.plugins.get(nE).registerAttribute(GI);
          yE(t, GI, "code", $I);
        }
      }
      const YI =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 5.7 5.2 3.9v1.3l-5.6 4c-.1.2-.3.2-.5.2-.3-.1-.6-.7-.6-1l.3-.4 4.7-3.5L11.5 7l-.2-.2c-.1-.3-.1-.6 0-.8.2-.2.5-.4.8-.4a.8.8 0 0 1 .4.1zm-5.2 0L2 9.6v1.3l5.6 4c.1.2.3.2.5.2.3-.1.7-.7.6-1 0-.1 0-.3-.2-.4l-5-3.5L8.2 7l.2-.2c.1-.3.1-.6 0-.8-.2-.2-.5-.4-.8-.4a.8.8 0 0 0-.3.1z"/></svg>';
      var ZI = n(8180);
      var QI = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      QI.insert = "head";
      QI.singleton = true;
      var JI = Il()(ZI.Z, QI);
      const XI = ZI.Z.locals || {};
      const tM = "code";
      class eM extends Cl {
        static get pluginName() {
          return "CodeUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(tM, (n) => {
            const i = t.commands.get(tM);
            const o = new R_(n);
            o.set({
              label: e("Code"),
              icon: YI,
              tooltip: true,
              isToggleable: true,
            });
            o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
            this.listenTo(o, "execute", () => {
              t.execute(tM);
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class nM extends Cl {
        static get requires() {
          return [KI, eM];
        }
        static get pluginName() {
          return "Code";
        }
      }
      function iM(t) {
        const e = t.t;
        const n = t.config.get("codeBlock.languages");
        for (const t of n) {
          if (t.label === "Plain text") {
            t.label = e("Plain text");
          }
          if (t.class === undefined) {
            t.class = \`language-\${t.language}\`;
          }
        }
        return n;
      }
      function oM(t, e, n) {
        const i = {};
        for (const o of t) {
          if (e === "class") {
            i[o[e].split(" ").shift()] = o[n];
          } else {
            i[o[e]] = o[n];
          }
        }
        return i;
      }
      function rM(t) {
        return t.data.match(/^(\\s*)/)[0];
      }
      function sM(t, e) {
        const n = t.createDocumentFragment();
        const i = e.split("\\n");
        const o = i.reduce((e, n, o) => {
          e.push(n);
          if (o < i.length - 1) {
            e.push(t.createElement("br"));
          }
          return e;
        }, []);
        t.appendChild(o, n);
        return n;
      }
      function aM(t) {
        const e = t.document.selection;
        const n = [];
        if (e.isCollapsed) {
          n.push(e.anchor);
        } else {
          const i = e
            .getFirstRange()
            .getWalker({ ignoreElementEnd: true, direction: "backward" });
          for (const { item: e } of i) {
            if (e.is("$textProxy") && e.parent.is("element", "codeBlock")) {
              const i = rM(e.textNode);
              const { parent: o, startOffset: r } = e.textNode;
              const s = t.createPositionAt(o, r + i.length);
              n.push(s);
            }
          }
        }
        return n;
      }
      function cM(t) {
        const e = sl(t.getSelectedBlocks());
        return e && e.is("element", "codeBlock");
      }
      function lM(t, e) {
        if (e.is("rootElement") || t.isLimit(e)) {
          return false;
        }
        return t.checkChild(e.parent, "codeBlock");
      }
      class dM extends vl {
        constructor(t) {
          super(t);
          this._lastLanguage = null;
        }
        refresh() {
          this.value = this._getValue();
          this.isEnabled = this._checkEnabled();
        }
        execute(t = {}) {
          const e = this.editor;
          const n = e.model;
          const i = n.document.selection;
          const o = iM(e);
          const r = o[0];
          const s = Array.from(i.getSelectedBlocks());
          const a = t.forceValue === undefined ? !this.value : t.forceValue;
          const c = uM(t, this._lastLanguage, r.language);
          n.change((t) => {
            if (a) {
              this._applyCodeBlock(t, s, c);
            } else {
              this._removeCodeBlock(t, s);
            }
          });
        }
        _getValue() {
          const t = this.editor.model.document.selection;
          const e = sl(t.getSelectedBlocks());
          const n = !!(e && e.is("element", "codeBlock"));
          return n ? e.getAttribute("language") : false;
        }
        _checkEnabled() {
          if (this.value) {
            return true;
          }
          const t = this.editor.model.document.selection;
          const e = this.editor.model.schema;
          const n = sl(t.getSelectedBlocks());
          if (!n) {
            return false;
          }
          return lM(e, n);
        }
        _applyCodeBlock(t, e, n) {
          this._lastLanguage = n;
          const i = this.editor.model.schema;
          const o = e.filter((t) => lM(i, t));
          for (const e of o) {
            t.rename(e, "codeBlock");
            t.setAttribute("language", n, e);
            i.removeDisallowedAttributes([e], t);
            Array.from(e.getChildren())
              .filter((t) => !i.checkChild(e, t))
              .forEach((e) => t.remove(e));
          }
          o.reverse().forEach((e, n) => {
            const i = o[n + 1];
            if (e.previousSibling === i) {
              t.appendElement("softBreak", i);
              t.merge(t.createPositionBefore(e));
            }
          });
        }
        _removeCodeBlock(t, e) {
          const n = e.filter((t) => t.is("element", "codeBlock"));
          for (const e of n) {
            const n = t.createRangeOn(e);
            for (const e of Array.from(n.getItems()).reverse()) {
              if (
                e.is("element", "softBreak") &&
                e.parent.is("element", "codeBlock")
              ) {
                const { position: n } = t.split(t.createPositionBefore(e));
                t.rename(n.nodeAfter, "paragraph");
                t.removeAttribute("language", n.nodeAfter);
                t.remove(e);
              }
            }
            t.rename(e, "paragraph");
            t.removeAttribute("language", e);
          }
        }
      }
      function uM(t, e, n) {
        if (t.language) {
          return t.language;
        }
        if (t.usePreviousLanguageChoice && e) {
          return e;
        }
        return n;
      }
      class hM extends vl {
        constructor(t) {
          super(t);
          this._indentSequence = t.config.get("codeBlock.indentSequence");
        }
        refresh() {
          this.isEnabled = this._checkEnabled();
        }
        execute() {
          const t = this.editor;
          const e = t.model;
          e.change((t) => {
            const n = aM(e);
            for (const i of n) {
              const n = t.createText(this._indentSequence);
              e.insertContent(n, i);
            }
          });
        }
        _checkEnabled() {
          if (!this._indentSequence) {
            return false;
          }
          return cM(this.editor.model.document.selection);
        }
      }
      class mM extends vl {
        constructor(t) {
          super(t);
          this._indentSequence = t.config.get("codeBlock.indentSequence");
        }
        refresh() {
          this.isEnabled = this._checkEnabled();
        }
        execute() {
          const t = this.editor;
          const e = t.model;
          e.change(() => {
            const t = aM(e);
            for (const n of t) {
              const t = gM(e, n, this._indentSequence);
              if (t) {
                e.deleteContent(e.createSelection(t));
              }
            }
          });
        }
        _checkEnabled() {
          if (!this._indentSequence) {
            return false;
          }
          const t = this.editor.model;
          if (!cM(t.document.selection)) {
            return false;
          }
          return aM(t).some((e) => gM(t, e, this._indentSequence));
        }
      }
      function gM(t, e, n) {
        const i = fM(e);
        if (!i) {
          return null;
        }
        const o = rM(i);
        const r = o.lastIndexOf(n);
        if (r + n.length !== o.length) {
          return null;
        }
        if (r === -1) {
          return null;
        }
        const { parent: s, startOffset: a } = i;
        return t.createRange(
          t.createPositionAt(s, a + r),
          t.createPositionAt(s, a + r + n.length)
        );
      }
      function fM(t) {
        let e = t.parent.getChild(t.index);
        if (!e || e.is("element", "softBreak")) {
          e = t.nodeBefore;
        }
        if (!e || e.is("element", "softBreak")) {
          return null;
        }
        return e;
      }
      function pM(t, e, n = false) {
        const i = oM(e, "language", "class");
        const o = oM(e, "language", "label");
        return (e, r, s) => {
          const { writer: a, mapper: c, consumable: l } = s;
          if (!l.consume(r.item, "insert")) {
            return;
          }
          const d = r.item.getAttribute("language");
          const u = c.toViewPosition(t.createPositionBefore(r.item));
          const h = {};
          if (n) {
            h["data-language"] = o[d];
            h.spellcheck = "false";
          }
          const m = a.createContainerElement("code", { class: i[d] || null });
          const g = a.createContainerElement("pre", h, m);
          a.insert(u, g);
          c.bindElements(r.item, m);
        };
      }
      function bM(t) {
        return (e, n, i) => {
          if (n.item.parent.name !== "codeBlock") {
            return;
          }
          const { writer: o, mapper: r, consumable: s } = i;
          if (!s.consume(n.item, "insert")) {
            return;
          }
          const a = r.toViewPosition(t.createPositionBefore(n.item));
          o.insert(a, o.createText("\\n"));
        };
      }
      function kM(t, e) {
        const n = oM(e, "class", "language");
        const i = e[0].language;
        return (t, e, o) => {
          const r = e.viewItem;
          const s = r.parent;
          if (!s || !s.is("element", "pre")) {
            return;
          }
          if (e.modelCursor.findAncestor("codeBlock")) {
            return;
          }
          const { consumable: a, writer: c } = o;
          if (!a.test(r, { name: true })) {
            return;
          }
          const l = c.createElement("codeBlock");
          const d = [...r.getClassNames()];
          if (!d.length) {
            d.push("");
          }
          for (const t of d) {
            const e = n[t];
            if (e) {
              c.setAttribute("language", e, l);
              break;
            }
          }
          if (!l.hasAttribute("language")) {
            c.setAttribute("language", i, l);
          }
          o.convertChildren(r, l);
          if (!o.safeInsert(l, e.modelCursor)) {
            return;
          }
          a.consume(r, { name: true });
          o.updateConversionResult(l, e);
        };
      }
      function wM() {
        return (t, e, { consumable: n, writer: i }) => {
          let o = e.modelCursor;
          if (!n.test(e.viewItem)) {
            return;
          }
          if (!o.findAncestor("codeBlock")) {
            return;
          }
          n.consume(e.viewItem);
          const r = e.viewItem.data;
          const s = r.split("\\n").map((t) => i.createText(t));
          const a = s[s.length - 1];
          for (const t of s) {
            i.insert(t, o);
            o = o.getShiftedBy(t.offsetSize);
            if (t !== a) {
              const t = i.createElement("softBreak");
              i.insert(t, o);
              o = i.createPositionAfter(t);
            }
          }
          e.modelRange = i.createRange(e.modelCursor, o);
          e.modelCursor = o;
        };
      }
      function AM() {
        return (t, e, { consumable: n }) => {
          const i = e.viewItem;
          if (i.findAncestor("pre")) {
            return;
          }
          const o = Array.from(i.getChildren());
          const r = o.find((t) => t.is("element", "code"));
          if (!r) {
            return;
          }
          for (const t of o) {
            if (t === r || !t.is("$text")) {
              continue;
            }
            n.consume(t, { name: true });
          }
        };
      }
      const CM = "paragraph";
      class _M extends Cl {
        static get pluginName() {
          return "CodeBlockEditing";
        }
        static get requires() {
          return [YE];
        }
        constructor(t) {
          super(t);
          t.config.define("codeBlock", {
            languages: [
              { language: "plaintext", label: "Plain text" },
              { language: "c", label: "C" },
              { language: "cs", label: "C#" },
              { language: "cpp", label: "C++" },
              { language: "css", label: "CSS" },
              { language: "diff", label: "Diff" },
              { language: "html", label: "HTML" },
              { language: "java", label: "Java" },
              { language: "javascript", label: "JavaScript" },
              { language: "php", label: "PHP" },
              { language: "python", label: "Python" },
              { language: "ruby", label: "Ruby" },
              { language: "typescript", label: "TypeScript" },
              { language: "xml", label: "XML" },
            ],
            indentSequence: "\\t",
          });
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.model;
          const i = t.editing.view;
          const o = t.plugins.has("DocumentListEditing");
          const r = iM(t);
          t.commands.add("codeBlock", new dM(t));
          t.commands.add("indentCodeBlock", new hM(t));
          t.commands.add("outdentCodeBlock", new mM(t));
          this.listenTo(
            i.document,
            "tab",
            (e, n) => {
              const i = n.shiftKey ? "outdentCodeBlock" : "indentCodeBlock";
              const o = t.commands.get(i);
              if (!o.isEnabled) {
                return;
              }
              t.execute(i);
              n.stopPropagation();
              n.preventDefault();
              e.stop();
            },
            { context: "pre" }
          );
          e.register("codeBlock", {
            allowWhere: "$block",
            allowChildren: "$text",
            isBlock: true,
            allowAttributes: ["language"],
          });
          e.addAttributeCheck((t, e) => {
            const n =
              t.endsWith("codeBlock") && e.startsWith("list") && e !== "list";
            if (o && n) {
              return true;
            }
            if (t.endsWith("codeBlock $text")) {
              return false;
            }
          });
          t.model.schema.addChildCheck((t, e) => {
            if (t.endsWith("codeBlock") && e.isObject) {
              return false;
            }
          });
          t.editing.downcastDispatcher.on("insert:codeBlock", pM(n, r, true));
          t.data.downcastDispatcher.on("insert:codeBlock", pM(n, r));
          t.data.downcastDispatcher.on("insert:softBreak", bM(n), {
            priority: "high",
          });
          t.data.upcastDispatcher.on("element:code", kM(i, r));
          t.data.upcastDispatcher.on("text", wM());
          t.data.upcastDispatcher.on("element:pre", AM(), { priority: "high" });
          this.listenTo(t.editing.view.document, "clipboardInput", (e, i) => {
            let o = n.createRange(n.document.selection.anchor);
            if (i.targetRanges) {
              o = t.editing.mapper.toModelRange(i.targetRanges[0]);
            }
            if (!o.start.parent.is("element", "codeBlock")) {
              return;
            }
            const r = i.dataTransfer.getData("text/plain");
            const s = new Fw(t.editing.view.document);
            i.content = sM(s, r);
          });
          this.listenTo(n, "getSelectedContent", (t, [i]) => {
            const o = i.anchor;
            if (
              i.isCollapsed ||
              !o.parent.is("element", "codeBlock") ||
              !o.hasSameParentAs(i.focus)
            ) {
              return;
            }
            n.change((n) => {
              const r = t.return;
              if (r.childCount > 1 || i.containsEntireContent(o.parent)) {
                const e = n.createElement(
                  "codeBlock",
                  o.parent.getAttributes()
                );
                n.append(r, e);
                const i = n.createDocumentFragment();
                n.append(e, i);
                t.return = i;
              } else {
                const t = r.getChild(0);
                if (e.checkAttribute(t, "code")) {
                  n.setAttribute("code", true, t);
                }
              }
            });
          });
        }
        afterInit() {
          const t = this.editor;
          const e = t.commands;
          const n = e.get("indent");
          const i = e.get("outdent");
          if (n) {
            n.registerChildCommand(e.get("indentCodeBlock"), {
              priority: "highest",
            });
          }
          if (i) {
            i.registerChildCommand(e.get("outdentCodeBlock"));
          }
          this.listenTo(
            t.editing.view.document,
            "enter",
            (e, n) => {
              const i = t.model.document.selection.getLastPosition().parent;
              if (!i.is("element", "codeBlock")) {
                return;
              }
              if (!yM(t, n.isSoft) && !xM(t, n.isSoft)) {
                vM(t);
              }
              n.preventDefault();
              e.stop();
            },
            { context: "pre" }
          );
        }
      }
      function vM(t) {
        const e = t.model;
        const n = e.document;
        const i = n.selection.getLastPosition();
        const o = i.nodeBefore || i.textNode;
        let r;
        if (o && o.is("$text")) {
          r = rM(o);
        }
        t.model.change((e) => {
          t.execute("shiftEnter");
          if (r) {
            e.insertText(r, n.selection.anchor);
          }
        });
      }
      function yM(t, e) {
        const n = t.model;
        const i = n.document;
        const o = t.editing.view;
        const r = i.selection.getLastPosition();
        const s = r.nodeAfter;
        if (e || !i.selection.isCollapsed || !r.isAtStart) {
          return false;
        }
        if (!DM(s)) {
          return false;
        }
        t.model.change((e) => {
          t.execute("enter");
          const n = i.selection.anchor.parent.previousSibling;
          e.rename(n, CM);
          e.setSelection(n, "in");
          t.model.schema.removeDisallowedAttributes([n], e);
          e.remove(s);
        });
        o.scrollToTheSelection();
        return true;
      }
      function xM(t, e) {
        const n = t.model;
        const i = n.document;
        const o = t.editing.view;
        const r = i.selection.getLastPosition();
        const s = r.nodeBefore;
        let a;
        if (
          e ||
          !i.selection.isCollapsed ||
          !r.isAtEnd ||
          !s ||
          !s.previousSibling
        ) {
          return false;
        }
        if (DM(s) && DM(s.previousSibling)) {
          a = n.createRange(
            n.createPositionBefore(s.previousSibling),
            n.createPositionAfter(s)
          );
        } else if (
          EM(s) &&
          DM(s.previousSibling) &&
          DM(s.previousSibling.previousSibling)
        ) {
          a = n.createRange(
            n.createPositionBefore(s.previousSibling.previousSibling),
            n.createPositionAfter(s)
          );
        } else if (
          EM(s) &&
          DM(s.previousSibling) &&
          EM(s.previousSibling.previousSibling) &&
          DM(s.previousSibling.previousSibling.previousSibling)
        ) {
          a = n.createRange(
            n.createPositionBefore(
              s.previousSibling.previousSibling.previousSibling
            ),
            n.createPositionAfter(s)
          );
        } else {
          return false;
        }
        t.model.change((e) => {
          e.remove(a);
          t.execute("enter");
          const n = i.selection.anchor.parent;
          e.rename(n, CM);
          t.model.schema.removeDisallowedAttributes([n], e);
        });
        o.scrollToTheSelection();
        return true;
      }
      function EM(t) {
        return t && t.is("$text") && !t.data.match(/\\S/);
      }
      function DM(t) {
        return t && t.is("element", "softBreak");
      }
      const SM =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.87 12.61a.75.75 0 0 1-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 0 1 .237.95l-.057.095a.75.75 0 0 1-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 0 1 1.047.174zm2.795-.231.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 0 1-.88-.151l-.07-.086-.058-.095a.75.75 0 0 1 .15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 0 1 .862-1.207zM16 0a2 2 0 0 1 2 2v9.354l-.663-.492-.837-.001V2a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3.118L7.156 19H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h14zM5.009 15l.003 1H3v-1h2.009zm2.188-2-1.471 1H5v-1h2.197zM10 11v.095L8.668 12H7v-1h3zm4-2v1H7V9h7zm0-2v1H7V7h7zm-4-2v1H5V5h5zM6 3v1H3V3h3z"/></svg>';
      var TM = n(9085);
      var IM = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      IM.insert = "head";
      IM.singleton = true;
      var MM = Il()(TM.Z, IM);
      const BM = TM.Z.locals || {};
      class LM extends Cl {
        static get pluginName() {
          return "CodeBlockUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          const n = t.ui.componentFactory;
          const i = iM(t);
          n.add("codeBlock", (n) => {
            const o = t.commands.get("codeBlock");
            const r = Uv(n, rv);
            const s = r.buttonView;
            s.set({
              label: e("Insert code block"),
              tooltip: true,
              icon: SM,
              isToggleable: true,
            });
            s.bind("isOn").to(o, "value", (t) => !!t);
            s.on("execute", () => {
              t.execute("codeBlock", { usePreviousLanguageChoice: true });
              t.editing.view.focus();
            });
            r.on("execute", (e) => {
              t.execute("codeBlock", {
                language: e.source._codeBlockLanguage,
                forceValue: true,
              });
              t.editing.view.focus();
            });
            r.class = "ck-code-block-dropdown";
            r.bind("isEnabled").to(o);
            Wv(r, this._getLanguageListItemDefinitions(i));
            return r;
          });
        }
        _getLanguageListItemDefinitions(t) {
          const e = this.editor;
          const n = e.commands.get("codeBlock");
          const i = new rl();
          for (const e of t) {
            const t = {
              type: "button",
              model: new Py({
                _codeBlockLanguage: e.language,
                label: e.label,
                withText: true,
              }),
            };
            t.model
              .bind("isOn")
              .to(n, "value", (e) => e === t.model._codeBlockLanguage);
            i.add(t);
          }
          return i;
        }
      }
      class NM extends Cl {
        static get requires() {
          return [_M, LM];
        }
        static get pluginName() {
          return "CodeBlock";
        }
      }
      class zM extends vl {
        constructor(t) {
          super(t);
          this.affectsData = false;
        }
        execute() {
          const t = this.editor.model;
          const e = t.document.selection;
          let n = t.schema.getLimitElement(e);
          if (e.containsEntireContent(n) || !PM(t.schema, n)) {
            do {
              n = n.parent;
              if (!n) {
                return;
              }
            } while (!PM(t.schema, n));
          }
          t.change((t) => {
            t.setSelection(n, "in");
          });
        }
      }
      function PM(t, e) {
        return (
          t.isLimit(e) &&
          (t.checkChild(e, "$text") || t.checkChild(e, "paragraph"))
        );
      }
      const RM = Vc("Ctrl+A");
      class OM extends Cl {
        static get pluginName() {
          return "SelectAllEditing";
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          t.commands.add("selectAll", new zM(t));
          this.listenTo(n, "keydown", (e, n) => {
            if (Fc(n) === RM) {
              t.execute("selectAll");
              n.preventDefault();
            }
          });
        }
      }
      const jM =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>';
      class FM extends Cl {
        static get pluginName() {
          return "SelectAllUI";
        }
        init() {
          const t = this.editor;
          t.ui.componentFactory.add("selectAll", (e) => {
            const n = t.commands.get("selectAll");
            const i = new R_(e);
            const o = e.t;
            i.set({
              label: o("Select all"),
              icon: jM,
              keystroke: "Ctrl+A",
              tooltip: true,
            });
            i.bind("isEnabled").to(n, "isEnabled");
            this.listenTo(i, "execute", () => {
              t.execute("selectAll");
              t.editing.view.focus();
            });
            return i;
          });
        }
      }
      class VM extends Cl {
        static get requires() {
          return [OM, FM];
        }
        static get pluginName() {
          return "SelectAll";
        }
      }
      class HM extends Cl {
        static get requires() {
          return [BS, UE, VM, YE, Xx, HS];
        }
        static get pluginName() {
          return "Essentials";
        }
      }
      class UM extends vl {
        constructor(t, e) {
          super(t);
          this.attributeKey = e;
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.value = e.selection.getAttribute(this.attributeKey);
          this.isEnabled = t.schema.checkAttributeInSelection(
            e.selection,
            this.attributeKey
          );
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const i = n.selection;
          const o = t.value;
          e.change((t) => {
            if (i.isCollapsed) {
              if (o) {
                t.setSelectionAttribute(this.attributeKey, o);
              } else {
                t.removeSelectionAttribute(this.attributeKey);
              }
            } else {
              const n = e.schema.getValidRanges(
                i.getRanges(),
                this.attributeKey
              );
              for (const e of n) {
                if (o) {
                  t.setAttribute(this.attributeKey, o, e);
                } else {
                  t.removeAttribute(this.attributeKey, e);
                }
              }
            }
          });
        }
      }
      class qM extends rl {
        constructor(t) {
          super(t);
          this.set("isEmpty", true);
          this.on("change", () => {
            this.set("isEmpty", this.length === 0);
          });
        }
        add(t, e) {
          if (this.find((e) => e.color === t.color)) {
            return;
          }
          super.add(t, e);
        }
        hasColor(t) {
          return !!this.find((e) => e.color === t);
        }
      }
      C(qM, dt);
      var WM = n(2585);
      var GM = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      GM.insert = "head";
      GM.singleton = true;
      var $M = Il()(WM.Z, GM);
      const KM = WM.Z.locals || {};
      class YM extends pC {
        constructor(
          t,
          {
            colors: e,
            columns: n,
            removeButtonLabel: i,
            documentColorsLabel: o,
            documentColorsCount: r,
          }
        ) {
          super(t);
          this.items = this.createCollection();
          this.colorDefinitions = e;
          this.focusTracker = new al();
          this.keystrokes = new cl();
          this.set("selectedColor");
          this.removeButtonLabel = i;
          this.columns = n;
          this.documentColors = new qM();
          this.documentColorsCount = r;
          this._focusables = new PA();
          this._focusCycler = new hv({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          });
          this._documentColorsLabel = o;
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-color-table"] },
            children: this.items,
          });
          this.items.add(this._createRemoveColorButton());
        }
        updateDocumentColors(t, e) {
          const n = t.document;
          const i = this.documentColorsCount;
          this.documentColors.clear();
          for (const o of n.getRootNames()) {
            const r = n.getRoot(o);
            const s = t.createRangeIn(r);
            for (const t of s.getItems()) {
              if (t.is("$textProxy") && t.hasAttribute(e)) {
                this._addColorToDocumentColors(t.getAttribute(e));
                if (this.documentColors.length >= i) {
                  return;
                }
              }
            }
          }
        }
        updateSelectedColors() {
          const t = this.documentColorsGrid;
          const e = this.staticColorsGrid;
          const n = this.selectedColor;
          e.selectedColor = n;
          if (t) {
            t.selectedColor = n;
          }
        }
        render() {
          super.render();
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        appendGrids() {
          if (this.staticColorsGrid) {
            return;
          }
          this.staticColorsGrid = this._createStaticColorsGrid();
          this.items.add(this.staticColorsGrid);
          this.focusTracker.add(this.staticColorsGrid.element);
          this._focusables.add(this.staticColorsGrid);
          if (this.documentColorsCount) {
            const t = jA.bind(this.documentColors, this.documentColors);
            const e = new ly(this.locale);
            e.text = this._documentColorsLabel;
            e.extendTemplate({
              attributes: {
                class: [
                  "ck",
                  "ck-color-grid__label",
                  t.if("isEmpty", "ck-hidden"),
                ],
              },
            });
            this.items.add(e);
            this.documentColorsGrid = this._createDocumentColorsGrid();
            this.items.add(this.documentColorsGrid);
            this.focusTracker.add(this.documentColorsGrid.element);
            this._focusables.add(this.documentColorsGrid);
          }
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        _createRemoveColorButton() {
          const t = new R_();
          t.set({
            withText: true,
            icon: __.eraser,
            label: this.removeButtonLabel,
          });
          t.class = "ck-color-table__remove-color";
          t.on("execute", () => {
            this.fire("execute", { value: null });
          });
          t.render();
          this.focusTracker.add(t.element);
          this._focusables.add(t);
          return t;
        }
        _createStaticColorsGrid() {
          const t = new J_(this.locale, {
            colorDefinitions: this.colorDefinitions,
            columns: this.columns,
          });
          t.delegate("execute").to(this);
          return t;
        }
        _createDocumentColorsGrid() {
          const t = jA.bind(this.documentColors, this.documentColors);
          const e = new J_(this.locale, { columns: this.columns });
          e.delegate("execute").to(this);
          e.extendTemplate({
            attributes: { class: t.if("isEmpty", "ck-hidden") },
          });
          e.items.bindTo(this.documentColors).using((t) => {
            const e = new $_();
            e.set({
              color: t.color,
              hasBorder: t.options && t.options.hasBorder,
            });
            if (t.label) {
              e.set({ label: t.label, tooltip: true });
            }
            e.on("execute", () => {
              this.fire("execute", { value: t.color });
            });
            return e;
          });
          this.documentColors.on("change:isEmpty", (t, n, i) => {
            if (i) {
              e.selectedColor = null;
            }
          });
          return e;
        }
        _addColorToDocumentColors(t) {
          const e = this.colorDefinitions.find((e) => e.color === t);
          if (!e) {
            this.documentColors.add({
              color: t,
              label: t,
              options: { hasBorder: false },
            });
          } else {
            this.documentColors.add(Object.assign({}, e));
          }
        }
      }
      const ZM = "fontSize";
      const QM = "fontFamily";
      const JM = "fontColor";
      const XM = "fontBackgroundColor";
      function tB(t, e) {
        const n = { model: { key: t, values: [] }, view: {}, upcastAlso: {} };
        for (const t of e) {
          n.model.values.push(t.model);
          n.view[t.model] = t.view;
          if (t.upcastAlso) {
            n.upcastAlso[t.model] = t.upcastAlso;
          }
        }
        return n;
      }
      function eB(t) {
        return (e) => oB(e.getStyle(t));
      }
      function nB(t) {
        return (e, { writer: n }) =>
          n.createAttributeElement(
            "span",
            { style: \`\${t}:\${e}\` },
            { priority: 7 }
          );
      }
      function iB({
        dropdownView: t,
        colors: e,
        columns: n,
        removeButtonLabel: i,
        documentColorsLabel: o,
        documentColorsCount: r,
      }) {
        const s = t.locale;
        const a = new YM(s, {
          colors: e,
          columns: n,
          removeButtonLabel: i,
          documentColorsLabel: o,
          documentColorsCount: r,
        });
        t.colorTableView = a;
        t.panelView.children.add(a);
        a.delegate("execute").to(t, "execute");
        return a;
      }
      function oB(t) {
        return t.replace(/\\s/g, "");
      }
      class rB extends UM {
        constructor(t) {
          super(t, XM);
        }
      }
      class sB extends Cl {
        static get pluginName() {
          return "FontBackgroundColorEditing";
        }
        constructor(t) {
          super(t);
          t.config.define(XM, {
            colors: [
              { color: "hsl(0, 0%, 0%)", label: "Black" },
              { color: "hsl(0, 0%, 30%)", label: "Dim grey" },
              { color: "hsl(0, 0%, 60%)", label: "Grey" },
              { color: "hsl(0, 0%, 90%)", label: "Light grey" },
              { color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true },
              { color: "hsl(0, 75%, 60%)", label: "Red" },
              { color: "hsl(30, 75%, 60%)", label: "Orange" },
              { color: "hsl(60, 75%, 60%)", label: "Yellow" },
              { color: "hsl(90, 75%, 60%)", label: "Light green" },
              { color: "hsl(120, 75%, 60%)", label: "Green" },
              { color: "hsl(150, 75%, 60%)", label: "Aquamarine" },
              { color: "hsl(180, 75%, 60%)", label: "Turquoise" },
              { color: "hsl(210, 75%, 60%)", label: "Light blue" },
              { color: "hsl(240, 75%, 60%)", label: "Blue" },
              { color: "hsl(270, 75%, 60%)", label: "Purple" },
            ],
            columns: 5,
          });
          t.data.addStyleProcessorRules(mA);
          t.conversion.for("upcast").elementToAttribute({
            view: { name: "span", styles: { "background-color": /[\\s\\S]+/ } },
            model: { key: XM, value: eB("background-color") },
          });
          t.conversion
            .for("downcast")
            .attributeToElement({ model: XM, view: nB("background-color") });
          t.commands.add(XM, new rB(t));
          t.model.schema.extend("$text", { allowAttributes: XM });
          t.model.schema.setAttributeProperties(XM, {
            isFormatting: true,
            copyOnEnter: true,
          });
        }
      }
      class aB extends Cl {
        constructor(
          t,
          { commandName: e, icon: n, componentName: i, dropdownLabel: o }
        ) {
          super(t);
          this.commandName = e;
          this.componentName = i;
          this.icon = n;
          this.dropdownLabel = o;
          this.columns = t.config.get(\`\${this.componentName}.columns\`);
          this.colorTableView = undefined;
        }
        init() {
          const t = this.editor;
          const e = t.locale;
          const n = e.t;
          const i = t.commands.get(this.commandName);
          const o = q_(t.config.get(this.componentName).colors);
          const r = U_(e, o);
          const s = t.config.get(\`\${this.componentName}.documentColors\`);
          t.ui.componentFactory.add(this.componentName, (e) => {
            const o = Uv(e);
            this.colorTableView = iB({
              dropdownView: o,
              colors: r.map((t) => ({
                label: t.label,
                color: t.model,
                options: { hasBorder: t.hasBorder },
              })),
              columns: this.columns,
              removeButtonLabel: n("Remove color"),
              documentColorsLabel: s !== 0 ? n("Document colors") : undefined,
              documentColorsCount: s === undefined ? this.columns : s,
            });
            this.colorTableView.bind("selectedColor").to(i, "value");
            o.buttonView.set({
              label: this.dropdownLabel,
              icon: this.icon,
              tooltip: true,
            });
            o.extendTemplate({ attributes: { class: "ck-color-ui-dropdown" } });
            o.bind("isEnabled").to(i);
            o.on("execute", (e, n) => {
              t.execute(this.commandName, n);
              t.editing.view.focus();
            });
            o.on("change:isOpen", (e, n, i) => {
              o.colorTableView.appendGrids();
              if (i) {
                if (s !== 0) {
                  this.colorTableView.updateDocumentColors(
                    t.model,
                    this.componentName
                  );
                }
                this.colorTableView.updateSelectedColors();
              }
            });
            Gv(o, () =>
              o.colorTableView.staticColorsGrid.items.find((t) => t.isOn)
            );
            return o;
          });
        }
      }
      const cB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>';
      class lB extends aB {
        constructor(t) {
          const e = t.locale.t;
          super(t, {
            commandName: XM,
            componentName: XM,
            icon: cB,
            dropdownLabel: e("Font Background Color"),
          });
        }
        static get pluginName() {
          return "FontBackgroundColorUI";
        }
      }
      class dB extends Cl {
        static get requires() {
          return [sB, lB];
        }
        static get pluginName() {
          return "FontBackgroundColor";
        }
      }
      class uB extends UM {
        constructor(t) {
          super(t, JM);
        }
      }
      class hB extends Cl {
        static get pluginName() {
          return "FontColorEditing";
        }
        constructor(t) {
          super(t);
          t.config.define(JM, {
            colors: [
              { color: "hsl(0, 0%, 0%)", label: "Black" },
              { color: "hsl(0, 0%, 30%)", label: "Dim grey" },
              { color: "hsl(0, 0%, 60%)", label: "Grey" },
              { color: "hsl(0, 0%, 90%)", label: "Light grey" },
              { color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true },
              { color: "hsl(0, 75%, 60%)", label: "Red" },
              { color: "hsl(30, 75%, 60%)", label: "Orange" },
              { color: "hsl(60, 75%, 60%)", label: "Yellow" },
              { color: "hsl(90, 75%, 60%)", label: "Light green" },
              { color: "hsl(120, 75%, 60%)", label: "Green" },
              { color: "hsl(150, 75%, 60%)", label: "Aquamarine" },
              { color: "hsl(180, 75%, 60%)", label: "Turquoise" },
              { color: "hsl(210, 75%, 60%)", label: "Light blue" },
              { color: "hsl(240, 75%, 60%)", label: "Blue" },
              { color: "hsl(270, 75%, 60%)", label: "Purple" },
            ],
            columns: 5,
          });
          t.conversion.for("upcast").elementToAttribute({
            view: { name: "span", styles: { color: /[\\s\\S]+/ } },
            model: { key: JM, value: eB("color") },
          });
          t.conversion.for("upcast").elementToAttribute({
            view: { name: "font", attributes: { color: /^#?\\w+$/ } },
            model: { key: JM, value: (t) => t.getAttribute("color") },
          });
          t.conversion
            .for("downcast")
            .attributeToElement({ model: JM, view: nB("color") });
          t.commands.add(JM, new uB(t));
          t.model.schema.extend("$text", { allowAttributes: JM });
          t.model.schema.setAttributeProperties(JM, {
            isFormatting: true,
            copyOnEnter: true,
          });
        }
      }
      const mB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3 10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>';
      class gB extends aB {
        constructor(t) {
          const e = t.locale.t;
          super(t, {
            commandName: JM,
            componentName: JM,
            icon: mB,
            dropdownLabel: e("Font Color"),
          });
        }
        static get pluginName() {
          return "FontColorUI";
        }
      }
      class fB extends Cl {
        static get requires() {
          return [hB, gB];
        }
        static get pluginName() {
          return "FontColor";
        }
      }
      class pB extends UM {
        constructor(t) {
          super(t, QM);
        }
      }
      function bB(t) {
        return t.map(kB).filter((t) => !!t);
      }
      function kB(t) {
        if (typeof t === "object") {
          return t;
        }
        if (t === "default") {
          return { title: "Default", model: undefined };
        }
        if (typeof t !== "string") {
          return;
        }
        return wB(t);
      }
      function wB(t) {
        const e = t.replace(/"|'/g, "").split(",");
        const n = e[0];
        const i = e.map(AB).join(", ");
        return {
          title: n,
          model: i,
          view: { name: "span", styles: { "font-family": i }, priority: 7 },
        };
      }
      function AB(t) {
        t = t.trim();
        if (t.indexOf(" ") > 0) {
          t = \`'\${t}'\`;
        }
        return t;
      }
      class CB extends Cl {
        static get pluginName() {
          return "FontFamilyEditing";
        }
        constructor(t) {
          super(t);
          t.config.define(QM, {
            options: [
              "default",
              "Arial, Helvetica, sans-serif",
              "Courier New, Courier, monospace",
              "Georgia, serif",
              "Lucida Sans Unicode, Lucida Grande, sans-serif",
              "Tahoma, Geneva, sans-serif",
              "Times New Roman, Times, serif",
              "Trebuchet MS, Helvetica, sans-serif",
              "Verdana, Geneva, sans-serif",
            ],
            supportAllValues: false,
          });
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: QM });
          t.model.schema.setAttributeProperties(QM, {
            isFormatting: true,
            copyOnEnter: true,
          });
          const e = bB(t.config.get("fontFamily.options")).filter(
            (t) => t.model
          );
          const n = tB(QM, e);
          if (t.config.get("fontFamily.supportAllValues")) {
            this._prepareAnyValueConverters();
            this._prepareCompatibilityConverter();
          } else {
            t.conversion.attributeToElement(n);
          }
          t.commands.add(QM, new pB(t));
        }
        _prepareAnyValueConverters() {
          const t = this.editor;
          t.conversion.for("downcast").attributeToElement({
            model: QM,
            view: (t, { writer: e }) =>
              e.createAttributeElement(
                "span",
                { style: "font-family:" + t },
                { priority: 7 }
              ),
          });
          t.conversion.for("upcast").elementToAttribute({
            model: { key: QM, value: (t) => t.getStyle("font-family") },
            view: { name: "span", styles: { "font-family": /.*/ } },
          });
        }
        _prepareCompatibilityConverter() {
          const t = this.editor;
          t.conversion.for("upcast").elementToAttribute({
            view: { name: "font", attributes: { face: /.*/ } },
            model: { key: QM, value: (t) => t.getAttribute("face") },
          });
        }
      }
      const _B =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.03 3h6.149a.75.75 0 1 1 0 1.5h-5.514L11.03 3zm1.27 3h4.879a.75.75 0 1 1 0 1.5h-4.244L12.3 6zm1.27 3h3.609a.75.75 0 1 1 0 1.5h-2.973L13.57 9zm-2.754 2.5L8.038 4.785 5.261 11.5h5.555zm.62 1.5H4.641l-1.666 4.028H1.312l5.789-14h1.875l5.789 14h-1.663L11.436 13z"/></svg>';
      class vB extends Cl {
        static get pluginName() {
          return "FontFamilyUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          const n = this._getLocalizedOptions();
          const i = t.commands.get(QM);
          t.ui.componentFactory.add(QM, (o) => {
            const r = Uv(o);
            Wv(r, yB(n, i));
            r.buttonView.set({
              label: e("Font Family"),
              icon: _B,
              tooltip: true,
            });
            r.extendTemplate({
              attributes: { class: "ck-font-family-dropdown" },
            });
            r.bind("isEnabled").to(i);
            this.listenTo(r, "execute", (e) => {
              t.execute(e.source.commandName, { value: e.source.commandParam });
              t.editing.view.focus();
            });
            return r;
          });
        }
        _getLocalizedOptions() {
          const t = this.editor;
          const e = t.t;
          const n = bB(t.config.get(QM).options);
          return n.map((t) => {
            if (t.title === "Default") {
              t.title = e("Default");
            }
            return t;
          });
        }
      }
      function yB(t, e) {
        const n = new rl();
        for (const i of t) {
          const t = {
            type: "button",
            model: new Py({
              commandName: QM,
              commandParam: i.model,
              label: i.title,
              withText: true,
            }),
          };
          t.model.bind("isOn").to(e, "value", (t) => {
            if (t === i.model) {
              return true;
            }
            if (!t || !i.model) {
              return false;
            }
            return (
              t.split(",")[0].replace(/'/g, "").toLowerCase() ===
              i.model.toLowerCase()
            );
          });
          if (i.view && i.view.styles) {
            t.model.set(
              "labelStyle",
              \`font-family: \${i.view.styles["font-family"]}\`
            );
          }
          n.add(t);
        }
        return n;
      }
      class xB extends Cl {
        static get requires() {
          return [CB, vB];
        }
        static get pluginName() {
          return "FontFamily";
        }
      }
      class EB extends UM {
        constructor(t) {
          super(t, ZM);
        }
      }
      function DB(t) {
        return t.map((t) => TB(t)).filter((t) => !!t);
      }
      const SB = {
        get tiny() {
          return {
            title: "Tiny",
            model: "tiny",
            view: { name: "span", classes: "text-tiny", priority: 7 },
          };
        },
        get small() {
          return {
            title: "Small",
            model: "small",
            view: { name: "span", classes: "text-small", priority: 7 },
          };
        },
        get big() {
          return {
            title: "Big",
            model: "big",
            view: { name: "span", classes: "text-big", priority: 7 },
          };
        },
        get huge() {
          return {
            title: "Huge",
            model: "huge",
            view: { name: "span", classes: "text-huge", priority: 7 },
          };
        },
      };
      function TB(t) {
        if (LB(t)) {
          return MB(t);
        }
        const e = BB(t);
        if (e) {
          return MB(e);
        }
        if (t === "default") {
          return { model: undefined, title: "Default" };
        }
        if (NB(t)) {
          return;
        }
        return IB(t);
      }
      function IB(t) {
        if (typeof t === "number" || typeof t === "string") {
          t = { title: String(t), model: \`\${parseFloat(t)}px\` };
        }
        t.view = { name: "span", styles: { "font-size": t.model } };
        return MB(t);
      }
      function MB(t) {
        if (!t.view.priority) {
          t.view.priority = 7;
        }
        return t;
      }
      function BB(t) {
        return SB[t] || SB[t.model];
      }
      function LB(t) {
        return typeof t === "object" && t.title && t.model && t.view;
      }
      function NB(t) {
        let e;
        if (typeof t === "object") {
          if (!t.model) {
            throw new M("font-size-invalid-definition", null, t);
          } else {
            e = parseFloat(t.model);
          }
        } else {
          e = parseFloat(t);
        }
        return isNaN(e);
      }
      const zB = [
        "x-small",
        "x-small",
        "small",
        "medium",
        "large",
        "x-large",
        "xx-large",
        "xxx-large",
      ];
      class PB extends Cl {
        static get pluginName() {
          return "FontSizeEditing";
        }
        constructor(t) {
          super(t);
          t.config.define(ZM, {
            options: ["tiny", "small", "default", "big", "huge"],
            supportAllValues: false,
          });
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: ZM });
          t.model.schema.setAttributeProperties(ZM, {
            isFormatting: true,
            copyOnEnter: true,
          });
          const e = t.config.get("fontSize.supportAllValues");
          const n = DB(this.editor.config.get("fontSize.options")).filter(
            (t) => t.model
          );
          const i = tB(ZM, n);
          if (e) {
            this._prepareAnyValueConverters(i);
            this._prepareCompatibilityConverter();
          } else {
            t.conversion.attributeToElement(i);
          }
          t.commands.add(ZM, new EB(t));
        }
        _prepareAnyValueConverters(t) {
          const e = this.editor;
          const n = t.model.values.filter(
            (t) => !Qw(String(t)) && !Xw(String(t))
          );
          if (n.length) {
            throw new M("font-size-invalid-use-of-named-presets", null, {
              presets: n,
            });
          }
          e.conversion.for("downcast").attributeToElement({
            model: ZM,
            view: (t, { writer: e }) => {
              if (!t) {
                return;
              }
              return e.createAttributeElement(
                "span",
                { style: "font-size:" + t },
                { priority: 7 }
              );
            },
          });
          e.conversion.for("upcast").elementToAttribute({
            model: { key: ZM, value: (t) => t.getStyle("font-size") },
            view: { name: "span", styles: { "font-size": /.*/ } },
          });
        }
        _prepareCompatibilityConverter() {
          const t = this.editor;
          t.conversion.for("upcast").elementToAttribute({
            view: { name: "font", attributes: { size: /^[+-]?\\d{1,3}$/ } },
            model: {
              key: ZM,
              value: (t) => {
                const e = t.getAttribute("size");
                const n = e[0] === "-" || e[0] === "+";
                let i = parseInt(e, 10);
                if (n) {
                  i = 3 + i;
                }
                const o = zB.length - 1;
                const r = Math.min(Math.max(i, 0), o);
                return zB[r];
              },
            },
          });
        }
      }
      const RB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>';
      var OB = n(6203);
      var jB = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      jB.insert = "head";
      jB.singleton = true;
      var FB = Il()(OB.Z, jB);
      const VB = OB.Z.locals || {};
      class HB extends Cl {
        static get pluginName() {
          return "FontSizeUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          const n = this._getLocalizedOptions();
          const i = t.commands.get(ZM);
          t.ui.componentFactory.add(ZM, (o) => {
            const r = Uv(o);
            Wv(r, UB(n, i));
            r.buttonView.set({
              label: e("Font Size"),
              icon: RB,
              tooltip: true,
            });
            r.extendTemplate({
              attributes: { class: ["ck-font-size-dropdown"] },
            });
            r.bind("isEnabled").to(i);
            this.listenTo(r, "execute", (e) => {
              t.execute(e.source.commandName, { value: e.source.commandParam });
              t.editing.view.focus();
            });
            return r;
          });
        }
        _getLocalizedOptions() {
          const t = this.editor;
          const e = t.t;
          const n = {
            Default: e("Default"),
            Tiny: e("Tiny"),
            Small: e("Small"),
            Big: e("Big"),
            Huge: e("Huge"),
          };
          const i = DB(t.config.get(ZM).options);
          return i.map((t) => {
            const e = n[t.title];
            if (e && e != t.title) {
              t = Object.assign({}, t, { title: e });
            }
            return t;
          });
        }
      }
      function UB(t, e) {
        const n = new rl();
        for (const i of t) {
          const t = {
            type: "button",
            model: new Py({
              commandName: ZM,
              commandParam: i.model,
              label: i.title,
              class: "ck-fontsize-option",
              withText: true,
            }),
          };
          if (i.view && i.view.styles) {
            t.model.set(
              "labelStyle",
              \`font-size:\${i.view.styles["font-size"]}\`
            );
          }
          if (i.view && i.view.classes) {
            t.model.set("class", \`\${t.model.class} \${i.view.classes}\`);
          }
          t.model.bind("isOn").to(e, "value", (t) => t === i.model);
          n.add(t);
        }
        return n;
      }
      class qB extends Cl {
        static get requires() {
          return [PB, HB];
        }
        static get pluginName() {
          return "FontSize";
        }
        normalizeSizeOptions(t) {
          return DB(t);
        }
      }
      const WB = {
        block: [
          { model: "codeBlock", view: "pre" },
          { model: "paragraph", view: "p" },
          { model: "blockQuote", view: "blockquote" },
          { model: "listItem", view: "li" },
          { model: "pageBreak", view: "div" },
          { model: "rawHtml", view: "div" },
          { model: "table", view: "table" },
          { model: "tableRow", view: "tr" },
          { model: "tableCell", view: "td" },
          { model: "tableCell", view: "th" },
          { model: "caption", view: "caption" },
          { model: "caption", view: "figcaption" },
          { model: "imageBlock", view: "img" },
          { model: "imageInline", view: "img" },
          {
            model: "htmlP",
            view: "p",
            modelSchema: { inheritAllFrom: "$block" },
          },
          {
            model: "htmlBlockquote",
            view: "blockquote",
            modelSchema: { inheritAllFrom: "$container" },
          },
          {
            model: "htmlTable",
            view: "table",
            modelSchema: { allowWhere: "$block", isBlock: true },
          },
          {
            model: "htmlTbody",
            view: "tbody",
            modelSchema: { allowIn: "htmlTable", isBlock: false },
          },
          {
            model: "htmlThead",
            view: "thead",
            modelSchema: { allowIn: "htmlTable", isBlock: false },
          },
          {
            model: "htmlTfoot",
            view: "tfoot",
            modelSchema: { allowIn: "htmlTable", isBlock: false },
          },
          {
            model: "htmlCaption",
            view: "caption",
            modelSchema: {
              allowIn: "htmlTable",
              allowChildren: "$text",
              isBlock: false,
            },
          },
          {
            model: "htmlColgroup",
            view: "colgroup",
            modelSchema: {
              allowIn: "htmlTable",
              allowChildren: "col",
              isBlock: false,
            },
          },
          {
            model: "htmlCol",
            view: "col",
            modelSchema: { allowIn: "htmlColgroup", isBlock: false },
          },
          {
            model: "htmlTr",
            view: "tr",
            modelSchema: {
              allowIn: ["htmlTable", "htmlThead", "htmlTbody"],
              isLimit: true,
            },
          },
          {
            model: "htmlTd",
            view: "td",
            modelSchema: {
              allowIn: "htmlTr",
              allowContentOf: "$container",
              isLimit: true,
              isBlock: false,
            },
          },
          {
            model: "htmlTh",
            view: "th",
            modelSchema: {
              allowIn: "htmlTr",
              allowContentOf: "$container",
              isLimit: true,
              isBlock: false,
            },
          },
          {
            model: "htmlFigure",
            view: "figure",
            modelSchema: { inheritAllFrom: "$container", isBlock: false },
          },
          {
            model: "htmlFigcaption",
            view: "figcaption",
            modelSchema: {
              allowIn: "htmlFigure",
              allowChildren: "$text",
              isBlock: false,
            },
          },
          {
            model: "htmlAddress",
            view: "address",
            modelSchema: { inheritAllFrom: "$container", isBlock: false },
          },
          {
            model: "htmlAside",
            view: "aside",
            modelSchema: { inheritAllFrom: "$container", isBlock: false },
          },
          {
            model: "htmlMain",
            view: "main",
            modelSchema: { inheritAllFrom: "$container", isBlock: false },
          },
          {
            model: "htmlDetails",
            view: "details",
            modelSchema: { inheritAllFrom: "$container", isBlock: false },
          },
          {
            model: "htmlSummary",
            view: "summary",
            modelSchema: {
              allowChildren: "$text",
              allowIn: "htmlDetails",
              isBlock: false,
            },
          },
          {
            model: "htmlDiv",
            view: "div",
            paragraphLikeModel: "htmlDivParagraph",
            modelSchema: { inheritAllFrom: "$container" },
          },
          {
            model: "htmlFieldset",
            view: "fieldset",
            modelSchema: { inheritAllFrom: "$container", isBlock: false },
          },
          {
            model: "htmlLegend",
            view: "legend",
            modelSchema: { allowIn: "htmlFieldset", allowChildren: "$text" },
          },
          {
            model: "htmlHeader",
            view: "header",
            modelSchema: { inheritAllFrom: "$container", isBlock: false },
          },
          {
            model: "htmlFooter",
            view: "footer",
            modelSchema: { inheritAllFrom: "$container", isBlock: false },
          },
          {
            model: "htmlForm",
            view: "form",
            modelSchema: { inheritAllFrom: "$container", isBlock: true },
          },
          {
            model: "htmlHgroup",
            view: "hgroup",
            modelSchema: {
              allowChildren: [
                "htmlH1",
                "htmlH2",
                "htmlH3",
                "htmlH4",
                "htmlH5",
                "htmlH6",
              ],
              isBlock: false,
            },
          },
          {
            model: "htmlH1",
            view: "h1",
            modelSchema: { inheritAllFrom: "$block" },
          },
          {
            model: "htmlH2",
            view: "h2",
            modelSchema: { inheritAllFrom: "$block" },
          },
          {
            model: "htmlH3",
            view: "h3",
            modelSchema: { inheritAllFrom: "$block" },
          },
          {
            model: "htmlH4",
            view: "h4",
            modelSchema: { inheritAllFrom: "$block" },
          },
          {
            model: "htmlH5",
            view: "h5",
            modelSchema: { inheritAllFrom: "$block" },
          },
          {
            model: "htmlH6",
            view: "h6",
            modelSchema: { inheritAllFrom: "$block" },
          },
          {
            model: "$htmlList",
            modelSchema: {
              allowWhere: "$container",
              allowChildren: ["$htmlList", "htmlLi"],
              isBlock: false,
            },
          },
          {
            model: "htmlDir",
            view: "dir",
            modelSchema: { inheritAllFrom: "$htmlList" },
          },
          {
            model: "htmlMenu",
            view: "menu",
            modelSchema: { inheritAllFrom: "$htmlList" },
          },
          {
            model: "htmlUl",
            view: "ul",
            modelSchema: { inheritAllFrom: "$htmlList" },
          },
          {
            model: "htmlOl",
            view: "ol",
            modelSchema: { inheritAllFrom: "$htmlList" },
          },
          {
            model: "htmlLi",
            view: "li",
            modelSchema: {
              allowIn: "$htmlList",
              allowChildren: "$text",
              isBlock: false,
            },
          },
          {
            model: "htmlPre",
            view: "pre",
            modelSchema: { inheritAllFrom: "$block" },
          },
          {
            model: "htmlArticle",
            view: "article",
            modelSchema: { inheritAllFrom: "$container", isBlock: false },
          },
          {
            model: "htmlSection",
            view: "section",
            modelSchema: { inheritAllFrom: "$container", isBlock: false },
          },
          {
            model: "htmlNav",
            view: "nav",
            modelSchema: { inheritAllFrom: "$container", isBlock: false },
          },
          {
            model: "htmlDl",
            view: "dl",
            modelSchema: {
              allowWhere: "$container",
              allowChildren: ["htmlDt", "htmlDd"],
              isBlock: false,
            },
          },
          {
            model: "htmlDt",
            view: "dt",
            modelSchema: { allowChildren: "$block", isBlock: false },
          },
          {
            model: "htmlDd",
            view: "dd",
            modelSchema: { allowChildren: "$block", isBlock: false },
          },
          {
            model: "htmlCenter",
            view: "center",
            modelSchema: { inheritAllFrom: "$container", isBlock: false },
          },
        ],
        inline: [
          {
            model: "htmlAcronym",
            view: "acronym",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlTt",
            view: "tt",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlFont",
            view: "font",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlTime",
            view: "time",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlVar",
            view: "var",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlBig",
            view: "big",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlSmall",
            view: "small",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlSamp",
            view: "samp",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlQ",
            view: "q",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlOutput",
            view: "output",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlKbd",
            view: "kbd",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlBdi",
            view: "bdi",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlBdo",
            view: "bdo",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlAbbr",
            view: "abbr",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlA",
            view: "a",
            priority: 5,
            coupledAttribute: "linkHref",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlStrong",
            view: "strong",
            coupledAttribute: "bold",
            attributeProperties: { copyOnEnter: true, isFormatting: true },
          },
          {
            model: "htmlB",
            view: "b",
            coupledAttribute: "bold",
            attributeProperties: { copyOnEnter: true, isFormatting: true },
          },
          {
            model: "htmlI",
            view: "i",
            coupledAttribute: "italic",
            attributeProperties: { copyOnEnter: true, isFormatting: true },
          },
          {
            model: "htmlEm",
            view: "em",
            coupledAttribute: "italic",
            attributeProperties: { copyOnEnter: true, isFormatting: true },
          },
          {
            model: "htmlS",
            view: "s",
            coupledAttribute: "strikethrough",
            attributeProperties: { copyOnEnter: true, isFormatting: true },
          },
          {
            model: "htmlDel",
            view: "del",
            coupledAttribute: "strikethrough",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlIns",
            view: "ins",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlU",
            view: "u",
            coupledAttribute: "underline",
            attributeProperties: { copyOnEnter: true, isFormatting: true },
          },
          {
            model: "htmlSub",
            view: "sub",
            coupledAttribute: "subscript",
            attributeProperties: { copyOnEnter: true, isFormatting: true },
          },
          {
            model: "htmlSup",
            view: "sup",
            coupledAttribute: "superscript",
            attributeProperties: { copyOnEnter: true, isFormatting: true },
          },
          {
            model: "htmlCode",
            view: "code",
            coupledAttribute: "code",
            attributeProperties: { copyOnEnter: true, isFormatting: true },
          },
          {
            model: "htmlMark",
            view: "mark",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlSpan",
            view: "span",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlCite",
            view: "cite",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlLabel",
            view: "label",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlDfn",
            view: "dfn",
            attributeProperties: { copyOnEnter: true },
          },
          {
            model: "htmlObject",
            view: "object",
            isObject: true,
            modelSchema: { inheritAllFrom: "$inlineObject" },
          },
          {
            model: "htmlIframe",
            view: "iframe",
            isObject: true,
            modelSchema: { inheritAllFrom: "$inlineObject" },
          },
          {
            model: "htmlInput",
            view: "input",
            isObject: true,
            modelSchema: { inheritAllFrom: "$inlineObject" },
          },
          {
            model: "htmlButton",
            view: "button",
            isObject: true,
            modelSchema: { inheritAllFrom: "$inlineObject" },
          },
          {
            model: "htmlTextarea",
            view: "textarea",
            isObject: true,
            modelSchema: { inheritAllFrom: "$inlineObject" },
          },
          {
            model: "htmlSelect",
            view: "select",
            isObject: true,
            modelSchema: { inheritAllFrom: "$inlineObject" },
          },
          {
            model: "htmlVideo",
            view: "video",
            isObject: true,
            modelSchema: { inheritAllFrom: "$inlineObject" },
          },
          {
            model: "htmlEmbed",
            view: "embed",
            isObject: true,
            modelSchema: { inheritAllFrom: "$inlineObject" },
          },
          {
            model: "htmlOembed",
            view: "oembed",
            isObject: true,
            modelSchema: { inheritAllFrom: "$inlineObject" },
          },
          {
            model: "htmlAudio",
            view: "audio",
            isObject: true,
            modelSchema: { inheritAllFrom: "$inlineObject" },
          },
          {
            model: "htmlImg",
            view: "img",
            isObject: true,
            modelSchema: { inheritAllFrom: "$inlineObject" },
          },
          {
            model: "htmlCanvas",
            view: "canvas",
            isObject: true,
            modelSchema: { inheritAllFrom: "$inlineObject" },
          },
          {
            model: "htmlMeter",
            view: "meter",
            isObject: true,
            modelSchema: { inheritAllFrom: "$inlineObject" },
          },
          {
            model: "htmlProgress",
            view: "progress",
            isObject: true,
            modelSchema: { inheritAllFrom: "$inlineObject" },
          },
          {
            model: "htmlScript",
            view: "script",
            modelSchema: { allowWhere: ["$text", "$block"], isInline: true },
          },
          {
            model: "htmlStyle",
            view: "style",
            modelSchema: { allowWhere: ["$text", "$block"], isInline: true },
          },
          {
            model: "htmlCustomElement",
            view: "$customElement",
            modelSchema: { allowWhere: ["$text", "$block"], isInline: true },
          },
        ],
      };
      var GB = Ru(function (t, e, n, i) {
        mu(t, e, n, i);
      });
      const $B = GB;
      class KB extends Cl {
        constructor(t) {
          super(t);
          this._definitions = new Map();
        }
        static get pluginName() {
          return "DataSchema";
        }
        init() {
          for (const t of WB.block) {
            this.registerBlockElement(t);
          }
          for (const t of WB.inline) {
            this.registerInlineElement(t);
          }
        }
        registerBlockElement(t) {
          this._definitions.set(t.model, { ...t, isBlock: true });
        }
        registerInlineElement(t) {
          this._definitions.set(t.model, { ...t, isInline: true });
        }
        extendBlockElement(t) {
          this._extendDefinition({ ...t, isBlock: true });
        }
        extendInlineElement(t) {
          this._extendDefinition({ ...t, isInline: true });
        }
        getDefinitionsForView(t, e) {
          const n = new Set();
          for (const i of this._getMatchingViewDefinitions(t)) {
            if (e) {
              for (const t of this._getReferences(i.model)) {
                n.add(t);
              }
            }
            n.add(i);
          }
          return n;
        }
        _getMatchingViewDefinitions(t) {
          return Array.from(this._definitions.values()).filter(
            (e) => e.view && YB(t, e.view)
          );
        }
        *_getReferences(t) {
          const { modelSchema: e } = this._definitions.get(t);
          if (!e) {
            return;
          }
          const n = [
            "inheritAllFrom",
            "inheritTypesFrom",
            "allowWhere",
            "allowContentOf",
            "allowAttributesOf",
          ];
          for (const i of n) {
            for (const n of Yc(e[i] || [])) {
              const e = this._definitions.get(n);
              if (n !== t && e) {
                yield* this._getReferences(e.model);
                yield e;
              }
            }
          }
        }
        _extendDefinition(t) {
          const e = this._definitions.get(t.model);
          const n = $B({}, e, t, (t, e) =>
            Array.isArray(t) ? t.concat(e) : undefined
          );
          this._definitions.set(t.model, n);
        }
      }
      function YB(t, e) {
        if (typeof t === "string") {
          return t === e;
        }
        if (t instanceof RegExp) {
          return t.test(e);
        }
        return false;
      }
      function ZB(t, e, n, i) {
        if (e) {
          JB(t, e, i);
        }
        if (n) {
          QB(t, n, i);
        }
      }
      function QB(t, e, n) {
        if (e.attributes) {
          for (const [i, o] of Object.entries(e.attributes)) {
            t.setAttribute(i, o, n);
          }
        }
        if (e.styles) {
          t.setStyle(e.styles, n);
        }
        if (e.classes) {
          t.addClass(e.classes, n);
        }
      }
      function JB(t, e, n) {
        if (e.attributes) {
          for (const [i] of Object.entries(e.attributes)) {
            t.removeAttribute(i, n);
          }
        }
        if (e.styles) {
          for (const i of Object.keys(e.styles)) {
            t.removeStyle(i, n);
          }
        }
        if (e.classes) {
          t.removeClass(e.classes, n);
        }
      }
      function XB(t, e) {
        const n = Xf(t);
        for (const i in e) {
          if (Array.isArray(e[i])) {
            n[i] = Array.from(new Set([...(t[i] || []), ...e[i]]));
          } else {
            n[i] = { ...t[i], ...e[i] };
          }
        }
        return n;
      }
      function tL({ model: t }) {
        return (e, n) =>
          n.writer.createElement(t, {
            htmlContent: e.getCustomProperty("$rawContent"),
          });
      }
      function eL(t, { view: e, isInline: n }) {
        const i = t.t;
        return (t, { writer: o }) => {
          const r = i("HTML object");
          const s = nL(e, t, o);
          const a = t.getAttribute("htmlAttributes");
          o.addClass("html-object-embed__content", s);
          if (a) {
            QB(o, a, s);
          }
          const c = o.createContainerElement(
            n ? "span" : "div",
            { class: "html-object-embed", "data-html-object-embed-label": r },
            s
          );
          return oD(c, o, { widgetLabel: r });
        };
      }
      function nL(t, e, n) {
        return n.createRawElement(t, null, (t, n) => {
          n.setContentOf(t, e.getAttribute("htmlContent"));
        });
      }
      function iL({ view: t, model: e }, n) {
        return (i) => {
          i.on(
            \`element:\${t}\`,
            (t, i, o) => {
              let r = n.processViewAttributes(i.viewItem, o);
              if (!r && !o.consumable.test(i.viewItem, { name: true })) {
                return;
              }
              r = r || {};
              o.consumable.consume(i.viewItem, { name: true });
              if (!i.modelRange) {
                i = Object.assign(
                  i,
                  o.convertChildren(i.viewItem, i.modelCursor)
                );
              }
              for (const t of i.modelRange.getItems()) {
                if (o.schema.checkAttribute(t, e)) {
                  const n = t.getAttribute(e);
                  const i = XB(r, n || {});
                  o.writer.setAttribute(e, i, t);
                }
              }
            },
            { priority: "low" }
          );
        };
      }
      function oL({ priority: t, view: e }) {
        return (n, i) => {
          if (!n) {
            return;
          }
          const { writer: o } = i;
          const r = o.createAttributeElement(e, null, { priority: t });
          QB(o, n, r);
          return r;
        };
      }
      function rL({ view: t }, e) {
        return (n) => {
          n.on(
            \`element:\${t}\`,
            (t, n, i) => {
              if (!n.modelRange || n.modelRange.isCollapsed) {
                return;
              }
              const o = e.processViewAttributes(n.viewItem, i);
              if (o) {
                i.writer.setAttribute("htmlAttributes", o, n.modelRange);
              }
            },
            { priority: "low" }
          );
        };
      }
      function sL({ model: t }) {
        return (e) => {
          e.on(\`attribute:htmlAttributes:\${t}\`, (t, e, n) => {
            if (!n.consumable.consume(e.item, t.name)) {
              return;
            }
            const { attributeOldValue: i, attributeNewValue: o } = e;
            const r = n.writer;
            const s = n.mapper.toViewElement(e.item);
            ZB(r, i, o, s);
          });
        };
      }
      function aL(t, e, n, i) {
        var o = t.length,
          r = n + (i ? 1 : -1);
        while (i ? r-- : ++r < o) {
          if (e(t[r], r, t)) {
            return r;
          }
        }
        return -1;
      }
      const cL = aL;
      function lL(t) {
        return t !== t;
      }
      const dL = lL;
      function uL(t, e, n) {
        var i = n - 1,
          o = t.length;
        while (++i < o) {
          if (t[i] === e) {
            return i;
          }
        }
        return -1;
      }
      const hL = uL;
      function mL(t, e, n) {
        return e === e ? hL(t, e, n) : cL(t, dL, n);
      }
      const gL = mL;
      function fL(t, e, n, i) {
        var o = n - 1,
          r = t.length;
        while (++o < r) {
          if (i(t[o], e)) {
            return o;
          }
        }
        return -1;
      }
      const pL = fL;
      var bL = Array.prototype;
      var kL = bL.splice;
      function wL(t, e, n, i) {
        var o = i ? pL : gL,
          r = -1,
          s = e.length,
          a = t;
        if (t === e) {
          e = lr(e);
        }
        if (n) {
          a = xd(t, po(n));
        }
        while (++r < s) {
          var c = 0,
            l = e[r],
            d = n ? n(l) : l;
          while ((c = o(a, d, c, i)) > -1) {
            if (a !== t) {
              kL.call(a, c, 1);
            }
            kL.call(t, c, 1);
          }
        }
        return t;
      }
      const AL = wL;
      function CL(t, e) {
        return t && t.length && e && e.length ? AL(t, e) : t;
      }
      const _L = CL;
      var vL = Lu(_L);
      const yL = vL;
      var xL = n(8468);
      var EL = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      EL.insert = "head";
      EL.singleton = true;
      var DL = Il()(xL.Z, EL);
      const SL = xL.Z.locals || {};
      class TL extends Cl {
        constructor(t) {
          super(t);
          this._dataSchema = t.plugins.get("DataSchema");
          this._allowedAttributes = new Ql();
          this._disallowedAttributes = new Ql();
          this._allowedElements = new Set();
          this._disallowedElements = new Set();
          this._dataInitialized = false;
          this._coupledAttributes = null;
          this._registerElementsAfterInit();
          this._registerElementHandlers();
          this._registerModelPostFixer();
        }
        static get pluginName() {
          return "DataFilter";
        }
        static get requires() {
          return [KB, qD];
        }
        loadAllowedConfig(t) {
          for (const e of t) {
            const t = e.name || /[\\s\\S]+/;
            const n = PL(e);
            this.allowElement(t);
            n.forEach((t) => this.allowAttributes(t));
          }
        }
        loadDisallowedConfig(t) {
          for (const e of t) {
            const t = e.name || /[\\s\\S]+/;
            const n = PL(e);
            if (n.length == 0) {
              this.disallowElement(t);
            } else {
              n.forEach((t) => this.disallowAttributes(t));
            }
          }
        }
        allowElement(t) {
          for (const e of this._dataSchema.getDefinitionsForView(t, true)) {
            if (this._allowedElements.has(e)) {
              continue;
            }
            this._allowedElements.add(e);
            if (this._dataInitialized) {
              this.editor.data.once(
                "set",
                () => {
                  this._fireRegisterEvent(e);
                },
                { priority: S.get("highest") + 1 }
              );
            }
            this._coupledAttributes = null;
          }
        }
        disallowElement(t) {
          for (const e of this._dataSchema.getDefinitionsForView(t, false)) {
            this._disallowedElements.add(e.view);
          }
        }
        allowAttributes(t) {
          this._allowedAttributes.add(t);
        }
        disallowAttributes(t) {
          this._disallowedAttributes.add(t);
        }
        processViewAttributes(t, e) {
          IL(t, e, this._disallowedAttributes);
          return IL(t, e, this._allowedAttributes);
        }
        _registerElementsAfterInit() {
          this.editor.data.on(
            "init",
            () => {
              this._dataInitialized = true;
              for (const t of this._allowedElements) {
                this._fireRegisterEvent(t);
              }
            },
            { priority: S.get("highest") + 1 }
          );
        }
        _registerElementHandlers() {
          this.on(
            "register",
            (t, e) => {
              const n = this.editor.model.schema;
              if (e.isObject && !n.isRegistered(e.model)) {
                this._registerObjectElement(e);
              } else if (e.isBlock) {
                this._registerBlockElement(e);
              } else if (e.isInline) {
                this._registerInlineElement(e);
              } else {
                throw new M("data-filter-invalid-definition", null, e);
              }
              t.stop();
            },
            { priority: "lowest" }
          );
        }
        _registerModelPostFixer() {
          const t = this.editor.model;
          t.document.registerPostFixer((e) => {
            const n = t.document.differ.getChanges();
            let i = false;
            const o = this._getCoupledAttributesMap();
            for (const t of n) {
              if (t.type != "attribute" || t.attributeNewValue !== null) {
                continue;
              }
              const n = o.get(t.attributeKey);
              if (!n) {
                continue;
              }
              for (const { item: o } of t.range.getWalker({ shallow: true })) {
                for (const t of n) {
                  if (o.hasAttribute(t)) {
                    e.removeAttribute(t, o);
                    i = true;
                  }
                }
              }
            }
            return i;
          });
        }
        _getCoupledAttributesMap() {
          if (this._coupledAttributes) {
            return this._coupledAttributes;
          }
          this._coupledAttributes = new Map();
          for (const t of this._allowedElements) {
            if (t.coupledAttribute && t.model) {
              const e = this._coupledAttributes.get(t.coupledAttribute);
              if (e) {
                e.push(t.model);
              } else {
                this._coupledAttributes.set(t.coupledAttribute, [t.model]);
              }
            }
          }
        }
        _fireRegisterEvent(t) {
          if (t.view && this._disallowedElements.has(t.view)) {
            return;
          }
          this.fire(t.view ? \`register:\${t.view}\` : "register", t);
        }
        _registerObjectElement(t) {
          const e = this.editor;
          const n = e.model.schema;
          const i = e.conversion;
          const { view: o, model: r } = t;
          n.register(r, t.modelSchema);
          if (!o) {
            return;
          }
          n.extend(t.model, {
            allowAttributes: ["htmlAttributes", "htmlContent"],
          });
          e.data.registerRawContentMatcher({ name: o });
          i.for("upcast").elementToElement({
            view: o,
            model: tL(t),
            converterPriority: S.get("low") + 1,
          });
          i.for("upcast").add(rL(t, this));
          i.for("editingDowncast").elementToStructure({
            model: { name: r, attributes: ["htmlAttributes"] },
            view: eL(e, t),
          });
          i.for("dataDowncast").elementToElement({
            model: r,
            view: (t, { writer: e }) => nL(o, t, e),
          });
          i.for("dataDowncast").add(sL(t));
        }
        _registerBlockElement(t) {
          const e = this.editor;
          const n = e.model.schema;
          const i = e.conversion;
          const { view: o, model: r } = t;
          if (!n.isRegistered(t.model)) {
            n.register(t.model, t.modelSchema);
            if (!o) {
              return;
            }
            i.for("upcast").elementToElement({
              model: r,
              view: o,
              converterPriority: S.get("low") + 1,
            });
            i.for("downcast").elementToElement({ model: r, view: o });
          }
          if (!o) {
            return;
          }
          n.extend(t.model, { allowAttributes: "htmlAttributes" });
          i.for("upcast").add(rL(t, this));
          i.for("downcast").add(sL(t));
        }
        _registerInlineElement(t) {
          const e = this.editor;
          const n = e.model.schema;
          const i = e.conversion;
          const o = t.model;
          n.extend("$text", { allowAttributes: o });
          if (t.attributeProperties) {
            n.setAttributeProperties(o, t.attributeProperties);
          }
          i.for("upcast").add(iL(t, this));
          i.for("downcast").attributeToElement({ model: o, view: oL(t) });
        }
      }
      function IL(t, e, n) {
        const i = ML(t, e, n);
        const { attributes: o, styles: r, classes: s } = LL(i);
        const a = {};
        if (o.size) {
          for (const t of o) {
            if (!RL(t)) {
              o.delete(t);
            }
          }
        }
        if (o.size) {
          a.attributes = NL(o, (e) => t.getAttribute(e));
        }
        if (r.size) {
          a.styles = NL(r, (e) => t.getStyle(e));
        }
        if (s.size) {
          a.classes = Array.from(s);
        }
        if (!Object.keys(a).length) {
          return null;
        }
        return a;
      }
      function ML(t, { consumable: e }, n) {
        const i = n.matchAll(t) || [];
        const o = [];
        for (const n of i) {
          BL(e, t, n);
          delete n.match.name;
          e.consume(t, n.match);
          o.push(n);
        }
        return o;
      }
      function BL(t, e, n) {
        for (const i of ["attributes", "classes", "styles"]) {
          const o = n.match[i];
          if (!o) {
            continue;
          }
          for (const n of Array.from(o)) {
            if (!t.test(e, { [i]: [n] })) {
              yL(o, n);
            }
          }
        }
      }
      function LL(t) {
        const e = {
          attributes: new Set(),
          classes: new Set(),
          styles: new Set(),
        };
        for (const n of t) {
          for (const t in e) {
            const i = n.match[t] || [];
            i.forEach((n) => e[t].add(n));
          }
        }
        return e;
      }
      function NL(t, e) {
        const n = {};
        for (const i of t) {
          const t = e(i);
          if (t !== undefined) {
            n[i] = e(i);
          }
        }
        return n;
      }
      function zL(t, e) {
        const { name: n } = t;
        if (he(t[e])) {
          return Object.entries(t[e]).map(([t, i]) => ({
            name: n,
            [e]: { [t]: i },
          }));
        }
        if (Array.isArray(t[e])) {
          return t[e].map((t) => ({ name: n, [e]: [t] }));
        }
        return [t];
      }
      function PL(t) {
        const { name: e, attributes: n, classes: i, styles: o } = t;
        const r = [];
        if (n) {
          r.push(...zL({ name: e, attributes: n }, "attributes"));
        }
        if (i) {
          r.push(...zL({ name: e, classes: i }, "classes"));
        }
        if (o) {
          r.push(...zL({ name: e, styles: o }, "styles"));
        }
        return r;
      }
      function RL(t) {
        try {
          document.createAttribute(t);
        } catch (t) {
          return false;
        }
        return true;
      }
      class OL extends Cl {
        static get requires() {
          return [TL];
        }
        static get pluginName() {
          return "CodeBlockElementSupport";
        }
        init() {
          if (!this.editor.plugins.has("CodeBlockEditing")) {
            return;
          }
          const t = this.editor.plugins.get(TL);
          t.on("register:pre", (e, n) => {
            if (n.model !== "codeBlock") {
              return;
            }
            const i = this.editor;
            const o = i.model.schema;
            const r = i.conversion;
            o.extend("codeBlock", {
              allowAttributes: ["htmlAttributes", "htmlContentAttributes"],
            });
            r.for("upcast").add(jL(t));
            r.for("downcast").add(FL());
            e.stop();
          });
        }
      }
      function jL(t) {
        return (e) => {
          e.on(
            "element:code",
            (e, n, i) => {
              const o = n.viewItem;
              const r = o.parent;
              if (!r || !r.is("element", "pre")) {
                return;
              }
              s(r, "htmlAttributes");
              s(o, "htmlContentAttributes");
              function s(e, o) {
                const r = t.processViewAttributes(e, i);
                if (r) {
                  i.writer.setAttribute(o, r, n.modelRange);
                }
              }
            },
            { priority: "low" }
          );
        };
      }
      function FL() {
        return (t) => {
          t.on("attribute:htmlAttributes:codeBlock", (t, e, n) => {
            if (!n.consumable.consume(e.item, t.name)) {
              return;
            }
            const { attributeOldValue: i, attributeNewValue: o } = e;
            const r = n.mapper.toViewElement(e.item);
            const s = r.parent;
            ZB(n.writer, i, o, s);
          });
          t.on("attribute:htmlContentAttributes:codeBlock", (t, e, n) => {
            if (!n.consumable.consume(e.item, t.name)) {
              return;
            }
            const { attributeOldValue: i, attributeNewValue: o } = e;
            const r = n.mapper.toViewElement(e.item);
            ZB(n.writer, i, o, r);
          });
        };
      }
      class VL extends Cl {
        static get requires() {
          return [TL];
        }
        static get pluginName() {
          return "DualContentModelElementSupport";
        }
        init() {
          const t = this.editor.plugins.get(TL);
          t.on("register", (t, e) => {
            const n = this.editor;
            const i = n.model.schema;
            const o = n.conversion;
            if (!e.paragraphLikeModel) {
              return;
            }
            if (
              i.isRegistered(e.model) ||
              i.isRegistered(e.paragraphLikeModel)
            ) {
              return;
            }
            const r = { model: e.paragraphLikeModel, view: e.view };
            i.register(e.model, e.modelSchema);
            i.register(r.model, { inheritAllFrom: "$block" });
            o.for("upcast").elementToElement({
              view: e.view,
              model: (t, { writer: n }) => {
                if (this._hasBlockContent(t)) {
                  return n.createElement(e.model);
                }
                return n.createElement(r.model);
              },
              converterPriority: S.get("low") + 1,
            });
            o.for("downcast").elementToElement({
              view: e.view,
              model: e.model,
            });
            this._addAttributeConversion(e);
            o.for("downcast").elementToElement({
              view: r.view,
              model: r.model,
            });
            this._addAttributeConversion(r);
            t.stop();
          });
        }
        _hasBlockContent(t) {
          const e = this.editor.editing.view;
          const n = e.domConverter.blockElements;
          for (const i of e.createRangeIn(t).getItems()) {
            if (i.is("element") && n.includes(i.name)) {
              return true;
            }
          }
          return false;
        }
        _addAttributeConversion(t) {
          const e = this.editor;
          const n = e.conversion;
          const i = e.plugins.get(TL);
          e.model.schema.extend(t.model, { allowAttributes: "htmlAttributes" });
          n.for("upcast").add(rL(t, i));
          n.for("downcast").add(sL(t));
        }
      }
      class HL extends Cl {
        static get requires() {
          return [KB];
        }
        static get pluginName() {
          return "HeadingElementSupport";
        }
        init() {
          const t = this.editor;
          if (!t.plugins.has("HeadingEditing")) {
            return;
          }
          const e = t.plugins.get(KB);
          const n = t.config.get("heading.options");
          const i = [];
          for (const t of n) {
            if ("model" in t && "view" in t) {
              e.registerBlockElement({ view: t.view, model: t.model });
              i.push(t.model);
            }
          }
          e.extendBlockElement({
            model: "htmlHgroup",
            modelSchema: { allowChildren: i },
          });
        }
      }
      class UL extends Cl {
        static get requires() {
          return [TL];
        }
        static get pluginName() {
          return "ImageElementSupport";
        }
        init() {
          const t = this.editor;
          if (
            !t.plugins.has("ImageInlineEditing") &&
            !t.plugins.has("ImageBlockEditing")
          ) {
            return;
          }
          const e = t.model.schema;
          const n = t.conversion;
          const i = t.plugins.get(TL);
          i.on("register:figure", () => {
            n.for("upcast").add(WL(i));
          });
          i.on("register:img", (t, o) => {
            if (o.model !== "imageBlock" && o.model !== "imageInline") {
              return;
            }
            if (e.isRegistered("imageBlock")) {
              e.extend("imageBlock", {
                allowAttributes: [
                  "htmlAttributes",
                  "htmlFigureAttributes",
                  "htmlLinkAttributes",
                ],
              });
            }
            if (e.isRegistered("imageInline")) {
              e.extend("imageInline", {
                allowAttributes: ["htmlA", "htmlAttributes"],
              });
            }
            n.for("upcast").add(qL(i));
            n.for("downcast").add(GL());
            t.stop();
          });
        }
      }
      function qL(t) {
        return (e) => {
          e.on(
            "element:img",
            (e, n, i) => {
              if (!n.modelRange) {
                return;
              }
              const o = n.viewItem;
              const r = o.parent;
              s(o, "htmlAttributes");
              if (r.is("element", "a")) {
                a(r);
              }
              function s(e, o) {
                const r = t.processViewAttributes(e, i);
                if (r) {
                  i.writer.setAttribute(o, r, n.modelRange);
                }
              }
              function a(t) {
                if (
                  n.modelRange &&
                  n.modelRange.getContainedElement().is("element", "imageBlock")
                ) {
                  s(t, "htmlLinkAttributes");
                }
              }
            },
            { priority: "low" }
          );
        };
      }
      function WL(t) {
        return (e) => {
          e.on(
            "element:figure",
            (e, n, i) => {
              const o = n.viewItem;
              if (!n.modelRange || !o.hasClass("image")) {
                return;
              }
              const r = t.processViewAttributes(o, i);
              if (r) {
                i.writer.setAttribute("htmlFigureAttributes", r, n.modelRange);
              }
            },
            { priority: "low" }
          );
        };
      }
      function GL() {
        return (t) => {
          e("htmlAttributes");
          n("img", "htmlAttributes");
          n("figure", "htmlFigureAttributes");
          n("a", "htmlLinkAttributes");
          function e(e) {
            t.on(
              \`attribute:\${e}:imageInline\`,
              (t, e, n) => {
                if (!n.consumable.consume(e.item, t.name)) {
                  return;
                }
                const { attributeOldValue: i, attributeNewValue: o } = e;
                const r = n.mapper.toViewElement(e.item);
                ZB(n.writer, i, o, r);
              },
              { priority: "low" }
            );
          }
          function n(e, n) {
            t.on(
              \`attribute:\${n}:imageBlock\`,
              (t, n, i) => {
                if (!i.consumable.test(n.item, t.name)) {
                  return;
                }
                const { attributeOldValue: o, attributeNewValue: r } = n;
                const s = i.mapper.toViewElement(n.item);
                const a = $L(i.writer, s, e);
                if (a) {
                  ZB(i.writer, o, r, a);
                  i.consumable.consume(n.item, t.name);
                }
              },
              { priority: "low" }
            );
            if (e === "a") {
              t.on(
                "attribute:linkHref:imageBlock",
                (t, e, n) => {
                  if (
                    !n.consumable.consume(
                      e.item,
                      "attribute:htmlLinkAttributes:imageBlock"
                    )
                  ) {
                    return;
                  }
                  const i = n.mapper.toViewElement(e.item);
                  const o = $L(n.writer, i, "a");
                  QB(n.writer, e.item.getAttribute("htmlLinkAttributes"), o);
                },
                { priority: "low" }
              );
            }
          }
        };
      }
      function $L(t, e, n) {
        const i = t.createRangeOn(e);
        for (const { item: t } of i.getWalker()) {
          if (t.is("element", n)) {
            return t;
          }
        }
      }
      class KL extends Cl {
        static get requires() {
          return [TL];
        }
        static get pluginName() {
          return "MediaEmbedElementSupport";
        }
        init() {
          const t = this.editor;
          if (
            !t.plugins.has("MediaEmbed") ||
            t.config.get("mediaEmbed.previewsInData")
          ) {
            return;
          }
          const e = t.model.schema;
          const n = t.conversion;
          const i = this.editor.plugins.get(TL);
          const o = this.editor.plugins.get(KB);
          const r = t.config.get("mediaEmbed.elementName");
          o.registerBlockElement({ model: "media", view: r });
          i.on("register:figure", () => {
            n.for("upcast").add(ZL(i));
          });
          i.on(\`register:\${r}\`, (t, o) => {
            if (o.model !== "media") {
              return;
            }
            e.extend("media", {
              allowAttributes: ["htmlAttributes", "htmlFigureAttributes"],
            });
            n.for("upcast").add(YL(i, r));
            n.for("dataDowncast").add(QL(r));
            t.stop();
          });
        }
      }
      function YL(t, e) {
        return (t) => {
          t.on(\`element:\${e}\`, n, { priority: "low" });
        };
        function n(e, n, i) {
          const o = n.viewItem;
          r(o, "htmlAttributes");
          function r(e, o) {
            const r = t.processViewAttributes(e, i);
            if (r) {
              i.writer.setAttribute(o, r, n.modelRange);
            }
          }
        }
      }
      function ZL(t) {
        return (e) => {
          e.on(
            "element:figure",
            (e, n, i) => {
              const o = n.viewItem;
              if (!n.modelRange || !o.hasClass("media")) {
                return;
              }
              const r = t.processViewAttributes(o, i);
              if (r) {
                i.writer.setAttribute("htmlFigureAttributes", r, n.modelRange);
              }
            },
            { priority: "low" }
          );
        };
      }
      function QL(t) {
        return (e) => {
          n(t, "htmlAttributes");
          n("figure", "htmlFigureAttributes");
          function n(t, n) {
            e.on(\`attribute:\${n}:media\`, (e, n, i) => {
              if (!i.consumable.consume(n.item, e.name)) {
                return;
              }
              const { attributeOldValue: o, attributeNewValue: r } = n;
              const s = i.mapper.toViewElement(n.item);
              const a = JL(i.writer, s, t);
              ZB(i.writer, o, r, a);
            });
          }
        };
      }
      function JL(t, e, n) {
        const i = t.createRangeOn(e);
        for (const { item: t } of i.getWalker()) {
          if (t.is("element", n)) {
            return t;
          }
        }
      }
      class XL extends Cl {
        static get requires() {
          return [TL];
        }
        static get pluginName() {
          return "ScriptElementSupport";
        }
        init() {
          const t = this.editor.plugins.get(TL);
          t.on("register:script", (e, n) => {
            const i = this.editor;
            const o = i.model.schema;
            const r = i.conversion;
            o.register("htmlScript", n.modelSchema);
            o.extend("htmlScript", {
              allowAttributes: ["htmlAttributes", "htmlContent"],
              isContent: true,
            });
            i.data.registerRawContentMatcher({ name: "script" });
            r.for("upcast").elementToElement({ view: "script", model: tL(n) });
            r.for("upcast").add(rL(n, t));
            r.for("downcast").elementToElement({
              model: "htmlScript",
              view: (t, { writer: e }) => nL("script", t, e),
            });
            r.for("downcast").add(sL(n));
            e.stop();
          });
        }
      }
      class tN extends Cl {
        static get requires() {
          return [TL];
        }
        static get pluginName() {
          return "TableElementSupport";
        }
        init() {
          const t = this.editor;
          if (!t.plugins.has("TableEditing")) {
            return;
          }
          const e = t.model.schema;
          const n = t.conversion;
          const i = t.plugins.get(TL);
          i.on("register:figure", () => {
            n.for("upcast").add(nN(i));
          });
          i.on("register:table", (t, o) => {
            if (o.model !== "table") {
              return;
            }
            e.extend("table", {
              allowAttributes: [
                "htmlAttributes",
                "htmlFigureAttributes",
                "htmlTheadAttributes",
                "htmlTbodyAttributes",
              ],
            });
            n.for("upcast").add(eN(i));
            n.for("downcast").add(iN());
            t.stop();
          });
        }
      }
      function eN(t) {
        return (e) => {
          e.on(
            "element:table",
            (e, n, i) => {
              const o = n.viewItem;
              r(o, "htmlAttributes");
              for (const t of o.getChildren()) {
                if (t.is("element", "thead")) {
                  r(t, "htmlTheadAttributes");
                }
                if (t.is("element", "tbody")) {
                  r(t, "htmlTbodyAttributes");
                }
              }
              function r(e, o) {
                const r = t.processViewAttributes(e, i);
                if (r) {
                  i.writer.setAttribute(o, r, n.modelRange);
                }
              }
            },
            { priority: "low" }
          );
        };
      }
      function nN(t) {
        return (e) => {
          e.on(
            "element:figure",
            (e, n, i) => {
              const o = n.viewItem;
              if (!n.modelRange || !o.hasClass("table")) {
                return;
              }
              const r = t.processViewAttributes(o, i);
              if (r) {
                i.writer.setAttribute("htmlFigureAttributes", r, n.modelRange);
              }
            },
            { priority: "low" }
          );
        };
      }
      function iN() {
        return (t) => {
          e("table", "htmlAttributes");
          e("figure", "htmlFigureAttributes");
          e("thead", "htmlTheadAttributes");
          e("tbody", "htmlTbodyAttributes");
          function e(e, n) {
            t.on(\`attribute:\${n}:table\`, (t, n, i) => {
              if (!i.consumable.consume(n.item, t.name)) {
                return;
              }
              const o = i.mapper.toViewElement(n.item);
              const r = oN(i.writer, o, e);
              QB(i.writer, n.attributeNewValue, r);
            });
          }
        };
      }
      function oN(t, e, n) {
        const i = t.createRangeOn(e);
        for (const { item: t } of i.getWalker()) {
          if (t.is("element", n)) {
            return t;
          }
        }
      }
      class rN extends Cl {
        static get requires() {
          return [TL];
        }
        static get pluginName() {
          return "StyleElementSupport";
        }
        init() {
          const t = this.editor.plugins.get(TL);
          t.on("register:style", (e, n) => {
            const i = this.editor;
            const o = i.model.schema;
            const r = i.conversion;
            o.register("htmlStyle", n.modelSchema);
            o.extend("htmlStyle", {
              allowAttributes: ["htmlAttributes", "htmlContent"],
              isContent: true,
            });
            i.data.registerRawContentMatcher({ name: "style" });
            r.for("upcast").elementToElement({ view: "style", model: tL(n) });
            r.for("upcast").add(rL(n, t));
            r.for("downcast").elementToElement({
              model: "htmlStyle",
              view: (t, { writer: e }) => nL("style", t, e),
            });
            r.for("downcast").add(sL(n));
            e.stop();
          });
        }
      }
      class sN extends Cl {
        static get requires() {
          return [TL];
        }
        static get pluginName() {
          return "DocumentListElementSupport";
        }
        init() {
          const t = this.editor;
          if (!t.plugins.has("DocumentListEditing")) {
            return;
          }
          const e = t.model.schema;
          const n = t.conversion;
          const i = t.plugins.get(TL);
          const o = t.plugins.get("DocumentListEditing");
          o.registerDowncastStrategy({
            scope: "item",
            attributeName: "htmlLiAttributes",
            setAttributeOnDowncast(t, e, n) {
              QB(t, e, n);
            },
          });
          o.registerDowncastStrategy({
            scope: "list",
            attributeName: "htmlListAttributes",
            setAttributeOnDowncast(t, e, n) {
              QB(t, e, n);
            },
          });
          i.on("register", (t, o) => {
            if (!["ul", "ol", "li"].includes(o.view)) {
              return;
            }
            t.stop();
            if (e.checkAttribute("$block", "htmlListAttributes")) {
              return;
            }
            e.extend("$block", {
              allowAttributes: ["htmlListAttributes", "htmlLiAttributes"],
            });
            e.extend("$blockObject", {
              allowAttributes: ["htmlListAttributes", "htmlLiAttributes"],
            });
            e.extend("$container", {
              allowAttributes: ["htmlListAttributes", "htmlLiAttributes"],
            });
            n.for("upcast").add((t) => {
              t.on("element:ul", aN("htmlListAttributes", i), {
                priority: "low",
              });
              t.on("element:ol", aN("htmlListAttributes", i), {
                priority: "low",
              });
              t.on("element:li", aN("htmlLiAttributes", i), {
                priority: "low",
              });
            });
          });
          o.on("postFixer", (t, { listNodes: e, writer: n }) => {
            const i = [];
            for (const { node: o, previous: r } of e) {
              if (!r) {
                continue;
              }
              const e = o.getAttribute("listIndent");
              const s = r.getAttribute("listIndent");
              let a = null;
              if (e > s) {
                i[s] = r;
              } else if (e < s) {
                a = i[e];
                i.length = e;
              } else {
                a = r;
              }
              if (!a) {
                continue;
              }
              if (a.getAttribute("listType") == o.getAttribute("listType")) {
                const e = a.getAttribute("htmlListAttributes");
                if (!sk(o.getAttribute("htmlListAttributes"), e)) {
                  n.setAttribute("htmlListAttributes", e, o);
                  t.return = true;
                }
              }
              if (
                a.getAttribute("listItemId") == o.getAttribute("listItemId")
              ) {
                const e = a.getAttribute("htmlLiAttributes");
                if (!sk(o.getAttribute("htmlLiAttributes"), e)) {
                  n.setAttribute("htmlLiAttributes", e, o);
                  t.return = true;
                }
              }
            }
          });
        }
        afterInit() {
          const t = this.editor;
          if (!t.commands.get("indentList")) {
            return;
          }
          this.listenTo(
            t.commands.get("indentList"),
            "afterExecute",
            (e, n) => {
              t.model.change((t) => {
                for (const e of n) {
                  t.setAttribute("htmlListAttributes", {}, e);
                }
              });
            }
          );
        }
      }
      function aN(t, e) {
        return (n, i, o) => {
          const r = i.viewItem;
          if (!i.modelRange) {
            Object.assign(i, o.convertChildren(i.viewItem, i.modelCursor));
          }
          const s = e.processViewAttributes(r, o);
          for (const e of i.modelRange.getItems({ shallow: true })) {
            if (!e.hasAttribute("listItemId")) {
              continue;
            }
            if (e.hasAttribute(t)) {
              continue;
            }
            o.writer.setAttribute(t, s || {}, e);
          }
        };
      }
      class cN extends Cl {
        static get requires() {
          return [TL, KB];
        }
        static get pluginName() {
          return "CustomElementSupport";
        }
        init() {
          const t = this.editor.plugins.get(TL);
          const e = this.editor.plugins.get(KB);
          t.on("register:$customElement", (n, i) => {
            n.stop();
            const o = this.editor;
            const r = o.model.schema;
            const s = o.conversion;
            const a = o.editing.view.domConverter.unsafeElements;
            const c = o.data.htmlProcessor.domConverter.preElements;
            r.register(i.model, i.modelSchema);
            r.extend(i.model, {
              allowAttributes: [
                "htmlElementName",
                "htmlAttributes",
                "htmlContent",
              ],
              isContent: true,
            });
            s.for("upcast").elementToElement({
              view: /.*/,
              model: (n, r) => {
                if (n.name == "$comment") {
                  return;
                }
                if (!lN(n.name)) {
                  return;
                }
                if (e.getDefinitionsForView(n.name).size) {
                  return;
                }
                if (!a.includes(n.name)) {
                  a.push(n.name);
                }
                if (!c.includes(n.name)) {
                  c.push(n.name);
                }
                const s = r.writer.createElement(i.model, {
                  htmlElementName: n.name,
                });
                const l = t.processViewAttributes(n, r);
                if (l) {
                  r.writer.setAttribute("htmlAttributes", l, s);
                }
                const d = new Fw(n.document);
                const u = d.createDocumentFragment(n);
                const h = o.data.processor.toData(u);
                r.writer.setAttribute("htmlContent", h, s);
                for (const { item: t } of o.editing.view.createRangeIn(n)) {
                  r.consumable.consume(t, { name: true });
                }
                return s;
              },
              converterPriority: "low",
            });
            s.for("editingDowncast").elementToElement({
              model: {
                name: i.model,
                attributes: [
                  "htmlElementName",
                  "htmlAttributes",
                  "htmlContent",
                ],
              },
              view: (t, { writer: e }) => {
                const n = t.getAttribute("htmlElementName");
                const i = e.createRawElement(n);
                if (t.hasAttribute("htmlAttributes")) {
                  QB(e, t.getAttribute("htmlAttributes"), i);
                }
                return i;
              },
            });
            s.for("dataDowncast").elementToElement({
              model: {
                name: i.model,
                attributes: [
                  "htmlElementName",
                  "htmlAttributes",
                  "htmlContent",
                ],
              },
              view: (t, { writer: e }) => {
                const n = t.getAttribute("htmlElementName");
                const i = t.getAttribute("htmlContent");
                const o = e.createRawElement(n, null, (t, e) => {
                  e.setContentOf(t, i);
                  const n = t.firstChild;
                  n.remove();
                  while (n.firstChild) {
                    t.appendChild(n.firstChild);
                  }
                });
                if (t.hasAttribute("htmlAttributes")) {
                  QB(e, t.getAttribute("htmlAttributes"), o);
                }
                return o;
              },
            });
          });
        }
      }
      function lN(t) {
        try {
          document.createElement(t);
        } catch (t) {
          return false;
        }
        return true;
      }
      class dN extends Cl {
        static get pluginName() {
          return "GeneralHtmlSupport";
        }
        static get requires() {
          return [TL, OL, VL, HL, UL, KL, XL, tN, rN, sN, cN];
        }
        init() {
          const t = this.editor;
          const e = t.plugins.get(TL);
          e.loadAllowedConfig(t.config.get("htmlSupport.allow") || []);
          e.loadDisallowedConfig(t.config.get("htmlSupport.disallow") || []);
        }
        getGhsAttributeNameForElement(t) {
          const e = this.editor.plugins.get("DataSchema");
          const n = Array.from(e.getDefinitionsForView(t, false));
          if (n && n.length && n[0].isInline && !n[0].isObject) {
            return n[0].model;
          }
          return "htmlAttributes";
        }
        addModelHtmlClass(t, e, n) {
          const i = this.editor.model;
          const o = this.getGhsAttributeNameForElement(t);
          i.change((t) => {
            for (const r of uN(i, n, o)) {
              mN(t, r, o, "classes", (t) => {
                for (const n of Yc(e)) {
                  t.add(n);
                }
              });
            }
          });
        }
        removeModelHtmlClass(t, e, n) {
          const i = this.editor.model;
          const o = this.getGhsAttributeNameForElement(t);
          i.change((t) => {
            for (const r of uN(i, n, o)) {
              mN(t, r, o, "classes", (t) => {
                for (const n of Yc(e)) {
                  t.delete(n);
                }
              });
            }
          });
        }
        setModelHtmlAttributes(t, e, n) {
          const i = this.editor.model;
          const o = this.getGhsAttributeNameForElement(t);
          i.change((t) => {
            for (const r of uN(i, n, o)) {
              mN(t, r, o, "attributes", (t) => {
                for (const [n, i] of Object.entries(e)) {
                  t.set(n, i);
                }
              });
            }
          });
        }
        removeModelHtmlAttributes(t, e, n) {
          const i = this.editor.model;
          const o = this.getGhsAttributeNameForElement(t);
          i.change((t) => {
            for (const r of uN(i, n, o)) {
              mN(t, r, o, "attributes", (t) => {
                for (const n of Yc(e)) {
                  t.delete(n);
                }
              });
            }
          });
        }
        setModelHtmlStyles(t, e, n) {
          const i = this.editor.model;
          const o = this.getGhsAttributeNameForElement(t);
          i.change((t) => {
            for (const r of uN(i, n, o)) {
              mN(t, r, o, "styles", (t) => {
                for (const [n, i] of Object.entries(e)) {
                  t.set(n, i);
                }
              });
            }
          });
        }
        removeModelHtmlStyles(t, e, n) {
          const i = this.editor.model;
          const o = this.getGhsAttributeNameForElement(t);
          i.change((t) => {
            for (const r of uN(i, n, o)) {
              mN(t, r, o, "styles", (t) => {
                for (const n of Yc(e)) {
                  t.delete(n);
                }
              });
            }
          });
        }
      }
      function* uN(t, e, n) {
        if (e.is("documentSelection") && e.isCollapsed) {
          if (t.schema.checkAttributeInSelection(e, n)) {
            yield e;
          }
        } else {
          for (const i of hN(t, e, n)) {
            yield* i.getItems({ shallow: true });
          }
        }
      }
      function hN(t, e, n) {
        if (e.is("node") || e.is("$text") || e.is("$textProxy")) {
          if (t.schema.checkAttribute(e, n)) {
            return [t.createRangeOn(e)];
          } else {
            return [];
          }
        } else {
          return t.schema.getValidRanges(t.createSelection(e).getRanges(), n);
        }
      }
      function mN(t, e, n, i, o) {
        const r = e.getAttribute(n);
        const s = {};
        for (const t of ["attributes", "styles", "classes"]) {
          if (t != i) {
            if (r && r[t]) {
              s[t] = r[t];
            }
          } else {
            const e =
              t == "classes"
                ? new Set((r && r[t]) || [])
                : new Map(Object.entries((r && r[t]) || {}));
            o(e);
            if (e.size) {
              s[t] = t == "classes" ? Array.from(e) : Object.fromEntries(e);
            }
          }
        }
        if (Object.keys(s).length) {
          if (e.is("documentSelection")) {
            t.setSelectionAttribute(n, s);
          } else {
            t.setAttribute(n, s, e);
          }
        } else if (r) {
          if (e.is("documentSelection")) {
            t.removeSelectionAttribute(n);
          } else {
            t.removeAttribute(n, e);
          }
        }
      }
      class gN extends vl {
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          const n = sl(e.selection.getSelectedBlocks());
          this.value = !!n && n.is("element", "paragraph");
          this.isEnabled = !!n && fN(n, t.schema);
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          e.change((i) => {
            const o = (t.selection || n.selection).getSelectedBlocks();
            for (const t of o) {
              if (!t.is("element", "paragraph") && fN(t, e.schema)) {
                i.rename(t, "paragraph");
              }
            }
          });
        }
      }
      function fN(t, e) {
        return e.checkChild(t.parent, "paragraph") && !e.isObject(t);
      }
      class pN extends vl {
        execute(t) {
          const e = this.editor.model;
          const n = t.attributes;
          let i = t.position;
          e.change((t) => {
            const o = t.createElement("paragraph");
            if (n) {
              e.schema.setAllowedAttributes(o, n, t);
            }
            if (!e.schema.checkChild(i.parent, o)) {
              const n = e.schema.findAllowedParent(i, o);
              if (!n) {
                return;
              }
              i = t.split(i, n).position;
            }
            e.insertContent(o, i);
            t.setSelection(o, "in");
          });
        }
      }
      class bN extends Cl {
        static get pluginName() {
          return "Paragraph";
        }
        init() {
          const t = this.editor;
          const e = t.model;
          t.commands.add("paragraph", new gN(t));
          t.commands.add("insertParagraph", new pN(t));
          e.schema.register("paragraph", { inheritAllFrom: "$block" });
          t.conversion.elementToElement({ model: "paragraph", view: "p" });
          t.conversion.for("upcast").elementToElement({
            model: (t, { writer: e }) => {
              if (!bN.paragraphLikeElements.has(t.name)) {
                return null;
              }
              if (t.isEmpty) {
                return null;
              }
              return e.createElement("paragraph");
            },
            view: /.+/,
            converterPriority: "low",
          });
        }
      }
      bN.paragraphLikeElements = new Set([
        "blockquote",
        "dd",
        "div",
        "dt",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "li",
        "p",
        "td",
        "th",
      ]);
      const kN = __.paragraph;
      class wN extends (null && Plugin) {
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add("paragraph", (n) => {
            const i = new ButtonView(n);
            const o = t.commands.get("paragraph");
            i.label = e("Paragraph");
            i.icon = kN;
            i.tooltip = true;
            i.isToggleable = true;
            i.bind("isEnabled").to(o);
            i.bind("isOn").to(o, "value");
            i.on("execute", () => {
              t.execute("paragraph");
            });
            return i;
          });
        }
      }
      class AN extends vl {
        constructor(t, e) {
          super(t);
          this.modelElements = e;
        }
        refresh() {
          const t = sl(
            this.editor.model.document.selection.getSelectedBlocks()
          );
          this.value = !!t && this.modelElements.includes(t.name) && t.name;
          this.isEnabled =
            !!t &&
            this.modelElements.some((e) => CN(t, e, this.editor.model.schema));
        }
        execute(t) {
          const e = this.editor.model;
          const n = e.document;
          const i = t.value;
          e.change((t) => {
            const o = Array.from(n.selection.getSelectedBlocks()).filter((t) =>
              CN(t, i, e.schema)
            );
            for (const e of o) {
              if (!e.is("element", i)) {
                t.rename(e, i);
              }
            }
          });
        }
      }
      function CN(t, e, n) {
        return n.checkChild(t.parent, e) && !n.isObject(t);
      }
      const _N = "paragraph";
      class vN extends Cl {
        static get pluginName() {
          return "HeadingEditing";
        }
        constructor(t) {
          super(t);
          t.config.define("heading", {
            options: [
              {
                model: "paragraph",
                title: "Paragraph",
                class: "ck-heading_paragraph",
              },
              {
                model: "heading1",
                view: "h2",
                title: "Heading 1",
                class: "ck-heading_heading1",
              },
              {
                model: "heading2",
                view: "h3",
                title: "Heading 2",
                class: "ck-heading_heading2",
              },
              {
                model: "heading3",
                view: "h4",
                title: "Heading 3",
                class: "ck-heading_heading3",
              },
            ],
          });
        }
        static get requires() {
          return [bN];
        }
        init() {
          const t = this.editor;
          const e = t.config.get("heading.options");
          const n = [];
          for (const i of e) {
            if (i.model !== _N) {
              t.model.schema.register(i.model, { inheritAllFrom: "$block" });
              t.conversion.elementToElement(i);
              n.push(i.model);
            }
          }
          this._addDefaultH1Conversion(t);
          t.commands.add("heading", new AN(t, n));
        }
        afterInit() {
          const t = this.editor;
          const e = t.commands.get("enter");
          const n = t.config.get("heading.options");
          if (e) {
            this.listenTo(e, "afterExecute", (e, i) => {
              const o = t.model.document.selection.getFirstPosition().parent;
              const r = n.some((t) => o.is("element", t.model));
              if (r && !o.is("element", _N) && o.childCount === 0) {
                i.writer.rename(o, _N);
              }
            });
          }
        }
        _addDefaultH1Conversion(t) {
          t.conversion.for("upcast").elementToElement({
            model: "heading1",
            view: "h1",
            converterPriority: S.get("low") + 1,
          });
        }
      }
      function yN(t) {
        const e = t.t;
        const n = {
          Paragraph: e("Paragraph"),
          "Heading 1": e("Heading 1"),
          "Heading 2": e("Heading 2"),
          "Heading 3": e("Heading 3"),
          "Heading 4": e("Heading 4"),
          "Heading 5": e("Heading 5"),
          "Heading 6": e("Heading 6"),
        };
        return t.config.get("heading.options").map((t) => {
          const e = n[t.title];
          if (e && e != t.title) {
            t.title = e;
          }
          return t;
        });
      }
      var xN = n(3230);
      var EN = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      EN.insert = "head";
      EN.singleton = true;
      var DN = Il()(xN.Z, EN);
      const SN = xN.Z.locals || {};
      class TN extends Cl {
        static get pluginName() {
          return "HeadingUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          const n = yN(t);
          const i = e("Choose heading");
          const o = e("Heading");
          t.ui.componentFactory.add("heading", (e) => {
            const r = {};
            const s = new rl();
            const a = t.commands.get("heading");
            const c = t.commands.get("paragraph");
            const l = [a];
            for (const t of n) {
              const e = {
                type: "button",
                model: new Py({
                  label: t.title,
                  class: t.class,
                  withText: true,
                }),
              };
              if (t.model === "paragraph") {
                e.model.bind("isOn").to(c, "value");
                e.model.set("commandName", "paragraph");
                l.push(c);
              } else {
                e.model.bind("isOn").to(a, "value", (e) => e === t.model);
                e.model.set({ commandName: "heading", commandValue: t.model });
              }
              s.add(e);
              r[t.model] = t.title;
            }
            const d = Uv(e);
            Wv(d, s);
            d.buttonView.set({ isOn: false, withText: true, tooltip: o });
            d.extendTemplate({
              attributes: { class: ["ck-heading-dropdown"] },
            });
            d.bind("isEnabled").toMany(l, "isEnabled", (...t) =>
              t.some((t) => t)
            );
            d.buttonView.bind("label").to(a, "value", c, "value", (t, e) => {
              const n = t || (e && "paragraph");
              return r[n] ? r[n] : i;
            });
            this.listenTo(d, "execute", (e) => {
              t.execute(
                e.source.commandName,
                e.source.commandValue
                  ? { value: e.source.commandValue }
                  : undefined
              );
              t.editing.view.focus();
            });
            return d;
          });
        }
      }
      class IN extends Cl {
        static get requires() {
          return [vN, TN];
        }
        static get pluginName() {
          return "Heading";
        }
      }
      class MN extends vl {
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.value = e.selection.getAttribute("highlight");
          this.isEnabled = t.schema.checkAttributeInSelection(
            e.selection,
            "highlight"
          );
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const i = n.selection;
          const o = t.value;
          e.change((t) => {
            if (i.isCollapsed) {
              const e = i.getFirstPosition();
              if (i.hasAttribute("highlight")) {
                const n = (t) =>
                  t.item.hasAttribute("highlight") &&
                  t.item.getAttribute("highlight") === this.value;
                const i = e.getLastMatchingPosition(n, {
                  direction: "backward",
                });
                const r = e.getLastMatchingPosition(n);
                const s = t.createRange(i, r);
                if (!o || this.value === o) {
                  if (!e.isEqual(r)) {
                    t.removeAttribute("highlight", s);
                  }
                  t.removeSelectionAttribute("highlight");
                } else {
                  if (!e.isEqual(r)) {
                    t.setAttribute("highlight", o, s);
                  }
                  t.setSelectionAttribute("highlight", o);
                }
              } else if (o) {
                t.setSelectionAttribute("highlight", o);
              }
            } else {
              const n = e.schema.getValidRanges(i.getRanges(), "highlight");
              for (const e of n) {
                if (o) {
                  t.setAttribute("highlight", o, e);
                } else {
                  t.removeAttribute("highlight", e);
                }
              }
            }
          });
        }
      }
      class BN extends Cl {
        static get pluginName() {
          return "HighlightEditing";
        }
        constructor(t) {
          super(t);
          t.config.define("highlight", {
            options: [
              {
                model: "yellowMarker",
                class: "marker-yellow",
                title: "Yellow marker",
                color: "var(--ck-highlight-marker-yellow)",
                type: "marker",
              },
              {
                model: "greenMarker",
                class: "marker-green",
                title: "Green marker",
                color: "var(--ck-highlight-marker-green)",
                type: "marker",
              },
              {
                model: "pinkMarker",
                class: "marker-pink",
                title: "Pink marker",
                color: "var(--ck-highlight-marker-pink)",
                type: "marker",
              },
              {
                model: "blueMarker",
                class: "marker-blue",
                title: "Blue marker",
                color: "var(--ck-highlight-marker-blue)",
                type: "marker",
              },
              {
                model: "redPen",
                class: "pen-red",
                title: "Red pen",
                color: "var(--ck-highlight-pen-red)",
                type: "pen",
              },
              {
                model: "greenPen",
                class: "pen-green",
                title: "Green pen",
                color: "var(--ck-highlight-pen-green)",
                type: "pen",
              },
            ],
          });
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: "highlight" });
          const e = t.config.get("highlight.options");
          t.conversion.attributeToElement(LN(e));
          t.commands.add("highlight", new MN(t));
        }
      }
      function LN(t) {
        const e = { model: { key: "highlight", values: [] }, view: {} };
        for (const n of t) {
          e.model.values.push(n.model);
          e.view[n.model] = { name: "mark", classes: n.class };
        }
        return e;
      }
      const NN =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.798 1.59 3.002 12.875l1.895 1.852 2.521 1.402 6.997-12.194z"/><path d="m2.556 16.727.234-.348c-.297-.151-.462-.293-.498-.426-.036-.137.002-.416.115-.837.094-.25.15-.449.169-.595a4.495 4.495 0 0 0 0-.725c-.209-.621-.303-1.041-.284-1.26.02-.218.178-.506.475-.862l6.77-9.414c.539-.91 1.605-.85 3.199.18 1.594 1.032 2.188 1.928 1.784 2.686l-5.877 10.36c-.158.412-.333.673-.526.782-.193.108-.604.179-1.232.21-.362.131-.608.237-.738.318-.13.081-.305.238-.526.47-.293.265-.504.397-.632.397-.096 0-.27-.075-.524-.226l-.31.41-1.6-1.12zm-.279.415 1.575 1.103-.392.515H1.19l1.087-1.618zm8.1-13.656-4.953 6.9L8.75 12.57l4.247-7.574c.175-.25-.188-.647-1.092-1.192-.903-.546-1.412-.652-1.528-.32zM8.244 18.5 9.59 17h9.406v1.5H8.245z"/></svg>';
      const zN =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.126 2.268 2.002 13.874l1.895 1.852 2.521 1.402L14.47 5.481l-1.543-2.568-2.801-.645z"/><path d="m4.5 18.088-2.645-1.852-.04-2.95-.006-.005.006-.008v-.025l.011.008L8.73 2.97c.165-.233.356-.417.567-.557l-1.212.308L4.604 7.9l-.83-.558 3.694-5.495 2.708-.69 1.65 1.145.046.018.85-1.216 2.16 1.512-.856 1.222c.828.967 1.144 2.141.432 3.158L7.55 17.286l.006.005-3.055.797H4.5zm-.634.166-1.976.516-.026-1.918 2.002 1.402zM9.968 3.817l-.006-.004-6.123 9.184 3.277 2.294 6.108-9.162.005.003c.317-.452-.16-1.332-1.064-1.966-.891-.624-1.865-.776-2.197-.349zM8.245 18.5 9.59 17h9.406v1.5H8.245z"/></svg>';
      var PN = n(713);
      var RN = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      RN.insert = "head";
      RN.singleton = true;
      var ON = Il()(PN.Z, RN);
      const jN = PN.Z.locals || {};
      class FN extends Cl {
        get localizedOptionTitles() {
          const t = this.editor.t;
          return {
            "Yellow marker": t("Yellow marker"),
            "Green marker": t("Green marker"),
            "Pink marker": t("Pink marker"),
            "Blue marker": t("Blue marker"),
            "Red pen": t("Red pen"),
            "Green pen": t("Green pen"),
          };
        }
        static get pluginName() {
          return "HighlightUI";
        }
        init() {
          const t = this.editor.config.get("highlight.options");
          for (const e of t) {
            this._addHighlighterButton(e);
          }
          this._addRemoveHighlightButton();
          this._addDropdown(t);
        }
        _addRemoveHighlightButton() {
          const t = this.editor.t;
          const e = this.editor.commands.get("highlight");
          this._addButton(
            "removeHighlight",
            t("Remove highlight"),
            __.eraser,
            null,
            (t) => {
              t.bind("isEnabled").to(e, "isEnabled");
            }
          );
        }
        _addHighlighterButton(t) {
          const e = this.editor.commands.get("highlight");
          this._addButton(
            "highlight:" + t.model,
            t.title,
            HN(t.type),
            t.model,
            n
          );
          function n(n) {
            n.bind("isEnabled").to(e, "isEnabled");
            n.bind("isOn").to(e, "value", (e) => e === t.model);
            n.iconView.fillColor = t.color;
            n.isToggleable = true;
          }
        }
        _addButton(t, e, n, i, o) {
          const r = this.editor;
          r.ui.componentFactory.add(t, (t) => {
            const s = new R_(t);
            const a = this.localizedOptionTitles[e]
              ? this.localizedOptionTitles[e]
              : e;
            s.set({ label: a, icon: n, tooltip: true });
            s.on("execute", () => {
              r.execute("highlight", { value: i });
              r.editing.view.focus();
            });
            o(s);
            return s;
          });
        }
        _addDropdown(t) {
          const e = this.editor;
          const n = e.t;
          const i = e.ui.componentFactory;
          const o = t[0];
          const r = t.reduce((t, e) => {
            t[e.model] = e;
            return t;
          }, {});
          i.add("highlight", (s) => {
            const a = e.commands.get("highlight");
            const c = Uv(s, rv);
            const l = c.buttonView;
            l.set({
              label: n("Highlight"),
              tooltip: true,
              lastExecuted: o.model,
              commandValue: o.model,
              isToggleable: true,
            });
            l.bind("icon").to(a, "value", (t) => HN(u(t, "type")));
            l.bind("color").to(a, "value", (t) => u(t, "color"));
            l.bind("commandValue").to(a, "value", (t) => u(t, "model"));
            l.bind("isOn").to(a, "value", (t) => !!t);
            l.delegate("execute").to(c);
            const d = t.map((t) => {
              const e = i.create("highlight:" + t.model);
              this.listenTo(e, "execute", () => {
                c.buttonView.set({ lastExecuted: t.model });
              });
              return e;
            });
            c.bind("isEnabled").toMany(d, "isEnabled", (...t) =>
              t.some((t) => t)
            );
            d.push(new gv());
            d.push(i.create("removeHighlight"));
            qv(c, d, { enableActiveItemFocusOnDropdownOpen: true });
            VN(c);
            c.toolbarView.ariaLabel = n("Text highlight toolbar");
            l.on("execute", () => {
              e.execute("highlight", { value: l.commandValue });
            });
            this.listenTo(c, "execute", () => {
              e.editing.view.focus();
            });
            function u(t, e) {
              const n = !t || t === l.lastExecuted ? l.lastExecuted : t;
              return r[n][e];
            }
            return c;
          });
        }
      }
      function VN(t) {
        const e = t.buttonView.actionView;
        e.iconView.bind("fillColor").to(t.buttonView, "color");
      }
      function HN(t) {
        return t === "marker" ? NN : zN;
      }
      class UN extends Cl {
        static get requires() {
          return [BN, FN];
        }
        static get pluginName() {
          return "Highlight";
        }
      }
      class qN extends vl {
        refresh() {
          const t = this.editor.model;
          const e = t.schema;
          const n = t.document.selection;
          this.isEnabled = WN(n, e, t);
        }
        execute() {
          const t = this.editor.model;
          t.change((e) => {
            const n = e.createElement("horizontalLine");
            t.insertObject(n, null, null, { setSelection: "after" });
          });
        }
      }
      function WN(t, e, n) {
        const i = GN(t, n);
        return e.checkChild(i, "horizontalLine");
      }
      function GN(t, e) {
        const n = uD(t, e);
        const i = n.start.parent;
        if (i.isEmpty && !i.is("element", "$root")) {
          return i.parent;
        }
        return i;
      }
      var $N = n(2536);
      var KN = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      KN.insert = "head";
      KN.singleton = true;
      var YN = Il()($N.Z, KN);
      const ZN = $N.Z.locals || {};
      class QN extends Cl {
        static get pluginName() {
          return "HorizontalLineEditing";
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.t;
          const i = t.conversion;
          e.register("horizontalLine", { inheritAllFrom: "$blockObject" });
          i.for("dataDowncast").elementToElement({
            model: "horizontalLine",
            view: (t, { writer: e }) => e.createEmptyElement("hr"),
          });
          i.for("editingDowncast").elementToStructure({
            model: "horizontalLine",
            view: (t, { writer: e }) => {
              const i = n("Horizontal line");
              const o = e.createContainerElement(
                "div",
                null,
                e.createEmptyElement("hr")
              );
              e.addClass("ck-horizontal-line", o);
              e.setCustomProperty("hr", true, o);
              return JN(o, e, i);
            },
          });
          i.for("upcast").elementToElement({
            view: "hr",
            model: "horizontalLine",
          });
          t.commands.add("horizontalLine", new qN(t));
        }
      }
      function JN(t, e, n) {
        e.setCustomProperty("horizontalLine", true, t);
        return oD(t, e, { label: n });
      }
      const XN =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 9h16v2H2z"/></svg>';
      class tz extends Cl {
        static get pluginName() {
          return "HorizontalLineUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add("horizontalLine", (n) => {
            const i = t.commands.get("horizontalLine");
            const o = new R_(n);
            o.set({ label: e("Horizontal line"), icon: XN, tooltip: true });
            o.bind("isEnabled").to(i, "isEnabled");
            this.listenTo(o, "execute", () => {
              t.execute("horizontalLine");
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class ez extends Cl {
        static get requires() {
          return [QN, tz, qD];
        }
        static get pluginName() {
          return "HorizontalLine";
        }
      }
      class nz extends vl {
        refresh() {
          const t = this.editor.model;
          const e = t.schema;
          const n = t.document.selection;
          const i = rz(n);
          this.isEnabled = iz(n, e, t);
          this.value = i ? i.getAttribute("value") || "" : null;
        }
        execute(t) {
          const e = this.editor.model;
          const n = e.document.selection;
          e.change((i) => {
            let o;
            if (this.value !== null) {
              o = rz(n);
            } else {
              o = i.createElement("rawHtml");
              e.insertObject(o, null, null, { setSelection: "on" });
            }
            i.setAttribute("value", t, o);
          });
        }
      }
      function iz(t, e, n) {
        const i = oz(t, n);
        return e.checkChild(i, "rawHtml");
      }
      function oz(t, e) {
        const n = uD(t, e);
        const i = n.start.parent;
        if (i.isEmpty && !i.is("element", "$root")) {
          return i.parent;
        }
        return i;
      }
      function rz(t) {
        const e = t.getSelectedElement();
        if (e && e.is("element", "rawHtml")) {
          return e;
        }
        return null;
      }
      var sz = n(3403);
      var az = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      az.insert = "head";
      az.singleton = true;
      var cz = Il()(sz.Z, az);
      const lz = sz.Z.locals || {};
      class dz extends Cl {
        static get pluginName() {
          return "HtmlEmbedEditing";
        }
        constructor(t) {
          super(t);
          t.config.define("htmlEmbed", {
            showPreviews: false,
            sanitizeHtml: (t) => {
              B("html-embed-provide-sanitize-function");
              return { html: t, hasChanged: false };
            },
          });
          this._widgetButtonViewReferences = new Set();
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          e.register("rawHtml", {
            inheritAllFrom: "$blockObject",
            allowAttributes: ["value"],
          });
          t.commands.add("htmlEmbed", new nz(t));
          this._setupConversion();
        }
        _setupConversion() {
          const t = this.editor;
          const e = t.t;
          const n = t.editing.view;
          const i = this._widgetButtonViewReferences;
          const o = t.config.get("htmlEmbed");
          this.editor.editing.view.on(
            "render",
            () => {
              for (const t of i) {
                if (t.element.isConnected) {
                  return;
                }
                t.destroy();
                i.delete(t);
              }
            },
            { priority: "lowest" }
          );
          t.data.registerRawContentMatcher({
            name: "div",
            classes: "raw-html-embed",
          });
          t.conversion.for("upcast").elementToElement({
            view: { name: "div", classes: "raw-html-embed" },
            model: (t, { writer: e }) =>
              e.createElement("rawHtml", {
                value: t.getCustomProperty("$rawContent"),
              }),
          });
          t.conversion.for("dataDowncast").elementToElement({
            model: "rawHtml",
            view: (t, { writer: e }) =>
              e.createRawElement(
                "div",
                { class: "raw-html-embed" },
                function (e) {
                  e.innerHTML = t.getAttribute("value") || "";
                }
              ),
          });
          t.conversion.for("editingDowncast").elementToStructure({
            model: { name: "rawHtml", attributes: ["value"] },
            view: (i, { writer: s }) => {
              let a, c, l;
              const d = s.createRawElement(
                "div",
                { class: "raw-html-embed__content-wrapper" },
                function (e) {
                  a = e;
                  r({ domElement: e, editor: t, state: c, props: l });
                  a.addEventListener(
                    "mousedown",
                    () => {
                      if (c.isEditable) {
                        const e = t.model;
                        const n = e.document.selection.getSelectedElement();
                        if (n !== i) {
                          e.change((t) => t.setSelection(i, "on"));
                        }
                      }
                    },
                    true
                  );
                }
              );
              const u = {
                makeEditable() {
                  c = Object.assign({}, c, { isEditable: true });
                  r({ domElement: a, editor: t, state: c, props: l });
                  n.change((t) => {
                    t.setAttribute("data-cke-ignore-events", "true", d);
                  });
                  a.querySelector("textarea").focus();
                },
                save(e) {
                  if (e !== c.getRawHtmlValue()) {
                    t.execute("htmlEmbed", e);
                    t.editing.view.focus();
                  } else {
                    this.cancel();
                  }
                },
                cancel() {
                  c = Object.assign({}, c, { isEditable: false });
                  r({ domElement: a, editor: t, state: c, props: l });
                  t.editing.view.focus();
                  n.change((t) => {
                    t.removeAttribute("data-cke-ignore-events", d);
                  });
                },
              };
              c = {
                showPreviews: o.showPreviews,
                isEditable: false,
                getRawHtmlValue: () => i.getAttribute("value") || "",
              };
              l = {
                sanitizeHtml: o.sanitizeHtml,
                textareaPlaceholder: e("Paste raw HTML here..."),
                onEditClick() {
                  u.makeEditable();
                },
                onSaveClick(t) {
                  u.save(t);
                },
                onCancelClick() {
                  u.cancel();
                },
              };
              const h = s.createContainerElement(
                "div",
                {
                  class: "raw-html-embed",
                  "data-html-embed-label": e("HTML snippet"),
                  dir: t.locale.uiLanguageDirection,
                },
                d
              );
              s.setCustomProperty("rawHtmlApi", u, h);
              s.setCustomProperty("rawHtml", true, h);
              return oD(h, s, {
                widgetLabel: e("HTML snippet"),
                hasSelectionHandle: true,
              });
            },
          });
          function r({ domElement: t, editor: e, state: n, props: i }) {
            t.textContent = "";
            const o = t.ownerDocument;
            let r;
            if (n.isEditable) {
              const e = {
                isDisabled: false,
                placeholder: i.textareaPlaceholder,
              };
              r = a({ domDocument: o, state: n, props: e });
              t.append(r);
            } else if (n.showPreviews) {
              const r = { sanitizeHtml: i.sanitizeHtml };
              t.append(c({ domDocument: o, state: n, props: r, editor: e }));
            } else {
              const e = {
                isDisabled: true,
                placeholder: i.textareaPlaceholder,
              };
              t.append(a({ domDocument: o, state: n, props: e }));
            }
            const l = {
              onEditClick: i.onEditClick,
              onSaveClick: () => {
                i.onSaveClick(r.value);
              },
              onCancelClick: i.onCancelClick,
            };
            t.prepend(s({ editor: e, domDocument: o, state: n, props: l }));
          }
          function s({ editor: t, domDocument: e, state: n, props: o }) {
            const r = te(e, "div", {
              class: "raw-html-embed__buttons-wrapper",
            });
            if (n.isEditable) {
              const e = uz(t, "save", o.onSaveClick);
              const n = uz(t, "cancel", o.onCancelClick);
              r.append(e.element, n.element);
              i.add(e).add(n);
            } else {
              const e = uz(t, "edit", o.onEditClick);
              r.append(e.element);
              i.add(e);
            }
            return r;
          }
          function a({ domDocument: t, state: e, props: n }) {
            const i = te(t, "textarea", {
              placeholder: n.placeholder,
              class:
                "ck ck-reset ck-input ck-input-text raw-html-embed__source",
            });
            i.disabled = n.isDisabled;
            i.value = e.getRawHtmlValue();
            return i;
          }
          function c({ domDocument: t, state: n, props: i, editor: o }) {
            const r = i.sanitizeHtml(n.getRawHtmlValue());
            const s =
              n.getRawHtmlValue().length > 0
                ? e("No preview available")
                : e("Empty snippet content");
            const a = te(
              t,
              "div",
              { class: "ck ck-reset_all raw-html-embed__preview-placeholder" },
              s
            );
            const c = te(t, "div", {
              class: "raw-html-embed__preview-content",
              dir: o.locale.contentLanguageDirection,
            });
            const l = t.createRange();
            const d = l.createContextualFragment(r.html);
            c.appendChild(d);
            const u = te(t, "div", { class: "raw-html-embed__preview" }, [
              a,
              c,
            ]);
            return u;
          }
        }
      }
      function uz(t, e, n) {
        const i = t.locale.t;
        const o = new R_(t.locale);
        const r = t.commands.get("htmlEmbed");
        o.set({
          class: \`raw-html-embed__\${e}-button\`,
          icon: __.pencil,
          tooltip: true,
          tooltipPosition: t.locale.uiLanguageDirection === "rtl" ? "e" : "w",
        });
        o.render();
        if (e === "edit") {
          o.set({ icon: __.pencil, label: i("Edit source") });
          o.bind("isEnabled").to(r);
        } else if (e === "save") {
          o.set({ icon: __.check, label: i("Save changes") });
          o.bind("isEnabled").to(r);
        } else {
          o.set({ icon: __.cancel, label: i("Cancel") });
        }
        o.on("execute", n);
        return o;
      }
      const hz =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17 0a2 2 0 0 1 2 2v7a1 1 0 0 1 1 1v5a1 1 0 0 1-.883.993l-.118.006L19 17a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2l-.001-1.001-.116-.006A1 1 0 0 1 0 15v-5a1 1 0 0 1 .999-1L1 2a2 2 0 0 1 2-2h14zm.499 15.999h-15L2.5 17a.5.5 0 0 0 .5.5h14a.5.5 0 0 0 .5-.5l-.001-1.001zm-3.478-6.013-.014.014H14v.007l-1.525 1.525-1.46-1.46-.015.013V10h-1v5h1v-3.53l1.428 1.43.048.043.131-.129L14 11.421V15h1v-5h-.965l-.014-.014zM2 10H1v5h1v-2h2v2h1v-5H4v2H2v-2zm7 0H6v1h1v4h1v-4h1v-1zm8 0h-1v5h3v-1h-2v-4zm0-8.5H3a.5.5 0 0 0-.5.5l-.001 6.999h15L17.5 2a.5.5 0 0 0-.5-.5zM10 7v1H4V7h6zm3-2v1H4V5h9zm-3-2v1H4V3h6z"/></svg>';
      class mz extends Cl {
        static get pluginName() {
          return "HtmlEmbedUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add("htmlEmbed", (n) => {
            const i = t.commands.get("htmlEmbed");
            const o = new R_(n);
            o.set({ label: e("Insert HTML"), icon: hz, tooltip: true });
            o.bind("isEnabled").to(i, "isEnabled");
            this.listenTo(o, "execute", () => {
              t.execute("htmlEmbed");
              t.editing.view.focus();
              const e = t.editing.view.document.selection.getSelectedElement();
              e.getCustomProperty("rawHtmlApi").makeEditable();
            });
            return o;
          });
        }
      }
      class gz extends Cl {
        static get requires() {
          return [dz, mz, qD];
        }
        static get pluginName() {
          return "HtmlEmbed";
        }
      }
      class fz extends vl {
        refresh() {
          const t = this.editor;
          const e = t.plugins.get("ImageUtils");
          const n = e.getClosestSelectedImageElement(
            this.editor.model.document.selection
          );
          this.isEnabled = !!n;
          if (this.isEnabled && n.hasAttribute("alt")) {
            this.value = n.getAttribute("alt");
          } else {
            this.value = false;
          }
        }
        execute(t) {
          const e = this.editor;
          const n = e.plugins.get("ImageUtils");
          const i = e.model;
          const o = n.getClosestSelectedImageElement(i.document.selection);
          i.change((e) => {
            e.setAttribute("alt", t.newValue, o);
          });
        }
      }
      class pz extends Cl {
        static get requires() {
          return [$S];
        }
        static get pluginName() {
          return "ImageTextAlternativeEditing";
        }
        init() {
          this.editor.commands.add("imageTextAlternative", new fz(this.editor));
        }
      }
      var bz = n(6831);
      var kz = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      kz.insert = "head";
      kz.singleton = true;
      var wz = Il()(bz.Z, kz);
      const Az = bz.Z.locals || {};
      var Cz = n(1590);
      var _z = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      _z.insert = "head";
      _z.singleton = true;
      var vz = Il()(Cz.Z, _z);
      const yz = Cz.Z.locals || {};
      class xz extends pC {
        constructor(t) {
          super(t);
          const e = this.locale.t;
          this.focusTracker = new al();
          this.keystrokes = new cl();
          this.labeledInput = this._createLabeledInputView();
          this.saveButtonView = this._createButton(
            e("Save"),
            __.check,
            "ck-button-save"
          );
          this.saveButtonView.type = "submit";
          this.cancelButtonView = this._createButton(
            e("Cancel"),
            __.cancel,
            "ck-button-cancel",
            "cancel"
          );
          this._focusables = new PA();
          this._focusCycler = new hv({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          });
          this.setTemplate({
            tag: "form",
            attributes: {
              class: ["ck", "ck-text-alternative-form", "ck-responsive-form"],
              tabindex: "-1",
            },
            children: [
              this.labeledInput,
              this.saveButtonView,
              this.cancelButtonView,
            ],
          });
          y_(this);
        }
        render() {
          super.render();
          this.keystrokes.listenTo(this.element);
          x_({ view: this });
          [
            this.labeledInput,
            this.saveButtonView,
            this.cancelButtonView,
          ].forEach((t) => {
            this._focusables.add(t);
            this.focusTracker.add(t.element);
          });
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        _createButton(t, e, n, i) {
          const o = new R_(this.locale);
          o.set({ label: t, icon: e, tooltip: true });
          o.extendTemplate({ attributes: { class: n } });
          if (i) {
            o.delegate("execute").to(this, i);
          }
          return o;
        }
        _createLabeledInputView() {
          const t = this.locale.t;
          const e = new My(this.locale, By);
          e.label = t("Text alternative");
          return e;
        }
      }
      function Ez(t) {
        const e = t.plugins.get("ContextualBalloon");
        if (
          t.plugins
            .get("ImageUtils")
            .getClosestSelectedImageWidget(t.editing.view.document.selection)
        ) {
          const n = Dz(t);
          e.updatePosition(n);
        }
      }
      function Dz(t) {
        const e = t.editing.view;
        const n = vC.defaultPositions;
        const i = t.plugins.get("ImageUtils");
        return {
          target: e.domConverter.mapViewToDom(
            i.getClosestSelectedImageWidget(e.document.selection)
          ),
          positions: [
            n.northArrowSouth,
            n.northArrowSouthWest,
            n.northArrowSouthEast,
            n.southArrowNorth,
            n.southArrowNorthWest,
            n.southArrowNorthEast,
            n.viewportStickyNorth,
          ],
        };
      }
      class Sz extends Cl {
        static get requires() {
          return [Ky];
        }
        static get pluginName() {
          return "ImageTextAlternativeUI";
        }
        init() {
          this._createButton();
          this._createForm();
        }
        destroy() {
          super.destroy();
          this._form.destroy();
        }
        _createButton() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add("imageTextAlternative", (n) => {
            const i = t.commands.get("imageTextAlternative");
            const o = new R_(n);
            o.set({
              label: e("Change image text alternative"),
              icon: __.lowVision,
              tooltip: true,
            });
            o.bind("isEnabled").to(i, "isEnabled");
            o.bind("isOn").to(i, "value", (t) => !!t);
            this.listenTo(o, "execute", () => {
              this._showForm();
            });
            return o;
          });
        }
        _createForm() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          const i = t.plugins.get("ImageUtils");
          this._balloon = this.editor.plugins.get("ContextualBalloon");
          this._form = new xz(t.locale);
          this._form.render();
          this.listenTo(this._form, "submit", () => {
            t.execute("imageTextAlternative", {
              newValue: this._form.labeledInput.fieldView.element.value,
            });
            this._hideForm(true);
          });
          this.listenTo(this._form, "cancel", () => {
            this._hideForm(true);
          });
          this._form.keystrokes.set("Esc", (t, e) => {
            this._hideForm(true);
            e();
          });
          this.listenTo(t.ui, "update", () => {
            if (!i.getClosestSelectedImageWidget(n.selection)) {
              this._hideForm(true);
            } else if (this._isVisible) {
              Ez(t);
            }
          });
          v_({
            emitter: this._form,
            activator: () => this._isVisible,
            contextElements: [this._balloon.view.element],
            callback: () => this._hideForm(),
          });
        }
        _showForm() {
          if (this._isVisible) {
            return;
          }
          const t = this.editor;
          const e = t.commands.get("imageTextAlternative");
          const n = this._form.labeledInput;
          this._form.disableCssTransitions();
          if (!this._isInBalloon) {
            this._balloon.add({ view: this._form, position: Dz(t) });
          }
          n.fieldView.value = n.fieldView.element.value = e.value || "";
          this._form.labeledInput.fieldView.select();
          this._form.enableCssTransitions();
        }
        _hideForm(t) {
          if (!this._isInBalloon) {
            return;
          }
          if (this._form.focusTracker.isFocused) {
            this._form.saveButtonView.focus();
          }
          this._balloon.remove(this._form);
          if (t) {
            this.editor.editing.view.focus();
          }
        }
        get _isVisible() {
          return this._balloon.visibleView === this._form;
        }
        get _isInBalloon() {
          return this._balloon.hasView(this._form);
        }
      }
      class Tz extends Cl {
        static get requires() {
          return [pz, Sz];
        }
        static get pluginName() {
          return "ImageTextAlternative";
        }
      }
      function Iz(t) {
        return (t) => {
          t.on("element:figure", e);
        };
        function e(e, n, i) {
          if (
            !i.consumable.test(n.viewItem, { name: true, classes: "image" })
          ) {
            return;
          }
          const o = t.findViewImgElement(n.viewItem);
          if (!o || !i.consumable.test(o, { name: true })) {
            return;
          }
          i.consumable.consume(n.viewItem, { name: true, classes: "image" });
          const r = i.convertItem(o, n.modelCursor);
          const s = sl(r.modelRange.getItems());
          if (!s) {
            i.consumable.revert(n.viewItem, { name: true, classes: "image" });
            return;
          }
          i.convertChildren(n.viewItem, s);
          i.updateConversionResult(s, n);
        }
      }
      function Mz(t) {
        const e = ["srcset", "media", "type", "sizes"];
        return (t) => {
          t.on("element:picture", n);
        };
        function n(n, i, o) {
          const r = i.viewItem;
          if (!o.consumable.test(r, { name: true })) {
            return;
          }
          const s = new Map();
          for (const t of r.getChildren()) {
            if (t.is("element", "source")) {
              const n = {};
              for (const i of e) {
                if (t.hasAttribute(i)) {
                  if (o.consumable.test(t, { attributes: i })) {
                    n[i] = t.getAttribute(i);
                  }
                }
              }
              if (Object.keys(n).length) {
                s.set(t, n);
              }
            }
          }
          const a = t.findViewImgElement(r);
          if (!a) {
            return;
          }
          let c = i.modelCursor.parent;
          if (!c.is("element", "imageBlock")) {
            const t = o.convertItem(a, i.modelCursor);
            i.modelRange = t.modelRange;
            i.modelCursor = t.modelCursor;
            c = first(t.modelRange.getItems());
          }
          o.consumable.consume(r, { name: true });
          for (const [t, e] of s) {
            o.consumable.consume(t, { attributes: Object.keys(e) });
          }
          if (s.size) {
            o.writer.setAttribute("sources", Array.from(s.values()), c);
          }
          o.convertChildren(r, c);
        }
      }
      function Bz(t, e) {
        return (t) => {
          t.on(\`attribute:srcset:\${e}\`, n);
        };
        function n(e, n, i) {
          if (!i.consumable.consume(n.item, e.name)) {
            return;
          }
          const o = i.writer;
          const r = i.mapper.toViewElement(n.item);
          const s = t.findViewImgElement(r);
          if (n.attributeNewValue === null) {
            const t = n.attributeOldValue;
            if (t.data) {
              o.removeAttribute("srcset", s);
              o.removeAttribute("sizes", s);
              if (t.width) {
                o.removeAttribute("width", s);
              }
            }
          } else {
            const t = n.attributeNewValue;
            if (t.data) {
              o.setAttribute("srcset", t.data, s);
              o.setAttribute("sizes", "100vw", s);
              if (t.width) {
                o.setAttribute("width", t.width, s);
              }
            }
          }
        }
      }
      function Lz(t) {
        return (t) => {
          t.on("attribute:sources:imageBlock", e);
          t.on("attribute:sources:imageInline", e);
        };
        function e(e, n, i) {
          if (!i.consumable.consume(n.item, e.name)) {
            return;
          }
          const o = i.writer;
          const r = i.mapper.toViewElement(n.item);
          const s = t.findViewImgElement(r);
          if (n.attributeNewValue && n.attributeNewValue.length) {
            const t = o.createContainerElement(
              "picture",
              null,
              n.attributeNewValue.map((t) => o.createEmptyElement("source", t))
            );
            const e = [];
            let i = s.parent;
            while (i && i.is("attributeElement")) {
              const t = i.parent;
              o.unwrap(o.createRangeOn(s), i);
              e.unshift(i);
              i = t;
            }
            o.insert(o.createPositionBefore(s), t);
            o.move(o.createRangeOn(s), o.createPositionAt(t, "end"));
            for (const n of e) {
              o.wrap(o.createRangeOn(t), n);
            }
          } else if (s.parent.is("element", "picture")) {
            const t = s.parent;
            o.move(o.createRangeOn(s), o.createPositionBefore(t));
            o.remove(t);
          }
        }
      }
      function Nz(t, e, n) {
        return (t) => {
          t.on(\`attribute:\${n}:\${e}\`, i);
        };
        function i(e, n, i) {
          if (!i.consumable.consume(n.item, e.name)) {
            return;
          }
          const o = i.writer;
          const r = i.mapper.toViewElement(n.item);
          const s = t.findViewImgElement(r);
          o.setAttribute(n.attributeKey, n.attributeNewValue || "", s);
        }
      }
      class zz extends Em {
        observe(t) {
          this.listenTo(
            t,
            "load",
            (t, e) => {
              const n = e.target;
              if (this.checkShouldIgnoreEventFromTarget(n)) {
                return;
              }
              if (n.tagName == "IMG") {
                this._fireEvents(e);
              }
            },
            { useCapture: true }
          );
        }
        _fireEvents(t) {
          if (this.isEnabled) {
            this.document.fire("layoutChanged");
            this.document.fire("imageLoaded", t);
          }
        }
      }
      class Pz extends vl {
        constructor(t) {
          super(t);
          const e = t.config.get("image.insert.type");
          if (!t.plugins.has("ImageBlockEditing")) {
            if (e === "block") {
              B("image-block-plugin-required");
            }
          }
          if (!t.plugins.has("ImageInlineEditing")) {
            if (e === "inline") {
              B("image-inline-plugin-required");
            }
          }
        }
        refresh() {
          this.isEnabled = this.editor.plugins
            .get("ImageUtils")
            .isImageAllowed();
        }
        execute(t) {
          const e = Yc(t.source);
          const n = this.editor.model.document.selection;
          const i = this.editor.plugins.get("ImageUtils");
          const o = Object.fromEntries(n.getAttributes());
          e.forEach((t, e) => {
            const r = n.getSelectedElement();
            if (typeof t === "string") {
              t = { src: t };
            }
            if (e && r && i.isImage(r)) {
              const e = this.editor.model.createPositionAfter(r);
              i.insertImage({ ...t, ...o }, e);
            } else {
              i.insertImage({ ...t, ...o });
            }
          });
        }
      }
      class Rz extends Cl {
        static get requires() {
          return [$S];
        }
        static get pluginName() {
          return "ImageEditing";
        }
        init() {
          const t = this.editor;
          const e = t.conversion;
          t.editing.view.addObserver(zz);
          e.for("upcast")
            .attributeToAttribute({
              view: { name: "img", key: "alt" },
              model: "alt",
            })
            .attributeToAttribute({
              view: { name: "img", key: "srcset" },
              model: {
                key: "srcset",
                value: (t) => {
                  const e = { data: t.getAttribute("srcset") };
                  if (t.hasAttribute("width")) {
                    e.width = t.getAttribute("width");
                  }
                  return e;
                },
              },
            });
          const n = new Pz(t);
          t.commands.add("insertImage", n);
          t.commands.add("imageInsert", n);
        }
      }
      class Oz extends vl {
        constructor(t, e) {
          super(t);
          this._modelElementName = e;
        }
        refresh() {
          const t = this.editor;
          const e = t.plugins.get("ImageUtils");
          const n = e.getClosestSelectedImageElement(
            this.editor.model.document.selection
          );
          if (this._modelElementName === "imageBlock") {
            this.isEnabled = e.isInlineImage(n);
          } else {
            this.isEnabled = e.isBlockImage(n);
          }
        }
        execute() {
          const t = this.editor;
          const e = this.editor.model;
          const n = t.plugins.get("ImageUtils");
          const i = n.getClosestSelectedImageElement(e.document.selection);
          const o = Object.fromEntries(i.getAttributes());
          if (!o.src && !o.uploadId) {
            return null;
          }
          return e.change((t) => {
            const r = Array.from(e.markers).filter((t) =>
              t.getRange().containsItem(i)
            );
            const s = n.insertImage(
              o,
              e.createSelection(i, "on"),
              this._modelElementName
            );
            if (!s) {
              return null;
            }
            const a = t.createRangeOn(s);
            for (const e of r) {
              const n = e.getRange();
              const i =
                n.root.rootName != "$graveyard" ? n.getJoined(a, true) : a;
              t.updateMarker(e, { range: i });
            }
            return { oldElement: i, newElement: s };
          });
        }
      }
      class jz extends Cl {
        static get requires() {
          return [Rz, $S, RE];
        }
        static get pluginName() {
          return "ImageBlockEditing";
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          e.register("imageBlock", {
            inheritAllFrom: "$blockObject",
            allowAttributes: ["alt", "src", "srcset"],
          });
          this._setupConversion();
          if (t.plugins.has("ImageInlineEditing")) {
            t.commands.add("imageTypeBlock", new Oz(this.editor, "imageBlock"));
            this._setupClipboardIntegration();
          }
        }
        _setupConversion() {
          const t = this.editor;
          const e = t.t;
          const n = t.conversion;
          const i = t.plugins.get("ImageUtils");
          n.for("dataDowncast").elementToStructure({
            model: "imageBlock",
            view: (t, { writer: e }) => qS(e),
          });
          n.for("editingDowncast").elementToStructure({
            model: "imageBlock",
            view: (t, { writer: n }) =>
              i.toImageWidget(qS(n), n, e("image widget")),
          });
          n.for("downcast")
            .add(Nz(i, "imageBlock", "src"))
            .add(Nz(i, "imageBlock", "alt"))
            .add(Bz(i, "imageBlock"));
          n.for("upcast")
            .elementToElement({
              view: WS(t, "imageBlock"),
              model: (t, { writer: e }) =>
                e.createElement(
                  "imageBlock",
                  t.hasAttribute("src") ? { src: t.getAttribute("src") } : null
                ),
            })
            .add(Iz(i));
        }
        _setupClipboardIntegration() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const i = t.plugins.get("ImageUtils");
          this.listenTo(
            t.plugins.get("ClipboardPipeline"),
            "inputTransformation",
            (o, r) => {
              const s = Array.from(r.content.getChildren());
              let a;
              if (!s.every(i.isInlineImageView)) {
                return;
              }
              if (r.targetRanges) {
                a = t.editing.mapper.toModelRange(r.targetRanges[0]);
              } else {
                a = e.document.selection.getFirstRange();
              }
              const c = e.createSelection(a);
              if (GS(e.schema, c) === "imageBlock") {
                const t = new Fw(n.document);
                const e = s.map((e) =>
                  t.createElement("figure", { class: "image" }, e)
                );
                r.content = t.createDocumentFragment(e);
              }
            }
          );
        }
      }
      var Fz = n(9048);
      var Vz = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Vz.insert = "head";
      Vz.singleton = true;
      var Hz = Il()(Fz.Z, Vz);
      const Uz = Fz.Z.locals || {};
      class qz extends Cl {
        static get requires() {
          return [jz, qD, Tz];
        }
        static get pluginName() {
          return "ImageBlock";
        }
      }
      class Wz extends Cl {
        static get requires() {
          return [Rz, $S, RE];
        }
        static get pluginName() {
          return "ImageInlineEditing";
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          e.register("imageInline", {
            inheritAllFrom: "$inlineObject",
            allowAttributes: ["alt", "src", "srcset"],
          });
          e.addChildCheck((t, e) => {
            if (t.endsWith("caption") && e.name === "imageInline") {
              return false;
            }
          });
          this._setupConversion();
          if (t.plugins.has("ImageBlockEditing")) {
            t.commands.add(
              "imageTypeInline",
              new Oz(this.editor, "imageInline")
            );
            this._setupClipboardIntegration();
          }
        }
        _setupConversion() {
          const t = this.editor;
          const e = t.t;
          const n = t.conversion;
          const i = t.plugins.get("ImageUtils");
          n.for("dataDowncast").elementToElement({
            model: "imageInline",
            view: (t, { writer: e }) => e.createEmptyElement("img"),
          });
          n.for("editingDowncast").elementToStructure({
            model: "imageInline",
            view: (t, { writer: n }) =>
              i.toImageWidget(US(n), n, e("image widget")),
          });
          n.for("downcast")
            .add(Nz(i, "imageInline", "src"))
            .add(Nz(i, "imageInline", "alt"))
            .add(Bz(i, "imageInline"));
          n.for("upcast").elementToElement({
            view: WS(t, "imageInline"),
            model: (t, { writer: e }) =>
              e.createElement(
                "imageInline",
                t.hasAttribute("src") ? { src: t.getAttribute("src") } : null
              ),
          });
        }
        _setupClipboardIntegration() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const i = t.plugins.get("ImageUtils");
          this.listenTo(
            t.plugins.get("ClipboardPipeline"),
            "inputTransformation",
            (o, r) => {
              const s = Array.from(r.content.getChildren());
              let a;
              if (!s.every(i.isBlockImageView)) {
                return;
              }
              if (r.targetRanges) {
                a = t.editing.mapper.toModelRange(r.targetRanges[0]);
              } else {
                a = e.document.selection.getFirstRange();
              }
              const c = e.createSelection(a);
              if (GS(e.schema, c) === "imageInline") {
                const t = new Fw(n.document);
                const e = s.map((e) => {
                  if (e.childCount === 1) {
                    Array.from(e.getAttributes()).forEach((n) =>
                      t.setAttribute(...n, i.findViewImgElement(e))
                    );
                    return e.getChild(0);
                  } else {
                    return e;
                  }
                });
                r.content = t.createDocumentFragment(e);
              }
            }
          );
        }
      }
      class Gz extends Cl {
        static get requires() {
          return [Wz, qD, Tz];
        }
        static get pluginName() {
          return "ImageInline";
        }
      }
      class $z extends Cl {
        static get requires() {
          return [qz, Gz];
        }
        static get pluginName() {
          return "Image";
        }
      }
      class Kz extends vl {
        refresh() {
          const t = this.editor;
          const e = t.plugins.get("ImageCaptionUtils");
          if (!t.plugins.has(jz)) {
            this.isEnabled = false;
            this.value = false;
            return;
          }
          const n = t.model.document.selection;
          const i = n.getSelectedElement();
          if (!i) {
            const t = e.getCaptionFromModelSelection(n);
            this.isEnabled = !!t;
            this.value = !!t;
            return;
          }
          this.isEnabled = this.editor.plugins.get("ImageUtils").isImage(i);
          if (!this.isEnabled) {
            this.value = false;
          } else {
            this.value = !!e.getCaptionFromImageModelElement(i);
          }
        }
        execute(t = {}) {
          const { focusCaptionOnShow: e } = t;
          this.editor.model.change((t) => {
            if (this.value) {
              this._hideImageCaption(t);
            } else {
              this._showImageCaption(t, e);
            }
          });
        }
        _showImageCaption(t, e) {
          const n = this.editor.model;
          const i = n.document.selection;
          const o = this.editor.plugins.get("ImageCaptionEditing");
          let r = i.getSelectedElement();
          const s = o._getSavedCaption(r);
          if (this.editor.plugins.get("ImageUtils").isInlineImage(r)) {
            this.editor.execute("imageTypeBlock");
            r = i.getSelectedElement();
          }
          const a = s || t.createElement("caption");
          t.append(a, r);
          if (e) {
            t.setSelection(a, "in");
          }
        }
        _hideImageCaption(t) {
          const e = this.editor;
          const n = e.model.document.selection;
          const i = e.plugins.get("ImageCaptionEditing");
          const o = e.plugins.get("ImageCaptionUtils");
          let r = n.getSelectedElement();
          let s;
          if (r) {
            s = o.getCaptionFromImageModelElement(r);
          } else {
            s = o.getCaptionFromModelSelection(n);
            r = s.parent;
          }
          i._saveCaption(r, s);
          t.setSelection(r, "on");
          t.remove(s);
        }
      }
      class Yz extends Cl {
        static get pluginName() {
          return "ImageCaptionUtils";
        }
        static get requires() {
          return [$S];
        }
        getCaptionFromImageModelElement(t) {
          for (const e of t.getChildren()) {
            if (!!e && e.is("element", "caption")) {
              return e;
            }
          }
          return null;
        }
        getCaptionFromModelSelection(t) {
          const e = this.editor.plugins.get("ImageUtils");
          const n = t.getFirstPosition().findAncestor("caption");
          if (!n) {
            return null;
          }
          if (e.isBlockImage(n.parent)) {
            return n;
          }
          return null;
        }
        matchImageCaptionViewElement(t) {
          const e = this.editor.plugins.get("ImageUtils");
          if (t.name == "figcaption" && e.isBlockImageView(t.parent)) {
            return { name: true };
          }
          return null;
        }
      }
      class Zz extends Cl {
        static get requires() {
          return [$S, Yz];
        }
        static get pluginName() {
          return "ImageCaptionEditing";
        }
        constructor(t) {
          super(t);
          this._savedCaptionsMap = new WeakMap();
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          if (!e.isRegistered("caption")) {
            e.register("caption", {
              allowIn: "imageBlock",
              allowContentOf: "$block",
              isLimit: true,
            });
          } else {
            e.extend("caption", { allowIn: "imageBlock" });
          }
          t.commands.add("toggleImageCaption", new Kz(this.editor));
          this._setupConversion();
          this._setupImageTypeCommandsIntegration();
          this._registerCaptionReconversion();
        }
        _setupConversion() {
          const t = this.editor;
          const e = t.editing.view;
          const n = t.plugins.get("ImageUtils");
          const i = t.plugins.get("ImageCaptionUtils");
          const o = t.t;
          t.conversion.for("upcast").elementToElement({
            view: (t) => i.matchImageCaptionViewElement(t),
            model: "caption",
          });
          t.conversion.for("dataDowncast").elementToElement({
            model: "caption",
            view: (t, { writer: e }) => {
              if (!n.isBlockImage(t.parent)) {
                return null;
              }
              return e.createContainerElement("figcaption");
            },
          });
          t.conversion.for("editingDowncast").elementToElement({
            model: "caption",
            view: (t, { writer: i }) => {
              if (!n.isBlockImage(t.parent)) {
                return null;
              }
              const r = i.createEditableElement("figcaption");
              i.setCustomProperty("imageCaption", true, r);
              Pl({
                view: e,
                element: r,
                text: o("Enter image caption"),
                keepOnFocus: true,
              });
              const s = t.parent.getAttribute("alt");
              const a = s
                ? o("Caption for image: %0", [s])
                : o("Caption for the image");
              return dD(r, i, { label: a });
            },
          });
        }
        _setupImageTypeCommandsIntegration() {
          const t = this.editor;
          const e = t.plugins.get("ImageUtils");
          const n = t.plugins.get("ImageCaptionUtils");
          const i = t.commands.get("imageTypeInline");
          const o = t.commands.get("imageTypeBlock");
          const r = (t) => {
            if (!t.return) {
              return;
            }
            const { oldElement: i, newElement: o } = t.return;
            if (!i) {
              return;
            }
            if (e.isBlockImage(i)) {
              const t = n.getCaptionFromImageModelElement(i);
              if (t) {
                this._saveCaption(o, t);
                return;
              }
            }
            const r = this._getSavedCaption(i);
            if (r) {
              this._saveCaption(o, r);
            }
          };
          if (i) {
            this.listenTo(i, "execute", r, { priority: "low" });
          }
          if (o) {
            this.listenTo(o, "execute", r, { priority: "low" });
          }
        }
        _getSavedCaption(t) {
          const e = this._savedCaptionsMap.get(t);
          return e ? ff.fromJSON(e) : null;
        }
        _saveCaption(t, e) {
          this._savedCaptionsMap.set(t, e.toJSON());
        }
        _registerCaptionReconversion() {
          const t = this.editor;
          const e = t.model;
          const n = t.plugins.get("ImageUtils");
          const i = t.plugins.get("ImageCaptionUtils");
          e.document.on("change:data", () => {
            const o = e.document.differ.getChanges();
            for (const e of o) {
              if (e.attributeKey !== "alt") {
                continue;
              }
              const o = e.range.start.nodeAfter;
              if (n.isBlockImage(o)) {
                const e = i.getCaptionFromImageModelElement(o);
                if (!e) {
                  return;
                }
                t.editing.reconvertItem(e);
              }
            }
          });
        }
      }
      class Qz extends Cl {
        static get requires() {
          return [Yz];
        }
        static get pluginName() {
          return "ImageCaptionUI";
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = t.plugins.get("ImageCaptionUtils");
          const i = t.t;
          t.ui.componentFactory.add("toggleImageCaption", (o) => {
            const r = t.commands.get("toggleImageCaption");
            const s = new R_(o);
            s.set({ icon: __.caption, tooltip: true, isToggleable: true });
            s.bind("isOn", "isEnabled").to(r, "value", "isEnabled");
            s.bind("label").to(r, "value", (t) =>
              t ? i("Toggle caption off") : i("Toggle caption on")
            );
            this.listenTo(s, "execute", () => {
              t.execute("toggleImageCaption", { focusCaptionOnShow: true });
              const i = n.getCaptionFromModelSelection(
                t.model.document.selection
              );
              if (i) {
                const n = t.editing.mapper.toViewElement(i);
                e.scrollToTheSelection();
                e.change((t) => {
                  t.addClass("image__caption_highlighted", n);
                });
              }
              t.editing.view.focus();
            });
            return s;
          });
        }
      }
      var Jz = n(8662);
      var Xz = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Xz.insert = "head";
      Xz.singleton = true;
      var tP = Il()(Jz.Z, Xz);
      const eP = Jz.Z.locals || {};
      class nP extends Cl {
        static get requires() {
          return [Zz, Qz];
        }
        static get pluginName() {
          return "ImageCaption";
        }
      }
      class iP extends pC {
        constructor(t) {
          super(t);
          this.buttonView = new R_(t);
          this._fileInputView = new oP(t);
          this._fileInputView.bind("acceptedType").to(this);
          this._fileInputView.bind("allowMultipleFiles").to(this);
          this._fileInputView.delegate("done").to(this);
          this.setTemplate({
            tag: "span",
            attributes: { class: "ck-file-dialog-button" },
            children: [this.buttonView, this._fileInputView],
          });
          this.buttonView.on("execute", () => {
            this._fileInputView.open();
          });
        }
        focus() {
          this.buttonView.focus();
        }
      }
      class oP extends pC {
        constructor(t) {
          super(t);
          this.set("acceptedType", undefined);
          this.set("allowMultipleFiles", false);
          const e = this.bindTemplate;
          this.setTemplate({
            tag: "input",
            attributes: {
              class: ["ck-hidden"],
              type: "file",
              tabindex: "-1",
              accept: e.to("acceptedType"),
              multiple: e.to("allowMultipleFiles"),
            },
            on: {
              change: e.to(() => {
                if (
                  this.element &&
                  this.element.files &&
                  this.element.files.length
                ) {
                  this.fire("done", this.element.files);
                }
                this.element.value = "";
              }),
            },
          });
        }
        open() {
          this.element.click();
        }
      }
      class rP extends (null && Plugin) {
        static get requires() {
          return [FileRepository];
        }
        static get pluginName() {
          return "SimpleUploadAdapter";
        }
        init() {
          const t = this.editor.config.get("simpleUpload");
          if (!t) {
            return;
          }
          if (!t.uploadUrl) {
            logWarning("simple-upload-adapter-missing-uploadurl");
            return;
          }
          this.editor.plugins.get(FileRepository).createUploadAdapter = (e) =>
            new sP(e, t);
        }
      }
      class sP {
        constructor(t, e) {
          this.loader = t;
          this.options = e;
        }
        upload() {
          return this.loader.file.then(
            (t) =>
              new Promise((e, n) => {
                this._initRequest();
                this._initListeners(e, n, t);
                this._sendRequest(t);
              })
          );
        }
        abort() {
          if (this.xhr) {
            this.xhr.abort();
          }
        }
        _initRequest() {
          const t = (this.xhr = new XMLHttpRequest());
          t.open("POST", this.options.uploadUrl, true);
          t.responseType = "json";
        }
        _initListeners(t, e, n) {
          const i = this.xhr;
          const o = this.loader;
          const r = \`Couldn't upload file: \${n.name}.\`;
          i.addEventListener("error", () => e(r));
          i.addEventListener("abort", () => e());
          i.addEventListener("load", () => {
            const n = i.response;
            if (!n || n.error) {
              return e(n && n.error && n.error.message ? n.error.message : r);
            }
            const o = n.url ? { default: n.url } : n.urls;
            t({ ...n, urls: o });
          });
          if (i.upload) {
            i.upload.addEventListener("progress", (t) => {
              if (t.lengthComputable) {
                o.uploadTotal = t.total;
                o.uploaded = t.loaded;
              }
            });
          }
        }
        _sendRequest(t) {
          const e = this.options.headers || {};
          const n = this.options.withCredentials || false;
          for (const t of Object.keys(e)) {
            this.xhr.setRequestHeader(t, e[t]);
          }
          this.xhr.withCredentials = n;
          const i = new FormData();
          i.append("upload", t);
          this.xhr.send(i);
        }
      }
      function aP(t) {
        const e = t.map((t) => t.replace("+", "\\\\+"));
        return new RegExp(\`^image\\\\/(\${e.join("|")})$\`);
      }
      function cP(t) {
        return new Promise((e, n) => {
          const i = t.getAttribute("src");
          fetch(i)
            .then((t) => t.blob())
            .then((t) => {
              const n = dP(t, i);
              const o = n.replace("image/", "");
              const r = \`image.\${o}\`;
              const s = new File([t], r, { type: n });
              e(s);
            })
            .catch((t) =>
              t && t.name === "TypeError" ? uP(i).then(e).catch(n) : n(t)
            );
        });
      }
      function lP(t, e) {
        if (!t.isInlineImageView(e) || !e.getAttribute("src")) {
          return false;
        }
        return (
          e.getAttribute("src").match(/^data:image\\/\\w+;base64,/g) ||
          e.getAttribute("src").match(/^blob:/g)
        );
      }
      function dP(t, e) {
        if (t.type) {
          return t.type;
        } else if (e.match(/data:(image\\/\\w+);base64/)) {
          return e.match(/data:(image\\/\\w+);base64/)[1].toLowerCase();
        } else {
          return "image/jpeg";
        }
      }
      function uP(t) {
        return hP(t).then((e) => {
          const n = dP(e, t);
          const i = n.replace("image/", "");
          const o = \`image.\${i}\`;
          return new File([e], o, { type: n });
        });
      }
      function hP(t) {
        return new Promise((e, n) => {
          const i = Xa.document.createElement("img");
          i.addEventListener("load", () => {
            const t = Xa.document.createElement("canvas");
            t.width = i.width;
            t.height = i.height;
            const o = t.getContext("2d");
            o.drawImage(i, 0, 0);
            t.toBlob((t) => (t ? e(t) : n()));
          });
          i.addEventListener("error", () => n());
          i.src = t;
        });
      }
      class mP extends Cl {
        static get pluginName() {
          return "ImageUploadUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          const n = (n) => {
            const i = new iP(n);
            const o = t.commands.get("uploadImage");
            const r = t.config.get("image.upload.types");
            const s = aP(r);
            i.set({
              acceptedType: r.map((t) => \`image/\${t}\`).join(","),
              allowMultipleFiles: true,
            });
            i.buttonView.set({
              label: e("Insert image"),
              icon: __.image,
              tooltip: true,
            });
            i.buttonView.bind("isEnabled").to(o);
            i.on("done", (e, n) => {
              const i = Array.from(n).filter((t) => s.test(t.type));
              if (i.length) {
                t.execute("uploadImage", { file: i });
                t.editing.view.focus();
              }
            });
            return i;
          };
          t.ui.componentFactory.add("uploadImage", n);
          t.ui.componentFactory.add("imageUpload", n);
        }
      }
      var gP = n(5870);
      var fP = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      fP.insert = "head";
      fP.singleton = true;
      var pP = Il()(gP.Z, fP);
      const bP = gP.Z.locals || {};
      var kP = n(9899);
      var wP = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      wP.insert = "head";
      wP.singleton = true;
      var AP = Il()(kP.Z, wP);
      const CP = kP.Z.locals || {};
      var _P = n(9825);
      var vP = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      vP.insert = "head";
      vP.singleton = true;
      var yP = Il()(_P.Z, vP);
      const xP = _P.Z.locals || {};
      class EP extends Cl {
        static get pluginName() {
          return "ImageUploadProgress";
        }
        constructor(t) {
          super(t);
          this.placeholder =
            "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        }
        init() {
          const t = this.editor;
          if (t.plugins.has("ImageBlockEditing")) {
            t.editing.downcastDispatcher.on(
              "attribute:uploadStatus:imageBlock",
              (...t) => this.uploadStatusChange(...t)
            );
          }
          if (t.plugins.has("ImageInlineEditing")) {
            t.editing.downcastDispatcher.on(
              "attribute:uploadStatus:imageInline",
              (...t) => this.uploadStatusChange(...t)
            );
          }
        }
        uploadStatusChange(t, e, n) {
          const i = this.editor;
          const o = e.item;
          const r = o.getAttribute("uploadId");
          if (!n.consumable.consume(e.item, t.name)) {
            return;
          }
          const s = i.plugins.get("ImageUtils");
          const a = i.plugins.get(mI);
          const c = r ? e.attributeNewValue : null;
          const l = this.placeholder;
          const d = i.editing.mapper.toViewElement(o);
          const u = n.writer;
          if (c == "reading") {
            DP(d, u);
            TP(s, l, d, u);
            return;
          }
          if (c == "uploading") {
            const t = a.loaders.get(r);
            DP(d, u);
            if (!t) {
              TP(s, l, d, u);
            } else {
              IP(d, u);
              MP(d, u, t, i.editing.view);
              OP(s, d, u, t);
            }
            return;
          }
          if (c == "complete" && a.loaders.get(r)) {
            LP(d, u, i.editing.view);
          }
          BP(d, u);
          IP(d, u);
          SP(d, u);
        }
      }
      function DP(t, e) {
        if (!t.hasClass("ck-appear")) {
          e.addClass("ck-appear", t);
        }
      }
      function SP(t, e) {
        e.removeClass("ck-appear", t);
      }
      function TP(t, e, n, i) {
        if (!n.hasClass("ck-image-upload-placeholder")) {
          i.addClass("ck-image-upload-placeholder", n);
        }
        const o = t.findViewImgElement(n);
        if (o.getAttribute("src") !== e) {
          i.setAttribute("src", e, o);
        }
        if (!PP(n, "placeholder")) {
          i.insert(i.createPositionAfter(o), zP(i));
        }
      }
      function IP(t, e) {
        if (t.hasClass("ck-image-upload-placeholder")) {
          e.removeClass("ck-image-upload-placeholder", t);
        }
        RP(t, e, "placeholder");
      }
      function MP(t, e, n, i) {
        const o = NP(e);
        e.insert(e.createPositionAt(t, "end"), o);
        n.on("change:uploadedPercent", (t, e, n) => {
          i.change((t) => {
            t.setStyle("width", n + "%", o);
          });
        });
      }
      function BP(t, e) {
        RP(t, e, "progressBar");
      }
      function LP(t, e, n) {
        const i = e.createUIElement("div", {
          class: "ck-image-upload-complete-icon",
        });
        e.insert(e.createPositionAt(t, "end"), i);
        setTimeout(() => {
          n.change((t) => t.remove(t.createRangeOn(i)));
        }, 3e3);
      }
      function NP(t) {
        const e = t.createUIElement("div", { class: "ck-progress-bar" });
        t.setCustomProperty("progressBar", true, e);
        return e;
      }
      function zP(t) {
        const e = t.createUIElement("div", {
          class: "ck-upload-placeholder-loader",
        });
        t.setCustomProperty("placeholder", true, e);
        return e;
      }
      function PP(t, e) {
        for (const n of t.getChildren()) {
          if (n.getCustomProperty(e)) {
            return n;
          }
        }
      }
      function RP(t, e, n) {
        const i = PP(t, n);
        if (i) {
          e.remove(e.createRangeOn(i));
        }
      }
      function OP(t, e, n, i) {
        if (i.data) {
          const o = t.findViewImgElement(e);
          n.setAttribute("src", i.data, o);
        }
      }
      class jP extends vl {
        refresh() {
          const t = this.editor;
          const e = t.plugins.get("ImageUtils");
          const n = t.model.document.selection.getSelectedElement();
          this.isEnabled = e.isImageAllowed() || e.isImage(n);
        }
        execute(t) {
          const e = Yc(t.file);
          const n = this.editor.model.document.selection;
          const i = this.editor.plugins.get("ImageUtils");
          const o = Object.fromEntries(n.getAttributes());
          e.forEach((t, e) => {
            const r = n.getSelectedElement();
            if (e && r && i.isImage(r)) {
              const e = this.editor.model.createPositionAfter(r);
              this._uploadImage(t, o, e);
            } else {
              this._uploadImage(t, o);
            }
          });
        }
        _uploadImage(t, e, n) {
          const i = this.editor;
          const o = i.plugins.get(mI);
          const r = o.createLoader(t);
          const s = i.plugins.get("ImageUtils");
          if (!r) {
            return;
          }
          s.insertImage({ ...e, uploadId: r.id }, n);
        }
      }
      class FP extends Cl {
        static get requires() {
          return [mI, zy, RE, $S];
        }
        static get pluginName() {
          return "ImageUploadEditing";
        }
        constructor(t) {
          super(t);
          t.config.define("image", {
            upload: { types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"] },
          });
          this._uploadImageElements = new Map();
        }
        init() {
          const t = this.editor;
          const e = t.model.document;
          const n = t.conversion;
          const i = t.plugins.get(mI);
          const o = t.plugins.get("ImageUtils");
          const r = aP(t.config.get("image.upload.types"));
          const s = new jP(t);
          t.commands.add("uploadImage", s);
          t.commands.add("imageUpload", s);
          n.for("upcast").attributeToAttribute({
            view: { name: "img", key: "uploadId" },
            model: "uploadId",
          });
          this.listenTo(t.editing.view.document, "clipboardInput", (e, n) => {
            if (VP(n.dataTransfer)) {
              return;
            }
            const i = Array.from(n.dataTransfer.files).filter((t) => {
              if (!t) {
                return false;
              }
              return r.test(t.type);
            });
            if (!i.length) {
              return;
            }
            e.stop();
            t.model.change((e) => {
              if (n.targetRanges) {
                e.setSelection(
                  n.targetRanges.map((e) => t.editing.mapper.toModelRange(e))
                );
              }
              t.model.enqueueChange(() => {
                t.execute("uploadImage", { file: i });
              });
            });
          });
          this.listenTo(
            t.plugins.get("ClipboardPipeline"),
            "inputTransformation",
            (e, n) => {
              const r = Array.from(t.editing.view.createRangeIn(n.content))
                .filter(
                  (t) =>
                    lP(o, t.item) && !t.item.getAttribute("uploadProcessed")
                )
                .map((t) => ({ promise: cP(t.item), imageElement: t.item }));
              if (!r.length) {
                return;
              }
              const s = new Fw(t.editing.view.document);
              for (const t of r) {
                s.setAttribute("uploadProcessed", true, t.imageElement);
                const e = i.createLoader(t.promise);
                if (e) {
                  s.setAttribute("src", "", t.imageElement);
                  s.setAttribute("uploadId", e.id, t.imageElement);
                }
              }
            }
          );
          t.editing.view.document.on("dragover", (t, e) => {
            e.preventDefault();
          });
          e.on("change", () => {
            const n = e.differ
              .getChanges({ includeChangesInGraveyard: true })
              .reverse();
            const o = new Set();
            for (const e of n) {
              if (e.type == "insert" && e.name != "$text") {
                const n = e.position.nodeAfter;
                const r = e.position.root.rootName == "$graveyard";
                for (const e of HP(t, n)) {
                  const t = e.getAttribute("uploadId");
                  if (!t) {
                    continue;
                  }
                  const n = i.loaders.get(t);
                  if (!n) {
                    continue;
                  }
                  if (r) {
                    if (!o.has(t)) {
                      n.abort();
                    }
                  } else {
                    o.add(t);
                    this._uploadImageElements.set(t, e);
                    if (n.status == "idle") {
                      this._readAndUpload(n);
                    }
                  }
                }
              }
            }
          });
          this.on(
            "uploadComplete",
            (t, { imageElement: e, data: n }) => {
              const i = n.urls ? n.urls : n;
              this.editor.model.change((t) => {
                t.setAttribute("src", i.default, e);
                this._parseAndSetSrcsetAttributeOnImage(i, e, t);
              });
            },
            { priority: "low" }
          );
        }
        afterInit() {
          const t = this.editor.model.schema;
          if (this.editor.plugins.has("ImageBlockEditing")) {
            t.extend("imageBlock", {
              allowAttributes: ["uploadId", "uploadStatus"],
            });
          }
          if (this.editor.plugins.has("ImageInlineEditing")) {
            t.extend("imageInline", {
              allowAttributes: ["uploadId", "uploadStatus"],
            });
          }
        }
        _readAndUpload(t) {
          const e = this.editor;
          const n = e.model;
          const i = e.locale.t;
          const o = e.plugins.get(mI);
          const s = e.plugins.get(zy);
          const a = e.plugins.get("ImageUtils");
          const c = this._uploadImageElements;
          n.enqueueChange({ isUndoable: false }, (e) => {
            e.setAttribute("uploadStatus", "reading", c.get(t.id));
          });
          return t
            .read()
            .then(() => {
              const i = t.upload();
              const o = c.get(t.id);
              if (r.isSafari) {
                const t = e.editing.mapper.toViewElement(o);
                const n = a.findViewImgElement(t);
                e.editing.view.once("render", () => {
                  if (!n.parent) {
                    return;
                  }
                  const t = e.editing.view.domConverter.mapViewToDom(n.parent);
                  if (!t) {
                    return;
                  }
                  const i = t.style.display;
                  t.style.display = "none";
                  t._ckHack = t.offsetHeight;
                  t.style.display = i;
                });
              }
              n.enqueueChange({ isUndoable: false }, (t) => {
                t.setAttribute("uploadStatus", "uploading", o);
              });
              return i;
            })
            .then((e) => {
              n.enqueueChange({ isUndoable: false }, (n) => {
                const i = c.get(t.id);
                n.setAttribute("uploadStatus", "complete", i);
                this.fire("uploadComplete", { data: e, imageElement: i });
              });
              l();
            })
            .catch((e) => {
              if (t.status !== "error" && t.status !== "aborted") {
                throw e;
              }
              if (t.status == "error" && e) {
                s.showWarning(e, {
                  title: i("Upload failed"),
                  namespace: "upload",
                });
              }
              n.enqueueChange({ isUndoable: false }, (e) => {
                e.remove(c.get(t.id));
              });
              l();
            });
          function l() {
            n.enqueueChange({ isUndoable: false }, (e) => {
              const n = c.get(t.id);
              e.removeAttribute("uploadId", n);
              e.removeAttribute("uploadStatus", n);
              c.delete(t.id);
            });
            o.destroyLoader(t);
          }
        }
        _parseAndSetSrcsetAttributeOnImage(t, e, n) {
          let i = 0;
          const o = Object.keys(t)
            .filter((t) => {
              const e = parseInt(t, 10);
              if (!isNaN(e)) {
                i = Math.max(i, e);
                return true;
              }
            })
            .map((e) => \`\${t[e]} \${e}w\`)
            .join(", ");
          if (o != "") {
            n.setAttribute("srcset", { data: o, width: i }, e);
          }
        }
      }
      function VP(t) {
        return (
          Array.from(t.types).includes("text/html") &&
          t.getData("text/html") !== ""
        );
      }
      function HP(t, e) {
        const n = t.plugins.get("ImageUtils");
        return Array.from(t.model.createRangeOn(e))
          .filter((t) => n.isImage(t.item))
          .map((t) => t.item);
      }
      class UP extends Cl {
        static get pluginName() {
          return "ImageUpload";
        }
        static get requires() {
          return [FP, mP, EP];
        }
      }
      var qP = n(5150);
      var WP = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      WP.insert = "head";
      WP.singleton = true;
      var GP = Il()(qP.Z, WP);
      const $P = qP.Z.locals || {};
      class KP extends pC {
        constructor(t, e = {}) {
          super(t);
          const n = this.bindTemplate;
          this.set("class", e.class || null);
          this.children = this.createCollection();
          if (e.children) {
            e.children.forEach((t) => this.children.add(t));
          }
          this.set("_role", null);
          this.set("_ariaLabelledBy", null);
          if (e.labelView) {
            this.set({ _role: "group", _ariaLabelledBy: e.labelView.id });
          }
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck", "ck-form__row", n.to("class")],
              role: n.to("_role"),
              "aria-labelledby": n.to("_ariaLabelledBy"),
            },
            children: this.children,
          });
        }
      }
      var YP = n(9292);
      var ZP = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      ZP.insert = "head";
      ZP.singleton = true;
      var QP = Il()(YP.Z, ZP);
      const JP = YP.Z.locals || {};
      class XP extends pC {
        constructor(t, e) {
          super(t);
          const { insertButtonView: n, cancelButtonView: i } =
            this._createActionButtons(t);
          this.insertButtonView = n;
          this.cancelButtonView = i;
          this.set("imageURLInputValue", "");
          this.focusTracker = new al();
          this.keystrokes = new cl();
          this._focusables = new PA();
          this._focusCycler = new hv({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          });
          this.set("_integrations", new rl());
          if (e) {
            for (const [t, n] of Object.entries(e)) {
              if (t === "insertImageViaUrl") {
                n.fieldView
                  .bind("value")
                  .to(this, "imageURLInputValue", (t) => t || "");
                n.fieldView.on("input", () => {
                  this.imageURLInputValue = n.fieldView.element.value.trim();
                });
              }
              n.name = t;
              this._integrations.add(n);
            }
          }
          this.setTemplate({
            tag: "form",
            attributes: {
              class: ["ck", "ck-image-insert-form"],
              tabindex: "-1",
            },
            children: [
              ...this._integrations,
              new KP(t, {
                children: [this.insertButtonView, this.cancelButtonView],
                class: "ck-image-insert-form__action-row",
              }),
            ],
          });
        }
        render() {
          super.render();
          x_({ view: this });
          const t = [
            ...this._integrations,
            this.insertButtonView,
            this.cancelButtonView,
          ];
          t.forEach((t) => {
            this._focusables.add(t);
            this.focusTracker.add(t.element);
          });
          this.keystrokes.listenTo(this.element);
          const e = (t) => t.stopPropagation();
          this.keystrokes.set("arrowright", e);
          this.keystrokes.set("arrowleft", e);
          this.keystrokes.set("arrowup", e);
          this.keystrokes.set("arrowdown", e);
          this.listenTo(
            t[0].element,
            "selectstart",
            (t, e) => {
              e.stopPropagation();
            },
            { priority: "high" }
          );
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        getIntegration(t) {
          return this._integrations.find((e) => e.name === t);
        }
        _createActionButtons(t) {
          const e = t.t;
          const n = new R_(t);
          const i = new R_(t);
          n.set({
            label: e("Insert"),
            icon: __.check,
            class: "ck-button-save",
            type: "submit",
            withText: true,
            isEnabled: this.imageURLInputValue,
          });
          i.set({
            label: e("Cancel"),
            icon: __.cancel,
            class: "ck-button-cancel",
            withText: true,
          });
          n.bind("isEnabled").to(this, "imageURLInputValue", (t) => !!t);
          n.delegate("execute").to(this, "submit");
          i.delegate("execute").to(this, "cancel");
          return { insertButtonView: n, cancelButtonView: i };
        }
        focus() {
          this._focusCycler.focusFirst();
        }
      }
      function tR(t) {
        const e = t.config.get("image.insert.integrations");
        const n = t.plugins.get("ImageInsertUI");
        const i = { insertImageViaUrl: eR(t.locale) };
        if (!e) {
          return i;
        }
        if (
          e.find((t) => t === "openCKFinder") &&
          t.ui.componentFactory.has("ckfinder")
        ) {
          const e = t.ui.componentFactory.create("ckfinder");
          e.set({ withText: true, class: "ck-image-insert__ck-finder-button" });
          e.delegate("execute").to(n, "cancel");
          i.openCKFinder = e;
        }
        return e.reduce((e, n) => {
          if (i[n]) {
            e[n] = i[n];
          } else if (t.ui.componentFactory.has(n)) {
            e[n] = t.ui.componentFactory.create(n);
          }
          return e;
        }, {});
      }
      function eR(t) {
        const e = t.t;
        const n = new My(t, By);
        n.set({ label: e("Insert image via URL") });
        n.fieldView.placeholder = "https://example.com/image.png";
        return n;
      }
      class nR extends Cl {
        static get pluginName() {
          return "ImageInsertUI";
        }
        init() {
          const t = this.editor;
          const e = (t) => this._createDropdownView(t);
          t.ui.componentFactory.add("insertImage", e);
          t.ui.componentFactory.add("imageInsert", e);
        }
        _createDropdownView(t) {
          const e = this.editor;
          const n = t.t;
          const i = e.commands.get("uploadImage");
          const o = e.commands.get("insertImage");
          this.dropdownView = Uv(t, i ? rv : undefined);
          const r = this.dropdownView.buttonView;
          const s = this.dropdownView.panelView;
          r.set({ label: n("Insert image"), icon: __.image, tooltip: true });
          s.extendTemplate({ attributes: { class: "ck-image-insert__panel" } });
          if (i) {
            const t = this.dropdownView.buttonView;
            t.actionView = e.ui.componentFactory.create("uploadImage");
            t.actionView.extendTemplate({
              attributes: { class: "ck ck-button ck-splitbutton__action" },
            });
          }
          return this._setUpDropdown(i || o);
        }
        _setUpDropdown(t) {
          const e = this.editor;
          const n = e.t;
          const i = new XP(e.locale, tR(e));
          const o = i.insertButtonView;
          const r = i.getIntegration("insertImageViaUrl");
          const s = this.dropdownView;
          const a = s.panelView;
          const c = this.editor.plugins.get("ImageUtils");
          s.bind("isEnabled").to(t);
          s.once("change:isOpen", () => {
            a.children.add(i);
          });
          s.on(
            "change:isOpen",
            () => {
              const t = e.model.document.selection.getSelectedElement();
              if (s.isOpen) {
                if (c.isImage(t)) {
                  i.imageURLInputValue = t.getAttribute("src");
                  o.label = n("Update");
                  r.label = n("Update image URL");
                } else {
                  i.imageURLInputValue = "";
                  o.label = n("Insert");
                  r.label = n("Insert image via URL");
                }
              }
            },
            { priority: "low" }
          );
          i.delegate("submit", "cancel").to(s);
          this.delegate("cancel").to(s);
          s.on("submit", () => {
            d();
            l();
          });
          s.on("cancel", () => {
            d();
          });
          function l() {
            const t = e.model.document.selection.getSelectedElement();
            if (c.isImage(t)) {
              e.model.change((e) => {
                e.setAttribute("src", i.imageURLInputValue, t);
                e.removeAttribute("srcset", t);
                e.removeAttribute("sizes", t);
              });
            } else {
              e.execute("insertImage", { source: i.imageURLInputValue });
            }
          }
          function d() {
            e.editing.view.focus();
            s.isOpen = false;
          }
          return s;
        }
      }
      class iR extends Cl {
        static get pluginName() {
          return "ImageInsertViaUrl";
        }
        static get requires() {
          return [nR];
        }
      }
      class oR extends Cl {
        static get pluginName() {
          return "ImageInsert";
        }
        static get requires() {
          return [UP, iR, nR];
        }
      }
      class rR extends vl {
        refresh() {
          const t = this.editor;
          const e = t.plugins.get("ImageUtils");
          const n = e.getClosestSelectedImageElement(
            t.model.document.selection
          );
          this.isEnabled = !!n;
          if (!n || !n.hasAttribute("width")) {
            this.value = null;
          } else {
            this.value = { width: n.getAttribute("width"), height: null };
          }
        }
        execute(t) {
          const e = this.editor;
          const n = e.model;
          const i = e.plugins.get("ImageUtils");
          const o = i.getClosestSelectedImageElement(n.document.selection);
          this.value = { width: t.width, height: null };
          if (o) {
            n.change((e) => {
              e.setAttribute("width", t.width, o);
            });
          }
        }
      }
      class sR extends Cl {
        static get requires() {
          return [$S];
        }
        static get pluginName() {
          return "ImageResizeEditing";
        }
        constructor(t) {
          super(t);
          t.config.define("image", {
            resizeUnit: "%",
            resizeOptions: [
              { name: "resizeImage:original", value: null, icon: "original" },
              { name: "resizeImage:25", value: "25", icon: "small" },
              { name: "resizeImage:50", value: "50", icon: "medium" },
              { name: "resizeImage:75", value: "75", icon: "large" },
            ],
          });
        }
        init() {
          const t = this.editor;
          const e = new rR(t);
          this._registerSchema();
          this._registerConverters("imageBlock");
          this._registerConverters("imageInline");
          t.commands.add("resizeImage", e);
          t.commands.add("imageResize", e);
        }
        _registerSchema() {
          if (this.editor.plugins.has("ImageBlockEditing")) {
            this.editor.model.schema.extend("imageBlock", {
              allowAttributes: "width",
            });
          }
          if (this.editor.plugins.has("ImageInlineEditing")) {
            this.editor.model.schema.extend("imageInline", {
              allowAttributes: "width",
            });
          }
        }
        _registerConverters(t) {
          const e = this.editor;
          e.conversion.for("downcast").add((e) =>
            e.on(\`attribute:width:\${t}\`, (t, e, n) => {
              if (!n.consumable.consume(e.item, t.name)) {
                return;
              }
              const i = n.writer;
              const o = n.mapper.toViewElement(e.item);
              if (e.attributeNewValue !== null) {
                i.setStyle("width", e.attributeNewValue, o);
                i.addClass("image_resized", o);
              } else {
                i.removeStyle("width", o);
                i.removeClass("image_resized", o);
              }
            })
          );
          e.conversion.for("upcast").attributeToAttribute({
            view: {
              name: t === "imageBlock" ? "figure" : "img",
              styles: { width: /.+/ },
            },
            model: { key: "width", value: (t) => t.getStyle("width") },
          });
        }
      }
      const aR = {
        small: __.objectSizeSmall,
        medium: __.objectSizeMedium,
        large: __.objectSizeLarge,
        original: __.objectSizeFull,
      };
      class cR extends Cl {
        static get requires() {
          return [sR];
        }
        static get pluginName() {
          return "ImageResizeButtons";
        }
        constructor(t) {
          super(t);
          this._resizeUnit = t.config.get("image.resizeUnit");
        }
        init() {
          const t = this.editor;
          const e = t.config.get("image.resizeOptions");
          const n = t.commands.get("resizeImage");
          this.bind("isEnabled").to(n);
          for (const t of e) {
            this._registerImageResizeButton(t);
          }
          this._registerImageResizeDropdown(e);
        }
        _registerImageResizeButton(t) {
          const e = this.editor;
          const { name: n, value: i, icon: o } = t;
          const r = i ? i + this._resizeUnit : null;
          e.ui.componentFactory.add(n, (n) => {
            const i = new R_(n);
            const s = e.commands.get("resizeImage");
            const a = this._getOptionLabelValue(t, true);
            if (!aR[o]) {
              throw new M("imageresizebuttons-missing-icon", e, t);
            }
            i.set({ label: a, icon: aR[o], tooltip: a, isToggleable: true });
            i.bind("isEnabled").to(this);
            i.bind("isOn").to(s, "value", lR(r));
            this.listenTo(i, "execute", () => {
              e.execute("resizeImage", { width: r });
            });
            return i;
          });
        }
        _registerImageResizeDropdown(t) {
          const e = this.editor;
          const n = e.t;
          const i = t.find((t) => !t.value);
          const o = (o) => {
            const r = e.commands.get("resizeImage");
            const s = Uv(o, tv);
            const a = s.buttonView;
            a.set({
              tooltip: n("Resize image"),
              commandValue: i.value,
              icon: aR.medium,
              isToggleable: true,
              label: this._getOptionLabelValue(i),
              withText: true,
              class: "ck-resize-image-button",
            });
            a.bind("label").to(r, "value", (t) => {
              if (t && t.width) {
                return t.width;
              } else {
                return this._getOptionLabelValue(i);
              }
            });
            s.bind("isOn").to(r);
            s.bind("isEnabled").to(this);
            Wv(s, this._getResizeDropdownListItemDefinitions(t, r));
            s.listView.ariaLabel = n("Image resize list");
            this.listenTo(s, "execute", (t) => {
              e.execute(t.source.commandName, { width: t.source.commandValue });
              e.editing.view.focus();
            });
            return s;
          };
          e.ui.componentFactory.add("resizeImage", o);
          e.ui.componentFactory.add("imageResize", o);
        }
        _getOptionLabelValue(t, e) {
          const n = this.editor.t;
          if (t.label) {
            return t.label;
          } else if (e) {
            if (t.value) {
              return n("Resize image to %0", t.value + this._resizeUnit);
            } else {
              return n("Resize image to the original size");
            }
          } else {
            if (t.value) {
              return t.value + this._resizeUnit;
            } else {
              return n("Original");
            }
          }
        }
        _getResizeDropdownListItemDefinitions(t, e) {
          const n = new rl();
          t.map((t) => {
            const i = t.value ? t.value + this._resizeUnit : null;
            const o = {
              type: "button",
              model: new Py({
                commandName: "resizeImage",
                commandValue: i,
                label: this._getOptionLabelValue(t),
                withText: true,
                icon: null,
              }),
            };
            o.model.bind("isOn").to(e, "value", lR(i));
            n.add(o);
          });
          return n;
        }
      }
      function lR(t) {
        return (e) => {
          if (t === null && e === t) {
            return true;
          }
          return e && e.width === t;
        };
      }
      const dR =
        "figure.image.ck-widget > img," +
        "figure.image.ck-widget > picture > img," +
        "figure.image.ck-widget > a > img," +
        "figure.image.ck-widget > a > picture > img," +
        "span.image-inline.ck-widget > img," +
        "span.image-inline.ck-widget > picture > img";
      const uR = /(image|image-inline)/;
      const hR = "image_resized";
      class mR extends Cl {
        static get requires() {
          return [fS];
        }
        static get pluginName() {
          return "ImageResizeHandles";
        }
        init() {
          const t = this.editor.commands.get("resizeImage");
          this.bind("isEnabled").to(t);
          this._setupResizerCreator();
        }
        _setupResizerCreator() {
          const t = this.editor;
          const e = t.editing.view;
          e.addObserver(zz);
          this.listenTo(e.document, "imageLoaded", (n, i) => {
            if (!i.target.matches(dR)) {
              return;
            }
            const o = t.editing.view.domConverter;
            const r = o.domToView(i.target);
            const s = r.findAncestor({ classes: uR });
            let a = this.editor.plugins.get(fS).getResizerByViewElement(s);
            if (a) {
              a.redraw();
              return;
            }
            const c = t.editing.mapper;
            const l = c.toModelElement(s);
            a = t.plugins.get(fS).attachTo({
              unit: t.config.get("image.resizeUnit"),
              modelElement: l,
              viewElement: s,
              editor: t,
              getHandleHost(t) {
                return t.querySelector("img");
              },
              getResizeHost() {
                return o.mapViewToDom(c.toViewElement(l.parent));
              },
              isCentered() {
                const t = l.getAttribute("imageStyle");
                return !t || t == "block" || t == "alignCenter";
              },
              onCommit(n) {
                e.change((t) => {
                  t.removeClass(hR, s);
                });
                t.execute("resizeImage", { width: n });
              },
            });
            a.on("updateSize", () => {
              if (!s.hasClass(hR)) {
                e.change((t) => {
                  t.addClass(hR, s);
                });
              }
            });
            a.bind("isEnabled").to(this);
          });
        }
      }
      var gR = n(1043);
      var fR = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      fR.insert = "head";
      fR.singleton = true;
      var pR = Il()(gR.Z, fR);
      const bR = gR.Z.locals || {};
      class kR extends Cl {
        static get requires() {
          return [sR, mR, cR];
        }
        static get pluginName() {
          return "ImageResize";
        }
      }
      class wR extends vl {
        constructor(t, e) {
          super(t);
          this._defaultStyles = { imageBlock: false, imageInline: false };
          this._styles = new Map(
            e.map((t) => {
              if (t.isDefault) {
                for (const e of t.modelElements) {
                  this._defaultStyles[e] = t.name;
                }
              }
              return [t.name, t];
            })
          );
        }
        refresh() {
          const t = this.editor;
          const e = t.plugins.get("ImageUtils");
          const n = e.getClosestSelectedImageElement(
            this.editor.model.document.selection
          );
          this.isEnabled = !!n;
          if (!this.isEnabled) {
            this.value = false;
          } else if (n.hasAttribute("imageStyle")) {
            this.value = n.getAttribute("imageStyle");
          } else {
            this.value = this._defaultStyles[n.name];
          }
        }
        execute(t = {}) {
          const e = this.editor;
          const n = e.model;
          const i = e.plugins.get("ImageUtils");
          n.change((e) => {
            const o = t.value;
            let r = i.getClosestSelectedImageElement(n.document.selection);
            if (o && this.shouldConvertImageType(o, r)) {
              this.editor.execute(
                i.isBlockImage(r) ? "imageTypeInline" : "imageTypeBlock"
              );
              r = i.getClosestSelectedImageElement(n.document.selection);
            }
            if (!o || this._styles.get(o).isDefault) {
              e.removeAttribute("imageStyle", r);
            } else {
              e.setAttribute("imageStyle", o, r);
            }
          });
        }
        shouldConvertImageType(t, e) {
          const n = this._styles.get(t).modelElements;
          return !n.includes(e.name);
        }
      }
      const {
        objectFullWidth: AR,
        objectInline: CR,
        objectLeft: _R,
        objectRight: vR,
        objectCenter: yR,
        objectBlockLeft: xR,
        objectBlockRight: ER,
      } = __;
      const DR = {
        get inline() {
          return {
            name: "inline",
            title: "In line",
            icon: CR,
            modelElements: ["imageInline"],
            isDefault: true,
          };
        },
        get alignLeft() {
          return {
            name: "alignLeft",
            title: "Left aligned image",
            icon: _R,
            modelElements: ["imageBlock", "imageInline"],
            className: "image-style-align-left",
          };
        },
        get alignBlockLeft() {
          return {
            name: "alignBlockLeft",
            title: "Left aligned image",
            icon: xR,
            modelElements: ["imageBlock"],
            className: "image-style-block-align-left",
          };
        },
        get alignCenter() {
          return {
            name: "alignCenter",
            title: "Centered image",
            icon: yR,
            modelElements: ["imageBlock"],
            className: "image-style-align-center",
          };
        },
        get alignRight() {
          return {
            name: "alignRight",
            title: "Right aligned image",
            icon: vR,
            modelElements: ["imageBlock", "imageInline"],
            className: "image-style-align-right",
          };
        },
        get alignBlockRight() {
          return {
            name: "alignBlockRight",
            title: "Right aligned image",
            icon: ER,
            modelElements: ["imageBlock"],
            className: "image-style-block-align-right",
          };
        },
        get block() {
          return {
            name: "block",
            title: "Centered image",
            icon: yR,
            modelElements: ["imageBlock"],
            isDefault: true,
          };
        },
        get side() {
          return {
            name: "side",
            title: "Side image",
            icon: vR,
            modelElements: ["imageBlock"],
            className: "image-style-side",
          };
        },
      };
      const SR = {
        full: AR,
        left: xR,
        right: ER,
        center: yR,
        inlineLeft: _R,
        inlineRight: vR,
        inline: CR,
      };
      const TR = [
        {
          name: "imageStyle:wrapText",
          title: "Wrap text",
          defaultItem: "imageStyle:alignLeft",
          items: ["imageStyle:alignLeft", "imageStyle:alignRight"],
        },
        {
          name: "imageStyle:breakText",
          title: "Break text",
          defaultItem: "imageStyle:block",
          items: [
            "imageStyle:alignBlockLeft",
            "imageStyle:block",
            "imageStyle:alignBlockRight",
          ],
        },
      ];
      function IR(t) {
        const e = t.configuredStyles.options || [];
        const n = e.map((t) => LR(t)).filter((e) => NR(e, t));
        return n;
      }
      function MR(t, e) {
        if (t && e) {
          return {
            options: [
              "inline",
              "alignLeft",
              "alignRight",
              "alignCenter",
              "alignBlockLeft",
              "alignBlockRight",
              "block",
              "side",
            ],
          };
        } else if (t) {
          return { options: ["block", "side"] };
        } else if (e) {
          return { options: ["inline", "alignLeft", "alignRight"] };
        }
        return {};
      }
      function BR(t) {
        if (t.has("ImageBlockEditing") && t.has("ImageInlineEditing")) {
          return [...TR];
        } else {
          return [];
        }
      }
      function LR(t) {
        if (typeof t === "string") {
          if (!DR[t]) {
            t = { name: t };
          } else {
            t = { ...DR[t] };
          }
        } else {
          t = zR(DR[t.name], t);
        }
        if (typeof t.icon === "string") {
          t.icon = SR[t.icon] || t.icon;
        }
        return t;
      }
      function NR(t, { isBlockPluginLoaded: e, isInlinePluginLoaded: n }) {
        const { modelElements: i, name: o } = t;
        if (!i || !i.length || !o) {
          PR({ style: t });
          return false;
        } else {
          const o = [e ? "imageBlock" : null, n ? "imageInline" : null];
          if (!i.some((t) => o.includes(t))) {
            B("image-style-missing-dependency", {
              style: t,
              missingPlugins: i.map((t) =>
                t === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing"
              ),
            });
            return false;
          }
        }
        return true;
      }
      function zR(t, e) {
        const n = { ...e };
        for (const i in t) {
          if (!Object.prototype.hasOwnProperty.call(e, i)) {
            n[i] = t[i];
          }
        }
        return n;
      }
      function PR(t) {
        B("image-style-configuration-definition-invalid", t);
      }
      const RR = {
        normalizeStyles: IR,
        getDefaultStylesConfiguration: MR,
        getDefaultDropdownDefinitions: BR,
        warnInvalidStyle: PR,
        DEFAULT_OPTIONS: DR,
        DEFAULT_ICONS: SR,
        DEFAULT_DROPDOWN_DEFINITIONS: TR,
      };
      function OR(t) {
        return (e, n, i) => {
          if (!i.consumable.consume(n.item, e.name)) {
            return;
          }
          const o = FR(n.attributeNewValue, t);
          const r = FR(n.attributeOldValue, t);
          const s = i.mapper.toViewElement(n.item);
          const a = i.writer;
          if (r) {
            a.removeClass(r.className, s);
          }
          if (o) {
            a.addClass(o.className, s);
          }
        };
      }
      function jR(t) {
        const e = {
          imageInline: t.filter(
            (t) => !t.isDefault && t.modelElements.includes("imageInline")
          ),
          imageBlock: t.filter(
            (t) => !t.isDefault && t.modelElements.includes("imageBlock")
          ),
        };
        return (t, n, i) => {
          if (!n.modelRange) {
            return;
          }
          const o = n.viewItem;
          const r = sl(n.modelRange.getItems());
          if (!r) {
            return;
          }
          if (!i.schema.checkAttribute(r, "imageStyle")) {
            return;
          }
          for (const t of e[r.name]) {
            if (i.consumable.consume(o, { classes: t.className })) {
              i.writer.setAttribute("imageStyle", t.name, r);
            }
          }
        };
      }
      function FR(t, e) {
        for (const n of e) {
          if (n.name === t) {
            return n;
          }
        }
      }
      class VR extends Cl {
        static get pluginName() {
          return "ImageStyleEditing";
        }
        static get requires() {
          return [$S];
        }
        init() {
          const { normalizeStyles: t, getDefaultStylesConfiguration: e } = RR;
          const n = this.editor;
          const i = n.plugins.has("ImageBlockEditing");
          const o = n.plugins.has("ImageInlineEditing");
          n.config.define("image.styles", e(i, o));
          this.normalizedStyles = t({
            configuredStyles: n.config.get("image.styles"),
            isBlockPluginLoaded: i,
            isInlinePluginLoaded: o,
          });
          this._setupConversion(i, o);
          this._setupPostFixer();
          n.commands.add("imageStyle", new wR(n, this.normalizedStyles));
        }
        _setupConversion(t, e) {
          const n = this.editor;
          const i = n.model.schema;
          const o = OR(this.normalizedStyles);
          const r = jR(this.normalizedStyles);
          n.editing.downcastDispatcher.on("attribute:imageStyle", o);
          n.data.downcastDispatcher.on("attribute:imageStyle", o);
          if (t) {
            i.extend("imageBlock", { allowAttributes: "imageStyle" });
            n.data.upcastDispatcher.on("element:figure", r, {
              priority: "low",
            });
          }
          if (e) {
            i.extend("imageInline", { allowAttributes: "imageStyle" });
            n.data.upcastDispatcher.on("element:img", r, { priority: "low" });
          }
        }
        _setupPostFixer() {
          const t = this.editor;
          const e = t.model.document;
          const n = t.plugins.get($S);
          const i = new Map(this.normalizedStyles.map((t) => [t.name, t]));
          e.registerPostFixer((t) => {
            let o = false;
            for (const r of e.differ.getChanges()) {
              if (
                r.type == "insert" ||
                (r.type == "attribute" && r.attributeKey == "imageStyle")
              ) {
                let e =
                  r.type == "insert"
                    ? r.position.nodeAfter
                    : r.range.start.nodeAfter;
                if (e && e.is("element", "paragraph") && e.childCount > 0) {
                  e = e.getChild(0);
                }
                if (!n.isImage(e)) {
                  continue;
                }
                const s = e.getAttribute("imageStyle");
                if (!s) {
                  continue;
                }
                const a = i.get(s);
                if (!a || !a.modelElements.includes(e.name)) {
                  t.removeAttribute("imageStyle", e);
                  o = true;
                }
              }
            }
            return o;
          });
        }
      }
      var HR = n(4622);
      var UR = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      UR.insert = "head";
      UR.singleton = true;
      var qR = Il()(HR.Z, UR);
      const WR = HR.Z.locals || {};
      class GR extends Cl {
        static get requires() {
          return [VR];
        }
        static get pluginName() {
          return "ImageStyleUI";
        }
        get localizedDefaultStylesTitles() {
          const t = this.editor.t;
          return {
            "Wrap text": t("Wrap text"),
            "Break text": t("Break text"),
            "In line": t("In line"),
            "Full size image": t("Full size image"),
            "Side image": t("Side image"),
            "Left aligned image": t("Left aligned image"),
            "Centered image": t("Centered image"),
            "Right aligned image": t("Right aligned image"),
          };
        }
        init() {
          const t = this.editor.plugins;
          const e = this.editor.config.get("image.toolbar") || [];
          const n = $R(
            t.get("ImageStyleEditing").normalizedStyles,
            this.localizedDefaultStylesTitles
          );
          for (const t of n) {
            this._createButton(t);
          }
          const i = $R(
            [...e.filter(it), ...RR.getDefaultDropdownDefinitions(t)],
            this.localizedDefaultStylesTitles
          );
          for (const t of i) {
            this._createDropdown(t, n);
          }
        }
        _createDropdown(t, e) {
          const n = this.editor.ui.componentFactory;
          n.add(t.name, (i) => {
            let o;
            const { defaultItem: r, items: s, title: a } = t;
            const c = s
              .filter((t) => e.find(({ name: e }) => KR(e) === t))
              .map((t) => {
                const e = n.create(t);
                if (t === r) {
                  o = e;
                }
                return e;
              });
            if (s.length !== c.length) {
              RR.warnInvalidStyle({ dropdown: t });
            }
            const l = Uv(i, rv);
            const d = l.buttonView;
            const u = d.arrowView;
            qv(l, c, { enableActiveItemFocusOnDropdownOpen: true });
            d.set({ label: YR(a, o.label), class: null, tooltip: true });
            u.unbind("label");
            u.set({ label: a });
            d.bind("icon").toMany(c, "isOn", (...t) => {
              const e = t.findIndex(fu);
              return e < 0 ? o.icon : c[e].icon;
            });
            d.bind("label").toMany(c, "isOn", (...t) => {
              const e = t.findIndex(fu);
              return YR(a, e < 0 ? o.label : c[e].label);
            });
            d.bind("isOn").toMany(c, "isOn", (...t) => t.some(fu));
            d.bind("class").toMany(c, "isOn", (...t) =>
              t.some(fu) ? "ck-splitbutton_flatten" : null
            );
            d.on("execute", () => {
              if (!c.some(({ isOn: t }) => t)) {
                o.fire("execute");
              } else {
                l.isOpen = !l.isOpen;
              }
            });
            l.bind("isEnabled").toMany(c, "isEnabled", (...t) => t.some(fu));
            this.listenTo(l, "execute", () => {
              this.editor.editing.view.focus();
            });
            return l;
          });
        }
        _createButton(t) {
          const e = t.name;
          this.editor.ui.componentFactory.add(KR(e), (n) => {
            const i = this.editor.commands.get("imageStyle");
            const o = new R_(n);
            o.set({
              label: t.title,
              icon: t.icon,
              tooltip: true,
              isToggleable: true,
            });
            o.bind("isEnabled").to(i, "isEnabled");
            o.bind("isOn").to(i, "value", (t) => t === e);
            o.on("execute", this._executeCommand.bind(this, e));
            return o;
          });
        }
        _executeCommand(t) {
          this.editor.execute("imageStyle", { value: t });
          this.editor.editing.view.focus();
        }
      }
      function $R(t, e) {
        for (const n of t) {
          if (e[n.title]) {
            n.title = e[n.title];
          }
        }
        return t;
      }
      function KR(t) {
        return \`imageStyle:\${t}\`;
      }
      function YR(t, e) {
        return (t ? t + ": " : "") + e;
      }
      class ZR extends Cl {
        static get requires() {
          return [VR, GR];
        }
        static get pluginName() {
          return "ImageStyle";
        }
      }
      class QR extends Cl {
        static get requires() {
          return [$D, $S];
        }
        static get pluginName() {
          return "ImageToolbar";
        }
        afterInit() {
          const t = this.editor;
          const e = t.t;
          const n = t.plugins.get($D);
          const i = t.plugins.get("ImageUtils");
          n.register("image", {
            ariaLabel: e("Image toolbar"),
            items: JR(t.config.get("image.toolbar") || []),
            getRelatedElement: (t) => i.getClosestSelectedImageWidget(t),
          });
        }
      }
      function JR(t) {
        return t.map((t) => (it(t) ? t.name : t));
      }
      class XR extends Cl {
        static get pluginName() {
          return "IndentEditing";
        }
        init() {
          const t = this.editor;
          t.commands.add("indent", new xl(t));
          t.commands.add("outdent", new xl(t));
        }
      }
      const tO =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>';
      const eO =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
      class nO extends Cl {
        static get pluginName() {
          return "IndentUI";
        }
        init() {
          const t = this.editor;
          const e = t.locale;
          const n = t.t;
          const i = e.uiLanguageDirection == "ltr" ? tO : eO;
          const o = e.uiLanguageDirection == "ltr" ? eO : tO;
          this._defineButton("indent", n("Increase indent"), i);
          this._defineButton("outdent", n("Decrease indent"), o);
        }
        _defineButton(t, e, n) {
          const i = this.editor;
          i.ui.componentFactory.add(t, (o) => {
            const r = i.commands.get(t);
            const s = new R_(o);
            s.set({ label: e, icon: n, tooltip: true });
            s.bind("isOn", "isEnabled").to(r, "value", "isEnabled");
            this.listenTo(s, "execute", () => {
              i.execute(t);
              i.editing.view.focus();
            });
            return s;
          });
        }
      }
      class iO extends Cl {
        static get pluginName() {
          return "Indent";
        }
        static get requires() {
          return [XR, nO];
        }
      }
      class oO extends vl {
        constructor(t, e) {
          super(t);
          this._indentBehavior = e;
        }
        refresh() {
          const t = this.editor;
          const e = t.model;
          const n = sl(e.document.selection.getSelectedBlocks());
          if (!n || !e.schema.checkAttribute(n, "blockIndent")) {
            this.isEnabled = false;
            return;
          }
          this.isEnabled = this._indentBehavior.checkEnabled(
            n.getAttribute("blockIndent")
          );
        }
        execute() {
          const t = this.editor.model;
          const e = rO(t);
          t.change((t) => {
            for (const n of e) {
              const e = n.getAttribute("blockIndent");
              const i = this._indentBehavior.getNextIndent(e);
              if (i) {
                t.setAttribute("blockIndent", i, n);
              } else {
                t.removeAttribute("blockIndent", n);
              }
            }
          });
        }
      }
      function rO(t) {
        const e = t.document.selection;
        const n = t.schema;
        const i = Array.from(e.getSelectedBlocks());
        return i.filter((t) => n.checkAttribute(t, "blockIndent"));
      }
      class sO {
        constructor(t) {
          this.isForward = t.direction === "forward";
          this.offset = t.offset;
          this.unit = t.unit;
        }
        checkEnabled(t) {
          const e = parseFloat(t || 0);
          return this.isForward || e > 0;
        }
        getNextIndent(t) {
          const e = parseFloat(t || 0);
          const n = !t || t.endsWith(this.unit);
          if (!n) {
            return this.isForward ? this.offset + this.unit : undefined;
          }
          const i = this.isForward ? this.offset : -this.offset;
          const o = e + i;
          return o > 0 ? o + this.unit : undefined;
        }
      }
      class aO {
        constructor(t) {
          this.isForward = t.direction === "forward";
          this.classes = t.classes;
        }
        checkEnabled(t) {
          const e = this.classes.indexOf(t);
          if (this.isForward) {
            return e < this.classes.length - 1;
          } else {
            return e >= 0;
          }
        }
        getNextIndent(t) {
          const e = this.classes.indexOf(t);
          const n = this.isForward ? 1 : -1;
          return this.classes[e + n];
        }
      }
      const cO = [
        "paragraph",
        "heading1",
        "heading2",
        "heading3",
        "heading4",
        "heading5",
        "heading6",
      ];
      class lO extends Cl {
        constructor(t) {
          super(t);
          t.config.define("indentBlock", { offset: 40, unit: "px" });
        }
        static get pluginName() {
          return "IndentBlock";
        }
        init() {
          const t = this.editor;
          const e = t.config.get("indentBlock");
          const n = !e.classes || !e.classes.length;
          const i = Object.assign({ direction: "forward" }, e);
          const o = Object.assign({ direction: "backward" }, e);
          if (n) {
            t.data.addStyleProcessorRules(TA);
            this._setupConversionUsingOffset(t.conversion);
            t.commands.add("indentBlock", new oO(t, new sO(i)));
            t.commands.add("outdentBlock", new oO(t, new sO(o)));
          } else {
            this._setupConversionUsingClasses(e.classes);
            t.commands.add("indentBlock", new oO(t, new aO(i)));
            t.commands.add("outdentBlock", new oO(t, new aO(o)));
          }
        }
        afterInit() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.commands.get("indent");
          const i = t.commands.get("outdent");
          const o = t.config.get("heading.options");
          const r = o && o.map((t) => t.model);
          const s = r || cO;
          s.forEach((t) => {
            if (e.isRegistered(t)) {
              e.extend(t, { allowAttributes: "blockIndent" });
            }
          });
          e.setAttributeProperties("blockIndent", { isFormatting: true });
          n.registerChildCommand(t.commands.get("indentBlock"));
          i.registerChildCommand(t.commands.get("outdentBlock"));
        }
        _setupConversionUsingOffset() {
          const t = this.editor.conversion;
          const e = this.editor.locale;
          const n =
            e.contentLanguageDirection === "rtl"
              ? "margin-right"
              : "margin-left";
          t.for("upcast").attributeToAttribute({
            view: { styles: { [n]: /[\\s\\S]+/ } },
            model: { key: "blockIndent", value: (t) => t.getStyle(n) },
          });
          t.for("downcast").attributeToAttribute({
            model: "blockIndent",
            view: (t) => ({ key: "style", value: { [n]: t } }),
          });
        }
        _setupConversionUsingClasses(t) {
          const e = { model: { key: "blockIndent", values: [] }, view: {} };
          for (const n of t) {
            e.model.values.push(n);
            e.view[n] = { key: "class", value: [n] };
          }
          this.editor.conversion.attributeToAttribute(e);
        }
      }
      const dO = "italic";
      class uO extends Cl {
        static get pluginName() {
          return "ItalicEditing";
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: dO });
          t.model.schema.setAttributeProperties(dO, {
            isFormatting: true,
            copyOnEnter: true,
          });
          t.conversion.attributeToElement({
            model: dO,
            view: "i",
            upcastAlso: ["em", { styles: { "font-style": "italic" } }],
          });
          t.commands.add(dO, new SI(t, dO));
          t.keystrokes.set("CTRL+I", dO);
        }
      }
      const hO =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>';
      const mO = "italic";
      class gO extends Cl {
        static get pluginName() {
          return "ItalicUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(mO, (n) => {
            const i = t.commands.get(mO);
            const o = new R_(n);
            o.set({
              label: e("Italic"),
              icon: hO,
              keystroke: "CTRL+I",
              tooltip: true,
              isToggleable: true,
            });
            o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
            this.listenTo(o, "execute", () => {
              t.execute(mO);
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class fO extends Cl {
        static get requires() {
          return [uO, gO];
        }
        static get pluginName() {
          return "Italic";
        }
      }
      class pO {
        constructor() {
          this._definitions = new Set();
        }
        get length() {
          return this._definitions.size;
        }
        add(t) {
          if (Array.isArray(t)) {
            t.forEach((t) => this._definitions.add(t));
          } else {
            this._definitions.add(t);
          }
        }
        getDispatcher() {
          return (t) => {
            t.on(
              "attribute:linkHref",
              (t, e, n) => {
                if (!n.consumable.test(e.item, "attribute:linkHref")) {
                  return;
                }
                if (!(e.item.is("selection") || n.schema.isInline(e.item))) {
                  return;
                }
                const i = n.writer;
                const o = i.document.selection;
                for (const t of this._definitions) {
                  const r = i.createAttributeElement("a", t.attributes, {
                    priority: 5,
                  });
                  if (t.classes) {
                    i.addClass(t.classes, r);
                  }
                  for (const e in t.styles) {
                    i.setStyle(e, t.styles[e], r);
                  }
                  i.setCustomProperty("link", true, r);
                  if (t.callback(e.attributeNewValue)) {
                    if (e.item.is("selection")) {
                      i.wrap(o.getFirstRange(), r);
                    } else {
                      i.wrap(n.mapper.toViewRange(e.range), r);
                    }
                  } else {
                    i.unwrap(n.mapper.toViewRange(e.range), r);
                  }
                }
              },
              { priority: "high" }
            );
          };
        }
        getDispatcherForLinkedImage() {
          return (t) => {
            t.on(
              "attribute:linkHref:imageBlock",
              (t, e, { writer: n, mapper: i }) => {
                const o = i.toViewElement(e.item);
                const r = Array.from(o.getChildren()).find(
                  (t) => t.name === "a"
                );
                for (const t of this._definitions) {
                  const i = dl(t.attributes);
                  if (t.callback(e.attributeNewValue)) {
                    for (const [t, e] of i) {
                      if (t === "class") {
                        n.addClass(e, r);
                      } else {
                        n.setAttribute(t, e, r);
                      }
                    }
                    if (t.classes) {
                      n.addClass(t.classes, r);
                    }
                    for (const e in t.styles) {
                      n.setStyle(e, t.styles[e], r);
                    }
                  } else {
                    for (const [t, e] of i) {
                      if (t === "class") {
                        n.removeClass(e, r);
                      } else {
                        n.removeAttribute(t, r);
                      }
                    }
                    if (t.classes) {
                      n.removeClass(t.classes, r);
                    }
                    for (const e in t.styles) {
                      n.removeStyle(e, r);
                    }
                  }
                }
              }
            );
          };
        }
      }
      class bO extends vl {
        constructor(t) {
          super(t);
          this.manualDecorators = new rl();
          this.automaticDecorators = new pO();
        }
        restoreManualDecoratorStates() {
          for (const t of this.manualDecorators) {
            t.value = this._getDecoratorStateFromModel(t.id);
          }
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document.selection;
          const n = e.getSelectedElement() || sl(e.getSelectedBlocks());
          if (XT(n, t.schema)) {
            this.value = n.getAttribute("linkHref");
            this.isEnabled = t.schema.checkAttribute(n, "linkHref");
          } else {
            this.value = e.getAttribute("linkHref");
            this.isEnabled = t.schema.checkAttributeInSelection(e, "linkHref");
          }
          for (const t of this.manualDecorators) {
            t.value = this._getDecoratorStateFromModel(t.id);
          }
        }
        execute(t, e = {}) {
          const n = this.editor.model;
          const i = n.document.selection;
          const o = [];
          const r = [];
          for (const t in e) {
            if (e[t]) {
              o.push(t);
            } else {
              r.push(t);
            }
          }
          n.change((e) => {
            if (i.isCollapsed) {
              const s = i.getFirstPosition();
              if (i.hasAttribute("linkHref")) {
                const a = _E(s, "linkHref", i.getAttribute("linkHref"), n);
                e.setAttribute("linkHref", t, a);
                o.forEach((t) => {
                  e.setAttribute(t, true, a);
                });
                r.forEach((t) => {
                  e.removeAttribute(t, a);
                });
                e.setSelection(e.createPositionAfter(a.end.nodeBefore));
              } else if (t !== "") {
                const r = dl(i.getAttributes());
                r.set("linkHref", t);
                o.forEach((t) => {
                  r.set(t, true);
                });
                const { end: a } = n.insertContent(e.createText(t, r), s);
                e.setSelection(a);
              }
              ["linkHref", ...o, ...r].forEach((t) => {
                e.removeSelectionAttribute(t);
              });
            } else {
              const s = n.schema.getValidRanges(i.getRanges(), "linkHref");
              const a = [];
              for (const t of i.getSelectedBlocks()) {
                if (n.schema.checkAttribute(t, "linkHref")) {
                  a.push(e.createRangeOn(t));
                }
              }
              const c = a.slice();
              for (const t of s) {
                if (this._isRangeToUpdate(t, a)) {
                  c.push(t);
                }
              }
              for (const n of c) {
                e.setAttribute("linkHref", t, n);
                o.forEach((t) => {
                  e.setAttribute(t, true, n);
                });
                r.forEach((t) => {
                  e.removeAttribute(t, n);
                });
              }
            }
          });
        }
        _getDecoratorStateFromModel(t) {
          const e = this.editor.model;
          const n = e.document.selection;
          const i = n.getSelectedElement();
          if (XT(i, e.schema)) {
            return i.getAttribute(t);
          }
          return n.getAttribute(t);
        }
        _isRangeToUpdate(t, e) {
          for (const n of e) {
            if (n.containsRange(t)) {
              return false;
            }
          }
          return true;
        }
      }
      class kO extends vl {
        refresh() {
          const t = this.editor.model;
          const e = t.document.selection;
          const n = e.getSelectedElement();
          if (XT(n, t.schema)) {
            this.isEnabled = t.schema.checkAttribute(n, "linkHref");
          } else {
            this.isEnabled = t.schema.checkAttributeInSelection(e, "linkHref");
          }
        }
        execute() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          const i = t.commands.get("link");
          e.change((t) => {
            const o = n.isCollapsed
              ? [
                  _E(
                    n.getFirstPosition(),
                    "linkHref",
                    n.getAttribute("linkHref"),
                    e
                  ),
                ]
              : e.schema.getValidRanges(n.getRanges(), "linkHref");
            for (const e of o) {
              t.removeAttribute("linkHref", e);
              if (i) {
                for (const n of i.manualDecorators) {
                  t.removeAttribute(n.id, e);
                }
              }
            }
          });
        }
      }
      class wO {
        constructor({
          id: t,
          label: e,
          attributes: n,
          classes: i,
          styles: o,
          defaultValue: r,
        }) {
          this.id = t;
          this.set("value");
          this.defaultValue = r;
          this.label = e;
          this.attributes = n;
          this.classes = i;
          this.styles = o;
        }
        _createPattern() {
          return {
            attributes: this.attributes,
            classes: this.classes,
            styles: this.styles,
          };
        }
      }
      C(wO, dt);
      var AO = n(399);
      var CO = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      CO.insert = "head";
      CO.singleton = true;
      var _O = Il()(AO.Z, CO);
      const vO = AO.Z.locals || {};
      const yO = "ck-link_selected";
      const xO = "automatic";
      const EO = "manual";
      const DO = /^(https?:)?\\/\\//;
      class SO extends Cl {
        static get pluginName() {
          return "LinkEditing";
        }
        static get requires() {
          return [nE, Fx, RE];
        }
        constructor(t) {
          super(t);
          t.config.define("link", { addTargetToExternalLinks: false });
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: "linkHref" });
          t.conversion
            .for("dataDowncast")
            .attributeToElement({ model: "linkHref", view: KT });
          t.conversion.for("editingDowncast").attributeToElement({
            model: "linkHref",
            view: (t, e) => KT(YT(t), e),
          });
          t.conversion.for("upcast").elementToAttribute({
            view: { name: "a", attributes: { href: true } },
            model: { key: "linkHref", value: (t) => t.getAttribute("href") },
          });
          t.commands.add("link", new bO(t));
          t.commands.add("unlink", new kO(t));
          const e = QT(t.t, JT(t.config.get("link.decorators")));
          this._enableAutomaticDecorators(e.filter((t) => t.mode === xO));
          this._enableManualDecorators(e.filter((t) => t.mode === EO));
          const n = t.plugins.get(nE);
          n.registerAttribute("linkHref");
          yE(t, "linkHref", "a", yO);
          this._enableLinkOpen();
          this._enableInsertContentSelectionAttributesFixer();
          this._enableClickingAfterLink();
          this._enableTypingOverLink();
          this._handleDeleteContentAfterLink();
        }
        _enableAutomaticDecorators(t) {
          const e = this.editor;
          const n = e.commands.get("link");
          const i = n.automaticDecorators;
          if (e.config.get("link.addTargetToExternalLinks")) {
            i.add({
              id: "linkIsExternal",
              mode: xO,
              callback: (t) => DO.test(t),
              attributes: { target: "_blank", rel: "noopener noreferrer" },
            });
          }
          i.add(t);
          if (i.length) {
            e.conversion.for("downcast").add(i.getDispatcher());
          }
        }
        _enableManualDecorators(t) {
          if (!t.length) {
            return;
          }
          const e = this.editor;
          const n = e.commands.get("link");
          const i = n.manualDecorators;
          t.forEach((t) => {
            e.model.schema.extend("$text", { allowAttributes: t.id });
            t = new wO(t);
            i.add(t);
            e.conversion.for("downcast").attributeToElement({
              model: t.id,
              view: (e, { writer: n, schema: i }, { item: o }) => {
                if (!(o.is("selection") || i.isInline(o))) {
                  return;
                }
                if (e) {
                  const e = n.createAttributeElement("a", t.attributes, {
                    priority: 5,
                  });
                  if (t.classes) {
                    n.addClass(t.classes, e);
                  }
                  for (const i in t.styles) {
                    n.setStyle(i, t.styles[i], e);
                  }
                  n.setCustomProperty("link", true, e);
                  return e;
                }
              },
            });
            e.conversion.for("upcast").elementToAttribute({
              view: { name: "a", ...t._createPattern() },
              model: { key: t.id },
            });
          });
        }
        _enableLinkOpen() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          this.listenTo(
            n,
            "click",
            (t, e) => {
              const n = r.isMac ? e.domEvent.metaKey : e.domEvent.ctrlKey;
              if (!n) {
                return;
              }
              let i = e.domTarget;
              if (i.tagName.toLowerCase() != "a") {
                i = i.closest("a");
              }
              if (!i) {
                return;
              }
              const o = i.getAttribute("href");
              if (!o) {
                return;
              }
              t.stop();
              e.preventDefault();
              iI(o);
            },
            { context: "$capture" }
          );
          this.listenTo(n, "keydown", (e, n) => {
            const i = t.commands.get("link").value;
            const o = i && n.keyCode === Oc.enter && n.altKey;
            if (!o) {
              return;
            }
            e.stop();
            iI(i);
          });
        }
        _enableInsertContentSelectionAttributesFixer() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          this.listenTo(
            e,
            "insertContent",
            () => {
              const t = n.anchor.nodeBefore;
              const i = n.anchor.nodeAfter;
              if (!n.hasAttribute("linkHref")) {
                return;
              }
              if (!t) {
                return;
              }
              if (!t.hasAttribute("linkHref")) {
                return;
              }
              if (i && i.hasAttribute("linkHref")) {
                return;
              }
              e.change((t) => {
                TO(t, BO(e.schema));
              });
            },
            { priority: "low" }
          );
        }
        _enableClickingAfterLink() {
          const t = this.editor;
          const e = t.model;
          t.editing.view.addObserver(jw);
          let n = false;
          this.listenTo(t.editing.view.document, "mousedown", () => {
            n = true;
          });
          this.listenTo(t.editing.view.document, "selectionChange", () => {
            if (!n) {
              return;
            }
            n = false;
            const t = e.document.selection;
            if (!t.isCollapsed) {
              return;
            }
            if (!t.hasAttribute("linkHref")) {
              return;
            }
            const i = t.getFirstPosition();
            const o = _E(i, "linkHref", t.getAttribute("linkHref"), e);
            if (i.isTouching(o.start) || i.isTouching(o.end)) {
              e.change((t) => {
                TO(t, BO(e.schema));
              });
            }
          });
        }
        _enableTypingOverLink() {
          const t = this.editor;
          const e = t.editing.view;
          let n;
          let i;
          this.listenTo(
            e.document,
            "delete",
            () => {
              i = true;
            },
            { priority: "high" }
          );
          this.listenTo(
            t.model,
            "deleteContent",
            () => {
              const e = t.model.document.selection;
              if (e.isCollapsed) {
                return;
              }
              if (i) {
                i = false;
                return;
              }
              if (!MO(t)) {
                return;
              }
              if (IO(t.model)) {
                n = e.getAttributes();
              }
            },
            { priority: "high" }
          );
          this.listenTo(
            t.model,
            "insertContent",
            (e, [o]) => {
              i = false;
              if (!MO(t)) {
                return;
              }
              if (!n) {
                return;
              }
              t.model.change((t) => {
                for (const [e, i] of n) {
                  t.setAttribute(e, i, o);
                }
              });
              n = null;
            },
            { priority: "high" }
          );
        }
        _handleDeleteContentAfterLink() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          const i = t.editing.view;
          let o = false;
          let r = false;
          this.listenTo(
            i.document,
            "delete",
            (t, e) => {
              r = e.direction === "backward";
            },
            { priority: "high" }
          );
          this.listenTo(
            e,
            "deleteContent",
            () => {
              o = false;
              const t = n.getFirstPosition();
              const i = n.getAttribute("linkHref");
              if (!i) {
                return;
              }
              const r = _E(t, "linkHref", i, e);
              o = r.containsPosition(t) || r.end.isEqual(t);
            },
            { priority: "high" }
          );
          this.listenTo(
            e,
            "deleteContent",
            () => {
              if (!r) {
                return;
              }
              r = false;
              if (o) {
                return;
              }
              t.model.enqueueChange((t) => {
                TO(t, BO(e.schema));
              });
            },
            { priority: "low" }
          );
        }
      }
      function TO(t, e) {
        t.removeSelectionAttribute("linkHref");
        for (const n of e) {
          t.removeSelectionAttribute(n);
        }
      }
      function IO(t) {
        const e = t.document.selection;
        const n = e.getFirstPosition();
        const i = e.getLastPosition();
        const o = n.nodeAfter;
        if (!o) {
          return false;
        }
        if (!o.is("$text")) {
          return false;
        }
        if (!o.hasAttribute("linkHref")) {
          return false;
        }
        const r = i.textNode || i.nodeBefore;
        if (o === r) {
          return true;
        }
        const s = _E(n, "linkHref", o.getAttribute("linkHref"), t);
        return s.containsRange(t.createRange(n, i), true);
      }
      function MO(t) {
        const e = t.model.change((t) => t.batch);
        return e.isTyping;
      }
      function BO(t) {
        const e = t.getDefinition("$text").allowAttributes;
        return e.filter((t) => t.startsWith("link"));
      }
      var LO = n(4827);
      var NO = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      NO.insert = "head";
      NO.singleton = true;
      var zO = Il()(LO.Z, NO);
      const PO = LO.Z.locals || {};
      class RO extends pC {
        constructor(t, e) {
          super(t);
          const n = t.t;
          this.focusTracker = new al();
          this.keystrokes = new cl();
          this.urlInputView = this._createUrlInput();
          this.saveButtonView = this._createButton(
            n("Save"),
            __.check,
            "ck-button-save"
          );
          this.saveButtonView.type = "submit";
          this.cancelButtonView = this._createButton(
            n("Cancel"),
            __.cancel,
            "ck-button-cancel",
            "cancel"
          );
          this._manualDecoratorSwitches =
            this._createManualDecoratorSwitches(e);
          this.children = this._createFormChildren(e.manualDecorators);
          this._focusables = new PA();
          this._focusCycler = new hv({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          });
          const i = ["ck", "ck-link-form", "ck-responsive-form"];
          if (e.manualDecorators.length) {
            i.push("ck-link-form_layout-vertical", "ck-vertical-form");
          }
          this.setTemplate({
            tag: "form",
            attributes: { class: i, tabindex: "-1" },
            children: this.children,
          });
          y_(this);
        }
        getDecoratorSwitchesState() {
          return Array.from(this._manualDecoratorSwitches).reduce((t, e) => {
            t[e.name] = e.isOn;
            return t;
          }, {});
        }
        render() {
          super.render();
          x_({ view: this });
          const t = [
            this.urlInputView,
            ...this._manualDecoratorSwitches,
            this.saveButtonView,
            this.cancelButtonView,
          ];
          t.forEach((t) => {
            this._focusables.add(t);
            this.focusTracker.add(t.element);
          });
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createUrlInput() {
          const t = this.locale.t;
          const e = new My(this.locale, By);
          e.label = t("Link URL");
          return e;
        }
        _createButton(t, e, n, i) {
          const o = new R_(this.locale);
          o.set({ label: t, icon: e, tooltip: true });
          o.extendTemplate({ attributes: { class: n } });
          if (i) {
            o.delegate("execute").to(this, i);
          }
          return o;
        }
        _createManualDecoratorSwitches(t) {
          const e = this.createCollection();
          for (const n of t.manualDecorators) {
            const i = new H_(this.locale);
            i.set({ name: n.id, label: n.label, withText: true });
            i.bind("isOn").toMany([n, t], "value", (t, e) =>
              e === undefined && t === undefined ? n.defaultValue : t
            );
            i.on("execute", () => {
              n.set("value", !i.isOn);
            });
            e.add(i);
          }
          return e;
        }
        _createFormChildren(t) {
          const e = this.createCollection();
          e.add(this.urlInputView);
          if (t.length) {
            const t = new pC();
            t.setTemplate({
              tag: "ul",
              children: this._manualDecoratorSwitches.map((t) => ({
                tag: "li",
                children: [t],
                attributes: { class: ["ck", "ck-list__item"] },
              })),
              attributes: { class: ["ck", "ck-reset", "ck-list"] },
            });
            e.add(t);
          }
          e.add(this.saveButtonView);
          e.add(this.cancelButtonView);
          return e;
        }
      }
      var OO = n(9465);
      var jO = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      jO.insert = "head";
      jO.singleton = true;
      var FO = Il()(OO.Z, jO);
      const VO = OO.Z.locals || {};
      const HO =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';
      class UO extends pC {
        constructor(t) {
          super(t);
          const e = t.t;
          this.focusTracker = new al();
          this.keystrokes = new cl();
          this.previewButtonView = this._createPreviewButton();
          this.unlinkButtonView = this._createButton(e("Unlink"), HO, "unlink");
          this.editButtonView = this._createButton(
            e("Edit link"),
            __.pencil,
            "edit"
          );
          this.set("href");
          this._focusables = new PA();
          this._focusCycler = new hv({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          });
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck", "ck-link-actions", "ck-responsive-form"],
              tabindex: "-1",
            },
            children: [
              this.previewButtonView,
              this.editButtonView,
              this.unlinkButtonView,
            ],
          });
        }
        render() {
          super.render();
          const t = [
            this.previewButtonView,
            this.editButtonView,
            this.unlinkButtonView,
          ];
          t.forEach((t) => {
            this._focusables.add(t);
            this.focusTracker.add(t.element);
          });
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createButton(t, e, n) {
          const i = new R_(this.locale);
          i.set({ label: t, icon: e, tooltip: true });
          i.delegate("execute").to(this, n);
          return i;
        }
        _createPreviewButton() {
          const t = new R_(this.locale);
          const e = this.bindTemplate;
          const n = this.t;
          t.set({ withText: true, tooltip: n("Open link in new tab") });
          t.extendTemplate({
            attributes: {
              class: ["ck", "ck-link-actions__preview"],
              href: e.to("href", (t) => t && YT(t)),
              target: "_blank",
              rel: "noopener noreferrer",
            },
          });
          t.bind("label").to(
            this,
            "href",
            (t) => t || n("This link has no URL")
          );
          t.bind("isEnabled").to(this, "href", (t) => !!t);
          t.template.tag = "a";
          t.template.eventListeners = {};
          return t;
        }
      }
      const qO =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>';
      const WO = "link-ui";
      class GO extends Cl {
        static get requires() {
          return [Ky];
        }
        static get pluginName() {
          return "LinkUI";
        }
        init() {
          const t = this.editor;
          t.editing.view.addObserver(Ow);
          this.actionsView = this._createActionsView();
          this.formView = this._createFormView();
          this._balloon = t.plugins.get(Ky);
          this._createToolbarLinkButton();
          this._enableUserBalloonInteractions();
          t.conversion.for("editingDowncast").markerToHighlight({
            model: WO,
            view: { classes: ["ck-fake-link-selection"] },
          });
          t.conversion.for("editingDowncast").markerToElement({
            model: WO,
            view: {
              name: "span",
              classes: [
                "ck-fake-link-selection",
                "ck-fake-link-selection_collapsed",
              ],
            },
          });
        }
        destroy() {
          super.destroy();
          this.formView.destroy();
        }
        _createActionsView() {
          const t = this.editor;
          const e = new UO(t.locale);
          const n = t.commands.get("link");
          const i = t.commands.get("unlink");
          e.bind("href").to(n, "value");
          e.editButtonView.bind("isEnabled").to(n);
          e.unlinkButtonView.bind("isEnabled").to(i);
          this.listenTo(e, "edit", () => {
            this._addFormView();
          });
          this.listenTo(e, "unlink", () => {
            t.execute("unlink");
            this._hideUI();
          });
          e.keystrokes.set("Esc", (t, e) => {
            this._hideUI();
            e();
          });
          e.keystrokes.set(GT, (t, e) => {
            this._addFormView();
            e();
          });
          return e;
        }
        _createFormView() {
          const t = this.editor;
          const e = t.commands.get("link");
          const n = t.config.get("link.defaultProtocol");
          const i = new RO(t.locale, e);
          i.urlInputView.fieldView.bind("value").to(e, "value");
          i.urlInputView.bind("isReadOnly").to(e, "isEnabled", (t) => !t);
          i.saveButtonView.bind("isEnabled").to(e);
          this.listenTo(i, "submit", () => {
            const { value: e } = i.urlInputView.fieldView.element;
            const o = eI(e, n);
            t.execute("link", o, i.getDecoratorSwitchesState());
            this._closeFormView();
          });
          this.listenTo(i, "cancel", () => {
            this._closeFormView();
          });
          i.keystrokes.set("Esc", (t, e) => {
            this._closeFormView();
            e();
          });
          return i;
        }
        _createToolbarLinkButton() {
          const t = this.editor;
          const e = t.commands.get("link");
          const n = t.t;
          t.keystrokes.set(GT, (t, n) => {
            n();
            if (e.isEnabled) {
              this._showUI(true);
            }
          });
          t.ui.componentFactory.add("link", (t) => {
            const i = new R_(t);
            i.isEnabled = true;
            i.label = n("Link");
            i.icon = qO;
            i.keystroke = GT;
            i.tooltip = true;
            i.isToggleable = true;
            i.bind("isEnabled").to(e, "isEnabled");
            i.bind("isOn").to(e, "value", (t) => !!t);
            this.listenTo(i, "execute", () => this._showUI(true));
            return i;
          });
        }
        _enableUserBalloonInteractions() {
          const t = this.editor.editing.view.document;
          this.listenTo(t, "click", () => {
            const t = this._getSelectedLinkElement();
            if (t) {
              this._showUI();
            }
          });
          this.editor.keystrokes.set(
            "Tab",
            (t, e) => {
              if (
                this._areActionsVisible &&
                !this.actionsView.focusTracker.isFocused
              ) {
                this.actionsView.focus();
                e();
              }
            },
            { priority: "high" }
          );
          this.editor.keystrokes.set("Esc", (t, e) => {
            if (this._isUIVisible) {
              this._hideUI();
              e();
            }
          });
          v_({
            emitter: this.formView,
            activator: () => this._isUIInPanel,
            contextElements: [this._balloon.view.element],
            callback: () => this._hideUI(),
          });
        }
        _addActionsView() {
          if (this._areActionsInPanel) {
            return;
          }
          this._balloon.add({
            view: this.actionsView,
            position: this._getBalloonPositionData(),
          });
        }
        _addFormView() {
          if (this._isFormInPanel) {
            return;
          }
          const t = this.editor;
          const e = t.commands.get("link");
          this.formView.disableCssTransitions();
          this._balloon.add({
            view: this.formView,
            position: this._getBalloonPositionData(),
          });
          if (this._balloon.visibleView === this.formView) {
            this.formView.urlInputView.fieldView.select();
          }
          this.formView.enableCssTransitions();
          this.formView.urlInputView.fieldView.element.value = e.value || "";
        }
        _closeFormView() {
          const t = this.editor.commands.get("link");
          t.restoreManualDecoratorStates();
          if (t.value !== undefined) {
            this._removeFormView();
          } else {
            this._hideUI();
          }
        }
        _removeFormView() {
          if (this._isFormInPanel) {
            this.formView.saveButtonView.focus();
            this._balloon.remove(this.formView);
            this.editor.editing.view.focus();
            this._hideFakeVisualSelection();
          }
        }
        _showUI(t = false) {
          if (!this._getSelectedLinkElement()) {
            this._showFakeVisualSelection();
            this._addActionsView();
            if (t) {
              this._balloon.showStack("main");
            }
            this._addFormView();
          } else {
            if (this._areActionsVisible) {
              this._addFormView();
            } else {
              this._addActionsView();
            }
            if (t) {
              this._balloon.showStack("main");
            }
          }
          this._startUpdatingUI();
        }
        _hideUI() {
          if (!this._isUIInPanel) {
            return;
          }
          const t = this.editor;
          this.stopListening(t.ui, "update");
          this.stopListening(this._balloon, "change:visibleView");
          t.editing.view.focus();
          this._removeFormView();
          this._balloon.remove(this.actionsView);
          this._hideFakeVisualSelection();
        }
        _startUpdatingUI() {
          const t = this.editor;
          const e = t.editing.view.document;
          let n = this._getSelectedLinkElement();
          let i = r();
          const o = () => {
            const t = this._getSelectedLinkElement();
            const e = r();
            if ((n && !t) || (!n && e !== i)) {
              this._hideUI();
            } else if (this._isUIVisible) {
              this._balloon.updatePosition(this._getBalloonPositionData());
            }
            n = t;
            i = e;
          };
          function r() {
            return e.selection.focus
              .getAncestors()
              .reverse()
              .find((t) => t.is("element"));
          }
          this.listenTo(t.ui, "update", o);
          this.listenTo(this._balloon, "change:visibleView", o);
        }
        get _isFormInPanel() {
          return this._balloon.hasView(this.formView);
        }
        get _areActionsInPanel() {
          return this._balloon.hasView(this.actionsView);
        }
        get _areActionsVisible() {
          return this._balloon.visibleView === this.actionsView;
        }
        get _isUIInPanel() {
          return this._isFormInPanel || this._areActionsInPanel;
        }
        get _isUIVisible() {
          const t = this._balloon.visibleView;
          return t == this.formView || this._areActionsVisible;
        }
        _getBalloonPositionData() {
          const t = this.editor.editing.view;
          const e = this.editor.model;
          const n = t.document;
          let i = null;
          if (e.markers.has(WO)) {
            const e = Array.from(
              this.editor.editing.mapper.markerNameToElements(WO)
            );
            const n = t.createRange(
              t.createPositionBefore(e[0]),
              t.createPositionAfter(e[e.length - 1])
            );
            i = t.domConverter.viewRangeToDom(n);
          } else {
            i = () => {
              const e = this._getSelectedLinkElement();
              return e
                ? t.domConverter.mapViewToDom(e)
                : t.domConverter.viewRangeToDom(n.selection.getFirstRange());
            };
          }
          return { target: i };
        }
        _getSelectedLinkElement() {
          const t = this.editor.editing.view;
          const e = t.document.selection;
          const n = e.getSelectedElement();
          if (e.isCollapsed || (n && iD(n))) {
            return $O(e.getFirstPosition());
          } else {
            const n = e.getFirstRange().getTrimmed();
            const i = $O(n.start);
            const o = $O(n.end);
            if (!i || i != o) {
              return null;
            }
            if (t.createRangeIn(i).getTrimmed().isEqual(n)) {
              return i;
            } else {
              return null;
            }
          }
        }
        _showFakeVisualSelection() {
          const t = this.editor.model;
          t.change((e) => {
            const n = t.document.selection.getFirstRange();
            if (t.markers.has(WO)) {
              e.updateMarker(WO, { range: n });
            } else {
              if (n.start.isAtEnd) {
                const i = n.start.getLastMatchingPosition(
                  ({ item: e }) => !t.schema.isContent(e),
                  { boundaries: n }
                );
                e.addMarker(WO, {
                  usingOperation: false,
                  affectsData: false,
                  range: e.createRange(i, n.end),
                });
              } else {
                e.addMarker(WO, {
                  usingOperation: false,
                  affectsData: false,
                  range: n,
                });
              }
            }
          });
        }
        _hideFakeVisualSelection() {
          const t = this.editor.model;
          if (t.markers.has(WO)) {
            t.change((t) => {
              t.removeMarker(WO);
            });
          }
        }
      }
      function $O(t) {
        return t.getAncestors().find((t) => $T(t));
      }
      class KO extends Cl {
        static get requires() {
          return [SO, GO, aI];
        }
        static get pluginName() {
          return "Link";
        }
      }
      class YO extends Cl {
        static get requires() {
          return ["ImageEditing", "ImageUtils", SO];
        }
        static get pluginName() {
          return "LinkImageEditing";
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          if (t.plugins.has("ImageBlockEditing")) {
            e.extend("imageBlock", { allowAttributes: ["linkHref"] });
          }
          t.conversion.for("upcast").add(ZO(t));
          t.conversion.for("downcast").add(QO(t));
          this._enableAutomaticDecorators();
          this._enableManualDecorators();
        }
        _enableAutomaticDecorators() {
          const t = this.editor;
          const e = t.commands.get("link");
          const n = e.automaticDecorators;
          if (n.length) {
            t.conversion.for("downcast").add(n.getDispatcherForLinkedImage());
          }
        }
        _enableManualDecorators() {
          const t = this.editor;
          const e = t.commands.get("link");
          for (const n of e.manualDecorators) {
            if (t.plugins.has("ImageBlockEditing")) {
              t.model.schema.extend("imageBlock", { allowAttributes: n.id });
            }
            if (t.plugins.has("ImageInlineEditing")) {
              t.model.schema.extend("imageInline", { allowAttributes: n.id });
            }
            t.conversion.for("downcast").add(JO(n));
            t.conversion.for("upcast").add(XO(t, n));
          }
        }
      }
      function ZO(t) {
        const e = t.plugins.has("ImageInlineEditing");
        const n = t.plugins.get("ImageUtils");
        return (t) => {
          t.on(
            "element:a",
            (t, i, o) => {
              const r = i.viewItem;
              const s = n.findViewImgElement(r);
              if (!s) {
                return;
              }
              const a = s.findAncestor((t) => n.isBlockImageView(t));
              if (e && !a) {
                return;
              }
              const c = { attributes: ["href"] };
              if (!o.consumable.consume(r, c)) {
                return;
              }
              const l = r.getAttribute("href");
              if (!l) {
                return;
              }
              let d = i.modelCursor.parent;
              if (!d.is("element", "imageBlock")) {
                const t = o.convertItem(s, i.modelCursor);
                i.modelRange = t.modelRange;
                i.modelCursor = t.modelCursor;
                d = i.modelCursor.nodeBefore;
              }
              if (d && d.is("element", "imageBlock")) {
                o.writer.setAttribute("linkHref", l, d);
              }
            },
            { priority: "high" }
          );
        };
      }
      function QO(t) {
        const e = t.plugins.get("ImageUtils");
        return (t) => {
          t.on(
            "attribute:linkHref:imageBlock",
            (t, n, i) => {
              if (!i.consumable.consume(n.item, t.name)) {
                return;
              }
              const o = i.mapper.toViewElement(n.item);
              const r = i.writer;
              const s = Array.from(o.getChildren()).find((t) => t.name === "a");
              const a = e.findViewImgElement(o);
              const c = a.parent.is("element", "picture") ? a.parent : a;
              if (s) {
                if (n.attributeNewValue) {
                  r.setAttribute("href", n.attributeNewValue, s);
                } else {
                  r.move(r.createRangeOn(c), r.createPositionAt(o, 0));
                  r.remove(s);
                }
              } else {
                const t = r.createContainerElement("a", {
                  href: n.attributeNewValue,
                });
                r.insert(r.createPositionAt(o, 0), t);
                r.move(r.createRangeOn(c), r.createPositionAt(t, 0));
              }
            },
            { priority: "high" }
          );
        };
      }
      function JO(t) {
        return (e) => {
          e.on(\`attribute:\${t.id}:imageBlock\`, (e, n, i) => {
            const o = i.mapper.toViewElement(n.item);
            const r = Array.from(o.getChildren()).find((t) => t.name === "a");
            if (!r) {
              return;
            }
            for (const [e, n] of dl(t.attributes)) {
              i.writer.setAttribute(e, n, r);
            }
            if (t.classes) {
              i.writer.addClass(t.classes, r);
            }
            for (const e in t.styles) {
              i.writer.setStyle(e, t.styles[e], r);
            }
          });
        };
      }
      function XO(t, e) {
        const n = t.plugins.has("ImageInlineEditing");
        const i = t.plugins.get("ImageUtils");
        return (t) => {
          t.on(
            "element:a",
            (t, o, r) => {
              const s = o.viewItem;
              const a = i.findViewImgElement(s);
              if (!a) {
                return;
              }
              const c = a.findAncestor((t) => i.isBlockImageView(t));
              if (n && !c) {
                return;
              }
              const l = new Ql(e._createPattern());
              const d = l.match(s);
              if (!d) {
                return;
              }
              if (!r.consumable.consume(s, d.match)) {
                return;
              }
              const u = o.modelCursor.nodeBefore || o.modelCursor.parent;
              r.writer.setAttribute(e.id, true, u);
            },
            { priority: "high" }
          );
        };
      }
      class tj extends Cl {
        static get requires() {
          return [SO, GO, "ImageBlockEditing"];
        }
        static get pluginName() {
          return "LinkImageUI";
        }
        init() {
          const t = this.editor;
          const e = t.editing.view.document;
          this.listenTo(
            e,
            "click",
            (e, n) => {
              if (this._isSelectedLinkedImage(t.model.document.selection)) {
                n.preventDefault();
                e.stop();
              }
            },
            { priority: "high" }
          );
          this._createToolbarLinkImageButton();
        }
        _createToolbarLinkImageButton() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add("linkImage", (n) => {
            const i = new R_(n);
            const o = t.plugins.get("LinkUI");
            const r = t.commands.get("link");
            i.set({
              isEnabled: true,
              label: e("Link image"),
              icon: qO,
              keystroke: GT,
              tooltip: true,
              isToggleable: true,
            });
            i.bind("isEnabled").to(r, "isEnabled");
            i.bind("isOn").to(r, "value", (t) => !!t);
            this.listenTo(i, "execute", () => {
              if (this._isSelectedLinkedImage(t.model.document.selection)) {
                o._addActionsView();
              } else {
                o._showUI(true);
              }
            });
            return i;
          });
        }
        _isSelectedLinkedImage(t) {
          const e = t.getSelectedElement();
          const n = this.editor.plugins.get("ImageUtils");
          return n.isImage(e) && e.hasAttribute("linkHref");
        }
      }
      var ej = n(3858);
      var nj = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      nj.insert = "head";
      nj.singleton = true;
      var ij = Il()(ej.Z, nj);
      const oj = ej.Z.locals || {};
      class rj extends Cl {
        static get requires() {
          return [YO, tj];
        }
        static get pluginName() {
          return "LinkImage";
        }
      }
      class sj extends vl {
        constructor(t, e) {
          super(t);
          this.type = e;
        }
        refresh() {
          this.value = this._getValue();
          this.isEnabled = this._checkEnabled();
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const i = Array.from(n.selection.getSelectedBlocks()).filter((t) =>
            cj(t, e.schema)
          );
          const o = t.forceValue !== undefined ? !t.forceValue : this.value;
          e.change((t) => {
            if (o) {
              let e = i[i.length - 1].nextSibling;
              let n = Number.POSITIVE_INFINITY;
              let o = [];
              while (
                e &&
                e.name == "listItem" &&
                e.getAttribute("listIndent") !== 0
              ) {
                const t = e.getAttribute("listIndent");
                if (t < n) {
                  n = t;
                }
                const i = t - n;
                o.push({ element: e, listIndent: i });
                e = e.nextSibling;
              }
              o = o.reverse();
              for (const e of o) {
                t.setAttribute("listIndent", e.listIndent, e.element);
              }
            }
            if (!o) {
              let t = Number.POSITIVE_INFINITY;
              for (const e of i) {
                if (
                  e.is("element", "listItem") &&
                  e.getAttribute("listIndent") < t
                ) {
                  t = e.getAttribute("listIndent");
                }
              }
              t = t === 0 ? 1 : t;
              aj(i, true, t);
              aj(i, false, t);
            }
            for (const e of i.reverse()) {
              if (o && e.name == "listItem") {
                t.rename(e, "paragraph");
              } else if (!o && e.name != "listItem") {
                t.setAttributes({ listType: this.type, listIndent: 0 }, e);
                t.rename(e, "listItem");
              } else if (
                !o &&
                e.name == "listItem" &&
                e.getAttribute("listType") != this.type
              ) {
                t.setAttribute("listType", this.type, e);
              }
            }
            this.fire("_executeCleanup", i);
          });
        }
        _getValue() {
          const t = sl(
            this.editor.model.document.selection.getSelectedBlocks()
          );
          return (
            !!t &&
            t.is("element", "listItem") &&
            t.getAttribute("listType") == this.type
          );
        }
        _checkEnabled() {
          if (this.value) {
            return true;
          }
          const t = this.editor.model.document.selection;
          const e = this.editor.model.schema;
          const n = sl(t.getSelectedBlocks());
          if (!n) {
            return false;
          }
          return cj(n, e);
        }
      }
      function aj(t, e, n) {
        const i = e ? t[0] : t[t.length - 1];
        if (i.is("element", "listItem")) {
          let o = i[e ? "previousSibling" : "nextSibling"];
          let r = i.getAttribute("listIndent");
          while (
            o &&
            o.is("element", "listItem") &&
            o.getAttribute("listIndent") >= n
          ) {
            if (r > o.getAttribute("listIndent")) {
              r = o.getAttribute("listIndent");
            }
            if (o.getAttribute("listIndent") == r) {
              t[e ? "unshift" : "push"](o);
            }
            o = o[e ? "previousSibling" : "nextSibling"];
          }
        }
      }
      function cj(t, e) {
        return e.checkChild(t.parent, "listItem") && !e.isObject(t);
      }
      class lj extends vl {
        constructor(t, e) {
          super(t);
          this._indentBy = e == "forward" ? 1 : -1;
        }
        refresh() {
          this.isEnabled = this._checkEnabled();
        }
        execute() {
          const t = this.editor.model;
          const e = t.document;
          let n = Array.from(e.selection.getSelectedBlocks());
          t.change((t) => {
            const e = n[n.length - 1];
            let i = e.nextSibling;
            while (
              i &&
              i.name == "listItem" &&
              i.getAttribute("listIndent") > e.getAttribute("listIndent")
            ) {
              n.push(i);
              i = i.nextSibling;
            }
            if (this._indentBy < 0) {
              n = n.reverse();
            }
            for (const e of n) {
              const n = e.getAttribute("listIndent") + this._indentBy;
              if (n < 0) {
                t.rename(e, "paragraph");
              } else {
                t.setAttribute("listIndent", n, e);
              }
            }
            this.fire("_executeCleanup", n);
          });
        }
        _checkEnabled() {
          const t = sl(
            this.editor.model.document.selection.getSelectedBlocks()
          );
          if (!t || !t.is("element", "listItem")) {
            return false;
          }
          if (this._indentBy > 0) {
            const e = t.getAttribute("listIndent");
            const n = t.getAttribute("listType");
            let i = t.previousSibling;
            while (
              i &&
              i.is("element", "listItem") &&
              i.getAttribute("listIndent") >= e
            ) {
              if (i.getAttribute("listIndent") == e) {
                return i.getAttribute("listType") == n;
              }
              i = i.previousSibling;
            }
            return false;
          }
          return true;
        }
      }
      function dj(t) {
        const e = t.createContainerElement("li");
        e.getFillerOffset = vj;
        return e;
      }
      function uj(t, e) {
        const n = e.mapper;
        const i = e.writer;
        const o = t.getAttribute("listType") == "numbered" ? "ol" : "ul";
        const r = dj(i);
        const s = i.createContainerElement(o, null);
        i.insert(i.createPositionAt(s, 0), r);
        n.bindElements(t, r);
        return r;
      }
      function hj(t, e, n, i) {
        const o = e.parent;
        const r = n.mapper;
        const s = n.writer;
        let a = r.toViewPosition(i.createPositionBefore(t));
        const c = fj(t.previousSibling, {
          sameIndent: true,
          smallerIndent: true,
          listIndent: t.getAttribute("listIndent"),
        });
        const l = t.previousSibling;
        if (c && c.getAttribute("listIndent") == t.getAttribute("listIndent")) {
          const t = r.toViewElement(c);
          a = s.breakContainer(s.createPositionAfter(t));
        } else {
          if (l && l.name == "listItem") {
            a = r.toViewPosition(i.createPositionAt(l, "end"));
            const t = r.findMappedViewAncestor(a);
            const e = bj(t);
            if (e) {
              a = s.createPositionBefore(e);
            } else {
              a = s.createPositionAt(t, "end");
            }
          } else {
            a = r.toViewPosition(i.createPositionBefore(t));
          }
        }
        a = gj(a);
        s.insert(a, o);
        if (l && l.name == "listItem") {
          const t = r.toViewElement(l);
          const n = s.createRange(s.createPositionAt(t, 0), a);
          const i = n.getWalker({ ignoreElementEnd: true });
          for (const t of i) {
            if (t.item.is("element", "li")) {
              const n = s.breakContainer(s.createPositionBefore(t.item));
              const o = t.item.parent;
              const r = s.createPositionAt(e, "end");
              mj(s, r.nodeBefore, r.nodeAfter);
              s.move(s.createRangeOn(o), r);
              i.position = n;
            }
          }
        } else {
          const n = o.nextSibling;
          if (n && (n.is("element", "ul") || n.is("element", "ol"))) {
            let i = null;
            for (const e of n.getChildren()) {
              const n = r.toModelElement(e);
              if (
                n &&
                n.getAttribute("listIndent") > t.getAttribute("listIndent")
              ) {
                i = e;
              } else {
                break;
              }
            }
            if (i) {
              s.breakContainer(s.createPositionAfter(i));
              s.move(s.createRangeOn(i.parent), s.createPositionAt(e, "end"));
            }
          }
        }
        mj(s, o, o.nextSibling);
        mj(s, o.previousSibling, o);
      }
      function mj(t, e, n) {
        if (!e || !n || (e.name != "ul" && e.name != "ol")) {
          return null;
        }
        if (
          e.name != n.name ||
          e.getAttribute("class") !== n.getAttribute("class")
        ) {
          return null;
        }
        return t.mergeContainers(t.createPositionAfter(e));
      }
      function gj(t) {
        return t.getLastMatchingPosition((t) => t.item.is("uiElement"));
      }
      function fj(t, e) {
        const n = !!e.sameIndent;
        const i = !!e.smallerIndent;
        const o = e.listIndent;
        let r = t;
        while (r && r.name == "listItem") {
          const t = r.getAttribute("listIndent");
          if ((n && o == t) || (i && o > t)) {
            return r;
          }
          if (e.direction === "forward") {
            r = r.nextSibling;
          } else {
            r = r.previousSibling;
          }
        }
        return null;
      }
      function pj(t, e, n, i) {
        t.ui.componentFactory.add(e, (o) => {
          const r = t.commands.get(e);
          const s = new R_(o);
          s.set({ label: n, icon: i, tooltip: true, isToggleable: true });
          s.bind("isOn", "isEnabled").to(r, "value", "isEnabled");
          s.on("execute", () => {
            t.execute(e);
            t.editing.view.focus();
          });
          return s;
        });
      }
      function bj(t) {
        for (const e of t.getChildren()) {
          if (e.name == "ul" || e.name == "ol") {
            return e;
          }
        }
        return null;
      }
      function kj(t, e) {
        const n = [];
        const i = t.parent;
        const o = {
          ignoreElementEnd: false,
          startPosition: t,
          shallow: true,
          direction: e,
        };
        const r = i.getAttribute("listIndent");
        const s = [...new bf(o)]
          .filter((t) => t.item.is("element"))
          .map((t) => t.item);
        for (const t of s) {
          if (!t.is("element", "listItem")) {
            break;
          }
          if (t.getAttribute("listIndent") < r) {
            break;
          }
          if (t.getAttribute("listIndent") > r) {
            continue;
          }
          if (t.getAttribute("listType") !== i.getAttribute("listType")) {
            break;
          }
          if (t.getAttribute("listStyle") !== i.getAttribute("listStyle")) {
            break;
          }
          if (
            t.getAttribute("listReversed") !== i.getAttribute("listReversed")
          ) {
            break;
          }
          if (t.getAttribute("listStart") !== i.getAttribute("listStart")) {
            break;
          }
          if (e === "backward") {
            n.unshift(t);
          } else {
            n.push(t);
          }
        }
        return n;
      }
      function wj(t) {
        const e = t.document;
        let n = [...e.selection.getSelectedBlocks()]
          .filter((t) => t.is("element", "listItem"))
          .map((e) => {
            const n = t.change((t) => t.createPositionAt(e, 0));
            return [...kj(n, "backward"), ...kj(n, "forward")];
          })
          .flat();
        n = [...new Set(n)];
        return n;
      }
      const Aj = ["disc", "circle", "square"];
      const Cj = [
        "decimal",
        "decimal-leading-zero",
        "lower-roman",
        "upper-roman",
        "lower-latin",
        "upper-latin",
      ];
      function _j(t) {
        if (Aj.includes(t)) {
          return "bulleted";
        }
        if (Cj.includes(t)) {
          return "numbered";
        }
        return null;
      }
      function vj() {
        const t =
          !this.isEmpty &&
          (this.getChild(0).name == "ul" || this.getChild(0).name == "ol");
        if (this.isEmpty || t) {
          return 0;
        }
        return th.call(this);
      }
      class yj extends Cl {
        static get pluginName() {
          return "ListUtils";
        }
        getListTypeFromListStyleType(t) {
          return _j(t);
        }
        getSelectedListItems(t) {
          return wj(t);
        }
        getSiblingNodes(t, e) {
          return kj(t, e);
        }
      }
      function xj(t) {
        return (e, n, i) => {
          const o = i.consumable;
          if (
            !o.test(n.item, "insert") ||
            !o.test(n.item, "attribute:listType") ||
            !o.test(n.item, "attribute:listIndent")
          ) {
            return;
          }
          o.consume(n.item, "insert");
          o.consume(n.item, "attribute:listType");
          o.consume(n.item, "attribute:listIndent");
          const r = n.item;
          const s = uj(r, i);
          hj(r, s, i, t);
        };
      }
      function Ej(t) {
        return (e, n, i) => {
          const o = i.mapper.toViewPosition(n.position);
          const r = o.getLastMatchingPosition(
            (t) => !t.item.is("element", "li")
          );
          const s = r.nodeAfter;
          const a = i.writer;
          a.breakContainer(a.createPositionBefore(s));
          a.breakContainer(a.createPositionAfter(s));
          const c = s.parent;
          const l = c.previousSibling;
          const d = a.createRangeOn(c);
          const u = a.remove(d);
          if (l && l.nextSibling) {
            mj(a, l, l.nextSibling);
          }
          const h = i.mapper.toModelElement(s);
          Vj(h.getAttribute("listIndent") + 1, n.position, d.start, s, i, t);
          for (const t of a.createRangeIn(u).getItems()) {
            i.mapper.unbindViewElement(t);
          }
          e.stop();
        };
      }
      function Dj(t, e, n) {
        if (!n.consumable.test(e.item, t.name)) {
          return;
        }
        const i = n.mapper.toViewElement(e.item);
        const o = n.writer;
        o.breakContainer(o.createPositionBefore(i));
        o.breakContainer(o.createPositionAfter(i));
        const r = i.parent;
        const s = e.attributeNewValue == "numbered" ? "ol" : "ul";
        o.rename(s, r);
      }
      function Sj(t, e, n) {
        n.consumable.consume(e.item, t.name);
        const i = n.mapper.toViewElement(e.item);
        const o = i.parent;
        const r = n.writer;
        mj(r, o, o.nextSibling);
        mj(r, o.previousSibling, o);
      }
      function Tj(t) {
        return (e, n, i) => {
          if (!i.consumable.consume(n.item, "attribute:listIndent")) {
            return;
          }
          const o = i.mapper.toViewElement(n.item);
          const r = i.writer;
          r.breakContainer(r.createPositionBefore(o));
          r.breakContainer(r.createPositionAfter(o));
          const s = o.parent;
          const a = s.previousSibling;
          const c = r.createRangeOn(s);
          r.remove(c);
          if (a && a.nextSibling) {
            mj(r, a, a.nextSibling);
          }
          Vj(n.attributeOldValue + 1, n.range.start, c.start, o, i, t);
          hj(n.item, o, i, t);
          for (const t of n.item.getChildren()) {
            i.consumable.consume(t, "insert");
          }
        };
      }
      function Ij(t, e, n) {
        if (!n.consumable.test(e.item, t.name)) {
          return;
        }
        if (e.item.name != "listItem") {
          let t = n.mapper.toViewPosition(e.range.start);
          const i = n.writer;
          const o = [];
          while (t.parent.name == "ul" || t.parent.name == "ol") {
            t = i.breakContainer(t);
            if (t.parent.name != "li") {
              break;
            }
            const e = t;
            const n = i.createPositionAt(t.parent, "end");
            if (!e.isEqual(n)) {
              const t = i.remove(i.createRange(e, n));
              o.push(t);
            }
            t = i.createPositionAfter(t.parent);
          }
          if (o.length > 0) {
            for (let e = 0; e < o.length; e++) {
              const n = t.nodeBefore;
              const r = i.insert(t, o[e]);
              t = r.end;
              if (e > 0) {
                const e = mj(i, n, n.nextSibling);
                if (e && e.parent == n) {
                  t.offset--;
                }
              }
            }
            mj(i, t.nodeBefore, t.nodeAfter);
          }
        }
      }
      function Mj(t, e, n) {
        const i = n.mapper.toViewPosition(e.position);
        const o = i.nodeBefore;
        const r = i.nodeAfter;
        mj(n.writer, o, r);
      }
      function Bj(t, e, n) {
        if (n.consumable.consume(e.viewItem, { name: true })) {
          const t = n.writer;
          const i = t.createElement("listItem");
          const o = Uj(e.viewItem);
          t.setAttribute("listIndent", o, i);
          const r =
            e.viewItem.parent && e.viewItem.parent.name == "ol"
              ? "numbered"
              : "bulleted";
          t.setAttribute("listType", r, i);
          if (!n.safeInsert(i, e.modelCursor)) {
            return;
          }
          const s = jj(i, e.viewItem.getChildren(), n);
          e.modelRange = t.createRange(e.modelCursor, s);
          n.updateConversionResult(i, e);
        }
      }
      function Lj(t, e, n) {
        if (n.consumable.test(e.viewItem, { name: true })) {
          const t = Array.from(e.viewItem.getChildren());
          for (const e of t) {
            const t = !(e.is("element", "li") || Hj(e));
            if (t) {
              e._remove();
            }
          }
        }
      }
      function Nj(t, e, n) {
        if (n.consumable.test(e.viewItem, { name: true })) {
          if (e.viewItem.childCount === 0) {
            return;
          }
          const t = [...e.viewItem.getChildren()];
          let n = false;
          for (const e of t) {
            if (n && !Hj(e)) {
              e._remove();
            }
            if (Hj(e)) {
              n = true;
            }
          }
        }
      }
      function zj(t) {
        return (e, n) => {
          if (n.isPhantom) {
            return;
          }
          const i = n.modelPosition.nodeBefore;
          if (i && i.is("element", "listItem")) {
            const e = n.mapper.toViewElement(i);
            const o = e.getAncestors().find(Hj);
            const r = t.createPositionAt(e, 0).getWalker();
            for (const t of r) {
              if (t.type == "elementStart" && t.item.is("element", "li")) {
                n.viewPosition = t.previousPosition;
                break;
              } else if (t.type == "elementEnd" && t.item == o) {
                n.viewPosition = t.nextPosition;
                break;
              }
            }
          }
        };
      }
      function Pj(t) {
        return (e, n) => {
          const i = n.viewPosition;
          const o = i.parent;
          const r = n.mapper;
          if (o.name == "ul" || o.name == "ol") {
            if (!i.isAtEnd) {
              const e = r.toModelElement(i.nodeAfter);
              n.modelPosition = t.createPositionBefore(e);
            } else {
              const e = r.toModelElement(i.nodeBefore);
              const o = r.getModelLength(i.nodeBefore);
              n.modelPosition = t.createPositionBefore(e).getShiftedBy(o);
            }
            e.stop();
          } else if (
            o.name == "li" &&
            i.nodeBefore &&
            (i.nodeBefore.name == "ul" || i.nodeBefore.name == "ol")
          ) {
            const s = r.toModelElement(o);
            let a = 1;
            let c = i.nodeBefore;
            while (c && Hj(c)) {
              a += r.getModelLength(c);
              c = c.previousSibling;
            }
            n.modelPosition = t.createPositionBefore(s).getShiftedBy(a);
            e.stop();
          }
        };
      }
      function Rj(t, e) {
        const n = t.document.differ.getChanges();
        const i = new Map();
        let o = false;
        for (const i of n) {
          if (i.type == "insert" && i.name == "listItem") {
            r(i.position);
          } else if (i.type == "insert" && i.name != "listItem") {
            if (i.name != "$text") {
              const n = i.position.nodeAfter;
              if (n.hasAttribute("listIndent")) {
                e.removeAttribute("listIndent", n);
                o = true;
              }
              if (n.hasAttribute("listType")) {
                e.removeAttribute("listType", n);
                o = true;
              }
              if (n.hasAttribute("listStyle")) {
                e.removeAttribute("listStyle", n);
                o = true;
              }
              if (n.hasAttribute("listReversed")) {
                e.removeAttribute("listReversed", n);
                o = true;
              }
              if (n.hasAttribute("listStart")) {
                e.removeAttribute("listStart", n);
                o = true;
              }
              for (const e of Array.from(t.createRangeIn(n)).filter((t) =>
                t.item.is("element", "listItem")
              )) {
                r(e.previousPosition);
              }
            }
            const n = i.position.getShiftedBy(i.length);
            r(n);
          } else if (i.type == "remove" && i.name == "listItem") {
            r(i.position);
          } else if (i.type == "attribute" && i.attributeKey == "listIndent") {
            r(i.range.start);
          } else if (i.type == "attribute" && i.attributeKey == "listType") {
            r(i.range.start);
          }
        }
        for (const t of i.values()) {
          s(t);
          a(t);
        }
        return o;
        function r(t) {
          const e = t.nodeBefore;
          if (!e || !e.is("element", "listItem")) {
            const e = t.nodeAfter;
            if (e && e.is("element", "listItem")) {
              i.set(e, e);
            }
          } else {
            let t = e;
            if (i.has(t)) {
              return;
            }
            for (
              let e = t.previousSibling;
              e && e.is("element", "listItem");
              e = t.previousSibling
            ) {
              t = e;
              if (i.has(t)) {
                return;
              }
            }
            i.set(e, t);
          }
        }
        function s(t) {
          let n = 0;
          let i = null;
          while (t && t.is("element", "listItem")) {
            const r = t.getAttribute("listIndent");
            if (r > n) {
              let s;
              if (i === null) {
                i = r - n;
                s = n;
              } else {
                if (i > r) {
                  i = r;
                }
                s = r - i;
              }
              e.setAttribute("listIndent", s, t);
              o = true;
            } else {
              i = null;
              n = t.getAttribute("listIndent") + 1;
            }
            t = t.nextSibling;
          }
        }
        function a(t) {
          let n = [];
          let i = null;
          while (t && t.is("element", "listItem")) {
            const r = t.getAttribute("listIndent");
            if (i && i.getAttribute("listIndent") > r) {
              n = n.slice(0, r + 1);
            }
            if (r != 0) {
              if (n[r]) {
                const i = n[r];
                if (t.getAttribute("listType") != i) {
                  e.setAttribute("listType", i, t);
                  o = true;
                }
              } else {
                n[r] = t.getAttribute("listType");
              }
            }
            i = t;
            t = t.nextSibling;
          }
        }
      }
      function Oj(t, [e, n, i]) {
        let o = e.is("documentFragment") ? e.getChild(0) : e;
        let r;
        if (!n) {
          r = this.document.selection;
        } else {
          r = this.createSelection(n, i);
        }
        if (o && o.is("element", "listItem")) {
          const t = r.getFirstPosition();
          let e = null;
          if (t.parent.is("element", "listItem")) {
            e = t.parent;
          } else if (t.nodeBefore && t.nodeBefore.is("element", "listItem")) {
            e = t.nodeBefore;
          }
          if (e) {
            const t = e.getAttribute("listIndent");
            if (t > 0) {
              while (o && o.is("element", "listItem")) {
                o._setAttribute("listIndent", o.getAttribute("listIndent") + t);
                o = o.nextSibling;
              }
            }
          }
        }
      }
      function jj(t, e, n) {
        const { writer: i, schema: o } = n;
        let r = i.createPositionAfter(t);
        for (const s of e) {
          if (s.name == "ul" || s.name == "ol") {
            r = n.convertItem(s, r).modelCursor;
          } else {
            const e = n.convertItem(s, i.createPositionAt(t, "end"));
            const a = e.modelRange.start.nodeAfter;
            const c = a && a.is("element") && !o.checkChild(t, a.name);
            if (c) {
              if (e.modelCursor.parent.is("element", "listItem")) {
                t = e.modelCursor.parent;
              } else {
                t = Fj(e.modelCursor);
              }
              r = i.createPositionAfter(t);
            }
          }
        }
        return r;
      }
      function Fj(t) {
        const e = new bf({ startPosition: t });
        let n;
        do {
          n = e.next();
        } while (!n.value.item.is("element", "listItem"));
        return n.value.item;
      }
      function Vj(t, e, n, i, o, r) {
        const s = fj(e.nodeBefore, {
          sameIndent: true,
          smallerIndent: true,
          listIndent: t,
          foo: "b",
        });
        const a = o.mapper;
        const c = o.writer;
        const l = s ? s.getAttribute("listIndent") : null;
        let d;
        if (!s) {
          d = n;
        } else if (l == t) {
          const t = a.toViewElement(s).parent;
          d = c.createPositionAfter(t);
        } else {
          const t = r.createPositionAt(s, "end");
          d = a.toViewPosition(t);
        }
        d = gj(d);
        for (const t of [...i.getChildren()]) {
          if (Hj(t)) {
            d = c.move(c.createRangeOn(t), d).end;
            mj(c, t, t.nextSibling);
            mj(c, t.previousSibling, t);
          }
        }
      }
      function Hj(t) {
        return t.is("element", "ol") || t.is("element", "ul");
      }
      function Uj(t) {
        let e = 0;
        let n = t.parent;
        while (n) {
          if (n.is("element", "li")) {
            e++;
          } else {
            const t = n.previousSibling;
            if (t && t.is("element", "li")) {
              e++;
            }
          }
          n = n.parent;
        }
        return e;
      }
      class qj extends Cl {
        static get pluginName() {
          return "ListEditing";
        }
        static get requires() {
          return [UE, Jx, yj];
        }
        init() {
          const t = this.editor;
          t.model.schema.register("listItem", {
            inheritAllFrom: "$block",
            allowAttributes: ["listType", "listIndent"],
          });
          const e = t.data;
          const n = t.editing;
          t.model.document.registerPostFixer((e) => Rj(t.model, e));
          n.mapper.registerViewToModelLength("li", Wj);
          e.mapper.registerViewToModelLength("li", Wj);
          n.mapper.on("modelToViewPosition", zj(n.view));
          n.mapper.on("viewToModelPosition", Pj(t.model));
          e.mapper.on("modelToViewPosition", zj(n.view));
          t.conversion.for("editingDowncast").add((e) => {
            e.on("insert", Ij, { priority: "high" });
            e.on("insert:listItem", xj(t.model));
            e.on("attribute:listType:listItem", Dj, { priority: "high" });
            e.on("attribute:listType:listItem", Sj, { priority: "low" });
            e.on("attribute:listIndent:listItem", Tj(t.model));
            e.on("remove:listItem", Ej(t.model));
            e.on("remove", Mj, { priority: "low" });
          });
          t.conversion.for("dataDowncast").add((e) => {
            e.on("insert", Ij, { priority: "high" });
            e.on("insert:listItem", xj(t.model));
          });
          t.conversion.for("upcast").add((t) => {
            t.on("element:ul", Lj, { priority: "high" });
            t.on("element:ol", Lj, { priority: "high" });
            t.on("element:li", Nj, { priority: "high" });
            t.on("element:li", Bj);
          });
          t.model.on("insertContent", Oj, { priority: "high" });
          t.commands.add("numberedList", new sj(t, "numbered"));
          t.commands.add("bulletedList", new sj(t, "bulleted"));
          t.commands.add("indentList", new lj(t, "forward"));
          t.commands.add("outdentList", new lj(t, "backward"));
          const i = n.view.document;
          this.listenTo(
            i,
            "enter",
            (t, e) => {
              const n = this.editor.model.document;
              const i = n.selection.getLastPosition().parent;
              if (
                n.selection.isCollapsed &&
                i.name == "listItem" &&
                i.isEmpty
              ) {
                this.editor.execute("outdentList");
                e.preventDefault();
                t.stop();
              }
            },
            { context: "li" }
          );
          this.listenTo(
            i,
            "delete",
            (t, e) => {
              if (e.direction !== "backward") {
                return;
              }
              const n = this.editor.model.document.selection;
              if (!n.isCollapsed) {
                return;
              }
              const i = n.getFirstPosition();
              if (!i.isAtStart) {
                return;
              }
              const o = i.parent;
              if (o.name !== "listItem") {
                return;
              }
              const r =
                o.previousSibling && o.previousSibling.name === "listItem";
              if (r) {
                return;
              }
              this.editor.execute("outdentList");
              e.preventDefault();
              t.stop();
            },
            { context: "li" }
          );
          this.listenTo(
            t.editing.view.document,
            "tab",
            (e, n) => {
              const i = n.shiftKey ? "outdentList" : "indentList";
              const o = this.editor.commands.get(i);
              if (o.isEnabled) {
                t.execute(i);
                n.stopPropagation();
                n.preventDefault();
                e.stop();
              }
            },
            { context: "li" }
          );
        }
        afterInit() {
          const t = this.editor.commands;
          const e = t.get("indent");
          const n = t.get("outdent");
          if (e) {
            e.registerChildCommand(t.get("indentList"));
          }
          if (n) {
            n.registerChildCommand(t.get("outdentList"));
          }
        }
      }
      function Wj(t) {
        let e = 1;
        for (const n of t.getChildren()) {
          if (n.name == "ul" || n.name == "ol") {
            for (const t of n.getChildren()) {
              e += Wj(t);
            }
          }
        }
        return e;
      }
      const Gj =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>';
      const $j =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>';
      class Kj extends Cl {
        static get pluginName() {
          return "ListUI";
        }
        init() {
          const t = this.editor.t;
          pj(this.editor, "numberedList", t("Numbered List"), Gj);
          pj(this.editor, "bulletedList", t("Bulleted List"), $j);
        }
      }
      class Yj extends Cl {
        static get requires() {
          return [qj, Kj];
        }
        static get pluginName() {
          return "List";
        }
      }
      function Zj(t, e) {
        return (t) => {
          t.on("attribute:url:media", n);
        };
        function n(n, i, o) {
          if (!o.consumable.consume(i.item, n.name)) {
            return;
          }
          const r = i.attributeNewValue;
          const s = o.writer;
          const a = o.mapper.toViewElement(i.item);
          const c = [...a.getChildren()].find((t) =>
            t.getCustomProperty("media-content")
          );
          s.remove(c);
          const l = t.getMediaViewElement(s, r, e);
          s.insert(s.createPositionAt(a, 0), l);
        }
      }
      function Qj(t, e, n) {
        e.setCustomProperty("media", true, t);
        return oD(t, e, { label: n });
      }
      function Jj(t) {
        const e = t.getSelectedElement();
        if (e && Xj(e)) {
          return e;
        }
        return null;
      }
      function Xj(t) {
        return !!t.getCustomProperty("media") && iD(t);
      }
      function tF(t, e, n, i) {
        return t.createContainerElement("figure", { class: "media" }, [
          e.getMediaViewElement(t, n, i),
          t.createSlot(),
        ]);
      }
      function eF(t) {
        const e = t.getSelectedElement();
        if (e && e.is("element", "media")) {
          return e;
        }
        return null;
      }
      function nF(t, e, n, i) {
        t.change((o) => {
          const r = o.createElement("media", { url: e });
          t.insertObject(r, n, null, {
            setSelection: "on",
            findOptimalPosition: i,
          });
        });
      }
      class iF extends vl {
        refresh() {
          const t = this.editor.model;
          const e = t.document.selection;
          const n = eF(e);
          this.value = n ? n.getAttribute("url") : null;
          this.isEnabled = rF(e) || oF(e, t);
        }
        execute(t) {
          const e = this.editor.model;
          const n = e.document.selection;
          const i = eF(n);
          if (i) {
            e.change((e) => {
              e.setAttribute("url", t, i);
            });
          } else {
            nF(e, t, n, true);
          }
        }
      }
      function oF(t, e) {
        const n = uD(t, e);
        let i = n.start.parent;
        if (i.isEmpty && !e.schema.isLimit(i)) {
          i = i.parent;
        }
        return e.schema.checkChild(i, "media");
      }
      function rF(t) {
        const e = t.getSelectedElement();
        return !!e && e.name === "media";
      }
      const sF =
        '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>';
      const aF = "0 0 64 42";
      class cF {
        constructor(t, e) {
          const n = e.providers;
          const i = e.extraProviders || [];
          const o = new Set(e.removeProviders);
          const r = n.concat(i).filter((t) => {
            const e = t.name;
            if (!e) {
              B("media-embed-no-provider-name", { provider: t });
              return false;
            }
            return !o.has(e);
          });
          this.locale = t;
          this.providerDefinitions = r;
        }
        hasMedia(t) {
          return !!this._getMedia(t);
        }
        getMediaViewElement(t, e, n) {
          return this._getMedia(e).getViewElement(t, n);
        }
        _getMedia(t) {
          if (!t) {
            return new lF(this.locale);
          }
          t = t.trim();
          for (const e of this.providerDefinitions) {
            const n = e.html;
            const i = Yc(e.url);
            for (const e of i) {
              const i = this._getUrlMatches(t, e);
              if (i) {
                return new lF(this.locale, t, i, n);
              }
            }
          }
          return null;
        }
        _getUrlMatches(t, e) {
          let n = t.match(e);
          if (n) {
            return n;
          }
          let i = t.replace(/^https?:\\/\\//, "");
          n = i.match(e);
          if (n) {
            return n;
          }
          i = i.replace(/^www\\./, "");
          n = i.match(e);
          if (n) {
            return n;
          }
          return null;
        }
      }
      class lF {
        constructor(t, e, n, i) {
          this.url = this._getValidUrl(e);
          this._locale = t;
          this._match = n;
          this._previewRenderer = i;
        }
        getViewElement(t, e) {
          const n = {};
          let i;
          if (
            e.renderForEditingView ||
            (e.renderMediaPreview && this.url && this._previewRenderer)
          ) {
            if (this.url) {
              n["data-oembed-url"] = this.url;
            }
            if (e.renderForEditingView) {
              n.class = "ck-media__wrapper";
            }
            const o = this._getPreviewHtml(e);
            i = t.createRawElement("div", n, (t, e) => {
              e.setContentOf(t, o);
            });
          } else {
            if (this.url) {
              n.url = this.url;
            }
            i = t.createEmptyElement(e.elementName, n);
          }
          t.setCustomProperty("media-content", true, i);
          return i;
        }
        _getPreviewHtml(t) {
          if (this._previewRenderer) {
            return this._previewRenderer(this._match);
          } else {
            if (this.url && t.renderForEditingView) {
              return this._getPlaceholderHtml();
            }
            return "";
          }
        }
        _getPlaceholderHtml() {
          const t = new B_();
          const e = this._locale.t;
          t.content = sF;
          t.viewBox = aF;
          const n = new jA({
            tag: "div",
            attributes: { class: "ck ck-reset_all ck-media__placeholder" },
            children: [
              {
                tag: "div",
                attributes: { class: "ck-media__placeholder__icon" },
                children: [t],
              },
              {
                tag: "a",
                attributes: {
                  class: "ck-media__placeholder__url",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  href: this.url,
                  "data-cke-tooltip-text": e("Open media in new tab"),
                },
                children: [
                  {
                    tag: "span",
                    attributes: { class: "ck-media__placeholder__url__text" },
                    children: [this.url],
                  },
                ],
              },
            ],
          }).render();
          return n.outerHTML;
        }
        _getValidUrl(t) {
          if (!t) {
            return null;
          }
          if (t.match(/^https?/)) {
            return t;
          }
          return "https://" + t;
        }
      }
      var dF = n(952);
      var uF = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      uF.insert = "head";
      uF.singleton = true;
      var hF = Il()(dF.Z, uF);
      const mF = dF.Z.locals || {};
      class gF extends Cl {
        static get pluginName() {
          return "MediaEmbedEditing";
        }
        constructor(t) {
          super(t);
          t.config.define("mediaEmbed", {
            elementName: "oembed",
            providers: [
              {
                name: "dailymotion",
                url: /^dailymotion\\.com\\/video\\/(\\w+)/,
                html: (t) => {
                  const e = t[1];
                  return (
                    '<div style="position: relative; padding-bottom: 100%; height: 0; ">' +
                    \`<iframe src="https://www.dailymotion.com/embed/video/\${e}" \` +
                    'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' +
                    'frameborder="0" width="480" height="270" allowfullscreen allow="autoplay">' +
                    "</iframe>" +
                    "</div>"
                  );
                },
              },
              {
                name: "spotify",
                url: [
                  /^open\\.spotify\\.com\\/(artist\\/\\w+)/,
                  /^open\\.spotify\\.com\\/(album\\/\\w+)/,
                  /^open\\.spotify\\.com\\/(track\\/\\w+)/,
                ],
                html: (t) => {
                  const e = t[1];
                  return (
                    '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;">' +
                    \`<iframe src="https://open.spotify.com/embed/\${e}" \` +
                    'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' +
                    'frameborder="0" allowtransparency="true" allow="encrypted-media">' +
                    "</iframe>" +
                    "</div>"
                  );
                },
              },
              {
                name: "youtube",
                url: [
                  /^(?:m\\.)?youtube\\.com\\/watch\\?v=([\\w-]+)(?:&t=(\\d+))?/,
                  /^(?:m\\.)?youtube\\.com\\/v\\/([\\w-]+)(?:\\?t=(\\d+))?/,
                  /^youtube\\.com\\/embed\\/([\\w-]+)(?:\\?start=(\\d+))?/,
                  /^youtu\\.be\\/([\\w-]+)(?:\\?t=(\\d+))?/,
                ],
                html: (t) => {
                  const e = t[1];
                  const n = t[2];
                  return (
                    '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;">' +
                    \`<iframe src="https://www.youtube.com/embed/\${e}\${
                      n ? \`?start=\${n}\` : ""
                    }" \` +
                    'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' +
                    'frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>' +
                    "</iframe>" +
                    "</div>"
                  );
                },
              },
              {
                name: "vimeo",
                url: [
                  /^vimeo\\.com\\/(\\d+)/,
                  /^vimeo\\.com\\/[^/]+\\/[^/]+\\/video\\/(\\d+)/,
                  /^vimeo\\.com\\/album\\/[^/]+\\/video\\/(\\d+)/,
                  /^vimeo\\.com\\/channels\\/[^/]+\\/(\\d+)/,
                  /^vimeo\\.com\\/groups\\/[^/]+\\/videos\\/(\\d+)/,
                  /^vimeo\\.com\\/ondemand\\/[^/]+\\/(\\d+)/,
                  /^player\\.vimeo\\.com\\/video\\/(\\d+)/,
                ],
                html: (t) => {
                  const e = t[1];
                  return (
                    '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;">' +
                    \`<iframe src="https://player.vimeo.com/video/\${e}" \` +
                    'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' +
                    'frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen>' +
                    "</iframe>" +
                    "</div>"
                  );
                },
              },
              { name: "instagram", url: /^instagram\\.com\\/p\\/(\\w+)/ },
              { name: "twitter", url: /^twitter\\.com/ },
              {
                name: "googleMaps",
                url: [
                  /^google\\.com\\/maps/,
                  /^goo\\.gl\\/maps/,
                  /^maps\\.google\\.com/,
                  /^maps\\.app\\.goo\\.gl/,
                ],
              },
              { name: "flickr", url: /^flickr\\.com/ },
              { name: "facebook", url: /^facebook\\.com/ },
            ],
          });
          this.registry = new cF(t.locale, t.config.get("mediaEmbed"));
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.t;
          const i = t.conversion;
          const o = t.config.get("mediaEmbed.previewsInData");
          const r = t.config.get("mediaEmbed.elementName");
          const s = this.registry;
          t.commands.add("mediaEmbed", new iF(t));
          e.register("media", {
            inheritAllFrom: "$blockObject",
            allowAttributes: ["url"],
          });
          i.for("dataDowncast").elementToStructure({
            model: "media",
            view: (t, { writer: e }) => {
              const n = t.getAttribute("url");
              return tF(e, s, n, {
                elementName: r,
                renderMediaPreview: n && o,
              });
            },
          });
          i.for("dataDowncast").add(
            Zj(s, { elementName: r, renderMediaPreview: o })
          );
          i.for("editingDowncast").elementToStructure({
            model: "media",
            view: (t, { writer: e }) => {
              const i = t.getAttribute("url");
              const o = tF(e, s, i, {
                elementName: r,
                renderForEditingView: true,
              });
              return Qj(o, e, n("media widget"));
            },
          });
          i.for("editingDowncast").add(
            Zj(s, { elementName: r, renderForEditingView: true })
          );
          i.for("upcast")
            .elementToElement({
              view: (t) =>
                ["oembed", r].includes(t.name) && t.getAttribute("url")
                  ? { name: true }
                  : null,
              model: (t, { writer: e }) => {
                const n = t.getAttribute("url");
                if (s.hasMedia(n)) {
                  return e.createElement("media", { url: n });
                }
              },
            })
            .elementToElement({
              view: { name: "div", attributes: { "data-oembed-url": true } },
              model: (t, { writer: e }) => {
                const n = t.getAttribute("data-oembed-url");
                if (s.hasMedia(n)) {
                  return e.createElement("media", { url: n });
                }
              },
            })
            .add((t) => {
              t.on("element:figure", e);
              function e(t, e, n) {
                if (
                  !n.consumable.consume(e.viewItem, {
                    name: true,
                    classes: "media",
                  })
                ) {
                  return;
                }
                const { modelRange: i, modelCursor: o } = n.convertChildren(
                  e.viewItem,
                  e.modelCursor
                );
                e.modelRange = i;
                e.modelCursor = o;
                const r = sl(i.getItems());
                if (!r) {
                  n.consumable.revert(e.viewItem, {
                    name: true,
                    classes: "media",
                  });
                }
              }
            });
        }
      }
      const fF = /^(?:http(s)?:\\/\\/)?[\\w-]+\\.[\\w-.~:/?#[\\]@!$&'()*+,;=%]+$/;
      class pF extends Cl {
        static get requires() {
          return [BS, Jx, HS];
        }
        static get pluginName() {
          return "AutoMediaEmbed";
        }
        constructor(t) {
          super(t);
          this._timeoutId = null;
          this._positionToInsert = null;
        }
        init() {
          const t = this.editor;
          const e = t.model.document;
          this.listenTo(
            t.plugins.get("ClipboardPipeline"),
            "inputTransformation",
            () => {
              const t = e.selection.getFirstRange();
              const n = Sk.fromPosition(t.start);
              n.stickiness = "toPrevious";
              const i = Sk.fromPosition(t.end);
              i.stickiness = "toNext";
              e.once(
                "change:data",
                () => {
                  this._embedMediaBetweenPositions(n, i);
                  n.detach();
                  i.detach();
                },
                { priority: "high" }
              );
            }
          );
          t.commands.get("undo").on(
            "execute",
            () => {
              if (this._timeoutId) {
                Xa.window.clearTimeout(this._timeoutId);
                this._positionToInsert.detach();
                this._timeoutId = null;
                this._positionToInsert = null;
              }
            },
            { priority: "high" }
          );
        }
        _embedMediaBetweenPositions(t, e) {
          const n = this.editor;
          const i = n.plugins.get(gF).registry;
          const o = new Ff(t, e);
          const r = o.getWalker({ ignoreElementEnd: true });
          let s = "";
          for (const t of r) {
            if (t.item.is("$textProxy")) {
              s += t.item.data;
            }
          }
          s = s.trim();
          if (!s.match(fF)) {
            o.detach();
            return;
          }
          if (!i.hasMedia(s)) {
            o.detach();
            return;
          }
          const a = n.commands.get("mediaEmbed");
          if (!a.isEnabled) {
            o.detach();
            return;
          }
          this._positionToInsert = Sk.fromPosition(t);
          this._timeoutId = Xa.window.setTimeout(() => {
            n.model.change((t) => {
              this._timeoutId = null;
              t.remove(o);
              o.detach();
              let e;
              if (this._positionToInsert.root.rootName !== "$graveyard") {
                e = this._positionToInsert;
              }
              nF(n.model, s, e, false);
              this._positionToInsert.detach();
              this._positionToInsert = null;
            });
            n.plugins.get("Delete").requestUndoOnBackspace();
          }, 100);
        }
      }
      var bF = n(3525);
      var kF = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      kF.insert = "head";
      kF.singleton = true;
      var wF = Il()(bF.Z, kF);
      const AF = bF.Z.locals || {};
      class CF extends pC {
        constructor(t, e) {
          super(e);
          const n = e.t;
          this.focusTracker = new al();
          this.keystrokes = new cl();
          this.set("mediaURLInputValue", "");
          this.urlInputView = this._createUrlInput();
          this.saveButtonView = this._createButton(
            n("Save"),
            __.check,
            "ck-button-save"
          );
          this.saveButtonView.type = "submit";
          this.saveButtonView
            .bind("isEnabled")
            .to(this, "mediaURLInputValue", (t) => !!t);
          this.cancelButtonView = this._createButton(
            n("Cancel"),
            __.cancel,
            "ck-button-cancel",
            "cancel"
          );
          this._focusables = new PA();
          this._focusCycler = new hv({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          });
          this._validators = t;
          this.setTemplate({
            tag: "form",
            attributes: {
              class: ["ck", "ck-media-form", "ck-responsive-form"],
              tabindex: "-1",
            },
            children: [
              this.urlInputView,
              this.saveButtonView,
              this.cancelButtonView,
            ],
          });
          y_(this);
        }
        render() {
          super.render();
          x_({ view: this });
          const t = [
            this.urlInputView,
            this.saveButtonView,
            this.cancelButtonView,
          ];
          t.forEach((t) => {
            this._focusables.add(t);
            this.focusTracker.add(t.element);
          });
          this.keystrokes.listenTo(this.element);
          const e = (t) => t.stopPropagation();
          this.keystrokes.set("arrowright", e);
          this.keystrokes.set("arrowleft", e);
          this.keystrokes.set("arrowup", e);
          this.keystrokes.set("arrowdown", e);
          this.listenTo(
            this.urlInputView.element,
            "selectstart",
            (t, e) => {
              e.stopPropagation();
            },
            { priority: "high" }
          );
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        get url() {
          return this.urlInputView.fieldView.element.value.trim();
        }
        set url(t) {
          this.urlInputView.fieldView.element.value = t.trim();
        }
        isValid() {
          this.resetFormStatus();
          for (const t of this._validators) {
            const e = t(this);
            if (e) {
              this.urlInputView.errorText = e;
              return false;
            }
          }
          return true;
        }
        resetFormStatus() {
          this.urlInputView.errorText = null;
          this.urlInputView.infoText = this._urlInputViewInfoDefault;
        }
        _createUrlInput() {
          const t = this.locale.t;
          const e = new My(this.locale, By);
          const n = e.fieldView;
          this._urlInputViewInfoDefault = t(
            "Paste the media URL in the input."
          );
          this._urlInputViewInfoTip = t(
            "Tip: Paste the URL into the content to embed faster."
          );
          e.label = t("Media URL");
          e.infoText = this._urlInputViewInfoDefault;
          n.on("input", () => {
            e.infoText = n.element.value
              ? this._urlInputViewInfoTip
              : this._urlInputViewInfoDefault;
            this.mediaURLInputValue = n.element.value.trim();
          });
          return e;
        }
        _createButton(t, e, n, i) {
          const o = new R_(this.locale);
          o.set({ label: t, icon: e, tooltip: true });
          o.extendTemplate({ attributes: { class: n } });
          if (i) {
            o.delegate("execute").to(this, i);
          }
          return o;
        }
      }
      const _F =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 0 1 .593-.351l5.133 2.824a.4.4 0 0 1 0 .7l-5.133 2.824a.4.4 0 0 1-.593-.35V7.176v.001z"/></svg>';
      class vF extends Cl {
        static get requires() {
          return [gF];
        }
        static get pluginName() {
          return "MediaEmbedUI";
        }
        init() {
          const t = this.editor;
          const e = t.commands.get("mediaEmbed");
          const n = t.plugins.get(gF).registry;
          t.ui.componentFactory.add("mediaEmbed", (i) => {
            const o = Uv(i);
            const r = new CF(yF(t.t, n), t.locale);
            this._setUpDropdown(o, r, e, t);
            this._setUpForm(o, r, e);
            return o;
          });
        }
        _setUpDropdown(t, e, n) {
          const i = this.editor;
          const o = i.t;
          const r = t.buttonView;
          t.bind("isEnabled").to(n);
          t.panelView.children.add(e);
          r.set({ label: o("Insert media"), icon: _F, tooltip: true });
          r.on(
            "open",
            () => {
              e.disableCssTransitions();
              e.url = n.value || "";
              e.urlInputView.fieldView.select();
              e.enableCssTransitions();
            },
            { priority: "low" }
          );
          t.on("submit", () => {
            if (e.isValid()) {
              i.execute("mediaEmbed", e.url);
              i.editing.view.focus();
            }
          });
          t.on("change:isOpen", () => e.resetFormStatus());
          t.on("cancel", () => {
            i.editing.view.focus();
          });
        }
        _setUpForm(t, e, n) {
          e.delegate("submit", "cancel").to(t);
          e.urlInputView.bind("value").to(n, "value");
          e.urlInputView.bind("isReadOnly").to(n, "isEnabled", (t) => !t);
        }
      }
      function yF(t, e) {
        return [
          (e) => {
            if (!e.url.length) {
              return t("The URL must not be empty.");
            }
          },
          (n) => {
            if (!e.hasMedia(n.url)) {
              return t("This media URL is not supported.");
            }
          },
        ];
      }
      var xF = n(5777);
      var EF = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      EF.insert = "head";
      EF.singleton = true;
      var DF = Il()(xF.Z, EF);
      const SF = xF.Z.locals || {};
      class TF extends Cl {
        static get requires() {
          return [gF, vF, pF, qD];
        }
        static get pluginName() {
          return "MediaEmbed";
        }
      }
      class IF extends Cl {
        static get requires() {
          return [$D];
        }
        static get pluginName() {
          return "MediaEmbedToolbar";
        }
        afterInit() {
          const t = this.editor;
          const e = t.t;
          const n = t.plugins.get($D);
          n.register("mediaEmbed", {
            ariaLabel: e("Media toolbar"),
            items: t.config.get("mediaEmbed.toolbar") || [],
            getRelatedElement: Jj,
          });
        }
      }
      class MF extends vl {
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.isEnabled = t.schema.checkAttributeInSelection(
            e.selection,
            "mention"
          );
        }
        execute(t) {
          const e = this.editor.model;
          const n = e.document;
          const i = n.selection;
          const o =
            typeof t.mention == "string" ? { id: t.mention } : t.mention;
          const r = o.id;
          const s = t.range || i.getFirstRange();
          const a = t.text || r;
          const c = LF({ _text: a, id: r }, o);
          if (t.marker.length != 1) {
            throw new M("mentioncommand-incorrect-marker", this);
          }
          if (r.charAt(0) != t.marker) {
            throw new M("mentioncommand-incorrect-id", this);
          }
          e.change((t) => {
            const n = dl(i.getAttributes());
            const o = new Map(n.entries());
            o.set("mention", c);
            e.insertContent(t.createText(a, o), s);
            e.insertContent(
              t.createText(" ", n),
              s.start.getShiftedBy(a.length)
            );
          });
        }
      }
      class BF extends Cl {
        static get pluginName() {
          return "MentionEditing";
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = e.document;
          e.schema.extend("$text", { allowAttributes: "mention" });
          t.conversion.for("upcast").elementToAttribute({
            view: { name: "span", key: "data-mention", classes: "mention" },
            model: { key: "mention", value: (t) => NF(t) },
          });
          t.conversion
            .for("downcast")
            .attributeToElement({ model: "mention", view: PF });
          t.conversion.for("downcast").add(zF);
          n.registerPostFixer((t) => jF(t, n, e.schema));
          n.registerPostFixer((t) => FF(t, n));
          n.registerPostFixer((t) => RF(t, n));
          t.commands.add("mention", new MF(t));
        }
      }
      function LF(t, e) {
        return Object.assign({ uid: E() }, t, e || {});
      }
      function NF(t, e) {
        const n = t.getAttribute("data-mention");
        const i = t.getChild(0);
        if (!i) {
          return;
        }
        const o = { id: n, _text: i.data };
        return LF(o, e);
      }
      function zF(t) {
        t.on(
          "attribute:mention",
          (t, e, n) => {
            const i = e.attributeNewValue;
            if (!e.item.is("$textProxy") || !i) {
              return;
            }
            const o = e.range.start;
            const r = o.textNode || o.nodeAfter;
            if (r.data != i._text) {
              n.consumable.consume(e.item, t.name);
            }
          },
          { priority: "highest" }
        );
      }
      function PF(t, { writer: e }) {
        if (!t) {
          return;
        }
        const n = { class: "mention", "data-mention": t.id };
        const i = { id: t.uid, priority: 20 };
        return e.createAttributeElement("span", n, i);
      }
      function RF(t, e) {
        const n = e.selection;
        const i = n.focus;
        if (n.isCollapsed && n.hasAttribute("mention") && OF(i)) {
          t.removeSelectionAttribute("mention");
          return true;
        }
      }
      function OF(t) {
        const e = t.isAtStart;
        const n = t.nodeBefore && t.nodeBefore.is("$text");
        return n || e;
      }
      function jF(t, e, n) {
        const i = e.differ.getChanges();
        let o = false;
        for (const e of i) {
          const i = e.position;
          if (e.name == "$text") {
            const e = i.textNode && i.textNode.nextSibling;
            o = HF(i.textNode, t) || o;
            o = HF(e, t) || o;
            o = HF(i.nodeBefore, t) || o;
            o = HF(i.nodeAfter, t) || o;
          }
          if (e.name != "$text" && e.type == "insert") {
            const e = i.nodeAfter;
            for (const n of t.createRangeIn(e).getItems()) {
              o = HF(n, t) || o;
            }
          }
          if (e.type == "insert" && n.isInline(e.name)) {
            const e = i.nodeAfter && i.nodeAfter.nextSibling;
            o = HF(i.nodeBefore, t) || o;
            o = HF(e, t) || o;
          }
        }
        return o;
      }
      function FF(t, e) {
        const n = e.differ.getChanges();
        let i = false;
        for (const e of n) {
          if (e.type === "attribute" && e.attributeKey != "mention") {
            const n = e.range.start.nodeBefore;
            const o = e.range.end.nodeAfter;
            for (const r of [n, o]) {
              if (
                VF(r) &&
                r.getAttribute(e.attributeKey) != e.attributeNewValue
              ) {
                t.setAttribute(e.attributeKey, e.attributeNewValue, r);
                i = true;
              }
            }
          }
        }
        return i;
      }
      function VF(t) {
        if (
          !t ||
          !(t.is("$text") || t.is("$textProxy")) ||
          !t.hasAttribute("mention")
        ) {
          return false;
        }
        const e = t.data;
        const n = t.getAttribute("mention");
        const i = n._text;
        return e != i;
      }
      function HF(t, e) {
        if (VF(t)) {
          e.removeAttribute("mention", t);
          return true;
        }
        return false;
      }
      var UF = n(6391);
      var qF = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      qF.insert = "head";
      qF.singleton = true;
      var WF = Il()(UF.Z, qF);
      const GF = UF.Z.locals || {};
      class $F extends Bv {
        constructor(t) {
          super(t);
          this.extendTemplate({
            attributes: { class: ["ck-mentions"], tabindex: "-1" },
          });
        }
        selectFirst() {
          this.select(0);
        }
        selectNext() {
          const t = this.selected;
          const e = this.items.getIndex(t);
          this.select(e + 1);
        }
        selectPrevious() {
          const t = this.selected;
          const e = this.items.getIndex(t);
          this.select(e - 1);
        }
        select(t) {
          let e = 0;
          if (t > 0 && t < this.items.length) {
            e = t;
          } else if (t < 0) {
            e = this.items.length - 1;
          }
          const n = this.items.get(e);
          if (this.selected === n) {
            return;
          }
          if (this.selected) {
            this.selected.removeHighlight();
          }
          n.highlight();
          this.selected = n;
          if (!this._isItemVisibleInScrolledArea(n)) {
            this.element.scrollTop = n.element.offsetTop;
          }
        }
        executeSelected() {
          this.selected.fire("execute");
        }
        _isItemVisibleInScrolledArea(t) {
          return new sc(this.element).contains(new sc(t.element));
        }
      }
      class KF extends pC {
        constructor(t, e) {
          super(t);
          this.template = false;
          this.domElement = e;
          this.domElement.classList.add("ck-button");
          this.set("isOn", false);
          this.on("change:isOn", (t, e, n) => {
            if (n) {
              this.domElement.classList.add("ck-on");
              this.domElement.classList.remove("ck-off");
            } else {
              this.domElement.classList.add("ck-off");
              this.domElement.classList.remove("ck-on");
            }
          });
          this.listenTo(this.domElement, "click", () => {
            this.fire("execute");
          });
        }
        render() {
          super.render();
          this.element = this.domElement;
        }
      }
      class YF extends Lv {
        highlight() {
          const t = this.children.first;
          t.isOn = true;
        }
        removeHighlight() {
          const t = this.children.first;
          t.isOn = false;
        }
      }
      const ZF = 3;
      const QF = [Oc.arrowup, Oc.arrowdown, Oc.esc];
      const JF = [Oc.enter, Oc.tab];
      class XF extends Cl {
        static get pluginName() {
          return "MentionUI";
        }
        static get requires() {
          return [Ky];
        }
        constructor(t) {
          super(t);
          this._mentionsView = this._createMentionView();
          this._mentionsConfigurations = new Map();
          this._requestFeedDebounced = Qm(this._requestFeed, 100);
          t.config.define("mention", { feeds: [] });
        }
        init() {
          const t = this.editor;
          const e = t.config.get("mention.commitKeys") || JF;
          const n = QF.concat(e);
          this._balloon = t.plugins.get(Ky);
          t.editing.view.document.on(
            "keydown",
            (t, n) => {
              if (o(n.keyCode) && this._isUIVisible) {
                n.preventDefault();
                t.stop();
                if (n.keyCode == Oc.arrowdown) {
                  this._mentionsView.selectNext();
                }
                if (n.keyCode == Oc.arrowup) {
                  this._mentionsView.selectPrevious();
                }
                if (e.includes(n.keyCode)) {
                  this._mentionsView.executeSelected();
                }
                if (n.keyCode == Oc.esc) {
                  this._hideUIAndRemoveMarker();
                }
              }
            },
            { priority: "highest" }
          );
          v_({
            emitter: this._mentionsView,
            activator: () => this._isUIVisible,
            contextElements: [this._balloon.view.element],
            callback: () => this._hideUIAndRemoveMarker(),
          });
          const i = t.config.get("mention.feeds");
          for (const t of i) {
            const e = t.feed;
            const n = t.marker;
            if (!cV(n)) {
              throw new M("mentionconfig-incorrect-marker", null, {
                marker: n,
              });
            }
            const i = typeof e == "function" ? e.bind(this.editor) : rV(e);
            const o = t.itemRenderer;
            const r = { marker: n, feedCallback: i, itemRenderer: o };
            this._mentionsConfigurations.set(n, r);
          }
          this._setupTextWatcher(i);
          this.listenTo(t, "change:isReadOnly", () => {
            this._hideUIAndRemoveMarker();
          });
          this.on("requestFeed:response", (t, e) =>
            this._handleFeedResponse(e)
          );
          this.on("requestFeed:error", () => this._hideUIAndRemoveMarker());
          function o(t) {
            return n.includes(t);
          }
        }
        destroy() {
          super.destroy();
          this._mentionsView.destroy();
        }
        get _isUIVisible() {
          return this._balloon.visibleView === this._mentionsView;
        }
        _createMentionView() {
          const t = this.editor.locale;
          const e = new $F(t);
          this._items = new rl();
          e.items.bindTo(this._items).using((n) => {
            const { item: i, marker: o } = n;
            const r = this.editor.config.get("mention.dropdownLimit") || 10;
            if (e.items.length >= r) {
              return;
            }
            const s = new YF(t);
            const a = this._renderItem(i, o);
            a.delegate("execute").to(s);
            s.children.add(a);
            s.item = i;
            s.marker = o;
            s.on("execute", () => {
              e.fire("execute", { item: i, marker: o });
            });
            return s;
          });
          e.on("execute", (t, e) => {
            const n = this.editor;
            const i = n.model;
            const o = e.item;
            const r = e.marker;
            const s = n.model.markers.get("mention");
            const a = i.createPositionAt(i.document.selection.focus);
            const c = i.createPositionAt(s.getStart());
            const l = i.createRange(c, a);
            this._hideUIAndRemoveMarker();
            n.execute("mention", {
              mention: o,
              text: o.text,
              marker: r,
              range: l,
            });
            n.editing.view.focus();
          });
          return e;
        }
        _getItemRenderer(t) {
          const { itemRenderer: e } = this._mentionsConfigurations.get(t);
          return e;
        }
        _requestFeed(t, e) {
          this._lastRequested = e;
          const { feedCallback: n } = this._mentionsConfigurations.get(t);
          const i = n(e);
          const o = i instanceof Promise;
          if (!o) {
            this.fire("requestFeed:response", {
              feed: i,
              marker: t,
              feedText: e,
            });
            return;
          }
          i.then((n) => {
            if (this._lastRequested == e) {
              this.fire("requestFeed:response", {
                feed: n,
                marker: t,
                feedText: e,
              });
            } else {
              this.fire("requestFeed:discarded", {
                feed: n,
                marker: t,
                feedText: e,
              });
            }
          }).catch((e) => {
            this.fire("requestFeed:error", { error: e });
            B("mention-feed-callback-error", { marker: t });
          });
        }
        _setupTextWatcher(t) {
          const e = this.editor;
          const n = t.map((t) => ({
            ...t,
            pattern: nV(t.marker, t.minimumCharacters || 0),
          }));
          const i = new eE(e.model, iV(n));
          i.on("matched", (t, i) => {
            const o = eV(n, i.text);
            const r = e.model.document.selection;
            const s = r.focus;
            const a = e.model.createPositionAt(s.parent, o.position);
            if (sV(s) || aV(a)) {
              this._hideUIAndRemoveMarker();
              return;
            }
            const c = oV(o, i.text);
            const l = o.marker.length + c.length;
            const d = s.getShiftedBy(-l);
            const u = s.getShiftedBy(-c.length);
            const h = e.model.createRange(d, u);
            if (lV(e)) {
              const t = e.model.markers.get("mention");
              e.model.change((e) => {
                e.updateMarker(t, { range: h });
              });
            } else {
              e.model.change((t) => {
                t.addMarker("mention", {
                  range: h,
                  usingOperation: false,
                  affectsData: false,
                });
              });
            }
            this._requestFeedDebounced(o.marker, c);
          });
          i.on("unmatched", () => {
            this._hideUIAndRemoveMarker();
          });
          const o = e.commands.get("mention");
          i.bind("isEnabled").to(o);
          return i;
        }
        _handleFeedResponse(t) {
          const { feed: e, marker: n } = t;
          if (!lV(this.editor)) {
            return;
          }
          this._items.clear();
          for (const t of e) {
            const e = typeof t != "object" ? { id: t, text: t } : t;
            this._items.add({ item: e, marker: n });
          }
          const i = this.editor.model.markers.get("mention");
          if (this._items.length) {
            this._showOrUpdateUI(i);
          } else {
            this._hideUIAndRemoveMarker();
          }
        }
        _showOrUpdateUI(t) {
          if (this._isUIVisible) {
            this._balloon.updatePosition(
              this._getBalloonPanelPositionData(t, this._mentionsView.position)
            );
          } else {
            this._balloon.add({
              view: this._mentionsView,
              position: this._getBalloonPanelPositionData(
                t,
                this._mentionsView.position
              ),
              singleViewMode: true,
            });
          }
          this._mentionsView.position = this._balloon.view.position;
          this._mentionsView.selectFirst();
        }
        _hideUIAndRemoveMarker() {
          if (this._balloon.hasView(this._mentionsView)) {
            this._balloon.remove(this._mentionsView);
          }
          if (lV(this.editor)) {
            this.editor.model.change((t) => t.removeMarker("mention"));
          }
          this._mentionsView.position = undefined;
        }
        _renderItem(t, e) {
          const n = this.editor;
          let i;
          let o = t.id;
          const r = this._getItemRenderer(e);
          if (r) {
            const e = r(t);
            if (typeof e != "string") {
              i = new KF(n.locale, e);
            } else {
              o = e;
            }
          }
          if (!i) {
            const t = new R_(n.locale);
            t.label = o;
            t.withText = true;
            i = t;
          }
          return i;
        }
        _getBalloonPanelPositionData(t, e) {
          const n = this.editor;
          const i = n.editing;
          const o = i.view.domConverter;
          const r = i.mapper;
          return {
            target: () => {
              let e = t.getRange();
              if (e.start.root.rootName == "$graveyard") {
                e = n.model.document.selection.getFirstRange();
              }
              const i = r.toViewRange(e);
              const s = sc.getDomRangeRects(o.viewRangeToDom(i));
              return s.pop();
            },
            limiter: () => {
              const t = this.editor.editing.view;
              const e = t.document;
              const n = e.selection.editableElement;
              if (n) {
                return t.domConverter.mapViewToDom(n.root);
              }
              return null;
            },
            positions: tV(e),
          };
        }
      }
      function tV(t) {
        const e = {
          caret_se: (t) => ({
            top: t.bottom + ZF,
            left: t.right,
            name: "caret_se",
            config: { withArrow: false },
          }),
          caret_ne: (t, e) => ({
            top: t.top - e.height - ZF,
            left: t.right,
            name: "caret_ne",
            config: { withArrow: false },
          }),
          caret_sw: (t, e) => ({
            top: t.bottom + ZF,
            left: t.right - e.width,
            name: "caret_sw",
            config: { withArrow: false },
          }),
          caret_nw: (t, e) => ({
            top: t.top - e.height - ZF,
            left: t.right - e.width,
            name: "caret_nw",
            config: { withArrow: false },
          }),
        };
        if (Object.prototype.hasOwnProperty.call(e, t)) {
          return [e[t]];
        }
        return [e.caret_se, e.caret_sw, e.caret_ne, e.caret_nw];
      }
      function eV(t, e) {
        let n;
        for (const i of t) {
          const t = e.lastIndexOf(i.marker);
          if (t > 0 && !e.substring(t - 1).match(i.pattern)) {
            continue;
          }
          if (!n || t >= n.position) {
            n = {
              marker: i.marker,
              position: t,
              minimumCharacters: i.minimumCharacters,
              pattern: i.pattern,
            };
          }
        }
        return n;
      }
      function nV(t, e) {
        const n = e == 0 ? "*" : \`{\${e},}\`;
        const i = r.features.isRegExpUnicodePropertySupported
          ? "\\\\p{Ps}\\\\p{Pi}\\"'"
          : "\\\\(\\\\[{\\"'";
        const o = ".";
        const s = \`(?:^|[ \${i}])([\${t}])(\${o}\${n})$\`;
        return new RegExp(s, "u");
      }
      function iV(t) {
        const e = (e) => {
          const n = eV(t, e);
          if (!n) {
            return false;
          }
          let i = 0;
          if (n.position !== 0) {
            i = n.position - 1;
          }
          const o = e.substring(i);
          return n.pattern.test(o);
        };
        return e;
      }
      function oV(t, e) {
        let n = 0;
        if (t.position !== 0) {
          n = t.position - 1;
        }
        const i = nV(t.marker, 0);
        const o = e.substring(n);
        const r = o.match(i);
        return r[2];
      }
      function rV(t) {
        return (e) => {
          const n = t.filter((t) => {
            const n = typeof t == "string" ? t : String(t.id);
            return n.toLowerCase().includes(e.toLowerCase());
          });
          return n;
        };
      }
      function sV(t) {
        const e = t.textNode && t.textNode.hasAttribute("mention");
        const n = t.nodeBefore;
        return e || (n && n.is("$text") && n.hasAttribute("mention"));
      }
      function aV(t) {
        const e = t.nodeAfter;
        return e && e.is("$text") && e.hasAttribute("mention");
      }
      function cV(t) {
        return t && t.length == 1;
      }
      function lV(t) {
        return t.model.markers.has("mention");
      }
      var dV = n(7583);
      var uV = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      uV.insert = "head";
      uV.singleton = true;
      var hV = Il()(dV.Z, uV);
      const mV = dV.Z.locals || {};
      class gV extends Cl {
        toMentionAttribute(t, e) {
          return NF(t, e);
        }
        static get pluginName() {
          return "Mention";
        }
        static get requires() {
          return [BF, XF];
        }
      }
      function fV(t, e) {
        for (const n of t.getChildren()) {
          if (n.is("element", "b") && n.getStyle("font-weight") === "normal") {
            const i = t.getChildIndex(n);
            e.remove(n);
            e.insertChild(i, n.getChildren(), t);
          }
        }
      }
      function pV(t, e) {
        const n = new kh(e.document.stylesProcessor);
        const i = new Am(n, { renderingMode: "data" });
        const o = i.blockElements;
        const r = i.inlineObjectElements;
        const s = [];
        for (const n of e.createRangeIn(t)) {
          const t = n.item;
          if (t.is("element", "br")) {
            const n = bV(t, "forward", e, {
              blockElements: o,
              inlineObjectElements: r,
            });
            const i = bV(t, "backward", e, {
              blockElements: o,
              inlineObjectElements: r,
            });
            const a = kV(n, o);
            const c = kV(i, o);
            if (c || a) {
              s.push(t);
            }
          }
        }
        for (const t of s) {
          if (t.hasClass("Apple-interchange-newline")) {
            e.remove(t);
          } else {
            e.replace(t, e.createElement("p"));
          }
        }
      }
      function bV(t, e, n, { blockElements: i, inlineObjectElements: o }) {
        let r = n.createPositionAt(t, e == "forward" ? "after" : "before");
        r = r.getLastMatchingPosition(
          ({ item: t }) =>
            t.is("element") && !i.includes(t.name) && !o.includes(t.name),
          { direction: e }
        );
        return e == "forward" ? r.nodeAfter : r.nodeBefore;
      }
      function kV(t, e) {
        return !!t && t.is("element") && e.includes(t.name);
      }
      function wV(t, e) {
        if (!t.childCount) {
          return;
        }
        const n = new Fw(t.document);
        const i = CV(t, n);
        if (!i.length) {
          return;
        }
        let o = null;
        let r = 1;
        i.forEach((t, s) => {
          const a = IV(i[s - 1], t);
          const c = a ? null : i[s - 1];
          const l = BV(c, t);
          if (a) {
            o = null;
            r = 1;
          }
          if (!o || l !== 0) {
            const i = _V(t, e);
            if (!o) {
              o = EV(i, t.element, n);
            } else if (t.indent > r) {
              const t = o.getChild(o.childCount - 1);
              const e = t.getChild(t.childCount - 1);
              o = EV(i, e, n);
              r += 1;
            } else if (t.indent < r) {
              const e = r - t.indent;
              o = LV(o, e);
              r = parseInt(t.indent);
            }
            if (t.indent <= r) {
              if (!o.is("element", i.type)) {
                o = n.rename(i.type, o);
              }
            }
          }
          const d = DV(t.element, n);
          n.appendChild(d, o);
        });
      }
      function AV(t, e) {
        for (const n of e.createRangeIn(t)) {
          const t = n.item;
          if (t.is("element", "li")) {
            const n = t.getChild(0);
            if (n && n.is("element", "p")) {
              e.unwrapElement(n);
            }
          }
        }
      }
      function CV(t, e) {
        const n = e.createRangeIn(t);
        const i = new Ql({ name: /^p|h\\d+$/, styles: { "mso-list": /.*/ } });
        const o = [];
        for (const t of n) {
          if (t.type === "elementStart" && i.match(t.item)) {
            const e = SV(t.item);
            o.push({
              element: t.item,
              id: e.id,
              order: e.order,
              indent: e.indent,
            });
          }
        }
        return o;
      }
      function _V(t, e) {
        const n = new RegExp(
          \`@list l\${t.id}:level\${t.indent}\\\\s*({[^}]*)\`,
          "gi"
        );
        const i = /mso-level-number-format:([^;]{0,100});/gi;
        const o = /mso-level-start-at:\\s{0,100}([0-9]{0,10})\\s{0,100};/gi;
        const r = n.exec(e);
        let s = "decimal";
        let a = "ol";
        let c = null;
        if (r && r[1]) {
          const e = i.exec(r[1]);
          if (e && e[1]) {
            s = e[1].trim();
            a = s !== "bullet" && s !== "image" ? "ol" : "ul";
          }
          if (s === "bullet") {
            const e = vV(t.element);
            if (e) {
              s = e;
            }
          } else {
            const t = o.exec(r[1]);
            if (t && t[1]) {
              c = parseInt(t[1]);
            }
          }
        }
        return { type: a, startIndex: c, style: xV(s) };
      }
      function vV(t) {
        const e = yV(t);
        if (!e) {
          return null;
        }
        const n = e._data;
        if (n === "o") {
          return "circle";
        } else if (n === "") {
          return "disc";
        } else if (n === "") {
          return "square";
        }
        return null;
      }
      function yV(t) {
        if (t.getChild(0).is("$text")) {
          return null;
        }
        for (const e of t.getChildren()) {
          if (!e.is("element", "span")) {
            continue;
          }
          const t = e.getChild(0);
          if (t.is("$text")) {
            return t;
          }
          return t.getChild(0);
        }
      }
      function xV(t) {
        if (t.startsWith("arabic-leading-zero")) {
          return "decimal-leading-zero";
        }
        switch (t) {
          case "alpha-upper":
            return "upper-alpha";
          case "alpha-lower":
            return "lower-alpha";
          case "roman-upper":
            return "upper-roman";
          case "roman-lower":
            return "lower-roman";
          case "circle":
          case "disc":
          case "square":
            return t;
          default:
            return null;
        }
      }
      function EV(t, e, n) {
        const i = e.parent;
        const o = n.createElement(t.type);
        const r = i.getChildIndex(e) + 1;
        n.insertChild(r, o, i);
        if (t.style) {
          n.setStyle("list-style-type", t.style, o);
        }
        if (t.startIndex && t.startIndex > 1) {
          n.setAttribute("start", t.startIndex, o);
        }
        return o;
      }
      function DV(t, e) {
        TV(t, e);
        return e.rename("li", t);
      }
      function SV(t) {
        const e = {};
        const n = t.getStyle("mso-list");
        if (n) {
          const t = n.match(/(^|\\s{1,100})l(\\d+)/i);
          const i = n.match(/\\s{0,100}lfo(\\d+)/i);
          const o = n.match(/\\s{0,100}level(\\d+)/i);
          if (t && i && o) {
            e.id = t[2];
            e.order = i[1];
            e.indent = o[1];
          }
        }
        return e;
      }
      function TV(t, e) {
        const n = new Ql({ name: "span", styles: { "mso-list": "Ignore" } });
        const i = e.createRangeIn(t);
        for (const t of i) {
          if (t.type === "elementStart" && n.match(t.item)) {
            e.remove(t.item);
          }
        }
      }
      function IV(t, e) {
        if (!t) {
          return true;
        }
        if (t.id !== e.id) {
          if (e.indent - t.indent === 1) {
            return false;
          }
          return true;
        }
        const n = e.element.previousSibling;
        if (!n) {
          return true;
        }
        return !MV(n);
      }
      function MV(t) {
        return t.is("element", "ol") || t.is("element", "ul");
      }
      function BV(t, e) {
        return t ? e.indent - t.indent : e.indent - 1;
      }
      function LV(t, e) {
        const n = t.getAncestors({ parentFirst: true });
        let i = null;
        let o = 0;
        for (const t of n) {
          if (t.name === "ul" || t.name === "ol") {
            o++;
          }
          if (o === e) {
            i = t;
            break;
          }
        }
        return i;
      }
      const NV = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
      class zV {
        constructor(t) {
          this.document = t;
        }
        isActive(t) {
          return NV.test(t);
        }
        execute(t) {
          const e = new Fw(this.document);
          const { body: n } = t._parsedData;
          fV(n, e);
          AV(n, e);
          pV(n, e);
          t.content = n;
        }
      }
      function PV(t, e) {
        if (!t.childCount) {
          return;
        }
        const n = new Fw();
        const i = OV(t, n);
        jV(i, t, n);
        FV(t, n);
        const o = VV(t, n);
        if (o.length) {
          UV(o, HV(e), n);
        }
      }
      function RV(t) {
        return btoa(
          t
            .match(/\\w{2}/g)
            .map((t) => String.fromCharCode(parseInt(t, 16)))
            .join("")
        );
      }
      function OV(t, e) {
        const n = e.createRangeIn(t);
        const i = new Ql({ name: /v:(.+)/ });
        const o = [];
        for (const t of n) {
          if (t.type != "elementStart") {
            continue;
          }
          const e = t.item;
          const n = (e.previousSibling && e.previousSibling.name) || null;
          if (
            i.match(e) &&
            e.getAttribute("o:gfxdata") &&
            n !== "v:shapetype"
          ) {
            o.push(t.item.getAttribute("id"));
          }
        }
        return o;
      }
      function jV(t, e, n) {
        const i = n.createRangeIn(e);
        const o = new Ql({ name: "img" });
        const r = [];
        for (const e of i) {
          if (o.match(e.item)) {
            const n = e.item;
            const i = n.getAttribute("v:shapes")
              ? n.getAttribute("v:shapes").split(" ")
              : [];
            if (i.length && i.every((e) => t.indexOf(e) > -1)) {
              r.push(n);
            } else if (!n.getAttribute("src")) {
              r.push(n);
            }
          }
        }
        for (const t of r) {
          n.remove(t);
        }
      }
      function FV(t, e) {
        const n = e.createRangeIn(t);
        const i = new Ql({ name: /v:(.+)/ });
        const o = [];
        for (const t of n) {
          if (t.type == "elementStart" && i.match(t.item)) {
            o.push(t.item);
          }
        }
        for (const t of o) {
          e.remove(t);
        }
      }
      function VV(t, e) {
        const n = e.createRangeIn(t);
        const i = new Ql({ name: "img" });
        const o = [];
        for (const t of n) {
          if (i.match(t.item)) {
            if (t.item.getAttribute("src").startsWith("file://")) {
              o.push(t.item);
            }
          }
        }
        return o;
      }
      function HV(t) {
        if (!t) {
          return [];
        }
        const e =
          /{\\\\pict[\\s\\S]+?\\\\bliptag-?\\d+(\\\\blipupi-?\\d+)?({\\\\\\*\\\\blipuid\\s?[\\da-fA-F]+)?[\\s}]*?/;
        const n = new RegExp("(?:(" + e.source + "))([\\\\da-fA-F\\\\s]+)\\\\}", "g");
        const i = t.match(n);
        const o = [];
        if (i) {
          for (const t of i) {
            let n = false;
            if (t.includes("\\\\pngblip")) {
              n = "image/png";
            } else if (t.includes("\\\\jpegblip")) {
              n = "image/jpeg";
            }
            if (n) {
              o.push({
                hex: t.replace(e, "").replace(/[^\\da-fA-F]/g, ""),
                type: n,
              });
            }
          }
        }
        return o;
      }
      function UV(t, e, n) {
        if (t.length === e.length) {
          for (let i = 0; i < t.length; i++) {
            const o = \`data:\${e[i].type};base64,\${RV(e[i].hex)}\`;
            n.setAttribute("src", o, t[i]);
          }
        }
      }
      const qV =
        /<meta\\s*name="?generator"?\\s*content="?microsoft\\s*word\\s*\\d+"?\\/?>/i;
      const WV = /xmlns:o="urn:schemas-microsoft-com/i;
      class GV {
        constructor(t) {
          this.document = t;
        }
        isActive(t) {
          return qV.test(t) || WV.test(t);
        }
        execute(t) {
          const { body: e, stylesString: n } = t._parsedData;
          wV(e, n);
          PV(e, t.dataTransfer.getData("text/rtf"));
          t.content = e;
        }
      }
      function $V(t) {
        return YV(YV(t))
          .replace(
            /(<span\\s+style=['"]mso-spacerun:yes['"]>[^\\S\\r\\n]*?)[\\r\\n]+([^\\S\\r\\n]*<\\/span>)/g,
            "$1$2"
          )
          .replace(/<span\\s+style=['"]mso-spacerun:yes['"]><\\/span>/g, "")
          .replace(/ <\\//g, "</")
          .replace(/ <o:p><\\/o:p>/g, "<o:p></o:p>")
          .replace(/<o:p>(&nbsp;|\\u00A0)<\\/o:p>/g, "")
          .replace(/>([^\\S\\r\\n]*[\\r\\n]\\s*)</g, "><");
      }
      function KV(t) {
        t.querySelectorAll("span[style*=spacerun]").forEach((t) => {
          const e = t.innerText.length || 0;
          t.innerText = Array(e + 1)
            .join(" ")
            .substr(0, e);
        });
      }
      function YV(t) {
        return t.replace(
          /<span(?: class="Apple-converted-space"|)>(\\s+)<\\/span>/g,
          (t, e) =>
            e.length === 1
              ? " "
              : Array(e.length + 1)
                  .join(" ")
                  .substr(0, e.length)
        );
      }
      function ZV(t, e) {
        const n = new DOMParser();
        t = t.replace(/<!--\\[if gte vml 1]>/g, "");
        const i = $V(XV(t));
        const o = n.parseFromString(i, "text/html");
        KV(o);
        const r = o.body.innerHTML;
        const s = QV(o, e);
        const a = JV(o);
        return {
          body: s,
          bodyString: r,
          styles: a.styles,
          stylesString: a.stylesString,
        };
      }
      function QV(t, e) {
        const n = new kh(e);
        const i = new Am(n, { renderingMode: "data" });
        const o = t.createDocumentFragment();
        const r = t.body.childNodes;
        while (r.length > 0) {
          o.appendChild(r[0]);
        }
        return i.domToView(o, { skipComments: true });
      }
      function JV(t) {
        const e = [];
        const n = [];
        const i = Array.from(t.getElementsByTagName("style"));
        for (const t of i) {
          if (t.sheet && t.sheet.cssRules && t.sheet.cssRules.length) {
            e.push(t.sheet);
            n.push(t.innerHTML);
          }
        }
        return { styles: e, stylesString: n.join(" ") };
      }
      function XV(t) {
        const e = "</body>";
        const n = "</html>";
        const i = t.indexOf(e);
        if (i < 0) {
          return t;
        }
        const o = t.indexOf(n, i + e.length);
        return t.substring(0, i + e.length) + (o >= 0 ? t.substring(o) : "");
      }
      class tH extends Cl {
        static get pluginName() {
          return "PasteFromOffice";
        }
        static get requires() {
          return [RE];
        }
        init() {
          const t = this.editor;
          const e = t.editing.view.document;
          const n = [];
          n.push(new GV(e));
          n.push(new zV(e));
          t.plugins.get("ClipboardPipeline").on(
            "inputTransformation",
            (i, o) => {
              if (o._isTransformedWithPasteFromOffice) {
                return;
              }
              const r = t.model.document.selection.getFirstPosition().parent;
              if (r.is("element", "codeBlock")) {
                return;
              }
              const s = o.dataTransfer.getData("text/html");
              const a = n.find((t) => t.isActive(s));
              if (a) {
                o._parsedData = ZV(s, e.stylesProcessor);
                a.execute(o);
                o._isTransformedWithPasteFromOffice = true;
              }
            },
            { priority: "high" }
          );
        }
      }
      const eH =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>';
      const nH = "removeFormat";
      class iH extends Cl {
        static get pluginName() {
          return "RemoveFormatUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(nH, (n) => {
            const i = t.commands.get(nH);
            const o = new R_(n);
            o.set({ label: e("Remove Format"), icon: eH, tooltip: true });
            o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
            this.listenTo(o, "execute", () => {
              t.execute(nH);
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class oH extends vl {
        refresh() {
          const t = this.editor.model;
          this.isEnabled = !!sl(
            this._getFormattingItems(t.document.selection, t.schema)
          );
        }
        execute() {
          const t = this.editor.model;
          const e = t.schema;
          t.change((n) => {
            for (const i of this._getFormattingItems(t.document.selection, e)) {
              if (i.is("selection")) {
                for (const t of this._getFormattingAttributes(i, e)) {
                  n.removeSelectionAttribute(t);
                }
              } else {
                const t = n.createRangeOn(i);
                for (const o of this._getFormattingAttributes(i, e)) {
                  n.removeAttribute(o, t);
                }
              }
            }
          });
        }
        *_getFormattingItems(t, e) {
          const n = (t) => !!sl(this._getFormattingAttributes(t, e));
          for (const i of t.getRanges()) {
            for (const t of i.getItems()) {
              if (!e.isBlock(t) && n(t)) {
                yield t;
              }
            }
          }
          for (const e of t.getSelectedBlocks()) {
            if (n(e)) {
              yield e;
            }
          }
          if (n(t)) {
            yield t;
          }
        }
        *_getFormattingAttributes(t, e) {
          for (const [n] of t.getAttributes()) {
            const t = e.getAttributeProperties(n);
            if (t && t.isFormatting) {
              yield n;
            }
          }
        }
      }
      class rH extends Cl {
        static get pluginName() {
          return "RemoveFormatEditing";
        }
        init() {
          const t = this.editor;
          t.commands.add("removeFormat", new oH(t));
        }
      }
      class sH extends Cl {
        static get requires() {
          return [rH, iH];
        }
        static get pluginName() {
          return "RemoveFormat";
        }
      }
      function aH(t) {
        const e = [
          { name: "address", isVoid: false },
          { name: "article", isVoid: false },
          { name: "aside", isVoid: false },
          { name: "blockquote", isVoid: false },
          { name: "br", isVoid: true },
          { name: "details", isVoid: false },
          { name: "dialog", isVoid: false },
          { name: "dd", isVoid: false },
          { name: "div", isVoid: false },
          { name: "dl", isVoid: false },
          { name: "dt", isVoid: false },
          { name: "fieldset", isVoid: false },
          { name: "figcaption", isVoid: false },
          { name: "figure", isVoid: false },
          { name: "footer", isVoid: false },
          { name: "form", isVoid: false },
          { name: "h1", isVoid: false },
          { name: "h2", isVoid: false },
          { name: "h3", isVoid: false },
          { name: "h4", isVoid: false },
          { name: "h5", isVoid: false },
          { name: "h6", isVoid: false },
          { name: "header", isVoid: false },
          { name: "hgroup", isVoid: false },
          { name: "hr", isVoid: true },
          { name: "input", isVoid: true },
          { name: "li", isVoid: false },
          { name: "main", isVoid: false },
          { name: "nav", isVoid: false },
          { name: "ol", isVoid: false },
          { name: "p", isVoid: false },
          { name: "section", isVoid: false },
          { name: "table", isVoid: false },
          { name: "tbody", isVoid: false },
          { name: "td", isVoid: false },
          { name: "textarea", isVoid: false },
          { name: "th", isVoid: false },
          { name: "thead", isVoid: false },
          { name: "tr", isVoid: false },
          { name: "ul", isVoid: false },
        ];
        const n = e.map((t) => t.name).join("|");
        const i = t
          .replace(new RegExp(\`</?(\${n})( .*?)?>\`, "g"), "\\n$&\\n")
          .split("\\n");
        let o = 0;
        return i
          .filter((t) => t.length)
          .map((t) => {
            if (cH(t, e)) {
              return dH(t, o++);
            }
            if (lH(t, e)) {
              return dH(t, --o);
            }
            return dH(t, o);
          })
          .join("\\n");
      }
      function cH(t, e) {
        return e.some((e) => {
          if (e.isVoid) {
            return false;
          }
          if (!new RegExp(\`<\${e.name}( .*?)?>\`).test(t)) {
            return false;
          }
          return true;
        });
      }
      function lH(t, e) {
        return e.some((e) => new RegExp(\`</\${e.name}>\`).test(t));
      }
      function dH(t, e, n = "    ") {
        return \`\${n.repeat(Math.max(0, e))}\${t}\`;
      }
      var uH = n(671);
      var hH = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      hH.insert = "head";
      hH.singleton = true;
      var mH = Il()(uH.Z, hH);
      const gH = uH.Z.locals || {};
      const fH =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 0 5 4.5v15.003h-16V0h11zM3 1.5v3.25l-1.497 1-.003 8 1.5 1v3.254L7.685 18l-.001 1.504H17.5V8.002L16 9.428l-.004-4.22-4.222-3.692L3 1.5z"/><path d="M4.06 6.64a.75.75 0 0 1 .958 1.15l-.085.07L2.29 9.75l2.646 1.89c.302.216.4.62.232.951l-.058.095a.75.75 0 0 1-.951.232l-.095-.058-3.5-2.5V9.14l3.496-2.5zm4.194 6.22a.75.75 0 0 1-.958-1.149l.085-.07 2.643-1.89-2.646-1.89a.75.75 0 0 1-.232-.952l.058-.095a.75.75 0 0 1 .95-.232l.096.058 3.5 2.5v1.22l-3.496 2.5zm7.644-.836 2.122 2.122-5.825 5.809-2.125-.005.003-2.116zm2.539-1.847 1.414 1.414a.5.5 0 0 1 0 .707l-1.06 1.06-2.122-2.12 1.061-1.061a.5.5 0 0 1 .707 0z"/></svg>';
      const pH = "SourceEditingMode";
      class bH extends Cl {
        static get pluginName() {
          return "SourceEditing";
        }
        static get requires() {
          return [VC];
        }
        constructor(t) {
          super(t);
          this.set("isSourceEditingMode", false);
          this._elementReplacer = new Ct();
          this._replacedRoots = new Map();
          this._dataFromRoots = new Map();
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add("sourceEditing", (n) => {
            const i = new R_(n);
            i.set({
              label: e("Source"),
              icon: fH,
              tooltip: true,
              withText: true,
              class: "ck-source-editing-button",
            });
            i.bind("isOn").to(this, "isSourceEditingMode");
            i.bind("isEnabled").to(
              this,
              "isEnabled",
              t,
              "isReadOnly",
              t.plugins.get(VC),
              "hasAny",
              (t, e, n) => {
                if (!t) {
                  return false;
                }
                if (e) {
                  return false;
                }
                if (n) {
                  return false;
                }
                return true;
              }
            );
            this.listenTo(i, "execute", () => {
              this.isSourceEditingMode = !this.isSourceEditingMode;
            });
            return i;
          });
          if (this._isAllowedToHandleSourceEditingMode()) {
            this.on("change:isSourceEditingMode", (t, e, n) => {
              if (n) {
                this._showSourceEditing();
                this._disableCommands();
              } else {
                this._hideSourceEditing();
                this._enableCommands();
              }
            });
            this.on("change:isEnabled", (t, e, n) =>
              this._handleReadOnlyMode(!n)
            );
            this.listenTo(t, "change:isReadOnly", (t, e, n) =>
              this._handleReadOnlyMode(n)
            );
          }
          t.data.on(
            "get",
            () => {
              if (this.isSourceEditingMode) {
                this._updateEditorData();
              }
            },
            { priority: "high" }
          );
        }
        afterInit() {
          const t = this.editor;
          const e = [
            "RealTimeCollaborativeEditing",
            "CommentsEditing",
            "TrackChangesEditing",
            "RevisionHistory",
          ];
          if (e.some((e) => t.plugins.has(e))) {
            console.warn(
              "You initialized the editor with the source editing feature and at least one of the collaboration features. " +
                "Please be advised that the source editing feature may not work, and be careful when editing document source " +
                "that contains markers created by the collaboration features."
            );
          }
          if (t.plugins.has("RestrictedEditingModeEditing")) {
            console.warn(
              "You initialized the editor with the source editing feature and restricted editing feature. " +
                "Please be advised that the source editing feature may not work, and be careful when editing document source " +
                "that contains markers created by the restricted editing feature."
            );
          }
        }
        _showSourceEditing() {
          const t = this.editor;
          const e = t.editing.view;
          const n = t.model;
          n.change((t) => {
            t.setSelection(null);
            t.removeSelectionAttribute(n.document.selection.getAttributeKeys());
          });
          for (const [n, i] of e.domRoots) {
            const o = kH(t.data.get({ rootName: n }));
            const r = te(i.ownerDocument, "textarea", {
              rows: "1",
              "aria-label": "Source code editing area",
            });
            const s = te(
              i.ownerDocument,
              "div",
              { class: "ck-source-editing-area", "data-value": o },
              [r]
            );
            r.value = o;
            r.setSelectionRange(0, 0);
            r.addEventListener("input", () => {
              s.dataset.value = r.value;
            });
            e.change((t) => {
              const i = e.document.getRoot(n);
              t.addClass("ck-hidden", i);
            });
            t.ui.setEditableElement("sourceEditing:" + n, r);
            this._replacedRoots.set(n, s);
            this._elementReplacer.replace(i, s);
            this._dataFromRoots.set(n, o);
          }
          this._focusSourceEditing();
        }
        _hideSourceEditing() {
          const t = this.editor;
          const e = t.editing.view;
          this._updateEditorData();
          e.change((t) => {
            for (const [n] of this._replacedRoots) {
              t.removeClass("ck-hidden", e.document.getRoot(n));
            }
          });
          this._elementReplacer.restore();
          this._replacedRoots.clear();
          this._dataFromRoots.clear();
          e.focus();
        }
        _updateEditorData() {
          const t = this.editor;
          const e = {};
          for (const [t, n] of this._replacedRoots) {
            const i = this._dataFromRoots.get(t);
            const o = n.dataset.value;
            if (i !== o) {
              e[t] = o;
            }
          }
          if (Object.keys(e).length) {
            t.data.set(e, { batchType: { isUndoable: true } });
          }
        }
        _focusSourceEditing() {
          const t = this.editor;
          const [e] = this._replacedRoots.values();
          const n = e.querySelector("textarea");
          t.editing.view.document.isFocused = false;
          n.focus();
        }
        _disableCommands() {
          const t = this.editor;
          for (const e of t.commands.commands()) {
            e.forceDisabled(pH);
          }
        }
        _enableCommands() {
          const t = this.editor;
          for (const e of t.commands.commands()) {
            e.clearForceDisabled(pH);
          }
        }
        _handleReadOnlyMode(t) {
          if (!this.isSourceEditingMode) {
            return;
          }
          for (const [, e] of this._replacedRoots) {
            e.querySelector("textarea").readOnly = t;
          }
        }
        _isAllowedToHandleSourceEditingMode() {
          const t = this.editor;
          const e = t.ui.view.editable;
          return e && !e._hasExternalElement;
        }
      }
      function kH(t) {
        if (!wH(t)) {
          return t;
        }
        return aH(t);
      }
      function wH(t) {
        return t.startsWith("<");
      }
      class AH extends by {
        constructor(t, e) {
          super(t);
          const n = t.t;
          this.set("class", "ck-special-characters-navigation");
          this.groupDropdownView = this._createGroupDropdown(e);
          this.groupDropdownView.panelPosition =
            t.uiLanguageDirection === "rtl" ? "se" : "sw";
          this.label = n("Special characters");
          this.children.add(this.groupDropdownView);
        }
        get currentGroupName() {
          return this.groupDropdownView.value;
        }
        focus() {
          this.groupDropdownView.focus();
        }
        _createGroupDropdown(t) {
          const e = this.locale;
          const n = e.t;
          const i = Uv(e);
          const o = this._getCharacterGroupListItemDefinitions(i, t);
          i.set("value", o.first.model.label);
          i.buttonView.bind("label").to(i, "value");
          i.buttonView.set({
            isOn: false,
            withText: true,
            tooltip: n("Character categories"),
            class: ["ck-dropdown__button_label-width_auto"],
          });
          i.on("execute", (t) => {
            i.value = t.source.label;
          });
          i.delegate("execute").to(this);
          Wv(i, o);
          return i;
        }
        _getCharacterGroupListItemDefinitions(t, e) {
          const n = new rl();
          for (const i of e) {
            const e = {
              type: "button",
              model: new Py({ label: i, withText: true }),
            };
            e.model.bind("isOn").to(t, "value", (t) => t === e.model.label);
            n.add(e);
          }
          return n;
        }
      }
      var CH = n(4046);
      var _H = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      _H.insert = "head";
      _H.singleton = true;
      var vH = Il()(CH.Z, _H);
      const yH = CH.Z.locals || {};
      class xH extends pC {
        constructor(t) {
          super(t);
          this.tiles = this.createCollection();
          this.setTemplate({
            tag: "div",
            children: [
              {
                tag: "div",
                attributes: { class: ["ck", "ck-character-grid__tiles"] },
                children: this.tiles,
              },
            ],
            attributes: { class: ["ck", "ck-character-grid"] },
          });
          this.focusTracker = new al();
          this.keystrokes = new cl();
          E_({
            keystrokeHandler: this.keystrokes,
            focusTracker: this.focusTracker,
            gridItems: this.tiles,
            numberOfColumns: () =>
              Xa.window
                .getComputedStyle(this.element.firstChild)
                .getPropertyValue("grid-template-columns")
                .split(" ").length,
            uiLanguageDirection: this.locale && this.locale.uiLanguageDirection,
          });
        }
        createTile(t, e) {
          const n = new R_(this.locale);
          n.set({ label: t, withText: true, class: "ck-character-grid__tile" });
          n.extendTemplate({
            attributes: { title: e },
            on: {
              mouseover: n.bindTemplate.to("mouseover"),
              focus: n.bindTemplate.to("focus"),
            },
          });
          n.on("mouseover", () => {
            this.fire("tileHover", { name: e, character: t });
          });
          n.on("focus", () => {
            this.fire("tileFocus", { name: e, character: t });
          });
          n.on("execute", () => {
            this.fire("execute", { name: e, character: t });
          });
          return n;
        }
        render() {
          super.render();
          for (const t of this.tiles) {
            this.focusTracker.add(t.element);
          }
          this.tiles.on("change", (t, { added: e, removed: n }) => {
            if (e.length > 0) {
              for (const t of e) {
                this.focusTracker.add(t.element);
              }
            }
            if (n.length > 0) {
              for (const t of n) {
                this.focusTracker.remove(t.element);
              }
            }
          });
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this.tiles.get(0).focus();
        }
      }
      var EH = n(4779);
      var DH = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      DH.insert = "head";
      DH.singleton = true;
      var SH = Il()(EH.Z, DH);
      const TH = EH.Z.locals || {};
      class IH extends pC {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set("character", null);
          this.set("name", null);
          this.bind("code").to(this, "character", MH);
          this.setTemplate({
            tag: "div",
            children: [
              {
                tag: "span",
                attributes: { class: ["ck-character-info__name"] },
                children: [{ text: e.to("name", (t) => (t ? t : "")) }],
              },
              {
                tag: "span",
                attributes: { class: ["ck-character-info__code"] },
                children: [{ text: e.to("code") }],
              },
            ],
            attributes: { class: ["ck", "ck-character-info"] },
          });
        }
      }
      function MH(t) {
        if (t === null) {
          return "";
        }
        const e = t.codePointAt(0).toString(16);
        return "U+" + ("0000" + e).slice(-4);
      }
      class BH extends pC {
        constructor(t, e, n, i) {
          super(t);
          this.items = this.createCollection();
          this.focusTracker = new al();
          this.keystrokes = new cl();
          this._focusCycler = new hv({
            focusables: this.items,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          });
          this.navigationView = e;
          this.gridView = n;
          this.infoView = i;
          this.setTemplate({
            tag: "div",
            children: [this.navigationView, this.gridView, this.infoView],
            attributes: { tabindex: "-1" },
          });
          this.items.add(this.navigationView.groupDropdownView.buttonView);
          this.items.add(this.gridView);
        }
        render() {
          super.render();
          this.focusTracker.add(
            this.navigationView.groupDropdownView.buttonView.element
          );
          this.focusTracker.add(this.gridView.element);
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this.navigationView.focus();
        }
      }
      const LH =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2.5a7.47 7.47 0 0 1 4.231 1.31 7.268 7.268 0 0 1 2.703 3.454 7.128 7.128 0 0 1 .199 4.353c-.39 1.436-1.475 2.72-2.633 3.677h2.013c0-.226.092-.443.254-.603a.876.876 0 0 1 1.229 0c.163.16.254.377.254.603v.853c0 .209-.078.41-.22.567a.873.873 0 0 1-.547.28l-.101.006h-4.695a.517.517 0 0 1-.516-.518v-1.265c0-.21.128-.398.317-.489a5.601 5.601 0 0 0 2.492-2.371 5.459 5.459 0 0 0 .552-3.693 5.53 5.53 0 0 0-1.955-3.2A5.71 5.71 0 0 0 10 4.206 5.708 5.708 0 0 0 6.419 5.46 5.527 5.527 0 0 0 4.46 8.663a5.457 5.457 0 0 0 .554 3.695 5.6 5.6 0 0 0 2.497 2.37.55.55 0 0 1 .317.49v1.264c0 .286-.23.518-.516.518H2.618a.877.877 0 0 1-.614-.25.845.845 0 0 1-.254-.603v-.853c0-.226.091-.443.254-.603a.876.876 0 0 1 1.228 0c.163.16.255.377.255.603h1.925c-1.158-.958-2.155-2.241-2.545-3.678a7.128 7.128 0 0 1 .199-4.352 7.268 7.268 0 0 1 2.703-3.455A7.475 7.475 0 0 1 10 2.5z"/></svg>';
      var NH = n(8170);
      var zH = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      zH.insert = "head";
      zH.singleton = true;
      var PH = Il()(NH.Z, zH);
      const RH = NH.Z.locals || {};
      const OH = "All";
      class jH extends Cl {
        static get requires() {
          return [Xx];
        }
        static get pluginName() {
          return "SpecialCharacters";
        }
        constructor(t) {
          super(t);
          this._characters = new Map();
          this._groups = new Map();
        }
        init() {
          const t = this.editor;
          const e = t.t;
          const n = t.commands.get("input");
          t.ui.componentFactory.add("specialCharacters", (i) => {
            const o = Uv(i);
            let r;
            o.buttonView.set({
              label: e("Special characters"),
              icon: LH,
              tooltip: true,
            });
            o.bind("isEnabled").to(n);
            o.on("execute", (e, n) => {
              t.execute("insertText", { text: n.character });
              t.editing.view.focus();
            });
            o.on("change:isOpen", () => {
              if (!r) {
                r = this._createDropdownPanelContent(i, o);
                const t = new BH(i, r.navigationView, r.gridView, r.infoView);
                o.panelView.children.add(t);
              }
              r.infoView.set({ character: null, name: null });
            });
            return o;
          });
        }
        addItems(t, e) {
          if (t === OH) {
            throw new M(
              \`special-character-invalid-group-name: The name "\${OH}" is reserved and cannot be used.\`
            );
          }
          const n = this._getGroup(t);
          for (const t of e) {
            n.add(t.title);
            this._characters.set(t.title, t.character);
          }
        }
        getGroups() {
          return this._groups.keys();
        }
        getCharactersForGroup(t) {
          if (t === OH) {
            return new Set(this._characters.keys());
          }
          return this._groups.get(t);
        }
        getCharacter(t) {
          return this._characters.get(t);
        }
        _getGroup(t) {
          if (!this._groups.has(t)) {
            this._groups.set(t, new Set());
          }
          return this._groups.get(t);
        }
        _updateGrid(t, e) {
          e.tiles.clear();
          const n = this.getCharactersForGroup(t);
          for (const t of n) {
            const n = this.getCharacter(t);
            e.tiles.add(e.createTile(n, t));
          }
        }
        _createDropdownPanelContent(t, e) {
          const n = [...this.getGroups()];
          n.unshift(OH);
          const i = new AH(t, n);
          const o = new xH(t);
          const r = new IH(t);
          o.delegate("execute").to(e);
          o.on("tileHover", (t, e) => {
            r.set(e);
          });
          o.on("tileFocus", (t, e) => {
            r.set(e);
          });
          i.on("execute", () => {
            this._updateGrid(i.currentGroupName, o);
          });
          this._updateGrid(i.currentGroupName, o);
          return { navigationView: i, gridView: o, infoView: r };
        }
      }
      class FH extends Cl {
        static get pluginName() {
          return "SpecialCharactersArrows";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.plugins.get("SpecialCharacters").addItems("Arrows", [
            { title: e("leftwards simple arrow"), character: "" },
            { title: e("rightwards simple arrow"), character: "" },
            { title: e("upwards simple arrow"), character: "" },
            { title: e("downwards simple arrow"), character: "" },
            { title: e("leftwards double arrow"), character: "" },
            { title: e("rightwards double arrow"), character: "" },
            { title: e("upwards double arrow"), character: "" },
            { title: e("downwards double arrow"), character: "" },
            { title: e("leftwards dashed arrow"), character: "" },
            { title: e("rightwards dashed arrow"), character: "" },
            { title: e("upwards dashed arrow"), character: "" },
            { title: e("downwards dashed arrow"), character: "" },
            { title: e("leftwards arrow to bar"), character: "" },
            { title: e("rightwards arrow to bar"), character: "" },
            { title: e("upwards arrow to bar"), character: "" },
            { title: e("downwards arrow to bar"), character: "" },
            { title: e("up down arrow with base"), character: "" },
            { title: e("back with leftwards arrow above"), character: "" },
            { title: e("end with leftwards arrow above"), character: "" },
            {
              title: e("on with exclamation mark with left right arrow above"),
              character: "",
            },
            { title: e("soon with rightwards arrow above"), character: "" },
            { title: e("top with upwards arrow above"), character: "" },
          ]);
        }
      }
      class VH extends Cl {
        static get pluginName() {
          return "SpecialCharactersCurrency";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.plugins.get("SpecialCharacters").addItems("Currency", [
            { character: "$", title: e("Dollar sign") },
            { character: "", title: e("Euro sign") },
            { character: "", title: e("Yen sign") },
            { character: "", title: e("Pound sign") },
            { character: "", title: e("Cent sign") },
            { character: "", title: e("Euro-currency sign") },
            { character: "", title: e("Colon sign") },
            { character: "", title: e("Cruzeiro sign") },
            { character: "", title: e("French franc sign") },
            { character: "", title: e("Lira sign") },
            { character: "", title: e("Currency sign") },
            { character: "", title: e("Bitcoin sign") },
            { character: "", title: e("Mill sign") },
            { character: "", title: e("Naira sign") },
            { character: "", title: e("Peseta sign") },
            { character: "", title: e("Rupee sign") },
            { character: "", title: e("Won sign") },
            { character: "", title: e("New sheqel sign") },
            { character: "", title: e("Dong sign") },
            { character: "", title: e("Kip sign") },
            { character: "", title: e("Tugrik sign") },
            { character: "", title: e("Drachma sign") },
            { character: "", title: e("German penny sign") },
            { character: "", title: e("Peso sign") },
            { character: "", title: e("Guarani sign") },
            { character: "", title: e("Austral sign") },
            { character: "", title: e("Hryvnia sign") },
            { character: "", title: e("Cedi sign") },
            { character: "", title: e("Livre tournois sign") },
            { character: "", title: e("Spesmilo sign") },
            { character: "", title: e("Tenge sign") },
            { character: "", title: e("Indian rupee sign") },
            { character: "", title: e("Turkish lira sign") },
            { character: "", title: e("Nordic mark sign") },
            { character: "", title: e("Manat sign") },
            { character: "", title: e("Ruble sign") },
          ]);
        }
      }
      class HH extends Cl {
        static get pluginName() {
          return "SpecialCharactersMathematical";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.plugins.get("SpecialCharacters").addItems("Mathematical", [
            { character: "<", title: e("Less-than sign") },
            { character: ">", title: e("Greater-than sign") },
            { character: "", title: e("Less-than or equal to") },
            { character: "", title: e("Greater-than or equal to") },
            { character: "", title: e("En dash") },
            { character: "", title: e("Em dash") },
            { character: "", title: e("Macron") },
            { character: "", title: e("Overline") },
            { character: "", title: e("Degree sign") },
            { character: "", title: e("Minus sign") },
            { character: "", title: e("Plus-minus sign") },
            { character: "", title: e("Division sign") },
            { character: "", title: e("Fraction slash") },
            { character: "", title: e("Multiplication sign") },
            { character: "", title: e("Latin small letter f with hook") },
            { character: "", title: e("Integral") },
            { character: "", title: e("N-ary summation") },
            { character: "", title: e("Infinity") },
            { character: "", title: e("Square root") },
            { character: "", title: e("Tilde operator") },
            { character: "", title: e("Approximately equal to") },
            { character: "", title: e("Almost equal to") },
            { character: "", title: e("Not equal to") },
            { character: "", title: e("Identical to") },
            { character: "", title: e("Element of") },
            { character: "", title: e("Not an element of") },
            { character: "", title: e("Contains as member") },
            { character: "", title: e("N-ary product") },
            { character: "", title: e("Logical and") },
            { character: "", title: e("Logical or") },
            { character: "", title: e("Not sign") },
            { character: "", title: e("Intersection") },
            { character: "", title: e("Union") },
            { character: "", title: e("Partial differential") },
            { character: "", title: e("For all") },
            { character: "", title: e("There exists") },
            { character: "", title: e("Empty set") },
            { character: "", title: e("Nabla") },
            { character: "", title: e("Asterisk operator") },
            { character: "", title: e("Proportional to") },
            { character: "", title: e("Angle") },
            { character: "", title: e("Vulgar fraction one quarter") },
            { character: "", title: e("Vulgar fraction one half") },
            { character: "", title: e("Vulgar fraction three quarters") },
          ]);
        }
      }
      class UH extends Cl {
        static get pluginName() {
          return "SpecialCharactersLatin";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.plugins.get("SpecialCharacters").addItems("Latin", [
            { character: "", title: e("Latin capital letter a with macron") },
            { character: "", title: e("Latin small letter a with macron") },
            { character: "", title: e("Latin capital letter a with breve") },
            { character: "", title: e("Latin small letter a with breve") },
            { character: "", title: e("Latin capital letter a with ogonek") },
            { character: "", title: e("Latin small letter a with ogonek") },
            { character: "", title: e("Latin capital letter c with acute") },
            { character: "", title: e("Latin small letter c with acute") },
            {
              character: "",
              title: e("Latin capital letter c with circumflex"),
            },
            {
              character: "",
              title: e("Latin small letter c with circumflex"),
            },
            {
              character: "",
              title: e("Latin capital letter c with dot above"),
            },
            { character: "", title: e("Latin small letter c with dot above") },
            { character: "", title: e("Latin capital letter c with caron") },
            { character: "", title: e("Latin small letter c with caron") },
            { character: "", title: e("Latin capital letter d with caron") },
            { character: "", title: e("Latin small letter d with caron") },
            { character: "", title: e("Latin capital letter d with stroke") },
            { character: "", title: e("Latin small letter d with stroke") },
            { character: "", title: e("Latin capital letter e with macron") },
            { character: "", title: e("Latin small letter e with macron") },
            { character: "", title: e("Latin capital letter e with breve") },
            { character: "", title: e("Latin small letter e with breve") },
            {
              character: "",
              title: e("Latin capital letter e with dot above"),
            },
            { character: "", title: e("Latin small letter e with dot above") },
            { character: "", title: e("Latin capital letter e with ogonek") },
            { character: "", title: e("Latin small letter e with ogonek") },
            { character: "", title: e("Latin capital letter e with caron") },
            { character: "", title: e("Latin small letter e with caron") },
            {
              character: "",
              title: e("Latin capital letter g with circumflex"),
            },
            {
              character: "",
              title: e("Latin small letter g with circumflex"),
            },
            { character: "", title: e("Latin capital letter g with breve") },
            { character: "", title: e("Latin small letter g with breve") },
            {
              character: "",
              title: e("Latin capital letter g with dot above"),
            },
            { character: "", title: e("Latin small letter g with dot above") },
            { character: "", title: e("Latin capital letter g with cedilla") },
            { character: "", title: e("Latin small letter g with cedilla") },
            {
              character: "",
              title: e("Latin capital letter h with circumflex"),
            },
            {
              character: "",
              title: e("Latin small letter h with circumflex"),
            },
            { character: "", title: e("Latin capital letter h with stroke") },
            { character: "", title: e("Latin small letter h with stroke") },
            { character: "", title: e("Latin capital letter i with tilde") },
            { character: "", title: e("Latin small letter i with tilde") },
            { character: "", title: e("Latin capital letter i with macron") },
            { character: "", title: e("Latin small letter i with macron") },
            { character: "", title: e("Latin capital letter i with breve") },
            { character: "", title: e("Latin small letter i with breve") },
            { character: "", title: e("Latin capital letter i with ogonek") },
            { character: "", title: e("Latin small letter i with ogonek") },
            {
              character: "",
              title: e("Latin capital letter i with dot above"),
            },
            { character: "", title: e("Latin small letter dotless i") },
            { character: "", title: e("Latin capital ligature ij") },
            { character: "", title: e("Latin small ligature ij") },
            {
              character: "",
              title: e("Latin capital letter j with circumflex"),
            },
            {
              character: "",
              title: e("Latin small letter j with circumflex"),
            },
            { character: "", title: e("Latin capital letter k with cedilla") },
            { character: "", title: e("Latin small letter k with cedilla") },
            { character: "", title: e("Latin small letter kra") },
            { character: "", title: e("Latin capital letter l with acute") },
            { character: "", title: e("Latin small letter l with acute") },
            { character: "", title: e("Latin capital letter l with cedilla") },
            { character: "", title: e("Latin small letter l with cedilla") },
            { character: "", title: e("Latin capital letter l with caron") },
            { character: "", title: e("Latin small letter l with caron") },
            {
              character: "",
              title: e("Latin capital letter l with middle dot"),
            },
            {
              character: "",
              title: e("Latin small letter l with middle dot"),
            },
            { character: "", title: e("Latin capital letter l with stroke") },
            { character: "", title: e("Latin small letter l with stroke") },
            { character: "", title: e("Latin capital letter n with acute") },
            { character: "", title: e("Latin small letter n with acute") },
            { character: "", title: e("Latin capital letter n with cedilla") },
            { character: "", title: e("Latin small letter n with cedilla") },
            { character: "", title: e("Latin capital letter n with caron") },
            { character: "", title: e("Latin small letter n with caron") },
            {
              character: "",
              title: e("Latin small letter n preceded by apostrophe"),
            },
            { character: "", title: e("Latin capital letter eng") },
            { character: "", title: e("Latin small letter eng") },
            { character: "", title: e("Latin capital letter o with macron") },
            { character: "", title: e("Latin small letter o with macron") },
            { character: "", title: e("Latin capital letter o with breve") },
            { character: "", title: e("Latin small letter o with breve") },
            {
              character: "",
              title: e("Latin capital letter o with double acute"),
            },
            {
              character: "",
              title: e("Latin small letter o with double acute"),
            },
            { character: "", title: e("Latin capital ligature oe") },
            { character: "", title: e("Latin small ligature oe") },
            { character: "", title: e("Latin capital letter r with acute") },
            { character: "", title: e("Latin small letter r with acute") },
            { character: "", title: e("Latin capital letter r with cedilla") },
            { character: "", title: e("Latin small letter r with cedilla") },
            { character: "", title: e("Latin capital letter r with caron") },
            { character: "", title: e("Latin small letter r with caron") },
            { character: "", title: e("Latin capital letter s with acute") },
            { character: "", title: e("Latin small letter s with acute") },
            {
              character: "",
              title: e("Latin capital letter s with circumflex"),
            },
            {
              character: "",
              title: e("Latin small letter s with circumflex"),
            },
            { character: "", title: e("Latin capital letter s with cedilla") },
            { character: "", title: e("Latin small letter s with cedilla") },
            { character: "", title: e("Latin capital letter s with caron") },
            { character: "", title: e("Latin small letter s with caron") },
            { character: "", title: e("Latin capital letter t with cedilla") },
            { character: "", title: e("Latin small letter t with cedilla") },
            { character: "", title: e("Latin capital letter t with caron") },
            { character: "", title: e("Latin small letter t with caron") },
            { character: "", title: e("Latin capital letter t with stroke") },
            { character: "", title: e("Latin small letter t with stroke") },
            { character: "", title: e("Latin capital letter u with tilde") },
            { character: "", title: e("Latin small letter u with tilde") },
            { character: "", title: e("Latin capital letter u with macron") },
            { character: "", title: e("Latin small letter u with macron") },
            { character: "", title: e("Latin capital letter u with breve") },
            { character: "", title: e("Latin small letter u with breve") },
            {
              character: "",
              title: e("Latin capital letter u with ring above"),
            },
            {
              character: "",
              title: e("Latin small letter u with ring above"),
            },
            {
              character: "",
              title: e("Latin capital letter u with double acute"),
            },
            {
              character: "",
              title: e("Latin small letter u with double acute"),
            },
            { character: "", title: e("Latin capital letter u with ogonek") },
            { character: "", title: e("Latin small letter u with ogonek") },
            {
              character: "",
              title: e("Latin capital letter w with circumflex"),
            },
            {
              character: "",
              title: e("Latin small letter w with circumflex"),
            },
            {
              character: "",
              title: e("Latin capital letter y with circumflex"),
            },
            {
              character: "",
              title: e("Latin small letter y with circumflex"),
            },
            {
              character: "",
              title: e("Latin capital letter y with diaeresis"),
            },
            { character: "", title: e("Latin capital letter z with acute") },
            { character: "", title: e("Latin small letter z with acute") },
            {
              character: "",
              title: e("Latin capital letter z with dot above"),
            },
            { character: "", title: e("Latin small letter z with dot above") },
            { character: "", title: e("Latin capital letter z with caron") },
            { character: "", title: e("Latin small letter z with caron") },
            { character: "", title: e("Latin small letter long s") },
          ]);
        }
      }
      class qH extends Cl {
        static get pluginName() {
          return "SpecialCharactersText";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.plugins.get("SpecialCharacters").addItems("Text", [
            {
              character: "",
              title: e("Single left-pointing angle quotation mark"),
            },
            {
              character: "",
              title: e("Single right-pointing angle quotation mark"),
            },
            {
              character: "",
              title: e("Left-pointing double angle quotation mark"),
            },
            {
              character: "",
              title: e("Right-pointing double angle quotation mark"),
            },
            { character: "", title: e("Left single quotation mark") },
            { character: "", title: e("Right single quotation mark") },
            { character: "", title: e("Left double quotation mark") },
            { character: "", title: e("Right double quotation mark") },
            { character: "", title: e("Single low-9 quotation mark") },
            { character: "", title: e("Double low-9 quotation mark") },
            { character: "", title: e("Inverted exclamation mark") },
            { character: "", title: e("Inverted question mark") },
            { character: "", title: e("Two dot leader") },
            { character: "", title: e("Horizontal ellipsis") },
            { character: "", title: e("Double dagger") },
            { character: "", title: e("Per mille sign") },
            { character: "", title: e("Per ten thousand sign") },
            { character: "", title: e("Double exclamation mark") },
            { character: "", title: e("Question exclamation mark") },
            { character: "", title: e("Exclamation question mark") },
            { character: "", title: e("Double question mark") },
            { character: "", title: e("Copyright sign") },
            { character: "", title: e("Registered sign") },
            { character: "", title: e("Trade mark sign") },
            { character: "", title: e("Section sign") },
            { character: "", title: e("Paragraph sign") },
            { character: "", title: e("Reversed paragraph sign") },
          ]);
        }
      }
      class WH extends Cl {
        static get requires() {
          return [VH, qH, HH, FH, UH];
        }
      }
      const GH = "strikethrough";
      class $H extends Cl {
        static get pluginName() {
          return "StrikethroughEditing";
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: GH });
          t.model.schema.setAttributeProperties(GH, {
            isFormatting: true,
            copyOnEnter: true,
          });
          t.conversion.attributeToElement({
            model: GH,
            view: "s",
            upcastAlso: [
              "del",
              "strike",
              { styles: { "text-decoration": "line-through" } },
            ],
          });
          t.commands.add(GH, new SI(t, GH));
          t.keystrokes.set("CTRL+SHIFT+X", "strikethrough");
        }
      }
      const KH =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>';
      const YH = "strikethrough";
      class ZH extends Cl {
        static get pluginName() {
          return "StrikethroughUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(YH, (n) => {
            const i = t.commands.get(YH);
            const o = new R_(n);
            o.set({
              label: e("Strikethrough"),
              icon: KH,
              keystroke: "CTRL+SHIFT+X",
              tooltip: true,
              isToggleable: true,
            });
            o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
            this.listenTo(o, "execute", () => {
              t.execute(YH);
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class QH extends Cl {
        static get requires() {
          return [$H, ZH];
        }
        static get pluginName() {
          return "Strikethrough";
        }
      }
      const JH = "subscript";
      class XH extends Cl {
        static get pluginName() {
          return "SubscriptEditing";
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: JH });
          t.model.schema.setAttributeProperties(JH, {
            isFormatting: true,
            copyOnEnter: true,
          });
          t.conversion.attributeToElement({
            model: JH,
            view: "sub",
            upcastAlso: [{ styles: { "vertical-align": "sub" } }],
          });
          t.commands.add(JH, new SI(t, JH));
        }
      }
      const tU =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.03 10.349 3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82zm8.147 7.829h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309z"/></svg>';
      const eU = "subscript";
      class nU extends Cl {
        static get pluginName() {
          return "SubscriptUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(eU, (n) => {
            const i = t.commands.get(eU);
            const o = new R_(n);
            o.set({
              label: e("Subscript"),
              icon: tU,
              tooltip: true,
              isToggleable: true,
            });
            o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
            this.listenTo(o, "execute", () => {
              t.execute(eU);
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class iU extends Cl {
        static get requires() {
          return [XH, nU];
        }
        static get pluginName() {
          return "Subscript";
        }
      }
      const oU = "superscript";
      class rU extends Cl {
        static get pluginName() {
          return "SuperscriptEditing";
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: oU });
          t.model.schema.setAttributeProperties(oU, {
            isFormatting: true,
            copyOnEnter: true,
          });
          t.conversion.attributeToElement({
            model: oU,
            view: "sup",
            upcastAlso: [{ styles: { "vertical-align": "super" } }],
          });
          t.commands.add(oU, new SI(t, oU));
        }
      }
      const sU =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.677 8.678h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82z"/></svg>';
      const aU = "superscript";
      class cU extends Cl {
        static get pluginName() {
          return "SuperscriptUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(aU, (n) => {
            const i = t.commands.get(aU);
            const o = new R_(n);
            o.set({
              label: e("Superscript"),
              icon: sU,
              tooltip: true,
              isToggleable: true,
            });
            o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
            this.listenTo(o, "execute", () => {
              t.execute(aU);
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class lU extends Cl {
        static get requires() {
          return [rU, cU];
        }
        static get pluginName() {
          return "Superscript";
        }
      }
      function dU(t, e) {
        const {
          viewElement: n,
          defaultValue: i,
          modelAttribute: o,
          styleName: r,
          reduceBoxSides: s = false,
          shouldUpcast: a = () => true,
        } = e;
        t.for("upcast").attributeToAttribute({
          view: { name: n, styles: { [r]: /[\\s\\S]+/ } },
          model: {
            key: o,
            value: (t) => {
              if (!a(t)) {
                return;
              }
              const e = t.getNormalizedStyle(r);
              const n = s ? gU(e) : e;
              if (i !== n) {
                return n;
              }
            },
          },
        });
      }
      function uU(t, e, n, i) {
        t.for("upcast").add((t) =>
          t.on("element:" + e, (t, e, o) => {
            if (!e.modelRange) {
              return;
            }
            const r = [
              "border-top-width",
              "border-top-color",
              "border-top-style",
              "border-bottom-width",
              "border-bottom-color",
              "border-bottom-style",
              "border-right-width",
              "border-right-color",
              "border-right-style",
              "border-left-width",
              "border-left-color",
              "border-left-style",
            ].filter((t) => e.viewItem.hasStyle(t));
            if (!r.length) {
              return;
            }
            const s = { styles: r };
            if (!o.consumable.test(e.viewItem, s)) {
              return;
            }
            const a = [...e.modelRange.getItems({ shallow: true })].pop();
            o.consumable.consume(e.viewItem, s);
            const c = {
              style: e.viewItem.getNormalizedStyle("border-style"),
              color: e.viewItem.getNormalizedStyle("border-color"),
              width: e.viewItem.getNormalizedStyle("border-width"),
            };
            const l = {
              style: gU(c.style),
              color: gU(c.color),
              width: gU(c.width),
            };
            if (l.style !== i.style) {
              o.writer.setAttribute(n.style, l.style, a);
            }
            if (l.color !== i.color) {
              o.writer.setAttribute(n.color, l.color, a);
            }
            if (l.width !== i.width) {
              o.writer.setAttribute(n.width, l.width, a);
            }
          })
        );
      }
      function hU(t, { modelElement: e, modelAttribute: n, styleName: i }) {
        t.for("downcast").attributeToAttribute({
          model: { name: e, key: n },
          view: (t) => ({ key: "style", value: { [i]: t } }),
        });
      }
      function mU(t, { modelAttribute: e, styleName: n }) {
        t.for("downcast").add((t) =>
          t.on(\`attribute:\${e}:table\`, (t, e, i) => {
            const { item: o, attributeNewValue: r } = e;
            const { mapper: s, writer: a } = i;
            if (!i.consumable.consume(e.item, t.name)) {
              return;
            }
            const c = [...s.toViewElement(o).getChildren()].find((t) =>
              t.is("element", "table")
            );
            if (r) {
              a.setStyle(n, r, c);
            } else {
              a.removeStyle(n, c);
            }
          })
        );
      }
      function gU(t) {
        if (!t) {
          return;
        }
        const e = ["top", "right", "bottom", "left"]
          .map((e) => t[e])
          .reduce((t, e) => (t == e ? t : null));
        return e || t;
      }
      function fU(t, e, n, i, o = 1) {
        if (e > o) {
          i.setAttribute(t, e, n);
        } else {
          i.removeAttribute(t, n);
        }
      }
      function pU(t, e, n = {}) {
        const i = t.createElement("tableCell", n);
        t.insertElement("paragraph", i);
        t.insert(i, e);
        return i;
      }
      function bU(t, e) {
        const n = e.parent.parent;
        const i = parseInt(n.getAttribute("headingColumns") || 0);
        const { column: o } = t.getCellLocation(e);
        return !!i && o < i;
      }
      function kU(t, e, n) {
        const { modelAttribute: i } = n;
        t.extend("tableCell", { allowAttributes: [i] });
        dU(e, { viewElement: /^(td|th)$/, ...n });
        hU(e, { modelElement: "tableCell", ...n });
      }
      function wU() {
        return (t) => {
          t.on("element:figure", (t, e, n) => {
            if (
              !n.consumable.test(e.viewItem, { name: true, classes: "table" })
            ) {
              return;
            }
            const i = vU(e.viewItem);
            if (!i || !n.consumable.test(i, { name: true })) {
              return;
            }
            n.consumable.consume(e.viewItem, { name: true, classes: "table" });
            const o = n.convertItem(i, e.modelCursor);
            const r = sl(o.modelRange.getItems());
            if (!r) {
              n.consumable.revert(e.viewItem, { name: true, classes: "table" });
              return;
            }
            n.convertChildren(e.viewItem, n.writer.createPositionAt(r, "end"));
            n.updateConversionResult(r, e);
          });
        };
      }
      function AU() {
        return (t) => {
          t.on("element:table", (t, e, n) => {
            const i = e.viewItem;
            if (!n.consumable.test(i, { name: true })) {
              return;
            }
            const { rows: o, headingRows: r, headingColumns: s } = yU(i);
            const a = {};
            if (s) {
              a.headingColumns = s;
            }
            if (r) {
              a.headingRows = r;
            }
            const c = n.writer.createElement("table", a);
            if (!n.safeInsert(c, e.modelCursor)) {
              return;
            }
            n.consumable.consume(i, { name: true });
            o.forEach((t) =>
              n.convertItem(t, n.writer.createPositionAt(c, "end"))
            );
            n.convertChildren(i, n.writer.createPositionAt(c, "end"));
            if (c.isEmpty) {
              const t = n.writer.createElement("tableRow");
              n.writer.insert(t, n.writer.createPositionAt(c, "end"));
              pU(n.writer, n.writer.createPositionAt(t, "end"));
            }
            n.updateConversionResult(c, e);
          });
        };
      }
      function CU() {
        return (t) => {
          t.on(
            "element:tr",
            (t, e) => {
              if (e.viewItem.isEmpty && e.modelCursor.index == 0) {
                t.stop();
              }
            },
            { priority: "high" }
          );
        };
      }
      function _U(t) {
        return (e) => {
          e.on(
            \`element:\${t}\`,
            (t, e, n) => {
              if (!e.modelRange) {
                return;
              }
              if (e.viewItem.isEmpty) {
                const t = e.modelRange.start.nodeAfter;
                const i = n.writer.createPositionAt(t, 0);
                n.writer.insertElement("paragraph", i);
              }
            },
            { priority: "low" }
          );
        };
      }
      function vU(t) {
        for (const e of t.getChildren()) {
          if (e.is("element", "table")) {
            return e;
          }
        }
      }
      function yU(t) {
        const e = { headingRows: 0, headingColumns: 0 };
        const n = [];
        const i = [];
        let o;
        for (const r of Array.from(t.getChildren())) {
          if (r.name === "tbody" || r.name === "thead" || r.name === "tfoot") {
            if (r.name === "thead" && !o) {
              o = r;
            }
            const t = Array.from(r.getChildren()).filter((t) =>
              t.is("element", "tr")
            );
            for (const r of t) {
              if (r.parent.name === "thead" && r.parent === o) {
                e.headingRows++;
                n.push(r);
              } else {
                i.push(r);
                const t = xU(r, e, o);
                if (t > e.headingColumns) {
                  e.headingColumns = t;
                }
              }
            }
          }
        }
        e.rows = [...n, ...i];
        return e;
      }
      function xU(t) {
        let e = 0;
        let n = 0;
        const i = Array.from(t.getChildren()).filter(
          (t) => t.name === "th" || t.name === "td"
        );
        while (n < i.length && i[n].name === "th") {
          const t = i[n];
          const o = parseInt(t.getAttribute("colspan") || 1);
          e = e + o;
          n++;
        }
        return e;
      }
      class EU {
        constructor(t, e = {}) {
          this._table = t;
          this._startRow = e.row !== undefined ? e.row : e.startRow || 0;
          this._endRow = e.row !== undefined ? e.row : e.endRow;
          this._startColumn =
            e.column !== undefined ? e.column : e.startColumn || 0;
          this._endColumn = e.column !== undefined ? e.column : e.endColumn;
          this._includeAllSlots = !!e.includeAllSlots;
          this._skipRows = new Set();
          this._row = 0;
          this._rowIndex = 0;
          this._column = 0;
          this._cellIndex = 0;
          this._spannedCells = new Map();
          this._nextCellAtColumn = -1;
        }
        [Symbol.iterator]() {
          return this;
        }
        next() {
          const t = this._table.getChild(this._rowIndex);
          if (!t || this._isOverEndRow()) {
            return { done: true };
          }
          if (!t.is("element", "tableRow")) {
            this._rowIndex++;
            return this.next();
          }
          if (this._isOverEndColumn()) {
            return this._advanceToNextRow();
          }
          let e = null;
          const n = this._getSpanned();
          if (n) {
            if (this._includeAllSlots && !this._shouldSkipSlot()) {
              e = this._formatOutValue(n.cell, n.row, n.column);
            }
          } else {
            const n = t.getChild(this._cellIndex);
            if (!n) {
              return this._advanceToNextRow();
            }
            const i = parseInt(n.getAttribute("colspan") || 1);
            const o = parseInt(n.getAttribute("rowspan") || 1);
            if (i > 1 || o > 1) {
              this._recordSpans(n, o, i);
            }
            if (!this._shouldSkipSlot()) {
              e = this._formatOutValue(n);
            }
            this._nextCellAtColumn = this._column + i;
          }
          this._column++;
          if (this._column == this._nextCellAtColumn) {
            this._cellIndex++;
          }
          return e || this.next();
        }
        skipRow(t) {
          this._skipRows.add(t);
        }
        _advanceToNextRow() {
          this._row++;
          this._rowIndex++;
          this._column = 0;
          this._cellIndex = 0;
          this._nextCellAtColumn = -1;
          return this.next();
        }
        _isOverEndRow() {
          return this._endRow !== undefined && this._row > this._endRow;
        }
        _isOverEndColumn() {
          return (
            this._endColumn !== undefined && this._column > this._endColumn
          );
        }
        _formatOutValue(t, e = this._row, n = this._column) {
          return { done: false, value: new DU(this, t, e, n) };
        }
        _shouldSkipSlot() {
          const t = this._skipRows.has(this._row);
          const e = this._row < this._startRow;
          const n = this._column < this._startColumn;
          const i =
            this._endColumn !== undefined && this._column > this._endColumn;
          return t || e || n || i;
        }
        _getSpanned() {
          const t = this._spannedCells.get(this._row);
          if (!t) {
            return null;
          }
          return t.get(this._column) || null;
        }
        _recordSpans(t, e, n) {
          const i = { cell: t, row: this._row, column: this._column };
          for (let t = this._row; t < this._row + e; t++) {
            for (let e = this._column; e < this._column + n; e++) {
              if (t != this._row || e != this._column) {
                this._markSpannedCell(t, e, i);
              }
            }
          }
        }
        _markSpannedCell(t, e, n) {
          if (!this._spannedCells.has(t)) {
            this._spannedCells.set(t, new Map());
          }
          const i = this._spannedCells.get(t);
          i.set(e, n);
        }
      }
      class DU {
        constructor(t, e, n, i) {
          this.cell = e;
          this.row = t._row;
          this.column = t._column;
          this.cellAnchorRow = n;
          this.cellAnchorColumn = i;
          this._cellIndex = t._cellIndex;
          this._rowIndex = t._rowIndex;
          this._table = t._table;
        }
        get isAnchor() {
          return (
            this.row === this.cellAnchorRow &&
            this.column === this.cellAnchorColumn
          );
        }
        get cellWidth() {
          return parseInt(this.cell.getAttribute("colspan") || 1);
        }
        get cellHeight() {
          return parseInt(this.cell.getAttribute("rowspan") || 1);
        }
        get rowIndex() {
          return this._rowIndex;
        }
        getPositionBefore() {
          const t = this._table.root.document.model;
          return t.createPositionAt(
            this._table.getChild(this.row),
            this._cellIndex
          );
        }
      }
      function SU(t, e = {}) {
        return (n, { writer: i }) => {
          const o = n.getAttribute("headingRows") || 0;
          const r = [];
          if (o > 0) {
            r.push(
              i.createContainerElement(
                "thead",
                null,
                i.createSlot((t) => t.is("element", "tableRow") && t.index < o)
              )
            );
          }
          if (o < t.getRows(n)) {
            r.push(
              i.createContainerElement(
                "tbody",
                null,
                i.createSlot((t) => t.is("element", "tableRow") && t.index >= o)
              )
            );
          }
          const s = i.createContainerElement("figure", { class: "table" }, [
            i.createContainerElement("table", null, r),
            i.createSlot((t) => !t.is("element", "tableRow")),
          ]);
          return e.asWidget ? LU(s, i) : s;
        };
      }
      function TU() {
        return (t, { writer: e }) =>
          t.isEmpty
            ? e.createEmptyElement("tr")
            : e.createContainerElement("tr");
      }
      function IU(t = {}) {
        return (e, { writer: n }) => {
          const i = e.parent;
          const o = i.parent;
          const r = o.getChildIndex(i);
          const s = new EU(o, { row: r });
          const a = o.getAttribute("headingRows") || 0;
          const c = o.getAttribute("headingColumns") || 0;
          for (const i of s) {
            if (i.cell == e) {
              const e = i.row < a || i.column < c;
              const o = e ? "th" : "td";
              return t.asWidget
                ? dD(n.createEditableElement(o), n)
                : n.createContainerElement(o);
            }
          }
        };
      }
      function MU(t = {}) {
        return (e, { writer: n, consumable: i, mapper: o }) => {
          if (!e.parent.is("element", "tableCell")) {
            return;
          }
          if (!BU(e)) {
            return;
          }
          if (t.asWidget) {
            return n.createContainerElement("span", {
              class: "ck-table-bogus-paragraph",
            });
          } else {
            i.consume(e, "insert");
            o.bindElements(e, o.toViewElement(e.parent));
          }
        };
      }
      function BU(t) {
        const e = t.parent;
        const n = e.childCount == 1;
        return n && !NU(t);
      }
      function LU(t, e) {
        e.setCustomProperty("table", true, t);
        return oD(t, e, { hasSelectionHandle: true });
      }
      function NU(t) {
        return !![...t.getAttributeKeys()].length;
      }
      class zU extends vl {
        refresh() {
          const t = this.editor.model;
          const e = t.document.selection;
          const n = t.schema;
          this.isEnabled = PU(e, n);
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = this.editor.plugins.get("TableUtils");
          const i = this.editor.config.get("table");
          const o = i.defaultHeadings.rows;
          const r = i.defaultHeadings.columns;
          if (t.headingRows === undefined && o) {
            t.headingRows = o;
          }
          if (t.headingColumns === undefined && r) {
            t.headingColumns = r;
          }
          e.change((i) => {
            const o = n.createTable(i, t);
            e.insertObject(o, null, null, { findOptimalPosition: "auto" });
            i.setSelection(i.createPositionAt(o.getNodeByPath([0, 0, 0]), 0));
          });
        }
      }
      function PU(t, e) {
        const n = t.getFirstPosition().parent;
        const i = n === n.root ? n : n.parent;
        return e.checkChild(i, "table");
      }
      class RU extends vl {
        constructor(t, e = {}) {
          super(t);
          this.order = e.order || "below";
        }
        refresh() {
          const t = this.editor.model.document.selection;
          const e = this.editor.plugins.get("TableUtils");
          const n = !!e.getSelectionAffectedTableCells(t).length;
          this.isEnabled = n;
        }
        execute() {
          const t = this.editor;
          const e = t.model.document.selection;
          const n = t.plugins.get("TableUtils");
          const i = this.order === "above";
          const o = n.getSelectionAffectedTableCells(e);
          const r = n.getRowIndexes(o);
          const s = i ? r.first : r.last;
          const a = o[0].findAncestor("table");
          n.insertRows(a, { at: i ? s : s + 1, copyStructureFromAbove: !i });
        }
      }
      class OU extends vl {
        constructor(t, e = {}) {
          super(t);
          this.order = e.order || "right";
        }
        refresh() {
          const t = this.editor.model.document.selection;
          const e = this.editor.plugins.get("TableUtils");
          const n = !!e.getSelectionAffectedTableCells(t).length;
          this.isEnabled = n;
        }
        execute() {
          const t = this.editor;
          const e = t.model.document.selection;
          const n = t.plugins.get("TableUtils");
          const i = this.order === "left";
          const o = n.getSelectionAffectedTableCells(e);
          const r = n.getColumnIndexes(o);
          const s = i ? r.first : r.last;
          const a = o[0].findAncestor("table");
          n.insertColumns(a, { columns: 1, at: i ? s : s + 1 });
        }
      }
      class jU extends vl {
        constructor(t, e = {}) {
          super(t);
          this.direction = e.direction || "horizontally";
        }
        refresh() {
          const t = this.editor.plugins.get("TableUtils");
          const e = t.getSelectionAffectedTableCells(
            this.editor.model.document.selection
          );
          this.isEnabled = e.length === 1;
        }
        execute() {
          const t = this.editor.plugins.get("TableUtils");
          const e = t.getSelectionAffectedTableCells(
            this.editor.model.document.selection
          )[0];
          const n = this.direction === "horizontally";
          if (n) {
            t.splitCellHorizontally(e, 2);
          } else {
            t.splitCellVertically(e, 2);
          }
        }
      }
      function FU(t, e, n) {
        const { startRow: i, startColumn: o, endRow: r, endColumn: s } = e;
        const a = n.createElement("table");
        const c = r - i + 1;
        for (let t = 0; t < c; t++) {
          n.insertElement("tableRow", a, "end");
        }
        const l = [
          ...new EU(t, {
            startRow: i,
            endRow: r,
            startColumn: o,
            endColumn: s,
            includeAllSlots: true,
          }),
        ];
        for (const {
          row: t,
          column: e,
          cell: c,
          isAnchor: d,
          cellAnchorRow: u,
          cellAnchorColumn: h,
        } of l) {
          const l = t - i;
          const m = a.getChild(l);
          if (!d) {
            if (u < i || h < o) {
              pU(n, n.createPositionAt(m, "end"));
            }
          } else {
            const i = n.cloneElement(c);
            n.append(i, m);
            WU(i, t, e, r, s, n);
          }
        }
        GU(a, t, i, o, n);
        return a;
      }
      function VU(t, e, n = 0) {
        const i = [];
        const o = new EU(t, { startRow: n, endRow: e - 1 });
        for (const t of o) {
          const { row: n, cellHeight: o } = t;
          const r = n + o - 1;
          if (n < e && e <= r) {
            i.push(t);
          }
        }
        return i;
      }
      function HU(t, e, n) {
        const i = t.parent;
        const o = i.parent;
        const r = i.index;
        const s = parseInt(t.getAttribute("rowspan"));
        const a = e - r;
        const c = {};
        const l = s - a;
        if (l > 1) {
          c.rowspan = l;
        }
        const d = parseInt(t.getAttribute("colspan") || 1);
        if (d > 1) {
          c.colspan = d;
        }
        const u = r;
        const h = u + a;
        const m = [
          ...new EU(o, { startRow: u, endRow: h, includeAllSlots: true }),
        ];
        let g = null;
        let f;
        for (const e of m) {
          const { row: i, column: o, cell: r } = e;
          if (r === t && f === undefined) {
            f = o;
          }
          if (f !== undefined && f === o && i === h) {
            g = pU(n, e.getPositionBefore(), c);
          }
        }
        fU("rowspan", a, t, n);
        return g;
      }
      function UU(t, e) {
        const n = [];
        const i = new EU(t);
        for (const t of i) {
          const { column: i, cellWidth: o } = t;
          const r = i + o - 1;
          if (i < e && e <= r) {
            n.push(t);
          }
        }
        return n;
      }
      function qU(t, e, n, i) {
        const o = parseInt(t.getAttribute("colspan"));
        const r = n - e;
        const s = {};
        const a = o - r;
        if (a > 1) {
          s.colspan = a;
        }
        const c = parseInt(t.getAttribute("rowspan") || 1);
        if (c > 1) {
          s.rowspan = c;
        }
        const l = pU(i, i.createPositionAfter(t), s);
        fU("colspan", r, t, i);
        return l;
      }
      function WU(t, e, n, i, o, r) {
        const s = parseInt(t.getAttribute("colspan") || 1);
        const a = parseInt(t.getAttribute("rowspan") || 1);
        const c = n + s - 1;
        if (c > o) {
          const e = o - n + 1;
          fU("colspan", e, t, r, 1);
        }
        const l = e + a - 1;
        if (l > i) {
          const n = i - e + 1;
          fU("rowspan", n, t, r, 1);
        }
      }
      function GU(t, e, n, i, o) {
        const r = parseInt(e.getAttribute("headingRows") || 0);
        if (r > 0) {
          const e = r - n;
          fU("headingRows", e, t, o, 0);
        }
        const s = parseInt(e.getAttribute("headingColumns") || 0);
        if (s > 0) {
          const e = s - i;
          fU("headingColumns", e, t, o, 0);
        }
      }
      function $U(t, e) {
        const n = e.getColumns(t);
        const i = new Array(n).fill(0);
        for (const { column: e } of new EU(t)) {
          i[e]++;
        }
        const o = i.reduce((t, e, n) => (e ? t : [...t, n]), []);
        if (o.length > 0) {
          const n = o[o.length - 1];
          e.removeColumns(t, { at: n });
          return true;
        }
        return false;
      }
      function KU(t, e) {
        const n = [];
        const i = e.getRows(t);
        for (let e = 0; e < i; e++) {
          const i = t.getChild(e);
          if (i.isEmpty) {
            n.push(e);
          }
        }
        if (n.length > 0) {
          const i = n[n.length - 1];
          e.removeRows(t, { at: i });
          return true;
        }
        return false;
      }
      function YU(t, e) {
        const n = $U(t, e);
        if (!n) {
          KU(t, e);
        }
      }
      function ZU(t, e) {
        const n = Array.from(
          new EU(t, {
            startColumn: e.firstColumn,
            endColumn: e.lastColumn,
            row: e.lastRow,
          })
        );
        const i = n.every(({ cellHeight: t }) => t === 1);
        if (i) {
          return e.lastRow;
        }
        const o = n[0].cellHeight - 1;
        return e.lastRow + o;
      }
      function QU(t, e) {
        const n = Array.from(
          new EU(t, {
            startRow: e.firstRow,
            endRow: e.lastRow,
            column: e.lastColumn,
          })
        );
        const i = n.every(({ cellWidth: t }) => t === 1);
        if (i) {
          return e.lastColumn;
        }
        const o = n[0].cellWidth - 1;
        return e.lastColumn + o;
      }
      class JU extends vl {
        constructor(t, e) {
          super(t);
          this.direction = e.direction;
          this.isHorizontal =
            this.direction == "right" || this.direction == "left";
        }
        refresh() {
          const t = this._getMergeableCell();
          this.value = t;
          this.isEnabled = !!t;
        }
        execute() {
          const t = this.editor.model;
          const e = t.document;
          const n = this.editor.plugins.get("TableUtils");
          const i = n.getTableCellsContainingSelection(e.selection)[0];
          const o = this.value;
          const r = this.direction;
          t.change((t) => {
            const e = r == "right" || r == "down";
            const n = e ? i : o;
            const s = e ? o : i;
            const a = s.parent;
            eq(s, n, t);
            const c = this.isHorizontal ? "colspan" : "rowspan";
            const l = parseInt(i.getAttribute(c) || 1);
            const d = parseInt(o.getAttribute(c) || 1);
            t.setAttribute(c, l + d, n);
            t.setSelection(t.createRangeIn(n));
            const u = this.editor.plugins.get("TableUtils");
            const h = a.findAncestor("table");
            YU(h, u);
          });
        }
        _getMergeableCell() {
          const t = this.editor.model;
          const e = t.document;
          const n = this.editor.plugins.get("TableUtils");
          const i = n.getTableCellsContainingSelection(e.selection)[0];
          if (!i) {
            return;
          }
          const o = this.isHorizontal
            ? XU(i, this.direction, n)
            : tq(i, this.direction, n);
          if (!o) {
            return;
          }
          const r = this.isHorizontal ? "rowspan" : "colspan";
          const s = parseInt(i.getAttribute(r) || 1);
          const a = parseInt(o.getAttribute(r) || 1);
          if (a === s) {
            return o;
          }
        }
      }
      function XU(t, e, n) {
        const i = t.parent;
        const o = i.parent;
        const r = e == "right" ? t.nextSibling : t.previousSibling;
        const s = (o.getAttribute("headingColumns") || 0) > 0;
        if (!r) {
          return;
        }
        const a = e == "right" ? t : r;
        const c = e == "right" ? r : t;
        const { column: l } = n.getCellLocation(a);
        const { column: d } = n.getCellLocation(c);
        const u = parseInt(a.getAttribute("colspan") || 1);
        const h = bU(n, a, o);
        const m = bU(n, c, o);
        if (s && h != m) {
          return;
        }
        const g = l + u === d;
        return g ? r : undefined;
      }
      function tq(t, e, n) {
        const i = t.parent;
        const o = i.parent;
        const r = o.getChildIndex(i);
        if ((e == "down" && r === n.getRows(o) - 1) || (e == "up" && r === 0)) {
          return;
        }
        const s = parseInt(t.getAttribute("rowspan") || 1);
        const a = o.getAttribute("headingRows") || 0;
        const c = e == "down" && r + s === a;
        const l = e == "up" && r === a;
        if (a && (c || l)) {
          return;
        }
        const d = parseInt(t.getAttribute("rowspan") || 1);
        const u = e == "down" ? r + d : r;
        const h = [...new EU(o, { endRow: u })];
        const m = h.find((e) => e.cell === t);
        const g = m.column;
        const f = h.find(({ row: t, cellHeight: n, column: i }) => {
          if (i !== g) {
            return false;
          }
          if (e == "down") {
            return t === u;
          } else {
            return u === t + n;
          }
        });
        return f && f.cell;
      }
      function eq(t, e, n) {
        if (!nq(t)) {
          if (nq(e)) {
            n.remove(n.createRangeIn(e));
          }
          n.move(n.createRangeIn(t), n.createPositionAt(e, "end"));
        }
        n.remove(t);
      }
      function nq(t) {
        return (
          t.childCount == 1 &&
          t.getChild(0).is("element", "paragraph") &&
          t.getChild(0).isEmpty
        );
      }
      class iq extends vl {
        refresh() {
          const t = this.editor.plugins.get("TableUtils");
          const e = t.getSelectionAffectedTableCells(
            this.editor.model.document.selection
          );
          const n = e[0];
          if (n) {
            const i = n.findAncestor("table");
            const o = this.editor.plugins.get("TableUtils").getRows(i);
            const r = o - 1;
            const s = t.getRowIndexes(e);
            const a = s.first === 0 && s.last === r;
            this.isEnabled = !a;
          } else {
            this.isEnabled = false;
          }
        }
        execute() {
          const t = this.editor.model;
          const e = this.editor.plugins.get("TableUtils");
          const n = e.getSelectionAffectedTableCells(t.document.selection);
          const i = e.getRowIndexes(n);
          const o = n[0];
          const r = o.findAncestor("table");
          const s = e.getCellLocation(o).column;
          t.change((t) => {
            const n = i.last - i.first + 1;
            e.removeRows(r, { at: i.first, rows: n });
            const o = oq(r, i.first, s, e.getRows(r));
            t.setSelection(t.createPositionAt(o, 0));
          });
        }
      }
      function oq(t, e, n, i) {
        const o = t.getChild(Math.min(e, i - 1));
        let r = o.getChild(0);
        let s = 0;
        for (const t of o.getChildren()) {
          if (s > n) {
            return r;
          }
          r = t;
          s += parseInt(t.getAttribute("colspan") || 1);
        }
        return r;
      }
      class rq extends vl {
        refresh() {
          const t = this.editor.plugins.get("TableUtils");
          const e = t.getSelectionAffectedTableCells(
            this.editor.model.document.selection
          );
          const n = e[0];
          if (n) {
            const i = n.findAncestor("table");
            const o = t.getColumns(i);
            const { first: r, last: s } = t.getColumnIndexes(e);
            this.isEnabled = s - r < o - 1;
          } else {
            this.isEnabled = false;
          }
        }
        execute() {
          const t = this.editor.plugins.get("TableUtils");
          const [e, n] = aq(this.editor.model.document.selection, t);
          const i = e.parent.parent;
          const o = [...new EU(i)];
          const r = {
            first: o.find((t) => t.cell === e).column,
            last: o.find((t) => t.cell === n).column,
          };
          const s = sq(o, e, n, r);
          this.editor.model.change((t) => {
            const e = r.last - r.first + 1;
            this.editor.plugins
              .get("TableUtils")
              .removeColumns(i, { at: r.first, columns: e });
            t.setSelection(t.createPositionAt(s, 0));
          });
        }
      }
      function sq(t, e, n, i) {
        const o = parseInt(n.getAttribute("colspan") || 1);
        if (o > 1) {
          return n;
        } else if (e.previousSibling || n.nextSibling) {
          return n.nextSibling || e.previousSibling;
        } else {
          if (i.first) {
            return t.reverse().find(({ column: t }) => t < i.first).cell;
          } else {
            return t.reverse().find(({ column: t }) => t > i.last).cell;
          }
        }
      }
      function aq(t, e) {
        const n = e.getSelectionAffectedTableCells(t);
        const i = n[0];
        const o = n.pop();
        const r = [i, o];
        return i.isBefore(o) ? r : r.reverse();
      }
      class cq extends vl {
        refresh() {
          const t = this.editor.plugins.get("TableUtils");
          const e = this.editor.model;
          const n = t.getSelectionAffectedTableCells(e.document.selection);
          const i = n.length > 0;
          this.isEnabled = i;
          this.value =
            i && n.every((t) => this._isInHeading(t, t.parent.parent));
        }
        execute(t = {}) {
          if (t.forceValue === this.value) {
            return;
          }
          const e = this.editor.plugins.get("TableUtils");
          const n = this.editor.model;
          const i = e.getSelectionAffectedTableCells(n.document.selection);
          const o = i[0].findAncestor("table");
          const { first: r, last: s } = e.getRowIndexes(i);
          const a = this.value ? r : s + 1;
          const c = o.getAttribute("headingRows") || 0;
          n.change((t) => {
            if (a) {
              const e = a > c ? c : 0;
              const n = VU(o, a, e);
              for (const { cell: e } of n) {
                HU(e, a, t);
              }
            }
            fU("headingRows", a, o, t, 0);
          });
        }
        _isInHeading(t, e) {
          const n = parseInt(e.getAttribute("headingRows") || 0);
          return !!n && t.parent.index < n;
        }
      }
      class lq extends vl {
        refresh() {
          const t = this.editor.model;
          const e = this.editor.plugins.get("TableUtils");
          const n = e.getSelectionAffectedTableCells(t.document.selection);
          const i = n.length > 0;
          this.isEnabled = i;
          this.value = i && n.every((t) => bU(e, t));
        }
        execute(t = {}) {
          if (t.forceValue === this.value) {
            return;
          }
          const e = this.editor.plugins.get("TableUtils");
          const n = this.editor.model;
          const i = e.getSelectionAffectedTableCells(n.document.selection);
          const o = i[0].findAncestor("table");
          const { first: r, last: s } = e.getColumnIndexes(i);
          const a = this.value ? r : s + 1;
          n.change((t) => {
            if (a) {
              const e = UU(o, a);
              for (const { cell: n, column: i } of e) {
                qU(n, i, a, t);
              }
            }
            fU("headingColumns", a, o, t, 0);
          });
        }
      }
      class dq extends Cl {
        static get pluginName() {
          return "TableUtils";
        }
        init() {
          this.decorate("insertColumns");
          this.decorate("insertRows");
        }
        getCellLocation(t) {
          const e = t.parent;
          const n = e.parent;
          const i = n.getChildIndex(e);
          const o = new EU(n, { row: i });
          for (const { cell: e, row: n, column: i } of o) {
            if (e === t) {
              return { row: n, column: i };
            }
          }
        }
        createTable(t, e) {
          const n = t.createElement("table");
          const i = parseInt(e.rows) || 2;
          const o = parseInt(e.columns) || 2;
          uq(t, n, 0, i, o);
          if (e.headingRows) {
            fU("headingRows", Math.min(e.headingRows, i), n, t, 0);
          }
          if (e.headingColumns) {
            fU("headingColumns", Math.min(e.headingColumns, o), n, t, 0);
          }
          return n;
        }
        insertRows(t, e = {}) {
          const n = this.editor.model;
          const i = e.at || 0;
          const o = e.rows || 1;
          const r = e.copyStructureFromAbove !== undefined;
          const s = e.copyStructureFromAbove ? i - 1 : i;
          const a = this.getRows(t);
          const c = this.getColumns(t);
          if (i > a) {
            throw new M("tableutils-insertrows-insert-out-of-range", this, {
              options: e,
            });
          }
          n.change((e) => {
            const n = t.getAttribute("headingRows") || 0;
            if (n > i) {
              fU("headingRows", n + o, t, e, 0);
            }
            if (!r && (i === 0 || i === a)) {
              uq(e, t, i, o, c);
              return;
            }
            const l = r ? Math.max(i, s) : i;
            const d = new EU(t, { endRow: l });
            const u = new Array(c).fill(1);
            for (const {
              row: t,
              column: n,
              cellHeight: a,
              cellWidth: c,
              cell: l,
            } of d) {
              const d = t + a - 1;
              const h = t < i && i <= d;
              const m = t <= s && s <= d;
              if (h) {
                e.setAttribute("rowspan", a + o, l);
                u[n] = -c;
              } else if (r && m) {
                u[n] = c;
              }
            }
            for (let n = 0; n < o; n++) {
              const n = e.createElement("tableRow");
              e.insert(n, t, i);
              for (let t = 0; t < u.length; t++) {
                const i = u[t];
                const o = e.createPositionAt(n, "end");
                if (i > 0) {
                  pU(e, o, i > 1 ? { colspan: i } : null);
                }
                t += Math.abs(i) - 1;
              }
            }
          });
        }
        insertColumns(t, e = {}) {
          const n = this.editor.model;
          const i = e.at || 0;
          const o = e.columns || 1;
          n.change((e) => {
            const n = t.getAttribute("headingColumns");
            if (i < n) {
              e.setAttribute("headingColumns", n + o, t);
            }
            const r = this.getColumns(t);
            if (i === 0 || r === i) {
              for (const n of t.getChildren()) {
                if (!n.is("element", "tableRow")) {
                  continue;
                }
                hq(o, e, e.createPositionAt(n, i ? "end" : 0));
              }
              return;
            }
            const s = new EU(t, { column: i, includeAllSlots: true });
            for (const t of s) {
              const {
                row: n,
                cell: r,
                cellAnchorColumn: a,
                cellAnchorRow: c,
                cellWidth: l,
                cellHeight: d,
              } = t;
              if (a < i) {
                e.setAttribute("colspan", l + o, r);
                const t = c + d - 1;
                for (let e = n; e <= t; e++) {
                  s.skipRow(e);
                }
              } else {
                hq(o, e, t.getPositionBefore());
              }
            }
          });
        }
        removeRows(t, e) {
          const n = this.editor.model;
          const i = e.rows || 1;
          const o = this.getRows(t);
          const r = e.at;
          const s = r + i - 1;
          if (s > o - 1) {
            throw new M("tableutils-removerows-row-index-out-of-range", this, {
              table: t,
              options: e,
            });
          }
          n.change((e) => {
            const { cellsToMove: n, cellsToTrim: i } = pq(t, r, s);
            if (n.size) {
              const i = s + 1;
              bq(t, i, n, e);
            }
            for (let n = s; n >= r; n--) {
              e.remove(t.getChild(n));
            }
            for (const { rowspan: t, cell: n } of i) {
              fU("rowspan", t, n, e);
            }
            fq(t, r, s, e);
            if (!$U(t, this)) {
              KU(t, this);
            }
          });
        }
        removeColumns(t, e) {
          const n = this.editor.model;
          const i = e.at;
          const o = e.columns || 1;
          const r = e.at + o - 1;
          n.change((e) => {
            gq(t, { first: i, last: r }, e);
            for (let n = r; n >= i; n--) {
              for (const { cell: i, column: o, cellWidth: r } of [
                ...new EU(t),
              ]) {
                if (o <= n && r > 1 && o + r > n) {
                  fU("colspan", r - 1, i, e);
                } else if (o === n) {
                  e.remove(i);
                }
              }
            }
            if (!KU(t, this)) {
              $U(t, this);
            }
          });
        }
        splitCellVertically(t, e = 2) {
          const n = this.editor.model;
          const i = t.parent;
          const o = i.parent;
          const r = parseInt(t.getAttribute("rowspan") || 1);
          const s = parseInt(t.getAttribute("colspan") || 1);
          n.change((n) => {
            if (s > 1) {
              const { newCellsSpan: i, updatedSpan: o } = mq(s, e);
              fU("colspan", o, t, n);
              const a = {};
              if (i > 1) {
                a.colspan = i;
              }
              if (r > 1) {
                a.rowspan = r;
              }
              const c = s > e ? e - 1 : s - 1;
              hq(c, n, n.createPositionAfter(t), a);
            }
            if (s < e) {
              const i = e - s;
              const a = [...new EU(o)];
              const { column: c } = a.find(({ cell: e }) => e === t);
              const l = a.filter(({ cell: e, cellWidth: n, column: i }) => {
                const o = e !== t && i === c;
                const r = i < c && i + n > c;
                return o || r;
              });
              for (const { cell: t, cellWidth: e } of l) {
                n.setAttribute("colspan", e + i, t);
              }
              const d = {};
              if (r > 1) {
                d.rowspan = r;
              }
              hq(i, n, n.createPositionAfter(t), d);
              const u = o.getAttribute("headingColumns") || 0;
              if (u > c) {
                fU("headingColumns", u + i, o, n);
              }
            }
          });
        }
        splitCellHorizontally(t, e = 2) {
          const n = this.editor.model;
          const i = t.parent;
          const o = i.parent;
          const r = o.getChildIndex(i);
          const s = parseInt(t.getAttribute("rowspan") || 1);
          const a = parseInt(t.getAttribute("colspan") || 1);
          n.change((n) => {
            if (s > 1) {
              const i = [
                ...new EU(o, {
                  startRow: r,
                  endRow: r + s - 1,
                  includeAllSlots: true,
                }),
              ];
              const { newCellsSpan: c, updatedSpan: l } = mq(s, e);
              fU("rowspan", l, t, n);
              const { column: d } = i.find(({ cell: e }) => e === t);
              const u = {};
              if (c > 1) {
                u.rowspan = c;
              }
              if (a > 1) {
                u.colspan = a;
              }
              for (const t of i) {
                const { column: e, row: i } = t;
                const o = i >= r + l;
                const s = e === d;
                const a = (i + r + l) % c === 0;
                if (o && s && a) {
                  hq(1, n, t.getPositionBefore(), u);
                }
              }
            }
            if (s < e) {
              const i = e - s;
              const c = [...new EU(o, { startRow: 0, endRow: r })];
              for (const { cell: e, cellHeight: o, row: s } of c) {
                if (e !== t && s + o > r) {
                  const t = o + i;
                  n.setAttribute("rowspan", t, e);
                }
              }
              const l = {};
              if (a > 1) {
                l.colspan = a;
              }
              uq(n, o, r + 1, i, 1, l);
              const d = o.getAttribute("headingRows") || 0;
              if (d > r) {
                fU("headingRows", d + i, o, n);
              }
            }
          });
        }
        getColumns(t) {
          const e = t.getChild(0);
          return [...e.getChildren()].reduce((t, e) => {
            const n = parseInt(e.getAttribute("colspan") || 1);
            return t + n;
          }, 0);
        }
        getRows(t) {
          return Array.from(t.getChildren()).reduce(
            (t, e) => (e.is("element", "tableRow") ? t + 1 : t),
            0
          );
        }
        createTableWalker(t, e = {}) {
          return new EU(t, e);
        }
        getSelectedTableCells(t) {
          const e = [];
          for (const n of this.sortRanges(t.getRanges())) {
            const t = n.getContainedElement();
            if (t && t.is("element", "tableCell")) {
              e.push(t);
            }
          }
          return e;
        }
        getTableCellsContainingSelection(t) {
          const e = [];
          for (const n of t.getRanges()) {
            const t = n.start.findAncestor("tableCell");
            if (t) {
              e.push(t);
            }
          }
          return e;
        }
        getSelectionAffectedTableCells(t) {
          const e = this.getSelectedTableCells(t);
          if (e.length) {
            return e;
          }
          return this.getTableCellsContainingSelection(t);
        }
        getRowIndexes(t) {
          const e = t.map((t) => t.parent.index);
          return this._getFirstLastIndexesObject(e);
        }
        getColumnIndexes(t) {
          const e = t[0].findAncestor("table");
          const n = [...new EU(e)];
          const i = n.filter((e) => t.includes(e.cell)).map((t) => t.column);
          return this._getFirstLastIndexesObject(i);
        }
        isSelectionRectangular(t) {
          if (t.length < 2 || !this._areCellInTheSameTableSection(t)) {
            return false;
          }
          const e = new Set();
          const n = new Set();
          let i = 0;
          for (const o of t) {
            const { row: t, column: r } = this.getCellLocation(o);
            const s = parseInt(o.getAttribute("rowspan") || 1);
            const a = parseInt(o.getAttribute("colspan") || 1);
            e.add(t);
            n.add(r);
            if (s > 1) {
              e.add(t + s - 1);
            }
            if (a > 1) {
              n.add(r + a - 1);
            }
            i += s * a;
          }
          const o = wq(e, n);
          return o == i;
        }
        sortRanges(t) {
          return Array.from(t).sort(kq);
        }
        _getFirstLastIndexesObject(t) {
          const e = t.sort((t, e) => t - e);
          const n = e[0];
          const i = e[e.length - 1];
          return { first: n, last: i };
        }
        _areCellInTheSameTableSection(t) {
          const e = t[0].findAncestor("table");
          const n = this.getRowIndexes(t);
          const i = parseInt(e.getAttribute("headingRows") || 0);
          if (!this._areIndexesInSameSection(n, i)) {
            return false;
          }
          const o = parseInt(e.getAttribute("headingColumns") || 0);
          const r = this.getColumnIndexes(t);
          return this._areIndexesInSameSection(r, o);
        }
        _areIndexesInSameSection({ first: t, last: e }, n) {
          const i = t < n;
          const o = e < n;
          return i === o;
        }
      }
      function uq(t, e, n, i, o, r = {}) {
        for (let s = 0; s < i; s++) {
          const i = t.createElement("tableRow");
          t.insert(i, e, n);
          hq(o, t, t.createPositionAt(i, "end"), r);
        }
      }
      function hq(t, e, n, i = {}) {
        for (let o = 0; o < t; o++) {
          pU(e, n, i);
        }
      }
      function mq(t, e) {
        if (t < e) {
          return { newCellsSpan: 1, updatedSpan: 1 };
        }
        const n = Math.floor(t / e);
        const i = t - n * e + n;
        return { newCellsSpan: n, updatedSpan: i };
      }
      function gq(t, e, n) {
        const i = t.getAttribute("headingColumns") || 0;
        if (i && e.first < i) {
          const o = Math.min(i - 1, e.last) - e.first + 1;
          n.setAttribute("headingColumns", i - o, t);
        }
      }
      function fq(t, e, n, i) {
        const o = t.getAttribute("headingRows") || 0;
        if (e < o) {
          const r = n < o ? o - (n - e + 1) : e;
          fU("headingRows", r, t, i, 0);
        }
      }
      function pq(t, e, n) {
        const i = new Map();
        const o = [];
        for (const { row: r, column: s, cellHeight: a, cell: c } of new EU(t, {
          endRow: n,
        })) {
          const t = r + a - 1;
          const l = r >= e && r <= n && t > n;
          if (l) {
            const t = n - r + 1;
            const e = a - t;
            i.set(s, { cell: c, rowspan: e });
          }
          const d = r < e && t >= e;
          if (d) {
            let i;
            if (t >= n) {
              i = n - e + 1;
            } else {
              i = t - e + 1;
            }
            o.push({ cell: c, rowspan: a - i });
          }
        }
        return { cellsToMove: i, cellsToTrim: o };
      }
      function bq(t, e, n, i) {
        const o = new EU(t, { includeAllSlots: true, row: e });
        const r = [...o];
        const s = t.getChild(e);
        let a;
        for (const { column: t, cell: e, isAnchor: o } of r) {
          if (n.has(t)) {
            const { cell: e, rowspan: o } = n.get(t);
            const r = a ? i.createPositionAfter(a) : i.createPositionAt(s, 0);
            i.move(i.createRangeOn(e), r);
            fU("rowspan", o, e, i);
            a = e;
          } else if (o) {
            a = e;
          }
        }
      }
      function kq(t, e) {
        const n = t.start;
        const i = e.start;
        return n.isBefore(i) ? -1 : 1;
      }
      function wq(t, e) {
        const n = Array.from(t.values());
        const i = Array.from(e.values());
        const o = Math.max(...n);
        const r = Math.min(...n);
        const s = Math.max(...i);
        const a = Math.min(...i);
        return (o - r + 1) * (s - a + 1);
      }
      class Aq extends vl {
        refresh() {
          const t = this.editor.plugins.get(dq);
          const e = t.getSelectedTableCells(
            this.editor.model.document.selection
          );
          this.isEnabled = t.isSelectionRectangular(
            e,
            this.editor.plugins.get(dq)
          );
        }
        execute() {
          const t = this.editor.model;
          const e = this.editor.plugins.get(dq);
          t.change((n) => {
            const i = e.getSelectedTableCells(t.document.selection);
            const o = i.shift();
            const { mergeWidth: r, mergeHeight: s } = vq(o, i, e);
            fU("colspan", r, o, n);
            fU("rowspan", s, o, n);
            for (const t of i) {
              Cq(t, o, n);
            }
            const a = o.findAncestor("table");
            YU(a, e);
            n.setSelection(o, "in");
          });
        }
      }
      function Cq(t, e, n) {
        if (!_q(t)) {
          if (_q(e)) {
            n.remove(n.createRangeIn(e));
          }
          n.move(n.createRangeIn(t), n.createPositionAt(e, "end"));
        }
        n.remove(t);
      }
      function _q(t) {
        return (
          t.childCount == 1 &&
          t.getChild(0).is("element", "paragraph") &&
          t.getChild(0).isEmpty
        );
      }
      function vq(t, e, n) {
        let i = 0;
        let o = 0;
        for (const t of e) {
          const { row: e, column: r } = n.getCellLocation(t);
          i = yq(t, r, i, "colspan");
          o = yq(t, e, o, "rowspan");
        }
        const { row: r, column: s } = n.getCellLocation(t);
        const a = i - s;
        const c = o - r;
        return { mergeWidth: a, mergeHeight: c };
      }
      function yq(t, e, n, i) {
        const o = parseInt(t.getAttribute(i) || 1);
        return Math.max(n, e + o);
      }
      class xq extends vl {
        constructor(t) {
          super(t);
          this.affectsData = false;
        }
        refresh() {
          const t = this.editor.plugins.get("TableUtils");
          const e = t.getSelectionAffectedTableCells(
            this.editor.model.document.selection
          );
          this.isEnabled = e.length > 0;
        }
        execute() {
          const t = this.editor.model;
          const e = this.editor.plugins.get("TableUtils");
          const n = e.getSelectionAffectedTableCells(t.document.selection);
          const i = e.getRowIndexes(n);
          const o = n[0].findAncestor("table");
          const r = [];
          for (let e = i.first; e <= i.last; e++) {
            for (const n of o.getChild(e).getChildren()) {
              r.push(t.createRangeOn(n));
            }
          }
          t.change((t) => {
            t.setSelection(r);
          });
        }
      }
      class Eq extends vl {
        constructor(t) {
          super(t);
          this.affectsData = false;
        }
        refresh() {
          const t = this.editor.plugins.get("TableUtils");
          const e = t.getSelectionAffectedTableCells(
            this.editor.model.document.selection
          );
          this.isEnabled = e.length > 0;
        }
        execute() {
          const t = this.editor.plugins.get("TableUtils");
          const e = this.editor.model;
          const n = t.getSelectionAffectedTableCells(e.document.selection);
          const i = n[0];
          const o = n.pop();
          const r = i.findAncestor("table");
          const s = t.getCellLocation(i);
          const a = t.getCellLocation(o);
          const c = Math.min(s.column, a.column);
          const l = Math.max(s.column, a.column);
          const d = [];
          for (const t of new EU(r, { startColumn: c, endColumn: l })) {
            d.push(e.createRangeOn(t.cell));
          }
          e.change((t) => {
            t.setSelection(d);
          });
        }
      }
      function Dq(t) {
        t.document.registerPostFixer((e) => Sq(e, t));
      }
      function Sq(t, e) {
        const n = e.document.differ.getChanges();
        let i = false;
        const o = new Set();
        for (const e of n) {
          let n;
          if (e.name == "table" && e.type == "insert") {
            n = e.position.nodeAfter;
          }
          if (e.name == "tableRow" || e.name == "tableCell") {
            n = e.position.findAncestor("table");
          }
          if (Lq(e)) {
            n = e.range.start.findAncestor("table");
          }
          if (n && !o.has(n)) {
            i = Tq(n, t) || i;
            i = Iq(n, t) || i;
            o.add(n);
          }
        }
        return i;
      }
      function Tq(t, e) {
        let n = false;
        const i = Mq(t);
        if (i.length) {
          n = true;
          for (const t of i) {
            fU("rowspan", t.rowspan, t.cell, e, 1);
          }
        }
        return n;
      }
      function Iq(t, e) {
        let n = false;
        const i = Bq(t);
        const o = [];
        for (const [e, n] of i.entries()) {
          if (!n && t.getChild(e).is("element", "tableRow")) {
            o.push(e);
          }
        }
        if (o.length) {
          n = true;
          for (const n of o.reverse()) {
            e.remove(t.getChild(n));
            i.splice(n, 1);
          }
        }
        const r = i.filter((e, n) => t.getChild(n).is("element", "tableRow"));
        const s = r[0];
        const a = r.every((t) => t === s);
        if (!a) {
          const i = r.reduce((t, e) => (e > t ? e : t), 0);
          for (const [o, s] of r.entries()) {
            const r = i - s;
            if (r) {
              for (let n = 0; n < r; n++) {
                pU(e, e.createPositionAt(t.getChild(o), "end"));
              }
              n = true;
            }
          }
        }
        return n;
      }
      function Mq(t) {
        const e = parseInt(t.getAttribute("headingRows") || 0);
        const n = Array.from(t.getChildren()).reduce(
          (t, e) => (e.is("element", "tableRow") ? t + 1 : t),
          0
        );
        const i = [];
        for (const { row: o, cell: r, cellHeight: s } of new EU(t)) {
          if (s < 2) {
            continue;
          }
          const t = o < e;
          const a = t ? e : n;
          if (o + s > a) {
            const t = a - o;
            i.push({ cell: r, rowspan: t });
          }
        }
        return i;
      }
      function Bq(t) {
        const e = new Array(t.childCount).fill(0);
        for (const { rowIndex: n } of new EU(t, { includeAllSlots: true })) {
          e[n]++;
        }
        return e;
      }
      function Lq(t) {
        const e = t.type === "attribute";
        const n = t.attributeKey;
        return e && (n === "headingRows" || n === "colspan" || n === "rowspan");
      }
      function Nq(t) {
        t.document.registerPostFixer((e) => zq(e, t));
      }
      function zq(t, e) {
        const n = e.document.differ.getChanges();
        let i = false;
        for (const e of n) {
          if (e.type == "insert" && e.name == "table") {
            i = Pq(e.position.nodeAfter, t) || i;
          }
          if (e.type == "insert" && e.name == "tableRow") {
            i = Rq(e.position.nodeAfter, t) || i;
          }
          if (e.type == "insert" && e.name == "tableCell") {
            i = Oq(e.position.nodeAfter, t) || i;
          }
          if (jq(e)) {
            i = Oq(e.position.parent, t) || i;
          }
        }
        return i;
      }
      function Pq(t, e) {
        let n = false;
        for (const i of t.getChildren()) {
          if (i.is("element", "tableRow")) {
            n = Rq(i, e) || n;
          }
        }
        return n;
      }
      function Rq(t, e) {
        let n = false;
        for (const i of t.getChildren()) {
          n = Oq(i, e) || n;
        }
        return n;
      }
      function Oq(t, e) {
        if (t.childCount == 0) {
          e.insertElement("paragraph", t);
          return true;
        }
        const n = Array.from(t.getChildren()).filter((t) => t.is("$text"));
        for (const t of n) {
          e.wrap(e.createRangeOn(t), "paragraph");
        }
        return !!n.length;
      }
      function jq(t) {
        if (!t.position || !t.position.parent.is("element", "tableCell")) {
          return false;
        }
        return (t.type == "insert" && t.name == "$text") || t.type == "remove";
      }
      function Fq(t, e) {
        const n = t.document.differ;
        for (const t of n.getChanges()) {
          let n;
          let i = false;
          if (t.type == "attribute") {
            const e = t.range.start.nodeAfter;
            if (!e || !e.is("element", "table")) {
              continue;
            }
            if (
              t.attributeKey != "headingRows" &&
              t.attributeKey != "headingColumns"
            ) {
              continue;
            }
            n = e;
            i = t.attributeKey == "headingRows";
          } else if (t.name == "tableRow" || t.name == "tableCell") {
            n = t.position.findAncestor("table");
            i = t.name == "tableRow";
          }
          if (!n) {
            continue;
          }
          const o = n.getAttribute("headingRows") || 0;
          const r = n.getAttribute("headingColumns") || 0;
          const s = new EU(n);
          for (const t of s) {
            const n = t.row < o || t.column < r;
            const s = n ? "th" : "td";
            const a = e.mapper.toViewElement(t.cell);
            if (a && a.is("element") && a.name != s) {
              e.reconvertItem(i ? t.cell.parent : t.cell);
            }
          }
        }
      }
      function Vq(t, e) {
        const n = t.document.differ;
        const i = new Set();
        for (const t of n.getChanges()) {
          const e =
            t.type == "attribute" ? t.range.start.parent : t.position.parent;
          if (e.is("element", "tableCell")) {
            i.add(e);
          }
        }
        for (const t of i.values()) {
          const n = Array.from(t.getChildren()).filter((t) => Hq(t, e.mapper));
          for (const t of n) {
            e.reconvertItem(t);
          }
        }
      }
      function Hq(t, e) {
        if (!t.is("element", "paragraph")) {
          return false;
        }
        const n = e.toViewElement(t);
        if (!n) {
          return false;
        }
        return BU(t) !== n.is("element", "span");
      }
      var Uq = n(4777);
      var qq = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      qq.insert = "head";
      qq.singleton = true;
      var Wq = Il()(Uq.Z, qq);
      const Gq = Uq.Z.locals || {};
      class $q extends Cl {
        static get pluginName() {
          return "TableEditing";
        }
        static get requires() {
          return [dq];
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = e.schema;
          const i = t.conversion;
          const o = t.plugins.get(dq);
          n.register("table", {
            inheritAllFrom: "$blockObject",
            allowAttributes: ["headingRows", "headingColumns"],
          });
          n.register("tableRow", { allowIn: "table", isLimit: true });
          n.register("tableCell", {
            allowContentOf: "$container",
            allowIn: "tableRow",
            allowAttributes: ["colspan", "rowspan"],
            isLimit: true,
            isSelectable: true,
          });
          i.for("upcast").add(wU());
          i.for("upcast").add(AU());
          i.for("editingDowncast").elementToStructure({
            model: { name: "table", attributes: ["headingRows"] },
            view: SU(o, { asWidget: true }),
          });
          i.for("dataDowncast").elementToStructure({
            model: { name: "table", attributes: ["headingRows"] },
            view: SU(o),
          });
          i.for("upcast").elementToElement({ model: "tableRow", view: "tr" });
          i.for("upcast").add(CU());
          i.for("downcast").elementToElement({ model: "tableRow", view: TU() });
          i.for("upcast").elementToElement({ model: "tableCell", view: "td" });
          i.for("upcast").elementToElement({ model: "tableCell", view: "th" });
          i.for("upcast").add(_U("td"));
          i.for("upcast").add(_U("th"));
          i.for("editingDowncast").elementToElement({
            model: "tableCell",
            view: IU({ asWidget: true }),
          });
          i.for("dataDowncast").elementToElement({
            model: "tableCell",
            view: IU(),
          });
          i.for("editingDowncast").elementToElement({
            model: "paragraph",
            view: MU({ asWidget: true }),
            converterPriority: "high",
          });
          i.for("dataDowncast").elementToElement({
            model: "paragraph",
            view: MU(),
            converterPriority: "high",
          });
          i.for("downcast").attributeToAttribute({
            model: "colspan",
            view: "colspan",
          });
          i.for("upcast").attributeToAttribute({
            model: { key: "colspan", value: Yq("colspan") },
            view: "colspan",
          });
          i.for("downcast").attributeToAttribute({
            model: "rowspan",
            view: "rowspan",
          });
          i.for("upcast").attributeToAttribute({
            model: { key: "rowspan", value: Yq("rowspan") },
            view: "rowspan",
          });
          t.data.mapper.on("modelToViewPosition", Kq());
          t.config.define("table.defaultHeadings.rows", 0);
          t.config.define("table.defaultHeadings.columns", 0);
          t.commands.add("insertTable", new zU(t));
          t.commands.add("insertTableRowAbove", new RU(t, { order: "above" }));
          t.commands.add("insertTableRowBelow", new RU(t, { order: "below" }));
          t.commands.add("insertTableColumnLeft", new OU(t, { order: "left" }));
          t.commands.add(
            "insertTableColumnRight",
            new OU(t, { order: "right" })
          );
          t.commands.add("removeTableRow", new iq(t));
          t.commands.add("removeTableColumn", new rq(t));
          t.commands.add(
            "splitTableCellVertically",
            new jU(t, { direction: "vertically" })
          );
          t.commands.add(
            "splitTableCellHorizontally",
            new jU(t, { direction: "horizontally" })
          );
          t.commands.add("mergeTableCells", new Aq(t));
          t.commands.add(
            "mergeTableCellRight",
            new JU(t, { direction: "right" })
          );
          t.commands.add(
            "mergeTableCellLeft",
            new JU(t, { direction: "left" })
          );
          t.commands.add(
            "mergeTableCellDown",
            new JU(t, { direction: "down" })
          );
          t.commands.add("mergeTableCellUp", new JU(t, { direction: "up" }));
          t.commands.add("setTableColumnHeader", new lq(t));
          t.commands.add("setTableRowHeader", new cq(t));
          t.commands.add("selectTableRow", new xq(t));
          t.commands.add("selectTableColumn", new Eq(t));
          Dq(e);
          Nq(e);
          this.listenTo(e.document, "change:data", () => {
            Fq(e, t.editing);
            Vq(e, t.editing);
          });
        }
      }
      function Kq() {
        return (t, e) => {
          const n = e.modelPosition.parent;
          const i = e.modelPosition.nodeBefore;
          if (!n.is("element", "tableCell")) {
            return;
          }
          if (!i || !i.is("element", "paragraph")) {
            return;
          }
          const o = e.mapper.toViewElement(i);
          const r = e.mapper.toViewElement(n);
          if (o === r) {
            e.viewPosition = e.mapper.findPositionIn(r, i.maxOffset);
          }
        };
      }
      function Yq(t) {
        return (e) => {
          const n = parseInt(e.getAttribute(t));
          if (Number.isNaN(n) || n <= 0) {
            return null;
          }
          return n;
        };
      }
      var Zq = n(8085);
      var Qq = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Qq.insert = "head";
      Qq.singleton = true;
      var Jq = Il()(Zq.Z, Qq);
      const Xq = Zq.Z.locals || {};
      class tW extends pC {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.items = this._createGridCollection();
          this.keystrokes = new cl();
          this.focusTracker = new al();
          this.set("rows", 0);
          this.set("columns", 0);
          this.bind("label").to(
            this,
            "columns",
            this,
            "rows",
            (t, e) => \`\${e}  \${t}\`
          );
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck"] },
            children: [
              {
                tag: "div",
                attributes: { class: ["ck-insert-table-dropdown__grid"] },
                on: {
                  "mouseover@.ck-insert-table-dropdown-grid-box":
                    e.to("boxover"),
                },
                children: this.items,
              },
              {
                tag: "div",
                attributes: {
                  class: ["ck", "ck-insert-table-dropdown__label"],
                  "aria-hidden": true,
                },
                children: [{ text: e.to("label") }],
              },
            ],
            on: {
              mousedown: e.to((t) => {
                t.preventDefault();
              }),
              click: e.to(() => {
                this.fire("execute");
              }),
            },
          });
          this.on("boxover", (t, e) => {
            const { row: n, column: i } = e.target.dataset;
            this.items
              .get((parseInt(n, 10) - 1) * 10 + (parseInt(i, 10) - 1))
              .focus();
          });
          this.focusTracker.on("change:focusedElement", (t, e, n) => {
            if (!n) {
              return;
            }
            const { row: i, column: o } = n.dataset;
            this.set({ rows: parseInt(i), columns: parseInt(o) });
          });
          this.on("change:columns", () => this._highlightGridBoxes());
          this.on("change:rows", () => this._highlightGridBoxes());
        }
        render() {
          super.render();
          E_({
            keystrokeHandler: this.keystrokes,
            focusTracker: this.focusTracker,
            gridItems: this.items,
            numberOfColumns: 10,
            uiLanguageDirection: this.locale && this.locale.uiLanguageDirection,
          });
          for (const t of this.items) {
            this.focusTracker.add(t.element);
          }
          this.keystrokes.listenTo(this.element);
        }
        focus() {
          this.items.get(0).focus();
        }
        focusLast() {
          this.items.get(0).focus();
        }
        _highlightGridBoxes() {
          const t = this.rows;
          const e = this.columns;
          this.items.map((n, i) => {
            const o = Math.floor(i / 10);
            const r = i % 10;
            const s = o < t && r < e;
            n.set("isOn", s);
          });
        }
        _createGridButton(t, e, n, i) {
          const o = new R_(t);
          o.set({ label: i, class: "ck-insert-table-dropdown-grid-box" });
          o.extendTemplate({ attributes: { "data-row": e, "data-column": n } });
          return o;
        }
        _createGridCollection() {
          const t = [];
          for (let e = 0; e < 100; e++) {
            const n = Math.floor(e / 10);
            const i = e % 10;
            const o = \`\${n + 1}  \${i + 1}\`;
            t.push(this._createGridButton(this.locale, n + 1, i + 1, o));
          }
          return this.createCollection(t);
        }
      }
      const eW =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>';
      const nW =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>';
      const iW =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>';
      const oW =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>';
      class rW extends Cl {
        static get pluginName() {
          return "TableUI";
        }
        init() {
          const t = this.editor;
          const e = this.editor.t;
          const n = t.locale.contentLanguageDirection;
          const i = n === "ltr";
          t.ui.componentFactory.add("insertTable", (n) => {
            const i = t.commands.get("insertTable");
            const o = Uv(n);
            o.bind("isEnabled").to(i);
            o.buttonView.set({
              icon: eW,
              label: e("Insert table"),
              tooltip: true,
            });
            let r;
            o.on("change:isOpen", () => {
              if (r) {
                return;
              }
              r = new tW(n);
              o.panelView.children.add(r);
              r.delegate("execute").to(o);
              o.on("execute", () => {
                t.execute("insertTable", { rows: r.rows, columns: r.columns });
                t.editing.view.focus();
              });
            });
            return o;
          });
          t.ui.componentFactory.add("tableColumn", (t) => {
            const n = [
              {
                type: "switchbutton",
                model: {
                  commandName: "setTableColumnHeader",
                  label: e("Header column"),
                  bindIsOn: true,
                },
              },
              { type: "separator" },
              {
                type: "button",
                model: {
                  commandName: i
                    ? "insertTableColumnLeft"
                    : "insertTableColumnRight",
                  label: e("Insert column left"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: i
                    ? "insertTableColumnRight"
                    : "insertTableColumnLeft",
                  label: e("Insert column right"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: "removeTableColumn",
                  label: e("Delete column"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: "selectTableColumn",
                  label: e("Select column"),
                },
              },
            ];
            return this._prepareDropdown(e("Column"), nW, n, t);
          });
          t.ui.componentFactory.add("tableRow", (t) => {
            const n = [
              {
                type: "switchbutton",
                model: {
                  commandName: "setTableRowHeader",
                  label: e("Header row"),
                  bindIsOn: true,
                },
              },
              { type: "separator" },
              {
                type: "button",
                model: {
                  commandName: "insertTableRowAbove",
                  label: e("Insert row above"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: "insertTableRowBelow",
                  label: e("Insert row below"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: "removeTableRow",
                  label: e("Delete row"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: "selectTableRow",
                  label: e("Select row"),
                },
              },
            ];
            return this._prepareDropdown(e("Row"), iW, n, t);
          });
          t.ui.componentFactory.add("mergeTableCells", (t) => {
            const n = [
              {
                type: "button",
                model: {
                  commandName: "mergeTableCellUp",
                  label: e("Merge cell up"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: i ? "mergeTableCellRight" : "mergeTableCellLeft",
                  label: e("Merge cell right"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: "mergeTableCellDown",
                  label: e("Merge cell down"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: i ? "mergeTableCellLeft" : "mergeTableCellRight",
                  label: e("Merge cell left"),
                },
              },
              { type: "separator" },
              {
                type: "button",
                model: {
                  commandName: "splitTableCellVertically",
                  label: e("Split cell vertically"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: "splitTableCellHorizontally",
                  label: e("Split cell horizontally"),
                },
              },
            ];
            return this._prepareMergeSplitButtonDropdown(
              e("Merge cells"),
              oW,
              n,
              t
            );
          });
        }
        _prepareDropdown(t, e, n, i) {
          const o = this.editor;
          const r = Uv(i);
          const s = this._fillDropdownWithListOptions(r, n);
          r.buttonView.set({ label: t, icon: e, tooltip: true });
          r.bind("isEnabled").toMany(s, "isEnabled", (...t) =>
            t.some((t) => t)
          );
          this.listenTo(r, "execute", (t) => {
            o.execute(t.source.commandName);
            if (!(t.source instanceof H_)) {
              o.editing.view.focus();
            }
          });
          return r;
        }
        _prepareMergeSplitButtonDropdown(t, e, n, i) {
          const o = this.editor;
          const r = Uv(i, rv);
          const s = "mergeTableCells";
          const a = o.commands.get(s);
          const c = this._fillDropdownWithListOptions(r, n);
          r.buttonView.set({
            label: t,
            icon: e,
            tooltip: true,
            isEnabled: true,
          });
          r.bind("isEnabled").toMany([a, ...c], "isEnabled", (...t) =>
            t.some((t) => t)
          );
          this.listenTo(r.buttonView, "execute", () => {
            o.execute(s);
            o.editing.view.focus();
          });
          this.listenTo(r, "execute", (t) => {
            o.execute(t.source.commandName);
            o.editing.view.focus();
          });
          return r;
        }
        _fillDropdownWithListOptions(t, e) {
          const n = this.editor;
          const i = [];
          const o = new rl();
          for (const t of e) {
            sW(t, n, i, o);
          }
          Wv(t, o, n.ui.componentFactory);
          return i;
        }
      }
      function sW(t, e, n, i) {
        const o = (t.model = new Py(t.model));
        const { commandName: r, bindIsOn: s } = t.model;
        if (t.type === "button" || t.type === "switchbutton") {
          const t = e.commands.get(r);
          n.push(t);
          o.set({ commandName: r });
          o.bind("isEnabled").to(t);
          if (s) {
            o.bind("isOn").to(t, "value");
          }
        }
        o.set({ withText: true });
        i.add(t);
      }
      var aW = n(5593);
      var cW = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      cW.insert = "head";
      cW.singleton = true;
      var lW = Il()(aW.Z, cW);
      const dW = aW.Z.locals || {};
      class uW extends Cl {
        static get pluginName() {
          return "TableSelection";
        }
        static get requires() {
          return [dq, dq];
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          this.listenTo(
            e,
            "deleteContent",
            (t, e) => this._handleDeleteContent(t, e),
            { priority: "high" }
          );
          this.listenTo(
            n.document,
            "insertText",
            (t, e) => this._handleInsertTextEvent(t, e),
            { priority: "high" }
          );
          this._defineSelectionConverter();
          this._enablePluginDisabling();
        }
        getSelectedTableCells() {
          const t = this.editor.plugins.get(dq);
          const e = this.editor.model.document.selection;
          const n = t.getSelectedTableCells(e);
          if (n.length == 0) {
            return null;
          }
          return n;
        }
        getSelectionAsFragment() {
          const t = this.editor.plugins.get(dq);
          const e = this.getSelectedTableCells();
          if (!e) {
            return null;
          }
          return this.editor.model.change((n) => {
            const i = n.createDocumentFragment();
            const { first: o, last: r } = t.getColumnIndexes(e);
            const { first: s, last: a } = t.getRowIndexes(e);
            const c = e[0].findAncestor("table");
            let l = a;
            let d = r;
            if (t.isSelectionRectangular(e)) {
              const t = {
                firstColumn: o,
                lastColumn: r,
                firstRow: s,
                lastRow: a,
              };
              l = ZU(c, t);
              d = QU(c, t);
            }
            const u = { startRow: s, startColumn: o, endRow: l, endColumn: d };
            const h = FU(c, u, n);
            n.insert(h, i, 0);
            return i;
          });
        }
        setCellSelection(t, e) {
          const n = this._getCellsToSelect(t, e);
          this.editor.model.change((t) => {
            t.setSelection(
              n.cells.map((e) => t.createRangeOn(e)),
              { backward: n.backward }
            );
          });
        }
        getFocusCell() {
          const t = this.editor.model.document.selection;
          const e = [...t.getRanges()].pop();
          const n = e.getContainedElement();
          if (n && n.is("element", "tableCell")) {
            return n;
          }
          return null;
        }
        getAnchorCell() {
          const t = this.editor.model.document.selection;
          const e = sl(t.getRanges());
          const n = e.getContainedElement();
          if (n && n.is("element", "tableCell")) {
            return n;
          }
          return null;
        }
        _defineSelectionConverter() {
          const t = this.editor;
          const e = new Set();
          t.conversion.for("editingDowncast").add((t) =>
            t.on(
              "selection",
              (t, i, o) => {
                const r = o.writer;
                n(r);
                const s = this.getSelectedTableCells();
                if (!s) {
                  return;
                }
                for (const t of s) {
                  const n = o.mapper.toViewElement(t);
                  r.addClass("ck-editor__editable_selected", n);
                  e.add(n);
                }
                const a = o.mapper.toViewElement(s[s.length - 1]);
                r.setSelection(a, 0);
              },
              { priority: "lowest" }
            )
          );
          function n(t) {
            for (const n of e) {
              t.removeClass("ck-editor__editable_selected", n);
            }
            e.clear();
          }
        }
        _enablePluginDisabling() {
          const t = this.editor;
          this.on("change:isEnabled", () => {
            if (!this.isEnabled) {
              const e = this.getSelectedTableCells();
              if (!e) {
                return;
              }
              t.model.change((n) => {
                const i = n.createPositionAt(e[0], 0);
                const o = t.model.schema.getNearestSelectionRange(i);
                n.setSelection(o);
              });
            }
          });
        }
        _handleDeleteContent(t, e) {
          const n = this.editor.plugins.get(dq);
          const [i, o] = e;
          const r = this.editor.model;
          const s = !o || o.direction == "backward";
          const a = n.getSelectedTableCells(i);
          if (!a.length) {
            return;
          }
          t.stop();
          r.change((t) => {
            const e = a[s ? a.length - 1 : 0];
            r.change((t) => {
              for (const e of a) {
                r.deleteContent(t.createSelection(e, "in"));
              }
            });
            const n = r.schema.getNearestSelectionRange(
              t.createPositionAt(e, 0)
            );
            if (i.is("documentSelection")) {
              t.setSelection(n);
            } else {
              i.setTo(n);
            }
          });
        }
        _handleInsertTextEvent(t, e) {
          const n = this.editor;
          const i = n.model;
          const o = i.document.selection;
          const r = this.getSelectedTableCells(o);
          if (!r) {
            return;
          }
          const s = n.editing.view;
          const a = n.editing.mapper;
          const c = r.map((t) => s.createRangeOn(a.toViewElement(t)));
          e.selection = s.createSelection(c);
        }
        _getCellsToSelect(t, e) {
          const n = this.editor.plugins.get("TableUtils");
          const i = n.getCellLocation(t);
          const o = n.getCellLocation(e);
          const r = Math.min(i.row, o.row);
          const s = Math.max(i.row, o.row);
          const a = Math.min(i.column, o.column);
          const c = Math.max(i.column, o.column);
          const l = new Array(s - r + 1).fill(null).map(() => []);
          const d = { startRow: r, endRow: s, startColumn: a, endColumn: c };
          for (const { row: e, cell: n } of new EU(
            t.findAncestor("table"),
            d
          )) {
            l[e - r].push(n);
          }
          const u = o.row < i.row;
          const h = o.column < i.column;
          if (u) {
            l.reverse();
          }
          if (h) {
            l.forEach((t) => t.reverse());
          }
          return { cells: l.flat(), backward: u || h };
        }
      }
      class hW extends Cl {
        static get pluginName() {
          return "TableClipboard";
        }
        static get requires() {
          return [uW, dq];
        }
        init() {
          const t = this.editor;
          const e = t.editing.view.document;
          this.listenTo(e, "copy", (t, e) => this._onCopyCut(t, e));
          this.listenTo(e, "cut", (t, e) => this._onCopyCut(t, e));
          this.listenTo(
            t.model,
            "insertContent",
            (t, e) => this._onInsertContent(t, ...e),
            { priority: "high" }
          );
          this.decorate("_replaceTableSlotCell");
        }
        _onCopyCut(t, e) {
          const n = this.editor.plugins.get(uW);
          if (!n.getSelectedTableCells()) {
            return;
          }
          if (t.name == "cut" && this.editor.isReadOnly) {
            return;
          }
          e.preventDefault();
          t.stop();
          const i = this.editor.data;
          const o = this.editor.editing.view.document;
          const r = i.toView(n.getSelectionAsFragment());
          o.fire("clipboardOutput", {
            dataTransfer: e.dataTransfer,
            content: r,
            method: t.name,
          });
        }
        _onInsertContent(t, e, n) {
          if (n && !n.is("documentSelection")) {
            return;
          }
          const i = this.editor.model;
          const o = this.editor.plugins.get(dq);
          let r = mW(e, i);
          if (!r) {
            return;
          }
          const s = o.getSelectionAffectedTableCells(i.document.selection);
          if (!s.length) {
            YU(r, o);
            return;
          }
          t.stop();
          i.change((t) => {
            const e = { width: o.getColumns(r), height: o.getRows(r) };
            const n = gW(s, e, t, o);
            const i = n.lastRow - n.firstRow + 1;
            const a = n.lastColumn - n.firstColumn + 1;
            const c = {
              startRow: 0,
              startColumn: 0,
              endRow: Math.min(i, e.height) - 1,
              endColumn: Math.min(a, e.width) - 1,
            };
            r = FU(r, c, t);
            const l = s[0].findAncestor("table");
            const d = this._replaceSelectedCellsWithPasted(r, e, l, n, t);
            if (this.editor.plugins.get("TableSelection").isEnabled) {
              const e = o.sortRanges(d.map((e) => t.createRangeOn(e)));
              t.setSelection(e);
            } else {
              t.setSelection(d[0], 0);
            }
          });
        }
        _replaceSelectedCellsWithPasted(t, e, n, i, o) {
          const { width: r, height: s } = e;
          const a = pW(t, r, s);
          const c = [
            ...new EU(n, {
              startRow: i.firstRow,
              endRow: i.lastRow,
              startColumn: i.firstColumn,
              endColumn: i.lastColumn,
              includeAllSlots: true,
            }),
          ];
          const l = [];
          let d;
          for (const t of c) {
            const { row: e, column: n } = t;
            if (n === i.firstColumn) {
              d = t.getPositionBefore();
            }
            const c = e - i.firstRow;
            const u = n - i.firstColumn;
            const h = a[c % s][u % r];
            const m = h ? o.cloneElement(h) : null;
            const g = this._replaceTableSlotCell(t, m, d, o);
            if (!g) {
              continue;
            }
            WU(g, e, n, i.lastRow, i.lastColumn, o);
            l.push(g);
            d = o.createPositionAfter(g);
          }
          const u = parseInt(n.getAttribute("headingRows") || 0);
          const h = parseInt(n.getAttribute("headingColumns") || 0);
          const m = i.firstRow < u && u <= i.lastRow;
          const g = i.firstColumn < h && h <= i.lastColumn;
          if (m) {
            const t = { first: i.firstColumn, last: i.lastColumn };
            const e = kW(n, u, t, o, i.firstRow);
            l.push(...e);
          }
          if (g) {
            const t = { first: i.firstRow, last: i.lastRow };
            const e = wW(n, h, t, o);
            l.push(...e);
          }
          return l;
        }
        _replaceTableSlotCell(t, e, n, i) {
          const { cell: o, isAnchor: r } = t;
          if (r) {
            i.remove(o);
          }
          if (!e) {
            return null;
          }
          i.insert(e, n);
          return e;
        }
        getTableIfOnlyTableInContent(t, e) {
          return mW(t, e);
        }
      }
      function mW(t, e) {
        if (!t.is("documentFragment") && !t.is("element")) {
          return null;
        }
        if (t.is("element", "table")) {
          return t;
        }
        if (t.childCount == 1 && t.getChild(0).is("element", "table")) {
          return t.getChild(0);
        }
        const n = e.createRangeIn(t);
        for (const t of n.getItems()) {
          if (t.is("element", "table")) {
            const i = e.createRange(n.start, e.createPositionBefore(t));
            if (e.hasContent(i, { ignoreWhitespaces: true })) {
              return null;
            }
            const o = e.createRange(e.createPositionAfter(t), n.end);
            if (e.hasContent(o, { ignoreWhitespaces: true })) {
              return null;
            }
            return t;
          }
        }
        return null;
      }
      function gW(t, e, n, i) {
        const o = t[0].findAncestor("table");
        const r = i.getColumnIndexes(t);
        const s = i.getRowIndexes(t);
        const a = {
          firstColumn: r.first,
          lastColumn: r.last,
          firstRow: s.first,
          lastRow: s.last,
        };
        const c = t.length === 1;
        if (c) {
          a.lastRow += e.height - 1;
          a.lastColumn += e.width - 1;
          fW(o, a.lastRow + 1, a.lastColumn + 1, i);
        }
        if (c || !i.isSelectionRectangular(t)) {
          bW(o, a, n);
        } else {
          a.lastRow = ZU(o, a);
          a.lastColumn = QU(o, a);
        }
        return a;
      }
      function fW(t, e, n, i) {
        const o = i.getColumns(t);
        const r = i.getRows(t);
        if (n > o) {
          i.insertColumns(t, { at: o, columns: n - o });
        }
        if (e > r) {
          i.insertRows(t, { at: r, rows: e - r });
        }
      }
      function pW(t, e, n) {
        const i = new Array(n).fill(null).map(() => new Array(e).fill(null));
        for (const { column: e, row: n, cell: o } of new EU(t)) {
          i[n][e] = o;
        }
        return i;
      }
      function bW(t, e, n) {
        const { firstRow: i, lastRow: o, firstColumn: r, lastColumn: s } = e;
        const a = { first: i, last: o };
        const c = { first: r, last: s };
        wW(t, r, a, n);
        wW(t, s + 1, a, n);
        kW(t, i, c, n);
        kW(t, o + 1, c, n, i);
      }
      function kW(t, e, n, i, o = 0) {
        if (e < 1) {
          return;
        }
        const r = VU(t, e, o);
        const s = r.filter(({ column: t, cellWidth: e }) => AW(t, e, n));
        return s.map(({ cell: t }) => HU(t, e, i));
      }
      function wW(t, e, n, i) {
        if (e < 1) {
          return;
        }
        const o = UU(t, e);
        const r = o.filter(({ row: t, cellHeight: e }) => AW(t, e, n));
        return r.map(({ cell: t, column: n }) => qU(t, n, e, i));
      }
      function AW(t, e, n) {
        const i = t + e - 1;
        const { first: o, last: r } = n;
        const s = t >= o && t <= r;
        const a = t < o && i >= o;
        return s || a;
      }
      class CW extends Cl {
        static get pluginName() {
          return "TableKeyboard";
        }
        static get requires() {
          return [uW, dq];
        }
        init() {
          const t = this.editor.editing.view;
          const e = t.document;
          this.listenTo(e, "arrowKey", (...t) => this._onArrowKey(...t), {
            context: "table",
          });
          this.listenTo(
            e,
            "tab",
            (...t) => this._handleTabOnSelectedTable(...t),
            { context: "figure" }
          );
          this.listenTo(e, "tab", (...t) => this._handleTab(...t), {
            context: ["th", "td"],
          });
        }
        _handleTabOnSelectedTable(t, e) {
          const n = this.editor;
          const i = n.model.document.selection;
          const o = i.getSelectedElement();
          if (!o || !o.is("element", "table")) {
            return;
          }
          e.preventDefault();
          e.stopPropagation();
          t.stop();
          n.model.change((t) => {
            t.setSelection(t.createRangeIn(o.getChild(0).getChild(0)));
          });
        }
        _handleTab(t, e) {
          const n = this.editor;
          const i = this.editor.plugins.get(dq);
          const o = n.model.document.selection;
          const r = !e.shiftKey;
          let s = i.getTableCellsContainingSelection(o)[0];
          if (!s) {
            s = this.editor.plugins.get("TableSelection").getFocusCell();
          }
          if (!s) {
            return;
          }
          e.preventDefault();
          e.stopPropagation();
          t.stop();
          const a = s.parent;
          const c = a.parent;
          const l = c.getChildIndex(a);
          const d = a.getChildIndex(s);
          const u = d === 0;
          if (!r && u && l === 0) {
            n.model.change((t) => {
              t.setSelection(t.createRangeOn(c));
            });
            return;
          }
          const h = d === a.childCount - 1;
          const m = l === i.getRows(c) - 1;
          if (r && m && h) {
            n.execute("insertTableRowBelow");
            if (l === i.getRows(c) - 1) {
              n.model.change((t) => {
                t.setSelection(t.createRangeOn(c));
              });
              return;
            }
          }
          let g;
          if (r && h) {
            const t = c.getChild(l + 1);
            g = t.getChild(0);
          } else if (!r && u) {
            const t = c.getChild(l - 1);
            g = t.getChild(t.childCount - 1);
          } else {
            g = a.getChild(d + (r ? 1 : -1));
          }
          n.model.change((t) => {
            t.setSelection(t.createRangeIn(g));
          });
        }
        _onArrowKey(t, e) {
          const n = this.editor;
          const i = e.keyCode;
          const o = qc(i, n.locale.contentLanguageDirection);
          const r = this._handleArrowKeys(o, e.shiftKey);
          if (r) {
            e.preventDefault();
            e.stopPropagation();
            t.stop();
          }
        }
        _handleArrowKeys(t, e) {
          const n = this.editor.plugins.get(dq);
          const i = this.editor.model;
          const o = i.document.selection;
          const r = ["right", "down"].includes(t);
          const s = n.getSelectedTableCells(o);
          if (s.length) {
            let n;
            if (e) {
              n = this.editor.plugins.get("TableSelection").getFocusCell();
            } else {
              n = r ? s[s.length - 1] : s[0];
            }
            this._navigateFromCellInDirection(n, t, e);
            return true;
          }
          const a = o.focus.findAncestor("tableCell");
          if (!a) {
            return false;
          }
          if (!o.isCollapsed) {
            if (e) {
              if (o.isBackward == r && !o.containsEntireContent(a)) {
                return false;
              }
            } else {
              const t = o.getSelectedElement();
              if (!t || !i.schema.isObject(t)) {
                return false;
              }
            }
          }
          if (this._isSelectionAtCellEdge(o, a, r)) {
            this._navigateFromCellInDirection(a, t, e);
            return true;
          }
          return false;
        }
        _isSelectionAtCellEdge(t, e, n) {
          const i = this.editor.model;
          const o = this.editor.model.schema;
          const r = n ? t.getLastPosition() : t.getFirstPosition();
          if (!o.getLimitElement(r).is("element", "tableCell")) {
            const t = i.createPositionAt(e, n ? "end" : 0);
            return t.isTouching(r);
          }
          const s = i.createSelection(r);
          i.modifySelection(s, { direction: n ? "forward" : "backward" });
          return r.isEqual(s.focus);
        }
        _navigateFromCellInDirection(t, e, n = false) {
          const i = this.editor.model;
          const o = t.findAncestor("table");
          const r = [...new EU(o, { includeAllSlots: true })];
          const { row: s, column: a } = r[r.length - 1];
          const c = r.find(({ cell: e }) => e == t);
          let { row: l, column: d } = c;
          switch (e) {
            case "left":
              d--;
              break;
            case "up":
              l--;
              break;
            case "right":
              d += c.cellWidth;
              break;
            case "down":
              l += c.cellHeight;
              break;
          }
          const u = l < 0 || l > s;
          const h = d < 0 && l <= 0;
          const m = d > a && l >= s;
          if (u || h || m) {
            i.change((t) => {
              t.setSelection(t.createRangeOn(o));
            });
            return;
          }
          if (d < 0) {
            d = n ? 0 : a;
            l--;
          } else if (d > a) {
            d = n ? a : 0;
            l++;
          }
          const g = r.find((t) => t.row == l && t.column == d).cell;
          const f = ["right", "down"].includes(e);
          const p = this.editor.plugins.get("TableSelection");
          if (n && p.isEnabled) {
            const e = p.getAnchorCell() || t;
            p.setCellSelection(e, g);
          } else {
            const t = i.createPositionAt(g, f ? 0 : "end");
            i.change((e) => {
              e.setSelection(t);
            });
          }
        }
      }
      class _W extends Im {
        constructor(t) {
          super(t);
          this.domEventType = ["mousemove", "mouseleave"];
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
      }
      class vW extends Cl {
        static get pluginName() {
          return "TableMouse";
        }
        static get requires() {
          return [uW, dq];
        }
        init() {
          const t = this.editor;
          t.editing.view.addObserver(_W);
          this._enableShiftClickSelection();
          this._enableMouseDragSelection();
        }
        _enableShiftClickSelection() {
          const t = this.editor;
          const e = t.plugins.get(dq);
          let n = false;
          const i = t.plugins.get(uW);
          this.listenTo(t.editing.view.document, "mousedown", (o, r) => {
            const s = t.model.document.selection;
            if (!this.isEnabled || !i.isEnabled) {
              return;
            }
            if (!r.domEvent.shiftKey) {
              return;
            }
            const a =
              i.getAnchorCell() || e.getTableCellsContainingSelection(s)[0];
            if (!a) {
              return;
            }
            const c = this._getModelTableCellFromDomEvent(r);
            if (c && yW(a, c)) {
              n = true;
              i.setCellSelection(a, c);
              r.preventDefault();
            }
          });
          this.listenTo(t.editing.view.document, "mouseup", () => {
            n = false;
          });
          this.listenTo(
            t.editing.view.document,
            "selectionChange",
            (t) => {
              if (n) {
                t.stop();
              }
            },
            { priority: "highest" }
          );
        }
        _enableMouseDragSelection() {
          const t = this.editor;
          let e, n;
          let i = false;
          let o = false;
          const r = t.plugins.get(uW);
          this.listenTo(t.editing.view.document, "mousedown", (t, n) => {
            if (!this.isEnabled || !r.isEnabled) {
              return;
            }
            if (
              n.domEvent.shiftKey ||
              n.domEvent.ctrlKey ||
              n.domEvent.altKey
            ) {
              return;
            }
            e = this._getModelTableCellFromDomEvent(n);
          });
          this.listenTo(t.editing.view.document, "mousemove", (t, s) => {
            if (!s.domEvent.buttons) {
              return;
            }
            if (!e) {
              return;
            }
            const a = this._getModelTableCellFromDomEvent(s);
            if (a && yW(e, a)) {
              n = a;
              if (!i && n != e) {
                i = true;
              }
            }
            if (!i) {
              return;
            }
            o = true;
            r.setCellSelection(e, n);
            s.preventDefault();
          });
          this.listenTo(t.editing.view.document, "mouseup", () => {
            i = false;
            o = false;
            e = null;
            n = null;
          });
          this.listenTo(
            t.editing.view.document,
            "selectionChange",
            (t) => {
              if (o) {
                t.stop();
              }
            },
            { priority: "highest" }
          );
        }
        _getModelTableCellFromDomEvent(t) {
          const e = t.target;
          const n = this.editor.editing.view.createPositionAt(e, 0);
          const i = this.editor.editing.mapper.toModelPosition(n);
          const o = i.parent;
          return o.findAncestor("tableCell", { includeSelf: true });
        }
      }
      function yW(t, e) {
        return t.parent.parent == e.parent.parent;
      }
      var xW = n(4104);
      var EW = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      EW.insert = "head";
      EW.singleton = true;
      var DW = Il()(xW.Z, EW);
      const SW = xW.Z.locals || {};
      class TW extends Cl {
        static get requires() {
          return [$q, rW, uW, vW, CW, hW, qD];
        }
        static get pluginName() {
          return "Table";
        }
      }
      class IW extends vl {
        constructor(t, e, n) {
          super(t);
          this.attributeName = e;
          this._defaultValue = n;
        }
        refresh() {
          const t = this.editor;
          const e = t.model.document.selection;
          const n = e.getFirstPosition().findAncestor("table");
          this.isEnabled = !!n;
          this.value = this._getValue(n);
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document.selection;
          const { value: i, batch: o } = t;
          const r = n.getFirstPosition().findAncestor("table");
          const s = this._getValueToSet(i);
          e.enqueueChange(o, (t) => {
            if (s) {
              t.setAttribute(this.attributeName, s, r);
            } else {
              t.removeAttribute(this.attributeName, r);
            }
          });
        }
        _getValue(t) {
          if (!t) {
            return;
          }
          const e = t.getAttribute(this.attributeName);
          if (e === this._defaultValue) {
            return;
          }
          return e;
        }
        _getValueToSet(t) {
          if (t === this._defaultValue) {
            return;
          }
          return t;
        }
      }
      class MW extends IW {
        constructor(t, e) {
          super(t, "tableWidth", e);
        }
        refresh() {
          this.isEnabled = true;
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = t.table || e.document.selection.getSelectedElement();
          const { tableWidth: i, columnWidths: o } = t;
          e.change((t) => {
            if (i) {
              t.setAttribute(this.attributeName, i, n);
            } else {
              t.removeAttribute(this.attributeName, n);
            }
            if (o) {
              t.setAttribute("columnWidths", o, n);
            } else {
              t.removeAttribute("columnWidths", n);
            }
          });
        }
      }
      class BW extends IW {
        constructor(t, e) {
          super(t, "columnWidths", e);
        }
        refresh() {
          this.isEnabled = true;
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = t.table || e.document.selection.getSelectedElement();
          const { columnWidths: i } = t;
          e.change((t) => {
            if (i) {
              t.setAttribute(this.attributeName, i, n);
            } else {
              t.removeAttribute(this.attributeName, n);
            }
          });
        }
      }
      const LW = 5;
      const NW = 40;
      const zW = 2;
      function PW(t) {
        const e = new Set();
        for (const n of t.document.differ.getChanges()) {
          let i = null;
          switch (n.type) {
            case "insert":
              i = ["table", "tableRow", "tableCell"].includes(n.name)
                ? n.position
                : null;
              break;
            case "remove":
              i = ["tableRow", "tableCell"].includes(n.name)
                ? n.position
                : null;
              break;
            case "attribute":
              if (n.range.start.nodeAfter) {
                i = ["table", "tableRow", "tableCell"].includes(
                  n.range.start.nodeAfter.name
                )
                  ? n.range.start
                  : null;
              }
              break;
          }
          if (!i) {
            continue;
          }
          const o =
            i.nodeAfter && i.nodeAfter.name === "table"
              ? i.nodeAfter
              : i.findAncestor("table");
          for (const n of t.createRangeOn(o).getItems()) {
            if (
              n.is("element") &&
              n.name === "table" &&
              n.hasAttribute("columnWidths")
            ) {
              e.add(n);
            }
          }
        }
        return e;
      }
      function RW(t, e) {
        return (NW * 100) / OW(t, e);
      }
      function OW(t, e) {
        const n = jW(t, "tbody", e) || jW(t, "thead", e);
        const i = e.editing.view.domConverter.mapViewToDom(n);
        return FW(i);
      }
      function jW(t, e, n) {
        const i = n.editing.mapper.toViewElement(t);
        const o = [...i.getChildren()].find((t) => t.is("element", "table"));
        return [...o.getChildren()].find((t) => t.is("element", e));
      }
      function FW(t) {
        const e = Xa.window.getComputedStyle(t);
        if (e.boxSizing === "border-box") {
          return (
            parseFloat(e.width) -
            parseFloat(e.paddingLeft) -
            parseFloat(e.paddingRight) -
            parseFloat(e.borderLeftWidth) -
            parseFloat(e.borderRightWidth)
          );
        } else {
          return parseFloat(e.width);
        }
      }
      function VW(t, e) {
        const n = e.getCellLocation(t).column;
        const i = t.getAttribute("colspan") || 1;
        return { leftEdge: n, rightEdge: n + i - 1 };
      }
      function HW(t) {
        const e = Math.pow(10, zW);
        const n = parseFloat(t);
        return Math.round(n * e) / e;
      }
      function UW(t, e, n) {
        if (t <= e) {
          return HW(e);
        }
        if (t >= n) {
          return HW(n);
        }
        return HW(t);
      }
      function qW(t, e) {
        return Array(t).fill(e);
      }
      function WW(t) {
        return t
          .map((t) => parseFloat(t))
          .filter((t) => !Number.isNaN(t))
          .reduce((t, e) => t + e, 0);
      }
      function GW(t) {
        t = $W(t);
        const e = WW(t);
        if (e === 100) {
          return t;
        }
        return t
          .map((t) => HW((t * 100) / e))
          .map((t, e, n) => {
            const i = e === n.length - 1;
            if (!i) {
              return t;
            }
            const o = WW(n);
            return HW(t + 100 - o);
          });
      }
      function $W(t) {
        const e = t.filter((t) => t === "auto").length;
        if (e === 0) {
          return t.map((t) => HW(t));
        }
        const n = WW(t);
        const i = Math.max((100 - n) / e, LW);
        return t.map((t) => (t === "auto" ? i : t)).map((t) => HW(t));
      }
      function KW(t, e) {
        let n = [...e.getChildren()].find((t) =>
          t.hasClass("ck-table-column-resizer")
        );
        if (n) {
          return;
        }
        n = t.createUIElement("div", { class: "ck-table-column-resizer" });
        t.insert(t.createPositionAt(e, "end"), n);
      }
      function YW(t) {
        const e = Xa.window.getComputedStyle(t);
        if (e.boxSizing === "border-box") {
          return parseInt(e.width);
        } else {
          return (
            parseFloat(e.width) +
            parseFloat(e.paddingLeft) +
            parseFloat(e.paddingRight) +
            parseFloat(e.borderWidth)
          );
        }
      }
      function ZW(t) {
        return (e) =>
          e.on("element:colgroup", (e, n, i) => {
            const o = n.viewItem;
            if (!i.consumable.test(o, { name: true })) {
              return;
            }
            i.consumable.consume(o, { name: true });
            const r = n.modelCursor.findAncestor("table");
            const s = t.getColumns(r);
            let a = [...Array(s).keys()].map((t) => {
              const e = o.getChild(t);
              if (!e || !e.is("element", "col")) {
                return "auto";
              }
              const n = e.getStyle("width");
              if (!n || !n.endsWith("%")) {
                return "auto";
              }
              return n;
            });
            if (a.includes("auto")) {
              a = GW(a).map((t) => t + "%");
            }
            i.writer.setAttribute("columnWidths", a.join(","), r);
          });
      }
      function QW() {
        return (t) =>
          t.on("attribute:columnWidths:table", (t, e, n) => {
            const i = n.writer;
            const o = e.item;
            const r = [...n.mapper.toViewElement(o).getChildren()].find((t) =>
              t.is("element", "table")
            );
            if (e.attributeNewValue) {
              JW(i, r, e.attributeNewValue);
              i.addClass("ck-table-resized", r);
            } else {
              XW(i, r);
              i.removeClass("ck-table-resized", r);
            }
          });
      }
      function JW(t, e, n) {
        const i = n.split(",");
        let o = [...e.getChildren()].find((t) => t.is("element", "colgroup"));
        if (!o) {
          o = t.createContainerElement("colgroup");
        } else {
          for (const e of [...o.getChildren()]) {
            t.remove(e);
          }
        }
        for (const e of Array(i.length).keys()) {
          const n = t.createEmptyElement("col");
          t.setStyle("width", i[e], n);
          t.insert(t.createPositionAt(o, "end"), n);
        }
        t.insert(t.createPositionAt(e, "start"), o);
      }
      function XW(t, e) {
        const n = [...e.getChildren()].find((t) => t.is("element", "colgroup"));
        t.remove(n);
      }
      class tG extends Cl {
        static get requires() {
          return [$q, dq];
        }
        static get pluginName() {
          return "TableColumnResizeEditing";
        }
        constructor(t) {
          super(t);
          this._isResizingActive = false;
          this.set("_isResizingAllowed", true);
          this._resizingData = null;
          this._domEmitter = Object.create(Ka);
          this._tableUtilsPlugin = t.plugins.get("TableUtils");
          this.on("change:_isResizingAllowed", (e, n, i) => {
            t.editing.view.change((e) => {
              e[i ? "removeClass" : "addClass"](
                "ck-column-resize_disabled",
                t.editing.view.document.getRoot()
              );
            });
          });
        }
        init() {
          this._extendSchema();
          this._registerPostFixer();
          this._registerConverters();
          this._registerResizingListeners();
          this._registerColgroupFixer();
          this._registerResizerInserter();
          const t = this.editor;
          const e = t.plugins.get("TableColumnResize");
          t.commands.add("resizeTableWidth", new MW(t));
          t.commands.add("resizeColumnWidths", new BW(t));
          const n = t.commands.get("resizeTableWidth");
          const i = t.commands.get("resizeColumnWidths");
          this.bind("_isResizingAllowed").to(
            t,
            "isReadOnly",
            e,
            "isEnabled",
            n,
            "isEnabled",
            i,
            "isEnabled",
            (t, e, n, i) => !t && e && n && i
          );
        }
        destroy() {
          this._domEmitter.stopListening();
          super.destroy();
        }
        _extendSchema() {
          this.editor.model.schema.extend("table", {
            allowAttributes: ["tableWidth", "columnWidths"],
          });
        }
        _registerPostFixer() {
          const t = this.editor;
          const e = t.model;
          e.document.registerPostFixer((t) => {
            let i = false;
            for (const o of PW(e)) {
              const e = GW(o.getAttribute("columnWidths").split(","));
              n(e, o, this);
              const r = e.map((t) => \`\${t}%\`).join(",");
              if (o.getAttribute("columnWidths") === r) {
                continue;
              }
              t.setAttribute("columnWidths", r, o);
              i = true;
            }
            return i;
          });
          function n(t, e, n) {
            const o = n._tableUtilsPlugin.getColumns(e);
            const r = o - t.length;
            if (r === 0) {
              return;
            }
            const s = i(n.editor.model.document.differ, e);
            for (const i of s) {
              const r = o - t.length;
              if (r === 0) {
                continue;
              }
              const s = r > 0;
              const a = n._tableUtilsPlugin.getCellLocation(i).column;
              if (s) {
                const i = RW(e, n.editor);
                const o = qW(r, i);
                t.splice(a, 0, ...o);
              } else {
                const e = t.splice(a, Math.abs(r));
                t[a] += WW(e);
              }
            }
          }
          function i(t, e) {
            const n = new Set();
            for (const i of t.getChanges()) {
              if (
                i.type == "insert" &&
                i.position.nodeAfter &&
                i.position.nodeAfter.name == "tableCell" &&
                i.position.nodeAfter.getAncestors().includes(e)
              ) {
                n.add(i.position.nodeAfter);
              } else if (i.type == "remove") {
                const t = i.position.nodeBefore || i.position.nodeAfter;
                if (t.name == "tableCell" && t.getAncestors().includes(e)) {
                  n.add(t);
                }
              }
            }
            return n;
          }
        }
        _registerConverters() {
          const t = this.editor;
          const e = t.conversion;
          const n = {
            view: { name: "figure", key: "style", value: { width: /[\\s\\S]+/ } },
            model: {
              name: "table",
              key: "tableWidth",
              value: (t) => t.getStyle("width"),
            },
          };
          const i = {
            model: { name: "table", key: "tableWidth" },
            view: (t) => ({
              name: "figure",
              key: "style",
              value: { width: t },
            }),
          };
          e.for("upcast").attributeToAttribute(n);
          e.for("upcast").add(ZW(this._tableUtilsPlugin));
          e.for("downcast").attributeToAttribute(i);
          e.for("downcast").add(QW());
        }
        _registerResizingListeners() {
          const t = this.editor.editing.view;
          t.addObserver(_W);
          t.document.on("mousedown", this._onMouseDownHandler.bind(this), {
            priority: "high",
          });
          this._domEmitter.listenTo(
            Xa.window.document,
            "mousemove",
            dS(this._onMouseMoveHandler.bind(this), 50)
          );
          this._domEmitter.listenTo(
            Xa.window.document,
            "mouseup",
            this._onMouseUpHandler.bind(this)
          );
        }
        _onMouseDownHandler(t, e) {
          const n = e.target;
          if (!n.hasClass("ck-table-column-resizer")) {
            return;
          }
          if (!this._isResizingAllowed) {
            return;
          }
          e.preventDefault();
          t.stop();
          const i = this.editor;
          const o = i.editing.mapper.toModelElement(n.findAncestor("figure"));
          const r = c(o, this._tableUtilsPlugin, i);
          const s = n.findAncestor("table");
          const a = i.editing.view;
          if (![...s.getChildren()].find((t) => t.is("element", "colgroup"))) {
            a.change((t) => {
              l(t, r, s);
            });
          }
          this._isResizingActive = true;
          this._resizingData = this._getResizingData(e, r);
          a.change((t) => d(t, s, this._resizingData));
          function c(t, e, n) {
            const i = Array(e.getColumns(t));
            const o = new EU(t);
            for (const t of o) {
              const e = n.editing.mapper.toViewElement(t.cell);
              const o = n.editing.view.domConverter.mapViewToDom(e);
              const r = YW(o);
              if (!i[t.column] || r < i[t.column]) {
                i[t.column] = HW(r);
              }
            }
            return i;
          }
          function l(t, e, n) {
            const i = t.createContainerElement("colgroup");
            for (let n = 0; n < e.length; n++) {
              const o = t.createEmptyElement("col");
              const r = \`\${HW((e[n] / WW(e)) * 100)}%\`;
              t.setStyle("width", r, o);
              t.insert(t.createPositionAt(i, "end"), o);
            }
            t.insert(t.createPositionAt(n, "start"), i);
          }
          function d(t, e, n) {
            const i = n.widths.viewFigureWidth / n.widths.viewFigureParentWidth;
            t.addClass("ck-table-resized", e);
            t.addClass(
              "ck-table-column-resizer__active",
              n.elements.viewResizer
            );
            t.setStyle("width", \`\${HW(i * 100)}%\`, e.findAncestor("figure"));
          }
        }
        _onMouseMoveHandler(t, e) {
          if (!this._isResizingActive) {
            return;
          }
          if (!this._isResizingAllowed) {
            this._onMouseUpHandler();
            return;
          }
          const {
            columnPosition: n,
            flags: { isRightEdge: i, isTableCentered: o, isLtrContent: r },
            elements: { viewFigure: s, viewLeftColumn: a, viewRightColumn: c },
            widths: {
              viewFigureParentWidth: l,
              tableWidth: d,
              leftColumnWidth: u,
              rightColumnWidth: h,
            },
          } = this._resizingData;
          const m = -u + NW;
          const g = i ? l - d : h - NW;
          const f = (r ? 1 : -1) * (i && o ? 2 : 1);
          const p = UW((e.clientX - n) * f, Math.min(m, 0), Math.max(g, 0));
          if (p === 0) {
            return;
          }
          this.editor.editing.view.change((t) => {
            const e = HW(((u + p) * 100) / d);
            t.setStyle("width", \`\${e}%\`, a);
            if (i) {
              const e = HW(((d + p) * 100) / l);
              t.setStyle("width", \`\${e}%\`, s);
            } else {
              const e = HW(((h - p) * 100) / d);
              t.setStyle("width", \`\${e}%\`, c);
            }
          });
        }
        _onMouseUpHandler() {
          if (!this._isResizingActive) {
            return;
          }
          const {
            viewResizer: t,
            modelTable: e,
            viewFigure: n,
            viewColgroup: i,
          } = this._resizingData.elements;
          const o = this.editor;
          const r = o.editing.view;
          const s = e.getAttribute("columnWidths");
          const a = [...i.getChildren()]
            .map((t) => t.getStyle("width"))
            .join(",");
          const c = s !== a;
          const l = e.getAttribute("tableWidth");
          const d = n.getStyle("width");
          const u = l !== d;
          if (c || u) {
            if (this._isResizingAllowed) {
              if (u) {
                o.execute("resizeTableWidth", {
                  table: e,
                  tableWidth: \`\${HW(d)}%\`,
                  columnWidths: a,
                });
              } else {
                o.execute("resizeColumnWidths", { columnWidths: a, table: e });
              }
            } else {
              r.change((t) => {
                if (s) {
                  const e = s.split(",");
                  for (const n of i.getChildren()) {
                    t.setStyle("width", e.shift(), n);
                  }
                } else {
                  t.remove(i);
                }
                if (u) {
                  if (l) {
                    t.setStyle("width", l, n);
                  } else {
                    t.removeStyle("width", n);
                  }
                }
                if (!s && !l) {
                  t.removeClass(
                    "ck-table-resized",
                    [...n.getChildren()].find((t) => t.name === "table")
                  );
                }
              });
            }
          }
          r.change((e) => {
            e.removeClass("ck-table-column-resizer__active", t);
          });
          this._isResizingActive = false;
          this._resizingData = null;
        }
        _getResizingData(t, e) {
          const n = this.editor;
          const i = t.domEvent.clientX;
          const o = t.target;
          const r = o.findAncestor("td") || o.findAncestor("th");
          const s = n.editing.mapper.toModelElement(r);
          const a = s.findAncestor("table");
          const c = VW(s, this._tableUtilsPlugin).rightEdge;
          const l = this._tableUtilsPlugin.getColumns(a) - 1;
          const d = c === l;
          const u = !a.hasAttribute("tableAlignment");
          const h = n.locale.contentLanguageDirection !== "rtl";
          const m = r.findAncestor("table");
          const g = m.findAncestor("figure");
          const f = [...m.getChildren()].find((t) =>
            t.is("element", "colgroup")
          );
          const p = f.getChild(c);
          const b = d ? undefined : f.getChild(c + 1);
          const k = FW(n.editing.view.domConverter.mapViewToDom(g.parent));
          const w = FW(n.editing.view.domConverter.mapViewToDom(g));
          const A = OW(a, n);
          const C = e[c];
          const _ = d ? undefined : e[c + 1];
          return {
            columnPosition: i,
            flags: { isRightEdge: d, isTableCentered: u, isLtrContent: h },
            elements: {
              viewResizer: o,
              modelTable: a,
              viewFigure: g,
              viewColgroup: f,
              viewLeftColumn: p,
              viewRightColumn: b,
            },
            widths: {
              viewFigureParentWidth: k,
              viewFigureWidth: w,
              tableWidth: A,
              leftColumnWidth: C,
              rightColumnWidth: _,
            },
          };
        }
        _registerColgroupFixer() {
          const t = this.editor;
          this.listenTo(
            t.editing.view.document,
            "layoutChanged",
            () => {
              const e = t.editing.view.document.selection
                .getFirstPosition()
                .getAncestors()
                .reverse()
                .find((t) => t.name === "table");
              const n =
                e &&
                [...e.getChildren()].find((t) => t.is("element", "colgroup"));
              const i = t.model.document.selection
                .getFirstPosition()
                .findAncestor("table");
              if (i && i.hasAttribute("columnWidths") && e && !n) {
                t.editing.reconvertItem(i);
              }
            },
            { priority: "low" }
          );
        }
        _registerResizerInserter() {
          const t = this.editor.editing.view;
          t.on(
            "render",
            () => {
              for (const e of t.createRangeIn(t.document.getRoot())) {
                if (!["td", "th"].includes(e.item.name)) {
                  continue;
                }
                t.change((t) => {
                  KW(t, e.item);
                });
              }
            },
            { priority: "lowest" }
          );
        }
      }
      class eG extends vl {
        constructor(t, e, n) {
          super(t);
          this.attributeName = e;
          this._defaultValue = n;
        }
        refresh() {
          const t = this.editor;
          const e = this.editor.plugins.get("TableUtils");
          const n = e.getSelectionAffectedTableCells(
            t.model.document.selection
          );
          this.isEnabled = !!n.length;
          this.value = this._getSingleValue(n);
        }
        execute(t = {}) {
          const { value: e, batch: n } = t;
          const i = this.editor.model;
          const o = this.editor.plugins.get("TableUtils");
          const r = o.getSelectionAffectedTableCells(i.document.selection);
          const s = this._getValueToSet(e);
          i.enqueueChange(n, (t) => {
            if (s) {
              r.forEach((e) => t.setAttribute(this.attributeName, s, e));
            } else {
              r.forEach((e) => t.removeAttribute(this.attributeName, e));
            }
          });
        }
        _getAttribute(t) {
          if (!t) {
            return;
          }
          const e = t.getAttribute(this.attributeName);
          if (e === this._defaultValue) {
            return;
          }
          return e;
        }
        _getValueToSet(t) {
          if (t === this._defaultValue) {
            return;
          }
          return t;
        }
        _getSingleValue(t) {
          const e = this._getAttribute(t[0]);
          const n = t.every((t) => this._getAttribute(t) === e);
          return n ? e : undefined;
        }
      }
      function nG(t) {
        if (!t || !it(t)) {
          return t;
        }
        const { top: e, right: n, bottom: i, left: o } = t;
        if (e == n && n == i && i == o) {
          return e;
        }
      }
      function iG(t, e) {
        const n = parseFloat(t);
        if (Number.isNaN(n)) {
          return t;
        }
        if (String(n) !== String(t)) {
          return t;
        }
        return \`\${n}\${e}\`;
      }
      function oG(t, e = {}) {
        const n = Object.assign(
          {
            borderStyle: "none",
            borderWidth: "",
            borderColor: "",
            backgroundColor: "",
            width: "",
            height: "",
          },
          t
        );
        if (e.includeAlignmentProperty && !n.alignment) {
          n.alignment = "center";
        }
        if (e.includePaddingProperty && !n.padding) {
          n.padding = "";
        }
        if (e.includeVerticalAlignmentProperty && !n.verticalAlignment) {
          n.verticalAlignment = "middle";
        }
        if (e.includeHorizontalAlignmentProperty && !n.horizontalAlignment) {
          n.horizontalAlignment = e.isRightToLeftContent ? "right" : "left";
        }
        return n;
      }
      class rG extends eG {
        constructor(t, e) {
          super(t, "tableCellWidth", e);
        }
        _getValueToSet(t) {
          t = iG(t, "px");
          if (t === this._defaultValue) {
            return;
          }
          return t;
        }
      }
      class sG extends Cl {
        static get pluginName() {
          return "TableCellWidthEditing";
        }
        static get requires() {
          return [$q];
        }
        init() {
          const t = this.editor;
          const e = oG(
            t.config.get("table.tableCellProperties.defaultProperties")
          );
          kU(t.model.schema, t.conversion, {
            modelAttribute: "tableCellWidth",
            styleName: "width",
            defaultValue: e.width,
          });
          t.commands.add("tableCellWidth", new rG(t, e.width));
        }
      }
      var aG = n(728);
      var cG = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      cG.insert = "head";
      cG.singleton = true;
      var lG = Il()(aG.Z, cG);
      const dG = aG.Z.locals || {};
      class uG extends Cl {
        static get requires() {
          return [tG, sG];
        }
        static get pluginName() {
          return "TableColumnResize";
        }
      }
      class hG extends IW {
        constructor(t, e) {
          super(t, "tableBackgroundColor", e);
        }
      }
      class mG extends IW {
        constructor(t, e) {
          super(t, "tableBorderColor", e);
        }
        _getValue(t) {
          if (!t) {
            return;
          }
          const e = nG(t.getAttribute(this.attributeName));
          if (e === this._defaultValue) {
            return;
          }
          return e;
        }
      }
      class gG extends IW {
        constructor(t, e) {
          super(t, "tableBorderStyle", e);
        }
        _getValue(t) {
          if (!t) {
            return;
          }
          const e = nG(t.getAttribute(this.attributeName));
          if (e === this._defaultValue) {
            return;
          }
          return e;
        }
      }
      class fG extends IW {
        constructor(t, e) {
          super(t, "tableBorderWidth", e);
        }
        _getValue(t) {
          if (!t) {
            return;
          }
          const e = nG(t.getAttribute(this.attributeName));
          if (e === this._defaultValue) {
            return;
          }
          return e;
        }
        _getValueToSet(t) {
          t = iG(t, "px");
          if (t === this._defaultValue) {
            return;
          }
          return t;
        }
      }
      class pG extends IW {
        constructor(t, e) {
          super(t, "tableWidth", e);
        }
        _getValueToSet(t) {
          t = iG(t, "px");
          if (t === this._defaultValue) {
            return;
          }
          return t;
        }
      }
      class bG extends IW {
        constructor(t, e) {
          super(t, "tableHeight", e);
        }
        _getValueToSet(t) {
          t = iG(t, "px");
          if (t === this._defaultValue) {
            return null;
          }
          return t;
        }
      }
      class kG extends IW {
        constructor(t, e) {
          super(t, "tableAlignment", e);
        }
      }
      const wG = /^(left|center|right)$/;
      const AG = /^(left|none|right)$/;
      class CG extends Cl {
        static get pluginName() {
          return "TablePropertiesEditing";
        }
        static get requires() {
          return [$q];
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.conversion;
          t.config.define("table.tableProperties.defaultProperties", {});
          const i = oG(
            t.config.get("table.tableProperties.defaultProperties"),
            { includeAlignmentProperty: true }
          );
          t.data.addStyleProcessorRules(bA);
          _G(e, n, {
            color: i.borderColor,
            style: i.borderStyle,
            width: i.borderWidth,
          });
          t.commands.add("tableBorderColor", new mG(t, i.borderColor));
          t.commands.add("tableBorderStyle", new gG(t, i.borderStyle));
          t.commands.add("tableBorderWidth", new fG(t, i.borderWidth));
          vG(e, n, i.alignment);
          t.commands.add("tableAlignment", new kG(t, i.alignment));
          xG(e, n, {
            modelAttribute: "tableWidth",
            styleName: "width",
            defaultValue: i.width,
          });
          t.commands.add("tableWidth", new pG(t, i.width));
          xG(e, n, {
            modelAttribute: "tableHeight",
            styleName: "height",
            defaultValue: i.height,
          });
          t.commands.add("tableHeight", new bG(t, i.height));
          t.data.addStyleProcessorRules(mA);
          yG(e, n, {
            modelAttribute: "tableBackgroundColor",
            styleName: "background-color",
            defaultValue: i.backgroundColor,
          });
          t.commands.add("tableBackgroundColor", new hG(t, i.backgroundColor));
        }
      }
      function _G(t, e, n) {
        const i = {
          width: "tableBorderWidth",
          color: "tableBorderColor",
          style: "tableBorderStyle",
        };
        t.extend("table", { allowAttributes: Object.values(i) });
        uU(e, "table", i, n);
        mU(e, { modelAttribute: i.color, styleName: "border-color" });
        mU(e, { modelAttribute: i.style, styleName: "border-style" });
        mU(e, { modelAttribute: i.width, styleName: "border-width" });
      }
      function vG(t, e, n) {
        t.extend("table", { allowAttributes: ["tableAlignment"] });
        e.for("downcast").attributeToAttribute({
          model: { name: "table", key: "tableAlignment" },
          view: (t) => ({
            key: "style",
            value: { float: t === "center" ? "none" : t },
          }),
          converterPriority: "high",
        });
        e.for("upcast")
          .attributeToAttribute({
            view: { name: /^(table|figure)$/, styles: { float: AG } },
            model: {
              key: "tableAlignment",
              value: (t) => {
                let e = t.getStyle("float");
                if (e === "none") {
                  e = "center";
                }
                return e === n ? null : e;
              },
            },
          })
          .attributeToAttribute({
            view: { attributes: { align: wG } },
            model: {
              name: "table",
              key: "tableAlignment",
              value: (t) => {
                const e = t.getAttribute("align");
                return e === n ? null : e;
              },
            },
          });
      }
      function yG(t, e, n) {
        const { modelAttribute: i } = n;
        t.extend("table", { allowAttributes: [i] });
        dU(e, { viewElement: "table", ...n });
        mU(e, n);
      }
      function xG(t, e, n) {
        const { modelAttribute: i } = n;
        t.extend("table", { allowAttributes: [i] });
        dU(e, {
          viewElement: /^(table|figure)$/,
          shouldUpcast: (t) =>
            !(t.name == "table" && t.parent.name == "figure"),
          ...n,
        });
        hU(e, { modelElement: "table", ...n });
      }
      var EG = n(4082);
      var DG = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      DG.insert = "head";
      DG.singleton = true;
      var SG = Il()(EG.Z, DG);
      const TG = EG.Z.locals || {};
      class IG extends pC {
        constructor(t, e) {
          super(t);
          this.set("value", "");
          this.set("isReadOnly", false);
          this.set("isFocused", false);
          this.set("isEmpty", true);
          this.options = e;
          this.focusTracker = new al();
          this._focusables = new PA();
          this.dropdownView = this._createDropdownView();
          this.inputView = this._createInputTextView();
          this.keystrokes = new cl();
          this._stillTyping = false;
          this._focusCycler = new hv({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          });
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-input-color"] },
            children: [this.dropdownView, this.inputView],
          });
          this.on("change:value", (t, e, n) => this._setInputValue(n));
        }
        render() {
          super.render();
          this.keystrokes.listenTo(this.dropdownView.panelView.element);
        }
        focus() {
          this.inputView.focus();
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        _createDropdownView() {
          const t = this.locale;
          const e = t.t;
          const n = this.bindTemplate;
          const i = this._createColorGrid(t);
          const o = Uv(t);
          const r = new pC();
          const s = this._createRemoveColorButton();
          r.setTemplate({
            tag: "span",
            attributes: {
              class: ["ck", "ck-input-color__button__preview"],
              style: { backgroundColor: n.to("value") },
            },
            children: [
              {
                tag: "span",
                attributes: {
                  class: [
                    "ck",
                    "ck-input-color__button__preview__no-color-indicator",
                    n.if("value", "ck-hidden", (t) => t != ""),
                  ],
                },
              },
            ],
          });
          o.buttonView.extendTemplate({
            attributes: { class: "ck-input-color__button" },
          });
          o.buttonView.children.add(r);
          o.buttonView.label = e("Color picker");
          o.buttonView.tooltip = true;
          o.panelPosition = t.uiLanguageDirection === "rtl" ? "se" : "sw";
          o.panelView.children.add(s);
          o.panelView.children.add(i);
          o.bind("isEnabled").to(this, "isReadOnly", (t) => !t);
          this._focusables.add(s);
          this._focusables.add(i);
          this.focusTracker.add(s.element);
          this.focusTracker.add(i.element);
          return o;
        }
        _createInputTextView() {
          const t = this.locale;
          const e = new yy(t);
          e.extendTemplate({ on: { blur: e.bindTemplate.to("blur") } });
          e.value = this.value;
          e.bind("isReadOnly", "hasError").to(this);
          this.bind("isFocused", "isEmpty").to(e);
          e.on("input", () => {
            const t = e.element.value;
            const n = this.options.colorDefinitions.find((e) => t === e.label);
            this._stillTyping = true;
            this.value = (n && n.color) || t;
          });
          e.on("blur", () => {
            this._stillTyping = false;
            this._setInputValue(e.element.value);
          });
          e.delegate("input").to(this);
          return e;
        }
        _createRemoveColorButton() {
          const t = this.locale;
          const e = t.t;
          const n = new R_(t);
          const i = this.options.defaultColorValue || "";
          const o = i ? e("Restore default") : e("Remove color");
          n.class = "ck-input-color__remove-color";
          n.withText = true;
          n.icon = __.eraser;
          n.label = o;
          n.on("execute", () => {
            this.value = i;
            this.dropdownView.isOpen = false;
            this.fire("input");
          });
          return n;
        }
        _createColorGrid(t) {
          const e = new J_(t, {
            colorDefinitions: this.options.colorDefinitions,
            columns: this.options.columns,
          });
          e.on("execute", (t, e) => {
            this.value = e.value;
            this.dropdownView.isOpen = false;
            this.fire("input");
          });
          e.bind("selectedColor").to(this, "value");
          return e;
        }
        _setInputValue(t) {
          if (!this._stillTyping) {
            const e = MG(t);
            const n = this.options.colorDefinitions.find(
              (t) => e === MG(t.color)
            );
            if (n) {
              this.inputView.value = n.label;
            } else {
              this.inputView.value = t || "";
            }
          }
        }
      }
      function MG(t) {
        return t
          .replace(/([(,])\\s+/g, "$1")
          .replace(/^\\s+|\\s+(?=[),\\s]|$)/g, "")
          .replace(/,|\\s/g, " ");
      }
      const BG = (t) => t === "";
      function LG(t) {
        return {
          none: t("None"),
          solid: t("Solid"),
          dotted: t("Dotted"),
          dashed: t("Dashed"),
          double: t("Double"),
          groove: t("Groove"),
          ridge: t("Ridge"),
          inset: t("Inset"),
          outset: t("Outset"),
        };
      }
      function NG(t) {
        return t(
          'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".'
        );
      }
      function zG(t) {
        return t('The value is invalid. Try "10px" or "2em" or simply "2".');
      }
      function PG(t) {
        t = t.trim();
        return BG(t) || $w(t);
      }
      function RG(t) {
        t = t.trim();
        return BG(t) || UG(t) || Qw(t) || Xw(t);
      }
      function OG(t) {
        t = t.trim();
        return BG(t) || UG(t) || Qw(t);
      }
      function jG(t, e) {
        const n = new rl();
        const i = LG(t.t);
        for (const o in i) {
          const r = {
            type: "button",
            model: new Py({
              _borderStyleValue: o,
              label: i[o],
              withText: true,
            }),
          };
          if (o === "none") {
            r.model.bind("isOn").to(t, "borderStyle", (t) => {
              if (e === "none") {
                return !t;
              }
              return t === o;
            });
          } else {
            r.model.bind("isOn").to(t, "borderStyle", (t) => t === o);
          }
          n.add(r);
        }
        return n;
      }
      function FG(t) {
        const {
          view: e,
          icons: n,
          toolbar: i,
          labels: o,
          propertyName: r,
          nameToValue: s,
          defaultValue: a,
        } = t;
        for (const t in o) {
          const c = new R_(e.locale);
          c.set({ label: o[t], icon: n[t], tooltip: o[t] });
          const l = s ? s(t) : t;
          c.bind("isOn").to(e, r, (t) => {
            let e = t;
            if (t === "" && a) {
              e = a;
            }
            return l === e;
          });
          c.on("execute", () => {
            e[r] = l;
          });
          i.items.add(c);
        }
      }
      const VG = [
        { color: "hsl(0, 0%, 0%)", label: "Black" },
        { color: "hsl(0, 0%, 30%)", label: "Dim grey" },
        { color: "hsl(0, 0%, 60%)", label: "Grey" },
        { color: "hsl(0, 0%, 90%)", label: "Light grey" },
        { color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true },
        { color: "hsl(0, 75%, 60%)", label: "Red" },
        { color: "hsl(30, 75%, 60%)", label: "Orange" },
        { color: "hsl(60, 75%, 60%)", label: "Yellow" },
        { color: "hsl(90, 75%, 60%)", label: "Light green" },
        { color: "hsl(120, 75%, 60%)", label: "Green" },
        { color: "hsl(150, 75%, 60%)", label: "Aquamarine" },
        { color: "hsl(180, 75%, 60%)", label: "Turquoise" },
        { color: "hsl(210, 75%, 60%)", label: "Light blue" },
        { color: "hsl(240, 75%, 60%)", label: "Blue" },
        { color: "hsl(270, 75%, 60%)", label: "Purple" },
      ];
      function HG(t) {
        return (e, n, i) => {
          const o = new IG(e.locale, {
            colorDefinitions: qG(t.colorConfig),
            columns: t.columns,
            defaultColorValue: t.defaultColorValue,
          });
          o.inputView.set({ id: n, ariaDescribedById: i });
          o.bind("isReadOnly").to(e, "isEnabled", (t) => !t);
          o.bind("hasError").to(e, "errorText", (t) => !!t);
          o.on("input", () => {
            e.errorText = null;
          });
          e.bind("isEmpty", "isFocused").to(o);
          return o;
        };
      }
      function UG(t) {
        const e = parseFloat(t);
        return !Number.isNaN(e) && t === String(e);
      }
      function qG(t) {
        return t.map((t) => ({
          color: t.model,
          label: t.label,
          options: { hasBorder: t.hasBorder },
        }));
      }
      var WG = n(9865);
      var GG = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      GG.insert = "head";
      GG.singleton = true;
      var $G = Il()(WG.Z, GG);
      const KG = WG.Z.locals || {};
      class YG extends pC {
        constructor(t, e = {}) {
          super(t);
          const n = this.bindTemplate;
          this.set("class", e.class || null);
          this.children = this.createCollection();
          if (e.children) {
            e.children.forEach((t) => this.children.add(t));
          }
          this.set("_role", null);
          this.set("_ariaLabelledBy", null);
          if (e.labelView) {
            this.set({ _role: "group", _ariaLabelledBy: e.labelView.id });
          }
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck", "ck-form__row", n.to("class")],
              role: n.to("_role"),
              "aria-labelledby": n.to("_ariaLabelledBy"),
            },
            children: this.children,
          });
        }
      }
      var ZG = n(4880);
      var QG = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      QG.insert = "head";
      QG.singleton = true;
      var JG = Il()(ZG.Z, QG);
      const XG = ZG.Z.locals || {};
      var t$ = n(198);
      var e$ = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      e$.insert = "head";
      e$.singleton = true;
      var n$ = Il()(t$.Z, e$);
      const i$ = t$.Z.locals || {};
      var o$ = n(9221);
      var r$ = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      r$.insert = "head";
      r$.singleton = true;
      var s$ = Il()(o$.Z, r$);
      const a$ = o$.Z.locals || {};
      const c$ = {
        left: __.objectLeft,
        center: __.objectCenter,
        right: __.objectRight,
      };
      class l$ extends pC {
        constructor(t, e) {
          super(t);
          this.set({
            borderStyle: "",
            borderWidth: "",
            borderColor: "",
            backgroundColor: "",
            width: "",
            height: "",
            alignment: "",
          });
          this.options = e;
          const {
            borderStyleDropdown: n,
            borderWidthInput: i,
            borderColorInput: o,
            borderRowLabel: r,
          } = this._createBorderFields();
          const { backgroundRowLabel: s, backgroundInput: a } =
            this._createBackgroundFields();
          const {
            widthInput: c,
            operatorLabel: l,
            heightInput: d,
            dimensionsLabel: u,
          } = this._createDimensionFields();
          const { alignmentToolbar: h, alignmentLabel: m } =
            this._createAlignmentFields();
          this.focusTracker = new al();
          this.keystrokes = new cl();
          this.children = this.createCollection();
          this.borderStyleDropdown = n;
          this.borderWidthInput = i;
          this.borderColorInput = o;
          this.backgroundInput = a;
          this.widthInput = c;
          this.heightInput = d;
          this.alignmentToolbar = h;
          const { saveButtonView: g, cancelButtonView: f } =
            this._createActionButtons();
          this.saveButtonView = g;
          this.cancelButtonView = f;
          this._focusables = new PA();
          this._focusCycler = new hv({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          });
          this.children.add(new by(t, { label: this.t("Table properties") }));
          this.children.add(
            new YG(t, {
              labelView: r,
              children: [r, n, o, i],
              class: "ck-table-form__border-row",
            })
          );
          this.children.add(
            new YG(t, {
              labelView: s,
              children: [s, a],
              class: "ck-table-form__background-row",
            })
          );
          this.children.add(
            new YG(t, {
              children: [
                new YG(t, {
                  labelView: u,
                  children: [u, c, l, d],
                  class: "ck-table-form__dimensions-row",
                }),
                new YG(t, {
                  labelView: m,
                  children: [m, h],
                  class: "ck-table-properties-form__alignment-row",
                }),
              ],
            })
          );
          this.children.add(
            new YG(t, {
              children: [this.saveButtonView, this.cancelButtonView],
              class: "ck-table-form__action-row",
            })
          );
          this.setTemplate({
            tag: "form",
            attributes: {
              class: [
                "ck",
                "ck-form",
                "ck-table-form",
                "ck-table-properties-form",
              ],
              tabindex: "-1",
            },
            children: this.children,
          });
        }
        render() {
          super.render();
          x_({ view: this });
          [
            this.borderStyleDropdown,
            this.borderColorInput,
            this.borderColorInput.fieldView.dropdownView.buttonView,
            this.borderWidthInput,
            this.backgroundInput,
            this.backgroundInput.fieldView.dropdownView.buttonView,
            this.widthInput,
            this.heightInput,
            this.alignmentToolbar,
            this.saveButtonView,
            this.cancelButtonView,
          ].forEach((t) => {
            this._focusables.add(t);
            this.focusTracker.add(t.element);
          });
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createBorderFields() {
          const t = this.options.defaultTableProperties;
          const e = {
            style: t.borderStyle,
            width: t.borderWidth,
            color: t.borderColor,
          };
          const n = HG({
            colorConfig: this.options.borderColors,
            columns: 5,
            defaultColorValue: e.color,
          });
          const i = this.locale;
          const o = this.t;
          const r = new ly(i);
          r.text = o("Border");
          const s = LG(this.t);
          const a = new My(i, Ny);
          a.set({ label: o("Style"), class: "ck-table-form__border-style" });
          a.fieldView.buttonView.set({
            isOn: false,
            withText: true,
            tooltip: o("Style"),
          });
          a.fieldView.buttonView
            .bind("label")
            .to(this, "borderStyle", (t) => s[t ? t : "none"]);
          a.fieldView.on("execute", (t) => {
            this.borderStyle = t.source._borderStyleValue;
          });
          a.bind("isEmpty").to(this, "borderStyle", (t) => !t);
          Wv(a.fieldView, jG(this, e.style));
          const c = new My(i, By);
          c.set({ label: o("Width"), class: "ck-table-form__border-width" });
          c.fieldView.bind("value").to(this, "borderWidth");
          c.bind("isEnabled").to(this, "borderStyle", d$);
          c.fieldView.on("input", () => {
            this.borderWidth = c.fieldView.element.value;
          });
          const l = new My(i, n);
          l.set({ label: o("Color"), class: "ck-table-form__border-color" });
          l.fieldView.bind("value").to(this, "borderColor");
          l.bind("isEnabled").to(this, "borderStyle", d$);
          l.fieldView.on("input", () => {
            this.borderColor = l.fieldView.value;
          });
          this.on("change:borderStyle", (t, n, i, o) => {
            if (!d$(i)) {
              this.borderColor = "";
              this.borderWidth = "";
            }
            if (!d$(o)) {
              this.borderColor = e.color;
              this.borderWidth = e.width;
            }
          });
          return {
            borderRowLabel: r,
            borderStyleDropdown: a,
            borderColorInput: l,
            borderWidthInput: c,
          };
        }
        _createBackgroundFields() {
          const t = this.locale;
          const e = this.t;
          const n = new ly(t);
          n.text = e("Background");
          const i = HG({
            colorConfig: this.options.backgroundColors,
            columns: 5,
            defaultColorValue:
              this.options.defaultTableProperties.backgroundColor,
          });
          const o = new My(t, i);
          o.set({
            label: e("Color"),
            class: "ck-table-properties-form__background",
          });
          o.fieldView.bind("value").to(this, "backgroundColor");
          o.fieldView.on("input", () => {
            this.backgroundColor = o.fieldView.value;
          });
          return { backgroundRowLabel: n, backgroundInput: o };
        }
        _createDimensionFields() {
          const t = this.locale;
          const e = this.t;
          const n = new ly(t);
          n.text = e("Dimensions");
          const i = new My(t, By);
          i.set({
            label: e("Width"),
            class: "ck-table-form__dimensions-row__width",
          });
          i.fieldView.bind("value").to(this, "width");
          i.fieldView.on("input", () => {
            this.width = i.fieldView.element.value;
          });
          const o = new pC(t);
          o.setTemplate({
            tag: "span",
            attributes: { class: ["ck-table-form__dimension-operator"] },
            children: [{ text: "" }],
          });
          const r = new My(t, By);
          r.set({
            label: e("Height"),
            class: "ck-table-form__dimensions-row__height",
          });
          r.fieldView.bind("value").to(this, "height");
          r.fieldView.on("input", () => {
            this.height = r.fieldView.element.value;
          });
          return {
            dimensionsLabel: n,
            widthInput: i,
            operatorLabel: o,
            heightInput: r,
          };
        }
        _createAlignmentFields() {
          const t = this.locale;
          const e = this.t;
          const n = new ly(t);
          n.text = e("Alignment");
          const i = new yv(t);
          i.set({ isCompact: true, ariaLabel: e("Table alignment toolbar") });
          FG({
            view: this,
            icons: c$,
            toolbar: i,
            labels: this._alignmentLabels,
            propertyName: "alignment",
            defaultValue: this.options.defaultTableProperties.alignment,
          });
          return { alignmentLabel: n, alignmentToolbar: i };
        }
        _createActionButtons() {
          const t = this.locale;
          const e = this.t;
          const n = new R_(t);
          const i = new R_(t);
          const o = [
            this.borderWidthInput,
            this.borderColorInput,
            this.backgroundInput,
            this.widthInput,
            this.heightInput,
          ];
          n.set({
            label: e("Save"),
            icon: __.check,
            class: "ck-button-save",
            type: "submit",
            withText: true,
          });
          n.bind("isEnabled").toMany(o, "errorText", (...t) =>
            t.every((t) => !t)
          );
          i.set({
            label: e("Cancel"),
            icon: __.cancel,
            class: "ck-button-cancel",
            withText: true,
          });
          i.delegate("execute").to(this, "cancel");
          return { saveButtonView: n, cancelButtonView: i };
        }
        get _alignmentLabels() {
          const t = this.locale;
          const e = this.t;
          const n = e("Align table to the left");
          const i = e("Center table");
          const o = e("Align table to the right");
          if (t.uiLanguageDirection === "rtl") {
            return { right: o, center: i, left: n };
          } else {
            return { left: n, center: i, right: o };
          }
        }
      }
      function d$(t) {
        return t !== "none";
      }
      const u$ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v5h4V2h1v5h5v1h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5H7v-5H2v-1h5V8H2V7h5V2h1zm4 6H8v4h4V8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM17 1a2 2 0 0 1 2 2v9.475l-.85-.124-.857-1.736a2.048 2.048 0 0 0-.292-.44L17 3H3v14h7.808l.402.392L10.935 19H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14z"/></svg>';
      function h$(t) {
        const e = t.getSelectedElement();
        if (e && g$(e)) {
          return e;
        }
        return null;
      }
      function m$(t) {
        const e = t.getFirstPosition();
        if (!e) {
          return null;
        }
        let n = e.parent;
        while (n) {
          if (n.is("element") && g$(n)) {
            return n;
          }
          n = n.parent;
        }
        return null;
      }
      function g$(t) {
        return !!t.getCustomProperty("table") && iD(t);
      }
      const f$ = vC.defaultPositions;
      const p$ = [
        f$.northArrowSouth,
        f$.northArrowSouthWest,
        f$.northArrowSouthEast,
        f$.southArrowNorth,
        f$.southArrowNorthWest,
        f$.southArrowNorthEast,
        f$.viewportStickyNorth,
      ];
      function b$(t, e) {
        const n = t.plugins.get("ContextualBalloon");
        if (m$(t.editing.view.document.selection)) {
          let i;
          if (e === "cell") {
            i = w$(t);
          } else {
            i = k$(t);
          }
          n.updatePosition(i);
        }
      }
      function k$(t) {
        const e = t.model.document.selection.getFirstPosition();
        const n = e.findAncestor("table");
        const i = t.editing.mapper.toViewElement(n);
        return {
          target: t.editing.view.domConverter.mapViewToDom(i),
          positions: p$,
        };
      }
      function w$(t) {
        const e = t.editing.mapper;
        const n = t.editing.view.domConverter;
        const i = t.model.document.selection;
        if (i.rangeCount > 1) {
          return { target: () => C$(i.getRanges(), t), positions: p$ };
        }
        const o = A$(i.getFirstPosition());
        const r = e.toViewElement(o);
        return { target: n.mapViewToDom(r), positions: p$ };
      }
      function A$(t) {
        const e = t.nodeAfter && t.nodeAfter.is("element", "tableCell");
        return e ? t.nodeAfter : t.findAncestor("tableCell");
      }
      function C$(t, e) {
        const n = e.editing.mapper;
        const i = e.editing.view.domConverter;
        const o = Array.from(t).map((t) => {
          const e = A$(t.start);
          const o = n.toViewElement(e);
          return new sc(i.mapViewToDom(o));
        });
        return sc.getBoundingRect(o);
      }
      const _$ = 500;
      const v$ = {
        borderStyle: "tableBorderStyle",
        borderColor: "tableBorderColor",
        borderWidth: "tableBorderWidth",
        backgroundColor: "tableBackgroundColor",
        width: "tableWidth",
        height: "tableHeight",
        alignment: "tableAlignment",
      };
      class y$ extends Cl {
        static get requires() {
          return [Ky];
        }
        static get pluginName() {
          return "TablePropertiesUI";
        }
        constructor(t) {
          super(t);
          t.config.define("table.tableProperties", {
            borderColors: VG,
            backgroundColors: VG,
          });
        }
        init() {
          const t = this.editor;
          const e = t.t;
          this._defaultTableProperties = oG(
            t.config.get("table.tableProperties.defaultProperties"),
            { includeAlignmentProperty: true }
          );
          this._balloon = t.plugins.get(Ky);
          this.view = this._createPropertiesView();
          this._undoStepBatch = null;
          t.ui.componentFactory.add("tableProperties", (n) => {
            const i = new R_(n);
            i.set({ label: e("Table properties"), icon: u$, tooltip: true });
            this.listenTo(i, "execute", () => this._showView());
            const o = Object.values(v$).map((e) => t.commands.get(e));
            i.bind("isEnabled").toMany(o, "isEnabled", (...t) =>
              t.some((t) => t)
            );
            return i;
          });
        }
        destroy() {
          super.destroy();
          this.view.destroy();
        }
        _createPropertiesView() {
          const t = this.editor;
          const e = t.config.get("table.tableProperties");
          const n = q_(e.borderColors);
          const i = U_(t.locale, n);
          const o = q_(e.backgroundColors);
          const r = U_(t.locale, o);
          const s = new l$(t.locale, {
            borderColors: i,
            backgroundColors: r,
            defaultTableProperties: this._defaultTableProperties,
          });
          const a = t.t;
          s.render();
          this.listenTo(s, "submit", () => {
            this._hideView();
          });
          this.listenTo(s, "cancel", () => {
            if (this._undoStepBatch.operations.length) {
              t.execute("undo", this._undoStepBatch);
            }
            this._hideView();
          });
          s.keystrokes.set("Esc", (t, e) => {
            this._hideView();
            e();
          });
          v_({
            emitter: s,
            activator: () => this._isViewInBalloon,
            contextElements: [this._balloon.view.element],
            callback: () => this._hideView(),
          });
          const c = NG(a);
          const l = zG(a);
          s.on(
            "change:borderStyle",
            this._getPropertyChangeCallback(
              "tableBorderStyle",
              this._defaultTableProperties.borderStyle
            )
          );
          s.on(
            "change:borderColor",
            this._getValidatedPropertyChangeCallback({
              viewField: s.borderColorInput,
              commandName: "tableBorderColor",
              errorText: c,
              validator: PG,
              defaultValue: this._defaultTableProperties.borderColor,
            })
          );
          s.on(
            "change:borderWidth",
            this._getValidatedPropertyChangeCallback({
              viewField: s.borderWidthInput,
              commandName: "tableBorderWidth",
              errorText: l,
              validator: OG,
              defaultValue: this._defaultTableProperties.borderWidth,
            })
          );
          s.on(
            "change:backgroundColor",
            this._getValidatedPropertyChangeCallback({
              viewField: s.backgroundInput,
              commandName: "tableBackgroundColor",
              errorText: c,
              validator: PG,
              defaultValue: this._defaultTableProperties.backgroundColor,
            })
          );
          s.on(
            "change:width",
            this._getValidatedPropertyChangeCallback({
              viewField: s.widthInput,
              commandName: "tableWidth",
              errorText: l,
              validator: RG,
              defaultValue: this._defaultTableProperties.width,
            })
          );
          s.on(
            "change:height",
            this._getValidatedPropertyChangeCallback({
              viewField: s.heightInput,
              commandName: "tableHeight",
              errorText: l,
              validator: RG,
              defaultValue: this._defaultTableProperties.height,
            })
          );
          s.on(
            "change:alignment",
            this._getPropertyChangeCallback(
              "tableAlignment",
              this._defaultTableProperties.alignment
            )
          );
          return s;
        }
        _fillViewFormFromCommandValues() {
          const t = this.editor.commands;
          const e = t.get("tableBorderStyle");
          Object.entries(v$)
            .map(([e, n]) => {
              const i = this._defaultTableProperties[e] || "";
              return [e, t.get(n).value || i];
            })
            .forEach(([t, n]) => {
              if (
                (t === "borderColor" || t === "borderWidth") &&
                e.value === "none"
              ) {
                return;
              }
              this.view.set(t, n);
            });
        }
        _showView() {
          const t = this.editor;
          this.listenTo(t.ui, "update", () => {
            this._updateView();
          });
          this._fillViewFormFromCommandValues();
          this._balloon.add({ view: this.view, position: k$(t) });
          this._undoStepBatch = t.model.createBatch();
          this.view.focus();
        }
        _hideView() {
          const t = this.editor;
          this.stopListening(t.ui, "update");
          this.view.saveButtonView.focus();
          this._balloon.remove(this.view);
          this.editor.editing.view.focus();
        }
        _updateView() {
          const t = this.editor;
          const e = t.editing.view.document;
          if (!m$(e.selection)) {
            this._hideView();
          } else if (this._isViewVisible) {
            b$(t, "table");
          }
        }
        get _isViewVisible() {
          return this._balloon.visibleView === this.view;
        }
        get _isViewInBalloon() {
          return this._balloon.hasView(this.view);
        }
        _getPropertyChangeCallback(t, e) {
          return (n, i, o, r) => {
            if (!r && e === o) {
              return;
            }
            this.editor.execute(t, { value: o, batch: this._undoStepBatch });
          };
        }
        _getValidatedPropertyChangeCallback(t) {
          const {
            commandName: e,
            viewField: n,
            validator: i,
            errorText: o,
            defaultValue: r,
          } = t;
          const s = Qm(() => {
            n.errorText = o;
          }, _$);
          return (t, o, a, c) => {
            s.cancel();
            if (!c && r === a) {
              return;
            }
            if (i(a)) {
              this.editor.execute(e, { value: a, batch: this._undoStepBatch });
              n.errorText = null;
            } else {
              s();
            }
          };
        }
      }
      class x$ extends Cl {
        static get pluginName() {
          return "TableProperties";
        }
        static get requires() {
          return [CG, y$];
        }
      }
      class E$ extends Cl {
        static get requires() {
          return [$D];
        }
        static get pluginName() {
          return "TableToolbar";
        }
        afterInit() {
          const t = this.editor;
          const e = t.t;
          const n = t.plugins.get($D);
          const i = t.config.get("table.contentToolbar");
          const o = t.config.get("table.tableToolbar");
          if (i) {
            n.register("tableContent", {
              ariaLabel: e("Table toolbar"),
              items: i,
              getRelatedElement: m$,
            });
          }
          if (o) {
            n.register("table", {
              ariaLabel: e("Table toolbar"),
              items: o,
              getRelatedElement: h$,
            });
          }
        }
      }
      const D$ = "todoListChecked";
      class S$ extends vl {
        constructor(t) {
          super(t);
          this._selectedElements = [];
          this.on(
            "execute",
            () => {
              this.refresh();
            },
            { priority: "highest" }
          );
        }
        refresh() {
          this._selectedElements = this._getSelectedItems();
          this.value = this._selectedElements.every(
            (t) => !!t.getAttribute("todoListChecked")
          );
          this.isEnabled = !!this._selectedElements.length;
        }
        _getSelectedItems() {
          const t = this.editor.model;
          const e = t.schema;
          const n = t.document.selection.getFirstRange();
          const i = n.start.parent;
          const o = [];
          if (e.checkAttribute(i, D$)) {
            o.push(i);
          }
          for (const t of n.getItems()) {
            if (e.checkAttribute(t, D$) && !o.includes(t)) {
              o.push(t);
            }
          }
          return o;
        }
        execute(t = {}) {
          this.editor.model.change((e) => {
            for (const n of this._selectedElements) {
              const i = t.forceValue === undefined ? !this.value : t.forceValue;
              if (i) {
                e.setAttribute(D$, true, n);
              } else {
                e.removeAttribute(D$, n);
              }
            }
          });
        }
      }
      function T$(t, e) {
        return (n, i, o) => {
          const r = o.consumable;
          if (
            !r.test(i.item, "insert") ||
            !r.test(i.item, "attribute:listType") ||
            !r.test(i.item, "attribute:listIndent")
          ) {
            return;
          }
          if (i.item.getAttribute("listType") != "todo") {
            return;
          }
          const s = i.item;
          r.consume(s, "insert");
          r.consume(s, "attribute:listType");
          r.consume(s, "attribute:listIndent");
          r.consume(s, "attribute:todoListChecked");
          const a = o.writer;
          const c = uj(s, o);
          const l = !!s.getAttribute("todoListChecked");
          const d = z$(s, a, l, e);
          const u = a.createContainerElement("span", {
            class: "todo-list__label__description",
          });
          a.addClass("todo-list", c.parent);
          a.insert(a.createPositionAt(c, 0), d);
          a.insert(a.createPositionAfter(d), u);
          hj(s, c, o, t);
        };
      }
      function I$(t) {
        return (e, n, i) => {
          const o = i.consumable;
          if (
            !o.test(n.item, "insert") ||
            !o.test(n.item, "attribute:listType") ||
            !o.test(n.item, "attribute:listIndent")
          ) {
            return;
          }
          if (n.item.getAttribute("listType") != "todo") {
            return;
          }
          const r = n.item;
          o.consume(r, "insert");
          o.consume(r, "attribute:listType");
          o.consume(r, "attribute:listIndent");
          o.consume(r, "attribute:todoListChecked");
          const s = i.writer;
          const a = uj(r, i);
          s.addClass("todo-list", a.parent);
          const c = s.createContainerElement("label", {
            class: "todo-list__label",
          });
          const l = s.createEmptyElement("input", {
            type: "checkbox",
            disabled: "disabled",
          });
          const d = s.createContainerElement("span", {
            class: "todo-list__label__description",
          });
          if (r.getAttribute("todoListChecked")) {
            s.setAttribute("checked", "checked", l);
          }
          s.insert(s.createPositionAt(a, 0), c);
          s.insert(s.createPositionAt(c, 0), l);
          s.insert(s.createPositionAfter(l), d);
          hj(r, a, i, t);
        };
      }
      function M$(t, e, n) {
        const i = e.modelCursor;
        const o = i.parent;
        const r = e.viewItem;
        if (
          r.getAttribute("type") != "checkbox" ||
          o.name != "listItem" ||
          !i.isAtStart
        ) {
          return;
        }
        if (!n.consumable.consume(r, { name: true })) {
          return;
        }
        const s = n.writer;
        s.setAttribute("listType", "todo", o);
        if (e.viewItem.hasAttribute("checked")) {
          s.setAttribute("todoListChecked", true, o);
        }
        e.modelRange = s.createRange(i);
      }
      function B$(t, e) {
        return (n, i, o) => {
          if (!o.consumable.consume(i.item, n.name)) {
            return;
          }
          const r = o.mapper.toViewElement(i.item);
          const s = o.writer;
          const a = P$(r, e);
          if (i.attributeNewValue == "todo") {
            const e = !!i.item.getAttribute("todoListChecked");
            const n = z$(i.item, s, e, t);
            const o = s.createContainerElement("span", {
              class: "todo-list__label__description",
            });
            const a = s.createRangeIn(r);
            const c = bj(r);
            const l = gj(a.start);
            const d = c ? s.createPositionBefore(c) : a.end;
            const u = s.createRange(l, d);
            s.addClass("todo-list", r.parent);
            s.move(u, s.createPositionAt(o, 0));
            s.insert(s.createPositionAt(r, 0), n);
            s.insert(s.createPositionAfter(n), o);
          } else if (i.attributeOldValue == "todo") {
            const t = R$(r, e);
            s.removeClass("todo-list", r.parent);
            s.remove(a);
            s.move(s.createRangeIn(t), s.createPositionBefore(t));
            s.remove(t);
          }
        };
      }
      function L$(t) {
        return (e, n, i) => {
          if (n.item.getAttribute("listType") != "todo") {
            return;
          }
          if (!i.consumable.consume(n.item, "attribute:todoListChecked")) {
            return;
          }
          const { mapper: o, writer: r } = i;
          const s = !!n.item.getAttribute("todoListChecked");
          const a = o.toViewElement(n.item);
          const c = a.getChild(0);
          const l = z$(n.item, r, s, t);
          r.insert(r.createPositionAfter(c), l);
          r.remove(c);
        };
      }
      function N$(t) {
        return (e, n) => {
          const i = n.modelPosition;
          const o = i.parent;
          if (
            !o.is("element", "listItem") ||
            o.getAttribute("listType") != "todo"
          ) {
            return;
          }
          const r = n.mapper.toViewElement(o);
          const s = R$(r, t);
          if (s) {
            n.viewPosition = n.mapper.findPositionIn(s, i.offset);
          }
        };
      }
      function z$(t, e, n, i) {
        const o = e.createUIElement(
          "label",
          { class: "todo-list__label", contenteditable: false },
          function (e) {
            const o = te(document, "input", { type: "checkbox", tabindex: -1 });
            if (n) {
              o.setAttribute("checked", "checked");
            }
            o.addEventListener("change", () => i(t));
            const r = this.toDomElement(e);
            r.appendChild(o);
            return r;
          }
        );
        return o;
      }
      function P$(t, e) {
        const n = e.createRangeIn(t);
        for (const t of n) {
          if (t.item.is("uiElement", "label")) {
            return t.item;
          }
        }
      }
      function R$(t, e) {
        const n = e.createRangeIn(t);
        for (const t of n) {
          if (
            t.item.is("containerElement", "span") &&
            t.item.hasClass("todo-list__label__description")
          ) {
            return t.item;
          }
        }
      }
      const O$ = Vc("Ctrl+Enter");
      class j$ extends Cl {
        static get pluginName() {
          return "TodoListEditing";
        }
        static get requires() {
          return [qj];
        }
        init() {
          const t = this.editor;
          const { editing: e, data: n, model: i } = t;
          i.schema.extend("listItem", { allowAttributes: ["todoListChecked"] });
          i.schema.addAttributeCheck((t, e) => {
            const n = t.last;
            if (
              e == "todoListChecked" &&
              n.name == "listItem" &&
              n.getAttribute("listType") != "todo"
            ) {
              return false;
            }
          });
          t.commands.add("todoList", new sj(t, "todo"));
          const o = new S$(t);
          t.commands.add("checkTodoList", o);
          t.commands.add("todoListCheck", o);
          n.downcastDispatcher.on("insert:listItem", I$(i), {
            priority: "high",
          });
          n.upcastDispatcher.on("element:input", M$, { priority: "high" });
          e.downcastDispatcher.on(
            "insert:listItem",
            T$(i, (t) => this._handleCheckmarkChange(t)),
            { priority: "high" }
          );
          e.downcastDispatcher.on(
            "attribute:listType:listItem",
            B$((t) => this._handleCheckmarkChange(t), e.view)
          );
          e.downcastDispatcher.on(
            "attribute:todoListChecked:listItem",
            L$((t) => this._handleCheckmarkChange(t))
          );
          e.mapper.on("modelToViewPosition", N$(e.view));
          n.mapper.on("modelToViewPosition", N$(e.view));
          this.listenTo(e.view.document, "arrowKey", F$(i, t.locale), {
            context: "li",
          });
          this.listenTo(
            e.view.document,
            "keydown",
            (e, n) => {
              if (Fc(n) === O$) {
                t.execute("checkTodoList");
                e.stop();
              }
            },
            { priority: "high" }
          );
          const r = new Set();
          this.listenTo(i, "applyOperation", (t, e) => {
            const n = e[0];
            if (n.type == "rename" && n.oldName == "listItem") {
              const t = n.position.nodeAfter;
              if (t.hasAttribute("todoListChecked")) {
                r.add(t);
              }
            } else if (
              n.type == "changeAttribute" &&
              n.key == "listType" &&
              n.oldValue === "todo"
            ) {
              for (const t of n.range.getItems()) {
                if (
                  t.hasAttribute("todoListChecked") &&
                  t.getAttribute("listType") !== "todo"
                ) {
                  r.add(t);
                }
              }
            }
          });
          i.document.registerPostFixer((t) => {
            let e = false;
            for (const n of r) {
              t.removeAttribute("todoListChecked", n);
              e = true;
            }
            r.clear();
            return e;
          });
        }
        _handleCheckmarkChange(t) {
          const e = this.editor;
          const n = e.model;
          const i = Array.from(n.document.selection.getRanges());
          n.change((n) => {
            n.setSelection(t, "end");
            e.execute("checkTodoList");
            n.setSelection(i);
          });
        }
      }
      function F$(t, e) {
        return (n, i) => {
          const o = qc(i.keyCode, e.contentLanguageDirection);
          if (o != "left") {
            return;
          }
          const r = t.schema;
          const s = t.document.selection;
          if (!s.isCollapsed) {
            return;
          }
          const a = s.getFirstPosition();
          const c = a.parent;
          if (
            c.name === "listItem" &&
            c.getAttribute("listType") == "todo" &&
            a.isAtStart
          ) {
            const e = r.getNearestSelectionRange(
              t.createPositionBefore(c),
              "backward"
            );
            if (e) {
              t.change((t) => t.setSelection(e));
            }
            i.preventDefault();
            i.stopPropagation();
            n.stop();
          }
        };
      }
      const V$ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m2.315 14.705 2.224-2.24a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .949L2.865 16.07a.682.682 0 0 1-.112.089.647.647 0 0 1-.852-.051L.688 14.886a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.717.722zm5.185.045a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75zM2.329 5.745l2.21-2.226a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .95L2.865 7.125a.685.685 0 0 1-.496.196.644.644 0 0 1-.468-.187L.688 5.912a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.73.736zM7.5 5.75A.75.75 0 0 1 8.25 5h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>';
      class H$ extends Cl {
        static get pluginName() {
          return "TodoListUI";
        }
        init() {
          const t = this.editor.t;
          pj(this.editor, "todoList", t("To-do List"), V$);
        }
      }
      var U$ = n(1588);
      var q$ = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      q$.insert = "head";
      q$.singleton = true;
      var W$ = Il()(U$.Z, q$);
      const G$ = U$.Z.locals || {};
      class $$ extends Cl {
        static get requires() {
          return [j$, H$];
        }
        static get pluginName() {
          return "TodoList";
        }
      }
      const K$ = "underline";
      class Y$ extends Cl {
        static get pluginName() {
          return "UnderlineEditing";
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: K$ });
          t.model.schema.setAttributeProperties(K$, {
            isFormatting: true,
            copyOnEnter: true,
          });
          t.conversion.attributeToElement({
            model: K$,
            view: "u",
            upcastAlso: { styles: { "text-decoration": "underline" } },
          });
          t.commands.add(K$, new SI(t, K$));
          t.keystrokes.set("CTRL+U", "underline");
        }
      }
      const Z$ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>';
      const Q$ = "underline";
      class J$ extends Cl {
        static get pluginName() {
          return "UnderlineUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(Q$, (n) => {
            const i = t.commands.get(Q$);
            const o = new R_(n);
            o.set({
              label: e("Underline"),
              icon: Z$,
              keystroke: "CTRL+U",
              tooltip: true,
              isToggleable: true,
            });
            o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
            this.listenTo(o, "execute", () => {
              t.execute(Q$);
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class X$ extends Cl {
        static get requires() {
          return [Y$, J$];
        }
        static get pluginName() {
          return "Underline";
        }
      }
      function tK(t) {
        if (t.is("$text") || t.is("$textProxy")) {
          return t.data;
        }
        let e = "";
        let n = null;
        for (const i of t.getChildren()) {
          const t = tK(i);
          if (n && n.is("element")) {
            e += "\\n";
          }
          e += t;
          n = i;
        }
        return e;
      }
      class eK extends Cl {
        constructor(t) {
          super(t);
          this.set("characters", 0);
          this.set("words", 0);
          Object.defineProperties(this, {
            characters: {
              get() {
                return (this.characters = this._getCharacters());
              },
            },
            words: {
              get() {
                return (this.words = this._getWords());
              },
            },
          });
          this.set("_wordsLabel");
          this.set("_charactersLabel");
          this._config = t.config.get("wordCount") || {};
          this._outputView = undefined;
          this._wordsMatchRegExp = r.features.isRegExpUnicodePropertySupported
            ? new RegExp("([\\\\p{L}\\\\p{N}]+\\\\S?)+", "gu")
            : /([a-zA-Z0-9-]+\\S?)+/gu;
        }
        static get pluginName() {
          return "WordCount";
        }
        init() {
          const t = this.editor;
          t.model.document.on(
            "change:data",
            dS(this._refreshStats.bind(this), 250)
          );
          if (typeof this._config.onUpdate == "function") {
            this.on("update", (t, e) => {
              this._config.onUpdate(e);
            });
          }
          if (Va(this._config.container)) {
            this._config.container.appendChild(this.wordCountContainer);
          }
        }
        destroy() {
          if (this._outputView) {
            this._outputView.element.remove();
            this._outputView.destroy();
          }
          super.destroy();
        }
        get wordCountContainer() {
          const t = this.editor;
          const e = t.t;
          const n = t.config.get("wordCount.displayWords");
          const i = t.config.get("wordCount.displayCharacters");
          const o = jA.bind(this, this);
          const r = [];
          if (!this._outputView) {
            this._outputView = new pC();
            if (n || n === undefined) {
              this.bind("_wordsLabel").to(this, "words", (t) =>
                e("Words: %0", t)
              );
              r.push({
                tag: "div",
                children: [{ text: [o.to("_wordsLabel")] }],
                attributes: { class: "ck-word-count__words" },
              });
            }
            if (i || i === undefined) {
              this.bind("_charactersLabel").to(this, "characters", (t) =>
                e("Characters: %0", t)
              );
              r.push({
                tag: "div",
                children: [{ text: [o.to("_charactersLabel")] }],
                attributes: { class: "ck-word-count__characters" },
              });
            }
            this._outputView.setTemplate({
              tag: "div",
              attributes: { class: ["ck", "ck-word-count"] },
              children: r,
            });
            this._outputView.render();
          }
          return this._outputView.element;
        }
        _getCharacters() {
          const t = tK(this.editor.model.document.getRoot());
          return t.replace(/\\n/g, "").length;
        }
        _getWords() {
          const t = tK(this.editor.model.document.getRoot());
          const e = t.match(this._wordsMatchRegExp) || [];
          return e.length;
        }
        _refreshStats() {
          const t = (this.words = this._getWords());
          const e = (this.characters = this._getCharacters());
          this.fire("update", { words: t, characters: e });
        }
      }
      class nK extends bx {}
      nK.builtinPlugins = [
        zx,
        TE,
        XS,
        aI,
        fI,
        DI,
        gx,
        LI,
        WI,
        nM,
        NM,
        HM,
        dB,
        fB,
        xB,
        qB,
        dN,
        IN,
        UN,
        ez,
        gz,
        $z,
        nP,
        oR,
        kR,
        ZR,
        QR,
        UP,
        iO,
        lO,
        fO,
        KO,
        rj,
        Yj,
        TF,
        IF,
        gV,
        bN,
        tH,
        sH,
        bH,
        jH,
        FH,
        VH,
        WH,
        HH,
        qH,
        QH,
        iU,
        lU,
        TW,
        uG,
        x$,
        E$,
        fE,
        $$,
        X$,
        eK,
      ];
      nK.defaultConfig = {
        toolbar: {
          items: [
            "bold",
            "italic",
            "underline",
            "strikethrough",
            "subscript",
            "superscript",
            "blockQuote",
            "fontFamily",
            "fontBackgroundColor",
            "fontColor",
            "fontSize",
            "highlight",
            "removeFormat",
            "specialCharacters",
          ],
        },
        language: "en",
        blockToolbar: [
          "heading",
          "imageUpload",
          "imageInsert",
          "mediaEmbed",
          "link",
          "alignment",
          "indent",
          "outdent",
          "numberedList",
          "bulletedList",
          "todoList",
          "insertTable",
          "code",
          "codeBlock",
          "horizontalLine",
          "htmlEmbed",
          "sourceEditing",
          "undo",
        ],
        image: {
          toolbar: [
            "imageTextAlternative",
            "toggleImageCaption",
            "imageStyle:inline",
            "imageStyle:block",
            "imageStyle:side",
            "linkImage",
          ],
        },
        table: {
          contentToolbar: [
            "tableColumn",
            "tableRow",
            "mergeTableCells",
            "tableProperties",
          ],
        },
      };
      const iK = nK;
    })();
    i = i["default"];
    return i;
  })()
);`;
var Fy = /* @__PURE__ */ W('<div id="editorContent" style="margin: 0px 34px; min-height: 34px;"></div>');
function jy(o, n) {
  Ve(n, !0);
  let t = $(n, "editorContent", 15, ""), e;
  wb(() => {
    const s = document.createElement("script");
    s.textContent = Vy, document.head.appendChild(s), i();
  });
  function i() {
    let s = document.getElementById("editorContent");
    BalloonBlockEditor.create(s, {
      placeholder: "Add your content here...",
      // simpleUpload: {
      //   uploadUrl: imageUploadPath,
      //   withCredentials: true,
      //   headers: {
      //     Authorization: "Bearer " + "xyz",
      //   },
      // },
      autosave: {
        save() {
          return t(e.getData()), document.dispatchEvent(new CustomEvent("EditorContentSave", { detail: { text: t() } })), !0;
        }
      }
    }).then((a) => {
      e = a, t() && (console.log("Setting loaded to true in editor create"), e.setData(t()));
    });
  }
  var r = Fy();
  U(o, r), Fe();
}
customElements.define("gen-editor", ae(jy, { editorContent: { reflect: !0 } }, [], [], !1));
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
function Hy(o, n) {
  return n.forEach(function(t) {
    t && typeof t != "string" && !Array.isArray(t) && Object.keys(t).forEach(function(e) {
      if (e !== "default" && !(e in o)) {
        var i = Object.getOwnPropertyDescriptor(t, e);
        Object.defineProperty(o, e, i.get ? i : { enumerable: !0, get: function() {
          return t[e];
        } });
      }
    });
  }), Object.freeze(o);
}
let Fc;
try {
  Fc = { window, document };
} catch {
  Fc = { window: {}, document: {} };
}
var N = Fc;
function Uy() {
  try {
    return navigator.userAgent.toLowerCase();
  } catch {
    return "";
  }
}
const Ri = Uy(), H = { isMac: Lb(Ri), isWindows: $y(Ri), isGecko: qy(Ri), isSafari: Wy(Ri), isiOS: Gy(Ri), isAndroid: Ky(Ri), isBlink: Yy(Ri), get isMediaForcedColors() {
  return !!N.window.matchMedia && N.window.matchMedia("(forced-colors: active)").matches;
}, get isMotionReduced() {
  return !!N.window.matchMedia && N.window.matchMedia("(prefers-reduced-motion)").matches;
}, features: { isRegExpUnicodePropertySupported: Zy() } };
function Lb(o) {
  return o.indexOf("macintosh") > -1;
}
function $y(o) {
  return o.indexOf("windows") > -1;
}
function qy(o) {
  return !!o.match(/gecko\/\d+/);
}
function Wy(o) {
  return o.indexOf(" applewebkit/") > -1 && o.indexOf("chrome") === -1;
}
function Gy(o) {
  return !!o.match(/iphone|ipad/i) || Lb(o) && navigator.maxTouchPoints > 0;
}
function Ky(o) {
  return o.indexOf("android") > -1;
}
function Yy(o) {
  return o.indexOf("chrome/") > -1 && o.indexOf("edge/") < 0;
}
function Zy() {
  let o = !1;
  try {
    o = "".search(new RegExp("[\\p{L}]", "u")) === 0;
  } catch {
  }
  return o;
}
function Bb(o, n, t, e) {
  t = t || function(l, c) {
    return l === c;
  };
  const i = Array.isArray(o) ? o : Array.prototype.slice.call(o), r = Array.isArray(n) ? n : Array.prototype.slice.call(n), s = function(l, c, d) {
    const u = lh(l, c, d);
    if (u === -1) return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
    const h = ch(l, u), g = ch(c, u), f = lh(h, g, d), p = l.length - f, b = c.length - f;
    return { firstIndex: u, lastIndexOld: p, lastIndexNew: b };
  }(i, r, t);
  return e ? function(l, c) {
    const { firstIndex: d, lastIndexOld: u, lastIndexNew: h } = l;
    if (d === -1) return Array(c).fill("equal");
    let g = [];
    return d > 0 && (g = g.concat(Array(d).fill("equal"))), h - d > 0 && (g = g.concat(Array(h - d).fill("insert"))), u - d > 0 && (g = g.concat(Array(u - d).fill("delete"))), h < c && (g = g.concat(Array(c - h).fill("equal"))), g;
  }(s, r.length) : function(l, c) {
    const d = [], { firstIndex: u, lastIndexOld: h, lastIndexNew: g } = c;
    return g - u > 0 && d.push({ index: u, type: "insert", values: l.slice(u, g) }), h - u > 0 && d.push({ index: u + (g - u), type: "delete", howMany: h - u }), d;
  }(r, s);
}
function lh(o, n, t) {
  for (let e = 0; e < Math.max(o.length, n.length); e++) if (o[e] === void 0 || n[e] === void 0 || !t(o[e], n[e])) return e;
  return -1;
}
function ch(o, n) {
  return o.slice(n).reverse();
}
function Go(o, n, t) {
  t = t || function(p, b) {
    return p === b;
  };
  const e = o.length, i = n.length;
  if (e > 200 || i > 200 || e + i > 300) return Go.fastDiff(o, n, t, !0);
  let r, s;
  if (i < e) {
    const p = o;
    o = n, n = p, r = "delete", s = "insert";
  } else r = "insert", s = "delete";
  const a = o.length, l = n.length, c = l - a, d = {}, u = {};
  function h(p) {
    const b = (u[p - 1] !== void 0 ? u[p - 1] : -1) + 1, k = u[p + 1] !== void 0 ? u[p + 1] : -1, w = b > k ? -1 : 1;
    d[p + w] && (d[p] = d[p + w].slice(0)), d[p] || (d[p] = []), d[p].push(b > k ? r : s);
    let _ = Math.max(b, k), y = _ - p;
    for (; y < a && _ < l && t(o[y], n[_]); ) y++, _++, d[p].push("equal");
    return _;
  }
  let g, f = 0;
  do {
    for (g = -f; g < c; g++) u[g] = h(g);
    for (g = c + f; g > c; g--) u[g] = h(g);
    u[c] = h(c), f++;
  } while (u[c] !== l);
  return d[c].slice(1);
}
Go.fastDiff = Bb;
class oi {
  constructor(n, t) {
    m(this, "source");
    m(this, "name");
    m(this, "path");
    m(this, "stop");
    m(this, "off");
    m(this, "return");
    this.source = n, this.name = t, this.path = [], this.stop = function e() {
      e.called = !0;
    }, this.off = function e() {
      e.called = !0;
    };
  }
}
const ye = new Array(256).fill("").map((o, n) => ("0" + n.toString(16)).slice(-2));
function Ee() {
  const [o, n, t, e] = crypto.getRandomValues(new Uint32Array(4));
  return "e" + ye[255 & o] + ye[o >> 8 & 255] + ye[o >> 16 & 255] + ye[o >> 24 & 255] + ye[255 & n] + ye[n >> 8 & 255] + ye[n >> 16 & 255] + ye[n >> 24 & 255] + ye[255 & t] + ye[t >> 8 & 255] + ye[t >> 16 & 255] + ye[t >> 24 & 255] + ye[255 & e] + ye[e >> 8 & 255] + ye[e >> 16 & 255] + ye[e >> 24 & 255];
}
const Ci = { get(o = "normal") {
  return typeof o != "number" ? this[o] || this.normal : o;
}, highest: 1e5, high: 1e3, normal: 0, low: -1e3, lowest: -1e5 };
function Nb(o, n) {
  const t = Ci.get(n.priority);
  let e = 0, i = o.length;
  for (; e < i; ) {
    const r = e + i >> 1;
    Ci.get(o[r].priority) < t ? i = r : e = r + 1;
  }
  o.splice(e, 0, n);
}
class v extends Error {
  constructor(t, e, i) {
    super(function(r, s) {
      const a = /* @__PURE__ */ new WeakSet(), l = (u, h) => {
        if (typeof h == "object" && h !== null) {
          if (a.has(h)) return `[object ${h.constructor.name}]`;
          a.add(h);
        }
        return h;
      }, c = s ? ` ${JSON.stringify(s, l)}` : "", d = zb(r);
      return r + c + d;
    }(t, i));
    m(this, "context");
    m(this, "data");
    this.name = "CKEditorError", this.context = e, this.data = i;
  }
  is(t) {
    return t === "CKEditorError";
  }
  static rethrowUnexpectedError(t, e) {
    if (t.is && t.is("CKEditorError")) throw t;
    const i = new v(t.message, e);
    throw i.stack = t.stack, i;
  }
}
function at(o, n) {
  console.warn(...Ob(o, n));
}
function Qy(o, n) {
  console.error(...Ob(o, n));
}
function zb(o) {
  return `
Read more: https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html#error-${o}`;
}
function Ob(o, n) {
  const t = zb(o);
  return n ? [o, n, t] : [o, t];
}
const Rb = "45.0.0", Jy = new Date(2025, 3, 7);
if (globalThis.CKEDITOR_VERSION) throw new v("ckeditor-duplicated-modules", null);
globalThis.CKEDITOR_VERSION = Rb;
const Io = Symbol("listeningTo"), jc = Symbol("emitterId"), $n = Symbol("delegations"), Vb = vt(Object);
function vt(o) {
  return o ? class extends o {
    on(n, t, e) {
      this.listenTo(this, n, t, e);
    }
    once(n, t, e) {
      let i = !1;
      this.listenTo(this, n, (r, ...s) => {
        i || (i = !0, r.off(), t.call(this, r, ...s));
      }, e);
    }
    off(n, t) {
      this.stopListening(this, n, t);
    }
    listenTo(n, t, e, i = {}) {
      let r, s;
      this[Io] || (this[Io] = {});
      const a = this[Io];
      Al(n) || Fb(n);
      const l = Al(n);
      (r = a[l]) || (r = a[l] = { emitter: n, callbacks: {} }), (s = r.callbacks[t]) || (s = r.callbacks[t] = []), s.push(e), function(c, d, u, h, g) {
        d._addEventListener ? d._addEventListener(u, h, g) : c._addEventListener.call(d, u, h, g);
      }(this, n, t, e, i);
    }
    stopListening(n, t, e) {
      const i = this[Io];
      let r = n && Al(n);
      const s = i && r ? i[r] : void 0, a = s && t ? s.callbacks[t] : void 0;
      if (!(!i || n && !s || t && !a)) if (e)
        xl(this, n, t, e), a.indexOf(e) !== -1 && (a.length === 1 ? delete s.callbacks[t] : xl(this, n, t, e));
      else if (a) {
        for (; e = a.pop(); ) xl(this, n, t, e);
        delete s.callbacks[t];
      } else if (s) {
        for (t in s.callbacks) this.stopListening(n, t);
        delete i[r];
      } else {
        for (r in i) this.stopListening(i[r].emitter);
        delete this[Io];
      }
    }
    fire(n, ...t) {
      try {
        const e = n instanceof oi ? n : new oi(this, n), i = e.name;
        let r = function(a, l) {
          if (!a._events) return null;
          let c = l;
          do {
            const d = a._events[c];
            if (d && d.callbacks && d.callbacks.length) return d.callbacks;
            const u = c.lastIndexOf(":");
            c = u > -1 ? c.substring(0, u) : "";
          } while (c);
          return null;
        }(this, i);
        if (e.path.push(this), r) {
          r = r.slice();
          for (let a = 0; a < r.length; a++) {
            const l = r[a].callback;
            if (l.call(this, e, ...t), e.off.called && (delete e.off.called, this._removeEventListener(i, l)), e.stop.called) break;
          }
        }
        const s = this[$n];
        if (s) {
          const a = s.get(i), l = s.get("*");
          a && dh(a, e, t), l && dh(l, e, t);
        }
        return e.return;
      } catch (e) {
        v.rethrowUnexpectedError(e, this);
      }
    }
    delegate(...n) {
      return { to: (t, e) => {
        this[$n] || (this[$n] = /* @__PURE__ */ new Map()), n.forEach((i) => {
          const r = this[$n].get(i);
          r ? r.set(t, e) : this[$n].set(i, /* @__PURE__ */ new Map([[t, e]]));
        });
      } };
    }
    stopDelegating(n, t) {
      if (this[$n]) if (n) if (t) {
        const e = this[$n].get(n);
        e && e.delete(t);
      } else this[$n].delete(n);
      else this[$n].clear();
    }
    _addEventListener(n, t, e) {
      (function(s, a) {
        const l = jb(s);
        if (l[a]) return;
        let c = a, d = null;
        const u = [];
        for (; c !== "" && !l[c]; ) l[c] = { callbacks: [], childEvents: [] }, u.push(l[c]), d && l[c].childEvents.push(d), d = c, c = c.substr(0, c.lastIndexOf(":"));
        if (c !== "") {
          for (const h of u) h.callbacks = l[c].callbacks.slice();
          l[c].childEvents.push(d);
        }
      })(this, n);
      const i = Hc(this, n), r = { callback: t, priority: Ci.get(e.priority) };
      for (const s of i) Nb(s, r);
    }
    _removeEventListener(n, t) {
      const e = Hc(this, n);
      for (const i of e) for (let r = 0; r < i.length; r++) i[r].callback == t && (i.splice(r, 1), r--);
    }
  } : Vb;
}
function Fb(o, n) {
  o[jc] || (o[jc] = n || Ee());
}
function Al(o) {
  return o[jc];
}
function jb(o) {
  return o._events || Object.defineProperty(o, "_events", { value: {} }), o._events;
}
function Hc(o, n) {
  const t = jb(o)[n];
  if (!t) return [];
  let e = [t.callbacks];
  for (let i = 0; i < t.childEvents.length; i++) {
    const r = Hc(o, t.childEvents[i]);
    e = e.concat(r);
  }
  return e;
}
function dh(o, n, t) {
  for (let [e, i] of o) {
    i ? typeof i == "function" && (i = i(n.name)) : i = n.name;
    const r = new oi(n.source, i);
    r.path = [...n.path], e.fire(r, ...t);
  }
}
function xl(o, n, t, e) {
  n._removeEventListener ? n._removeEventListener(t, e) : o._removeEventListener.call(n, t, e);
}
function Mo(o) {
  return o;
}
function ma() {
}
function Zd(o) {
  return o == null || typeof o != "object" && typeof o != "function";
}
function Qd(o) {
  return ArrayBuffer.isView(o) && !(o instanceof DataView);
}
function Jd(o) {
  if (Zd(o)) return o;
  if (Array.isArray(o) || Qd(o) || o instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && o instanceof SharedArrayBuffer) return o.slice(0);
  const n = Object.getPrototypeOf(o), t = n.constructor;
  if (o instanceof Date || o instanceof Map || o instanceof Set) return new t(o);
  if (o instanceof RegExp) {
    const e = new t(o);
    return e.lastIndex = o.lastIndex, e;
  }
  if (o instanceof DataView) return new t(o.buffer.slice(0));
  if (o instanceof Error) {
    const e = new t(o.message);
    return e.stack = o.stack, e.name = o.name, e.cause = o.cause, e;
  }
  if (typeof File < "u" && o instanceof File)
    return new t([o], o.name, { type: o.type, lastModified: o.lastModified });
  if (typeof o == "object") {
    const e = Object.create(n);
    return Object.assign(e, o);
  }
  return o;
}
function uh(o) {
  if (!o || typeof o != "object") return !1;
  const n = Object.getPrototypeOf(o);
  return !(n !== null && n !== Object.prototype && Object.getPrototypeOf(n) !== null) && Object.prototype.toString.call(o) === "[object Object]";
}
function Uc(o) {
  return typeof o == "object" && o !== null;
}
function ga(o) {
  return Object.getOwnPropertySymbols(o).filter((n) => Object.prototype.propertyIsEnumerable.call(o, n));
}
function fa(o) {
  return o == null ? o === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(o);
}
["on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((o) => {
  vt[o] = Vb.prototype[o];
});
const Hb = "[object RegExp]", Xd = "[object String]", tu = "[object Number]", eu = "[object Boolean]", pa = "[object Arguments]", Ub = "[object Symbol]", $b = "[object Date]", qb = "[object Map]", Wb = "[object Set]", Gb = "[object Array]", Kb = "[object ArrayBuffer]", na = "[object Object]", Yb = "[object DataView]", Zb = "[object Uint8Array]", Qb = "[object Uint8ClampedArray]", Jb = "[object Uint16Array]", Xb = "[object Uint32Array]", tk = "[object Int8Array]", ek = "[object Int16Array]", nk = "[object Int32Array]", ik = "[object Float32Array]", ok = "[object Float64Array]";
function Oo(o, n, t, e = /* @__PURE__ */ new Map(), i = void 0) {
  const r = i == null ? void 0 : i(o, n, t, e);
  if (r != null) return r;
  if (Zd(o)) return o;
  if (e.has(o)) return e.get(o);
  if (Array.isArray(o)) {
    const s = new Array(o.length);
    e.set(o, s);
    for (let a = 0; a < o.length; a++) s[a] = Oo(o[a], a, t, e, i);
    return Object.hasOwn(o, "index") && (s.index = o.index), Object.hasOwn(o, "input") && (s.input = o.input), s;
  }
  if (o instanceof Date) return new Date(o.getTime());
  if (o instanceof RegExp) {
    const s = new RegExp(o.source, o.flags);
    return s.lastIndex = o.lastIndex, s;
  }
  if (o instanceof Map) {
    const s = /* @__PURE__ */ new Map();
    e.set(o, s);
    for (const [a, l] of o) s.set(a, Oo(l, a, t, e, i));
    return s;
  }
  if (o instanceof Set) {
    const s = /* @__PURE__ */ new Set();
    e.set(o, s);
    for (const a of o) s.add(Oo(a, void 0, t, e, i));
    return s;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(o)) return o.subarray();
  if (Qd(o)) {
    const s = new (Object.getPrototypeOf(o)).constructor(o.length);
    e.set(o, s);
    for (let a = 0; a < o.length; a++) s[a] = Oo(o[a], a, t, e, i);
    return s;
  }
  if (o instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && o instanceof SharedArrayBuffer) return o.slice(0);
  if (o instanceof DataView) {
    const s = new DataView(o.buffer.slice(0), o.byteOffset, o.byteLength);
    return e.set(o, s), qi(s, o, t, e, i), s;
  }
  if (typeof File < "u" && o instanceof File) {
    const s = new File([o], o.name, { type: o.type });
    return e.set(o, s), qi(s, o, t, e, i), s;
  }
  if (o instanceof Blob) {
    const s = new Blob([o], { type: o.type });
    return e.set(o, s), qi(s, o, t, e, i), s;
  }
  if (o instanceof Error) {
    const s = new o.constructor();
    return e.set(o, s), s.message = o.message, s.name = o.name, s.stack = o.stack, s.cause = o.cause, qi(s, o, t, e, i), s;
  }
  if (typeof o == "object" && function(s) {
    switch (fa(s)) {
      case pa:
      case Gb:
      case Kb:
      case Yb:
      case eu:
      case $b:
      case ik:
      case ok:
      case tk:
      case ek:
      case nk:
      case qb:
      case tu:
      case na:
      case Hb:
      case Wb:
      case Xd:
      case Ub:
      case Zb:
      case Qb:
      case Jb:
      case Xb:
        return !0;
      default:
        return !1;
    }
  }(o)) {
    const s = Object.create(Object.getPrototypeOf(o));
    return e.set(o, s), qi(s, o, t, e, i), s;
  }
  return o;
}
function qi(o, n, t = o, e, i) {
  const r = [...Object.keys(n), ...ga(n)];
  for (let s = 0; s < r.length; s++) {
    const a = r[s], l = Object.getOwnPropertyDescriptor(o, a);
    (l == null || l.writable) && (o[a] = Oo(n[a], a, t, e, i));
  }
}
function rk(o, n) {
  return o === n || Number.isNaN(o) && Number.isNaN(n);
}
function sk(o, n, t) {
  return Sr(o, n, void 0, void 0, void 0, void 0, t);
}
function Sr(o, n, t, e, i, r, s) {
  const a = s(o, n, t, e, i, r);
  if (a !== void 0) return a;
  if (typeof o == typeof n) switch (typeof o) {
    case "bigint":
    case "string":
    case "boolean":
    case "symbol":
    case "undefined":
    case "function":
      return o === n;
    case "number":
      return o === n || Object.is(o, n);
    case "object":
      return zr(o, n, r, s);
  }
  return zr(o, n, r, s);
}
function zr(o, n, t, e) {
  if (Object.is(o, n)) return !0;
  let i = fa(o), r = fa(n);
  if (i === pa && (i = na), r === pa && (r = na), i !== r) return !1;
  switch (i) {
    case Xd:
      return o.toString() === n.toString();
    case tu:
      return rk(o.valueOf(), n.valueOf());
    case eu:
    case $b:
    case Ub:
      return Object.is(o.valueOf(), n.valueOf());
    case Hb:
      return o.source === n.source && o.flags === n.flags;
    case "[object Function]":
      return o === n;
  }
  const s = (t = t ?? /* @__PURE__ */ new Map()).get(o), a = t.get(n);
  if (s != null && a != null) return s === n;
  t.set(o, n), t.set(n, o);
  try {
    switch (i) {
      case qb:
        if (o.size !== n.size) return !1;
        for (const [l, c] of o.entries()) if (!n.has(l) || !Sr(c, n.get(l), l, o, n, t, e)) return !1;
        return !0;
      case Wb: {
        if (o.size !== n.size) return !1;
        const l = Array.from(o.values()), c = Array.from(n.values());
        for (let d = 0; d < l.length; d++) {
          const u = l[d], h = c.findIndex((g) => Sr(u, g, void 0, o, n, t, e));
          if (h === -1) return !1;
          c.splice(h, 1);
        }
        return !0;
      }
      case Gb:
      case Zb:
      case Qb:
      case Jb:
      case Xb:
      case "[object BigUint64Array]":
      case tk:
      case ek:
      case nk:
      case "[object BigInt64Array]":
      case ik:
      case ok:
        if (typeof Buffer < "u" && Buffer.isBuffer(o) !== Buffer.isBuffer(n) || o.length !== n.length) return !1;
        for (let l = 0; l < o.length; l++) if (!Sr(o[l], n[l], l, o, n, t, e)) return !1;
        return !0;
      case Kb:
        return o.byteLength === n.byteLength && zr(new Uint8Array(o), new Uint8Array(n), t, e);
      case Yb:
        return o.byteLength === n.byteLength && o.byteOffset === n.byteOffset && zr(new Uint8Array(o), new Uint8Array(n), t, e);
      case "[object Error]":
        return o.name === n.name && o.message === n.message;
      case na: {
        if (!(zr(o.constructor, n.constructor, t, e) || uh(o) && uh(n))) return !1;
        const l = [...Object.keys(o), ...ga(o)], c = [...Object.keys(n), ...ga(n)];
        if (l.length !== c.length) return !1;
        for (let d = 0; d < l.length; d++) {
          const u = l[d], h = o[u];
          if (!Object.hasOwn(n, u) || !Sr(h, n[u], u, o, n, t, e)) return !1;
        }
        return !0;
      }
      default:
        return !1;
    }
  } finally {
    t.delete(o), t.delete(n);
  }
}
function ba(o, n) {
  return sk(o, n, ma);
}
function ka(o) {
  return typeof o == "function";
}
function Xy(o) {
  return o != null && typeof o != "function" && function(n) {
    return Number.isSafeInteger(n) && n >= 0;
  }(o.length);
}
function ak(o) {
  switch (typeof o) {
    case "number":
    case "symbol":
      return !1;
    case "string":
      return o.includes(".") || o.includes("[") || o.includes("]");
  }
}
function lk(o) {
  return Object.is(o, -0) ? "-0" : o.toString();
}
function nu(o) {
  const n = [], t = o.length;
  if (t === 0) return n;
  let e = 0, i = "", r = "", s = !1;
  for (o.charCodeAt(0) === 46 && (n.push(""), e++); e < t; ) {
    const a = o[e];
    r ? a === "\\" && e + 1 < t ? (e++, i += o[e]) : a === r ? r = "" : i += a : s ? a === '"' || a === "'" ? r = a : a === "]" ? (s = !1, n.push(i), i = "") : i += a : a === "[" ? (s = !0, i && (n.push(i), i = "")) : a === "." ? i && (n.push(i), i = "") : i += a, e++;
  }
  return i && n.push(i), n;
}
function Ti(o, n, t) {
  if (o == null) return t;
  switch (typeof n) {
    case "string": {
      const e = o[n];
      return e === void 0 ? ak(n) ? Ti(o, nu(n), t) : t : e;
    }
    case "number":
    case "symbol": {
      typeof n == "number" && (n = lk(n));
      const e = o[n];
      return e === void 0 ? t : e;
    }
    default: {
      if (Array.isArray(n)) return function(i, r, s) {
        if (r.length === 0) return s;
        let a = i;
        for (let l = 0; l < r.length; l++) {
          if (a == null) return s;
          a = a[r[l]];
        }
        return a === void 0 ? s : a;
      }(o, n, t);
      const e = o[n = Object.is(n == null ? void 0 : n.valueOf(), -0) ? "-0" : String(n)];
      return e === void 0 ? t : e;
    }
  }
}
function bn(o) {
  return o !== null && (typeof o == "object" || typeof o == "function");
}
function il(o, n) {
  return function(t, e) {
    return Oo(t, void 0, t, /* @__PURE__ */ new Map(), e);
  }(o, (t, e, i, r) => {
    const s = n == null ? void 0 : n(t, e, i, r);
    if (s != null) return s;
    if (typeof o == "object") switch (Object.prototype.toString.call(o)) {
      case tu:
      case Xd:
      case eu: {
        const a = new o.constructor(o == null ? void 0 : o.valueOf());
        return qi(a, o), a;
      }
      case pa: {
        const a = {};
        return qi(a, o), a.length = o.length, a[Symbol.iterator] = o[Symbol.iterator], a;
      }
      default:
        return;
    }
  });
}
function Ge(o) {
  return il(o);
}
const tC = /^(?:0|[1-9]\d*)$/;
function eC(o, n = Number.MAX_SAFE_INTEGER) {
  switch (typeof o) {
    case "number":
      return Number.isInteger(o) && o >= 0 && o < n;
    case "symbol":
      return !1;
    case "string":
      return tC.test(o);
  }
}
function hh(o) {
  return o !== null && typeof o == "object" && fa(o) === "[object Arguments]";
}
function nC(o) {
  return function(n) {
    return typeof n == "symbol" || n instanceof Symbol;
  }(o) ? NaN : Number(o);
}
function iC(o) {
  const n = function(e) {
    return e ? (e = nC(e)) === 1 / 0 || e === -1 / 0 ? (e < 0 ? -1 : 1) * Number.MAX_VALUE : e == e ? e : 0 : e === 0 ? e : 0;
  }(o), t = n % 1;
  return t ? n - t : n;
}
function mh(o) {
  return typeof o == "string" || o instanceof String;
}
function ck(o, n, t) {
  const e = Array.isArray(n) ? n : typeof n == "string" ? nu(n) : [n];
  let i = o;
  for (let r = 0; r < e.length - 1; r++) {
    const s = e[r], a = e[r + 1];
    i[s] == null && (i[s] = eC(a) ? [] : {}), i = i[s];
  }
  return i[e[e.length - 1]] = t, o;
}
function oC(o, n, { signal: t, edges: e } = {}) {
  let i, r = null;
  const s = e != null && e.includes("leading"), a = e == null || e.includes("trailing"), l = () => {
    r !== null && (o.apply(i, r), i = void 0, r = null);
  };
  let c = null;
  const d = () => {
    c != null && clearTimeout(c), c = setTimeout(() => {
      c = null, a && l(), h();
    }, n);
  }, u = () => {
    c !== null && (clearTimeout(c), c = null);
  }, h = () => {
    u(), i = void 0, r = null;
  }, g = function(...f) {
    if (t != null && t.aborted) return;
    i = this, r = f;
    const p = c == null;
    d(), s && p && l();
  };
  return g.schedule = d, g.cancel = h, g.flush = () => {
    u(), l();
  }, t == null || t.addEventListener("abort", h, { once: !0 }), g;
}
function kn(o, n = 0, t = {}) {
  typeof t != "object" && (t = {});
  const { signal: e, leading: i = !1, trailing: r = !0, maxWait: s } = t, a = Array(2);
  let l;
  i && (a[0] = "leading"), r && (a[1] = "trailing");
  let c = null;
  const d = oC(function(...h) {
    l = o.apply(this, h), c = null;
  }, n, { signal: e, edges: a }), u = function(...h) {
    if (s != null) {
      if (c === null) c = Date.now();
      else if (Date.now() - c >= s) return l = o.apply(this, h), c = Date.now(), d.cancel(), d.schedule(), l;
    }
    return d.apply(this, h), l;
  };
  return u.cancel = d.cancel, u.flush = () => (d.flush(), l), u;
}
function Qo(o, n = 0, t = {}) {
  typeof t != "object" && (t = {});
  const { leading: e = !0, trailing: i = !0, signal: r } = t;
  return kn(o, n, { leading: e, trailing: i, signal: r, maxWait: n });
}
function iu(o) {
  if (o == null) return "";
  if (Array.isArray(o)) return o.map(iu).join(",");
  const n = String(o);
  return n === "0" && Object.is(Number(o), -0) ? "-0" : n;
}
function dk(o) {
  return Qd(o);
}
function rC(o) {
  if (o == null) return [];
  switch (typeof o) {
    case "object":
    case "function":
      return Xy(o) ? function(n) {
        const t = function(i, r) {
          if ((i = iC(i)) < 1 || !Number.isSafeInteger(i)) return [];
          const s = new Array(i);
          for (let a = 0; a < i; a++) s[a] = typeof r == "function" ? r(a) : a;
          return s;
        }(n.length, (i) => `${i}`), e = new Set(t);
        return function(i) {
          return typeof Buffer < "u" && Buffer.isBuffer(i);
        }(n) && (e.add("offset"), e.add("parent")), dk(n) && (e.add("buffer"), e.add("byteLength"), e.add("byteOffset")), [...t, ...Ms(n).filter((i) => !e.has(i))];
      }(o) : function(n) {
        const t = n == null ? void 0 : n.constructor;
        return n === (typeof t == "function" ? t.prototype : Object.prototype);
      }(o) ? function(n) {
        return Ms(n).filter((e) => e !== "constructor");
      }(o) : Ms(o);
    default:
      return Ms(Object(o));
  }
}
function Ms(o) {
  const n = [];
  for (const t in o) n.push(t);
  return n;
}
function uk(o, ...n) {
  for (let t = 0; t < n.length; t++) sC(o, n[t]);
  return o;
}
function sC(o, n) {
  const t = rC(n);
  for (let e = 0; e < t.length; e++) {
    const i = t[e];
    rk(o[i], n[i]) || (o[i] = n[i]);
  }
}
function gh(o, n) {
  const t = {}, e = Object.keys(o);
  for (let i = 0; i < e.length; i++) {
    const r = e[i], s = o[r];
    t[r] = n(s, r, o);
  }
  return t;
}
function aC(o, n) {
  switch (typeof (n = n ?? Mo)) {
    case "string":
    case "symbol":
    case "number":
    case "object":
      return gh(o, (t = n, function(e) {
        return Ti(e, t);
      }));
    case "function":
      return gh(o, n);
  }
  var t;
}
function In(o) {
  var t;
  if (typeof o != "object" || o == null) return !1;
  if (Object.getPrototypeOf(o) === null) return !0;
  if (Object.prototype.toString.call(o) !== "[object Object]") {
    const e = o[Symbol.toStringTag];
    return e == null ? !1 : !!((t = Object.getOwnPropertyDescriptor(o, Symbol.toStringTag)) != null && t.writable) && o.toString() === `[object ${e}]`;
  }
  let n = o;
  for (; Object.getPrototypeOf(n) !== null; ) n = Object.getPrototypeOf(n);
  return Object.getPrototypeOf(o) === n;
}
function lC(o, ...n) {
  const t = n.slice(0, -1), e = n[n.length - 1];
  let i = o;
  for (let r = 0; r < t.length; r++)
    i = $c(i, t[r], e, /* @__PURE__ */ new Map());
  return i;
}
function $c(o, n, t, e) {
  if (Zd(o) && (o = Object(o)), n == null || typeof n != "object") return o;
  if (e.has(n)) return Jd(e.get(n));
  if (e.set(n, o), Array.isArray(n)) {
    n = n.slice();
    for (let r = 0; r < n.length; r++) n[r] = n[r] ?? void 0;
  }
  const i = [...Object.keys(n), ...ga(n)];
  for (let r = 0; r < i.length; r++) {
    const s = i[r];
    let a = n[s], l = o[s];
    if (hh(a) && (a = { ...a }), hh(l) && (l = { ...l }), typeof Buffer < "u" && Buffer.isBuffer(a) && (a = Ge(a)), Array.isArray(a)) if (typeof l == "object" && l != null) {
      const d = [], u = Reflect.ownKeys(l);
      for (let h = 0; h < u.length; h++) {
        const g = u[h];
        d[g] = l[g];
      }
      l = d;
    } else l = [];
    const c = t(l, a, s, o, n, e);
    c != null ? o[s] = c : Array.isArray(a) || Uc(l) && Uc(a) ? o[s] = $c(l, a, t, e) : l == null && In(a) ? o[s] = $c({}, a, t, e) : l == null && dk(a) ? o[s] = Ge(a) : l !== void 0 && a === void 0 || (o[s] = a);
  }
  return o;
}
function ou(o, ...n) {
  return lC(o, ...n, ma);
}
function cC(o, n) {
  if (o == null) return !0;
  switch (typeof n) {
    case "symbol":
    case "number":
    case "object":
      if (Array.isArray(n)) return fh(o, n);
      if (typeof n == "number" ? n = lk(n) : typeof n == "object" && (n = Object.is(n == null ? void 0 : n.valueOf(), -0) ? "-0" : String(n)), (o == null ? void 0 : o[n]) === void 0) return !0;
      try {
        return delete o[n], !0;
      } catch {
        return !1;
      }
    case "string":
      if ((o == null ? void 0 : o[n]) === void 0 && ak(n)) return fh(o, nu(n));
      try {
        return delete o[n], !0;
      } catch {
        return !1;
      }
  }
}
function fh(o, n) {
  const t = Ti(o, n.slice(0, -1), o), e = n[n.length - 1];
  if ((t == null ? void 0 : t[e]) === void 0) return !0;
  try {
    return delete t[e], !0;
  } catch {
    return !1;
  }
}
function Si(o) {
  return Uc(o) && o.nodeType === 1 && !In(o);
}
function dC(o, n) {
  if (!Number.isInteger(o) || o < 0) throw new Error("n must be a non-negative integer.");
  let t = 0;
  return (...e) => {
    if (++t >= o) return n(...e);
  };
}
function hk(o, n, t = ma) {
  return typeof t != "function" && (t = ma), sk(o, n, (...e) => {
    const i = t(...e);
    return i !== void 0 ? !!i : o instanceof Map && n instanceof Map || o instanceof Set && n instanceof Set ? hk(Array.from(o), Array.from(n), dC(2, t)) : void 0;
  });
}
function mk(o) {
  return function(n) {
    return n.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
  }(iu(o));
}
const Or = Symbol("observableProperties"), Xr = Symbol("boundObservables"), Rr = Symbol("boundProperties"), Vi = Symbol("decoratedMethods"), ph = Symbol("decoratedOriginal"), gk = _t(vt());
function _t(o) {
  var n, t, e, i, r;
  return o ? class extends (r = o, i = Or, e = Vi, t = Rr, n = Xr, r) {
    constructor() {
      super(...arguments);
      m(this, i);
      m(this, e);
      m(this, t);
      m(this, n);
    }
    set(a, l) {
      if (bn(a)) return void Object.keys(a).forEach((d) => {
        this.set(d, a[d]);
      }, this);
      El(this);
      const c = this[Or];
      if (a in this && !c.has(a)) throw new v("observable-set-cannot-override", this);
      Object.defineProperty(this, a, { enumerable: !0, configurable: !0, get: () => c.get(a), set(d) {
        const u = c.get(a);
        let h = this.fire(`set:${a}`, a, d, u);
        h === void 0 && (h = d), u === h && c.has(a) || (c.set(a, h), this.fire(`change:${a}`, a, h, u));
      } }), this[a] = l;
    }
    bind(...a) {
      if (!a.length || !bh(a)) throw new v("observable-bind-wrong-properties", this);
      if (new Set(a).size !== a.length) throw new v("observable-bind-duplicate-properties", this);
      El(this);
      const l = this[Rr];
      a.forEach((d) => {
        if (l.has(d)) throw new v("observable-bind-rebind", this);
      });
      const c = /* @__PURE__ */ new Map();
      return a.forEach((d) => {
        const u = { property: d, to: [] };
        l.set(d, u), c.set(d, u);
      }), { to: uC, toMany: hC, _observable: this, _bindProperties: a, _to: [], _bindings: c };
    }
    unbind(...a) {
      if (!this[Or]) return;
      const l = this[Rr], c = this[Xr];
      if (a.length) {
        if (!bh(a)) throw new v("observable-unbind-wrong-properties", this);
        a.forEach((d) => {
          const u = l.get(d);
          u && (u.to.forEach(([h, g]) => {
            const f = c.get(h), p = f[g];
            p.delete(u), p.size || delete f[g], Object.keys(f).length || (c.delete(h), this.stopListening(h, "change"));
          }), l.delete(d));
        });
      } else c.forEach((d, u) => {
        this.stopListening(u, "change");
      }), c.clear(), l.clear();
    }
    decorate(a) {
      El(this);
      const l = this[a];
      if (!l) throw new v("observablemixin-cannot-decorate-undefined", this, { object: this, methodName: a });
      this.on(a, (c, d) => {
        c.return = l.apply(this, d);
      }), this[a] = function(...c) {
        return this.fire(a, c);
      }, this[a][ph] = l, this[Vi] || (this[Vi] = []), this[Vi].push(a);
    }
    stopListening(a, l, c) {
      if (!a && this[Vi]) {
        for (const d of this[Vi]) this[d] = this[d][ph];
        delete this[Vi];
      }
      super.stopListening(a, l, c);
    }
  } : gk;
}
function El(o) {
  o[Or] || (Object.defineProperty(o, Or, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(o, Xr, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(o, Rr, { value: /* @__PURE__ */ new Map() }));
}
function uC(...o) {
  const n = function(...r) {
    if (!r.length) throw new v("observable-bind-to-parse-error", null);
    const s = { to: [] };
    let a;
    return typeof r[r.length - 1] == "function" && (s.callback = r.pop()), r.forEach((l) => {
      if (typeof l == "string") a.properties.push(l);
      else {
        if (typeof l != "object") throw new v("observable-bind-to-parse-error", null);
        a = { observable: l, properties: [] }, s.to.push(a);
      }
    }), s;
  }(...o), t = Array.from(this._bindings.keys()), e = t.length;
  if (!n.callback && n.to.length > 1) throw new v("observable-bind-to-no-callback", this);
  if (e > 1 && n.callback) throw new v("observable-bind-to-extra-callback", this);
  var i;
  n.to.forEach((r) => {
    if (r.properties.length && r.properties.length !== e) throw new v("observable-bind-to-properties-length", this);
    r.properties.length || (r.properties = this._bindProperties);
  }), this._to = n.to, n.callback && (this._bindings.get(t[0]).callback = n.callback), i = this._observable, this._to.forEach((r) => {
    const s = i[Xr];
    let a;
    s.get(r.observable) || i.listenTo(r.observable, "change", (l, c) => {
      a = s.get(r.observable)[c], a && a.forEach((d) => {
        kh(i, d.property);
      });
    });
  }), function(r) {
    let s;
    r._bindings.forEach((a, l) => {
      r._to.forEach((c) => {
        s = c.properties[a.callback ? 0 : r._bindProperties.indexOf(l)], a.to.push([c.observable, s]), function(d, u, h, g) {
          const f = d[Xr], p = f.get(h), b = p || {};
          b[g] || (b[g] = /* @__PURE__ */ new Set()), b[g].add(u), p || f.set(h, b);
        }(r._observable, a, c.observable, s);
      });
    });
  }(this), this._bindProperties.forEach((r) => {
    kh(this._observable, r);
  });
}
function hC(o, n, t) {
  if (this._bindings.size > 1) throw new v("observable-bind-to-many-not-one-binding", this);
  this.to(...function(e, i) {
    const r = e.map((s) => [s, i]);
    return Array.prototype.concat.apply([], r);
  }(o, n), t);
}
function bh(o) {
  return o.every((n) => typeof n == "string");
}
function kh(o, n) {
  const t = o[Rr].get(n);
  let e;
  t.callback ? e = t.callback.apply(o, t.to.map((i) => i[0][i[1]])) : (e = t.to[0], e = e[0][e[1]]), Object.prototype.hasOwnProperty.call(o, n) ? o[n] = e : o.set(n, e);
}
["set", "bind", "unbind", "decorate", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((o) => {
  _t[o] = gk.prototype[o];
});
function qc(o) {
  let n = 0;
  for (const t of o) n++;
  return n;
}
function xe(o, n) {
  const t = Math.min(o.length, n.length);
  for (let e = 0; e < t; e++) if (o[e] != n[e]) return e;
  return o.length == n.length ? "same" : o.length < n.length ? "prefix" : "extension";
}
function Ye(o) {
  return !(!o || !o[Symbol.iterator]);
}
function mn(o, n, t = {}, e = []) {
  const i = t && t.xmlns, r = i ? o.createElementNS(i, n) : o.createElement(n);
  for (const s in t) r.setAttribute(s, t[s]);
  !mh(e) && Ye(e) || (e = [e]);
  for (let s of e) mh(s) && (s = o.createTextNode(s)), r.appendChild(s);
  return r;
}
class fk {
  constructor(n, t) {
    m(this, "_config");
    this._config = /* @__PURE__ */ Object.create(null), t && this.define(wh(t)), n && this._setObjectToTarget(this._config, n);
  }
  set(n, t) {
    this._setToTarget(this._config, n, t);
  }
  define(n, t) {
    this._setToTarget(this._config, n, t, !0);
  }
  get(n) {
    return this._getFromSource(this._config, n);
  }
  *names() {
    for (const n of Object.keys(this._config)) yield n;
  }
  _setToTarget(n, t, e, i = !1) {
    if (In(t)) return void this._setObjectToTarget(n, t, i);
    const r = t.split(".");
    t = r.pop();
    for (const s of r) In(n[s]) || (n[s] = /* @__PURE__ */ Object.create(null)), n = n[s];
    if (In(e)) return In(n[t]) || (n[t] = /* @__PURE__ */ Object.create(null)), n = n[t], void this._setObjectToTarget(n, e, i);
    i && n[t] !== void 0 || (n[t] = e);
  }
  _getFromSource(n, t) {
    const e = t.split(".");
    t = e.pop();
    for (const i of e) {
      if (!In(n[i])) {
        n = null;
        break;
      }
      n = n[i];
    }
    return n ? wh(n[t]) : void 0;
  }
  _setObjectToTarget(n, t, e) {
    Object.keys(t).forEach((i) => {
      this._setToTarget(n, i, t[i], e);
    });
  }
}
function wh(o) {
  return il(o, mC);
}
function mC(o) {
  return Si(o) || typeof o == "function" ? o : void 0;
}
function Ii(o) {
  if (o) {
    if (o.defaultView) return o instanceof o.defaultView.Document;
    if (o.ownerDocument && o.ownerDocument.defaultView) return o instanceof o.ownerDocument.defaultView.Node;
  }
  return !1;
}
function wa(o) {
  const n = Object.prototype.toString.apply(o);
  return n == "[object Window]" || n == "[object global]";
}
const pk = Pe(vt());
function Pe(o) {
  return o ? class extends o {
    listenTo(n, t, e, i = {}) {
      if (Ii(n) || wa(n) || n instanceof N.window.EventTarget) {
        const r = { capture: !!i.useCapture, passive: !!i.usePassive }, s = this._getProxyEmitter(n, r) || new gC(n, r);
        this.listenTo(s, t, e, i);
      } else super.listenTo(n, t, e, i);
    }
    stopListening(n, t, e) {
      if (Ii(n) || wa(n) || n instanceof N.window.EventTarget) {
        const i = this._getAllProxyEmitters(n);
        for (const r of i) this.stopListening(r, t, e);
      } else super.stopListening(n, t, e);
    }
    _getProxyEmitter(n, t) {
      return function(e, i) {
        const r = e[Io];
        return r && r[i] ? r[i].emitter : null;
      }(this, bk(n, t));
    }
    _getAllProxyEmitters(n) {
      return [{ capture: !1, passive: !1 }, { capture: !1, passive: !0 }, { capture: !0, passive: !1 }, { capture: !0, passive: !0 }].map((t) => this._getProxyEmitter(n, t)).filter((t) => !!t);
    }
  } : pk;
}
["_getProxyEmitter", "_getAllProxyEmitters", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((o) => {
  Pe[o] = pk.prototype[o];
});
class gC extends vt() {
  constructor(t, e) {
    super();
    m(this, "_domNode");
    m(this, "_options");
    m(this, "_domListeners");
    Fb(this, bk(t, e)), this._domNode = t, this._options = e;
  }
  attach(t) {
    if (this._domListeners && this._domListeners[t]) return;
    const e = this._createDomListener(t);
    this._domNode.addEventListener(t, e, this._options), this._domListeners || (this._domListeners = {}), this._domListeners[t] = e;
  }
  detach(t) {
    let e;
    !this._domListeners[t] || (e = this._events[t]) && e.callbacks.length || this._domListeners[t].removeListener();
  }
  _addEventListener(t, e, i) {
    this.attach(t), vt().prototype._addEventListener.call(this, t, e, i);
  }
  _removeEventListener(t, e) {
    vt().prototype._removeEventListener.call(this, t, e), this.detach(t);
  }
  _createDomListener(t) {
    const e = (i) => {
      this.fire(t, i);
    };
    return e.removeListener = () => {
      this._domNode.removeEventListener(t, e, this._options), delete this._domListeners[t];
    }, e;
  }
}
function bk(o, n) {
  let t = function(e) {
    return e["data-ck-expando"] || (e["data-ck-expando"] = Ee());
  }(o);
  for (const e of Object.keys(n).sort()) n[e] && (t += "-" + e);
  return t;
}
function kk(o) {
  const n = [];
  let t = o;
  for (; t && t.nodeType != Node.DOCUMENT_NODE; ) n.unshift(t), t = t.parentNode;
  return n;
}
function fC(o) {
  return o instanceof HTMLTextAreaElement ? o.value : o.innerHTML;
}
function _h(o) {
  const n = o.ownerDocument.defaultView.getComputedStyle(o);
  return { top: parseInt(n.borderTopWidth, 10), right: parseInt(n.borderRightWidth, 10), bottom: parseInt(n.borderBottomWidth, 10), left: parseInt(n.borderLeftWidth, 10) };
}
function wk(o) {
  if (!o.target) return null;
  const n = o.target.ownerDocument, t = o.clientX, e = o.clientY;
  let i = null;
  return n.caretRangeFromPoint && n.caretRangeFromPoint(t, e) ? i = n.caretRangeFromPoint(t, e) : o.rangeParent && (i = n.createRange(), i.setStart(o.rangeParent, o.rangeOffset), i.collapse(!0)), i;
}
function qt(o) {
  return Object.prototype.toString.call(o) == "[object Text]";
}
function ol(o) {
  return Object.prototype.toString.apply(o) == "[object Range]";
}
function _k(o) {
  return o && o.parentNode ? o.offsetParent === N.document.body ? null : o.offsetParent : null;
}
const vk = ["top", "right", "bottom", "left", "width", "height"];
class K {
  constructor(n) {
    m(this, "top");
    m(this, "right");
    m(this, "bottom");
    m(this, "left");
    m(this, "width");
    m(this, "height");
    m(this, "_source");
    const t = ol(n);
    if (Object.defineProperty(this, "_source", { value: n._source || n, writable: !0, enumerable: !1 }), Wc(n) || t) if (t) {
      const e = K.getDomRangeRects(n);
      Ds(this, K.getBoundingRect(e));
    } else Ds(this, n.getBoundingClientRect());
    else if (wa(n)) {
      const { innerWidth: e, innerHeight: i } = n;
      Ds(this, { top: 0, right: e, bottom: i, left: 0, width: e, height: i });
    } else Ds(this, n);
  }
  clone() {
    return new K(this);
  }
  moveTo(n, t) {
    return this.top = t, this.right = n + this.width, this.bottom = t + this.height, this.left = n, this;
  }
  moveBy(n, t) {
    return this.top += t, this.right += n, this.left += n, this.bottom += t, this;
  }
  getIntersection(n) {
    const t = { top: Math.max(this.top, n.top), right: Math.min(this.right, n.right), bottom: Math.min(this.bottom, n.bottom), left: Math.max(this.left, n.left), width: 0, height: 0 };
    if (t.width = t.right - t.left, t.height = t.bottom - t.top, t.width < 0 || t.height < 0) return null;
    {
      const e = new K(t);
      return e._source = this._source, e;
    }
  }
  getIntersectionArea(n) {
    const t = this.getIntersection(n);
    return t ? t.getArea() : 0;
  }
  getArea() {
    return this.width * this.height;
  }
  getVisible() {
    const n = this._source;
    let t = this.clone();
    if (vh(n)) return t;
    let e, i = n, r = n.parentNode || n.commonAncestorContainer;
    for (; r && !vh(r); ) {
      const a = ((s = r) instanceof HTMLElement ? s.ownerDocument.defaultView.getComputedStyle(s).overflow : "visible") === "visible";
      i instanceof HTMLElement && yh(i) === "absolute" && (e = i);
      const l = yh(r);
      if (a || e && (l === "relative" && a || l !== "relative")) {
        i = r, r = r.parentNode;
        continue;
      }
      const c = new K(r), d = t.getIntersection(c);
      if (!d) return null;
      d.getArea() < t.getArea() && (t = d), i = r, r = r.parentNode;
    }
    var s;
    return t;
  }
  isEqual(n) {
    for (const t of vk) if (this[t] !== n[t]) return !1;
    return !0;
  }
  contains(n) {
    const t = this.getIntersection(n);
    return !(!t || !t.isEqual(n));
  }
  toAbsoluteRect() {
    const { scrollX: n, scrollY: t } = N.window, e = this.clone().moveBy(n, t);
    if (Wc(e._source)) {
      const i = _k(e._source);
      i && function(r, s) {
        const a = new K(s), l = _h(s);
        let c = 0, d = 0;
        c -= a.left, d -= a.top, c += s.scrollLeft, d += s.scrollTop, c -= l.left, d -= l.top, r.moveBy(c, d);
      }(e, i);
    }
    return e;
  }
  excludeScrollbarsAndBorders() {
    const n = this._source;
    let t, e, i;
    if (wa(n)) t = n.innerWidth - n.document.documentElement.clientWidth, e = n.innerHeight - n.document.documentElement.clientHeight, i = n.getComputedStyle(n.document.documentElement).direction;
    else {
      const r = _h(n);
      t = n.offsetWidth - n.clientWidth - r.left - r.right, e = n.offsetHeight - n.clientHeight - r.top - r.bottom, i = n.ownerDocument.defaultView.getComputedStyle(n).direction, this.left += r.left, this.top += r.top, this.right -= r.right, this.bottom -= r.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top;
    }
    return this.width -= t, i === "ltr" ? this.right -= t : this.left += t, this.height -= e, this.bottom -= e, this;
  }
  static getDomRangeRects(n) {
    const t = [], e = Array.from(n.getClientRects());
    if (e.length) for (const i of e) t.push(new K(i));
    else {
      let i = n.startContainer;
      qt(i) && (i = i.parentNode);
      const r = new K(i.getBoundingClientRect());
      r.right = r.left, r.width = 0, t.push(r);
    }
    return t;
  }
  static getBoundingRect(n) {
    const t = { left: Number.POSITIVE_INFINITY, top: Number.POSITIVE_INFINITY, right: Number.NEGATIVE_INFINITY, bottom: Number.NEGATIVE_INFINITY, width: 0, height: 0 };
    let e = 0;
    for (const i of n) e++, t.left = Math.min(t.left, i.left), t.top = Math.min(t.top, i.top), t.right = Math.max(t.right, i.right), t.bottom = Math.max(t.bottom, i.bottom);
    return e == 0 ? null : (t.width = t.right - t.left, t.height = t.bottom - t.top, new K(t));
  }
}
function Ds(o, n) {
  for (const t of vk) o[t] = n[t];
}
function vh(o) {
  return !!Wc(o) && o === o.ownerDocument.body;
}
function Wc(o) {
  return o !== null && typeof o == "object" && o.nodeType === 1 && typeof o.getBoundingClientRect == "function";
}
function yh(o) {
  return o instanceof HTMLElement ? o.ownerDocument.defaultView.getComputedStyle(o).position : "static";
}
const Ut = class Ut {
  constructor(n, t) {
    m(this, "_element");
    m(this, "_callback");
    Ut._observerInstance || Ut._createObserver(), this._element = n, this._callback = t, Ut._addElementCallback(n, t), Ut._observerInstance.observe(n);
  }
  get element() {
    return this._element;
  }
  destroy() {
    Ut._deleteElementCallback(this._element, this._callback);
  }
  static _addElementCallback(n, t) {
    Ut._elementCallbacks || (Ut._elementCallbacks = /* @__PURE__ */ new Map());
    let e = Ut._elementCallbacks.get(n);
    e || (e = /* @__PURE__ */ new Set(), Ut._elementCallbacks.set(n, e)), e.add(t);
  }
  static _deleteElementCallback(n, t) {
    const e = Ut._getElementCallbacks(n);
    e && (e.delete(t), e.size || (Ut._elementCallbacks.delete(n), Ut._observerInstance.unobserve(n))), Ut._elementCallbacks && !Ut._elementCallbacks.size && (Ut._observerInstance = null, Ut._elementCallbacks = null);
  }
  static _getElementCallbacks(n) {
    return Ut._elementCallbacks ? Ut._elementCallbacks.get(n) : null;
  }
  static _createObserver() {
    Ut._observerInstance = new N.window.ResizeObserver((n) => {
      for (const t of n) {
        const e = Ut._getElementCallbacks(t.target);
        if (e) for (const i of e) i(t);
      }
    });
  }
};
m(Ut, "_observerInstance", null), m(Ut, "_elementCallbacks", null);
let to = Ut;
function Ch(o, n) {
  o instanceof HTMLTextAreaElement && (o.value = n), o.innerHTML = n;
}
function Li(o) {
  return (n) => n + o;
}
function Ir(o) {
  let n = 0;
  for (; o.previousSibling; ) o = o.previousSibling, n++;
  return n;
}
function yk(o, n, t) {
  o.insertBefore(t, o.childNodes[n] || null);
}
function Vr(o) {
  return o && o.nodeType === Node.COMMENT_NODE;
}
function pC(o) {
  try {
    N.document.createAttribute(o);
  } catch {
    return !1;
  }
  return !0;
}
function ri(o) {
  return !!o && (qt(o) ? ri(o.parentElement) : !!o.getClientRects && !!o.getClientRects().length);
}
function ru({ element: o, target: n, positions: t, limiter: e, fitInViewport: i, viewportOffsetConfig: r }) {
  ka(n) && (n = n()), ka(e) && (e = e());
  const s = _k(o), a = function(h) {
    h = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, h);
    const g = new K(N.window);
    return g.top += h.top, g.height -= h.top, g.bottom -= h.bottom, g.height -= h.bottom, g;
  }(r), l = new K(o), c = Ah(n, a);
  let d;
  if (!c || !a.getIntersection(c)) return null;
  const u = { targetRect: c, elementRect: l, positionedElementAncestor: s, viewportRect: a };
  if (e || i) {
    if (e) {
      const h = Ah(e, a);
      h && (u.limiterRect = h);
    }
    d = function(h, g) {
      const { elementRect: f } = g, p = f.getArea(), b = h.map((_) => new xh(_, g)).filter((_) => !!_.name);
      let k = 0, w = null;
      for (const _ of b) {
        const { limiterIntersectionArea: y, viewportIntersectionArea: C } = _;
        if (y === p) return _;
        const x = C ** 2 + y ** 2;
        x > k && (k = x, w = _);
      }
      return w;
    }(t, u);
  } else d = new xh(t[0], u);
  return d;
}
function Ah(o, n) {
  const t = new K(o).getVisible();
  return t ? t.getIntersection(n) : null;
}
class xh {
  constructor(n, t) {
    m(this, "name");
    m(this, "config");
    m(this, "_positioningFunctionCoordinates");
    m(this, "_options");
    m(this, "_cachedRect");
    m(this, "_cachedAbsoluteRect");
    const e = n(t.targetRect, t.elementRect, t.viewportRect, t.limiterRect);
    if (!e) return;
    const { left: i, top: r, name: s, config: a } = e;
    this.name = s, this.config = a, this._positioningFunctionCoordinates = { left: i, top: r }, this._options = t;
  }
  get left() {
    return this._absoluteRect.left;
  }
  get top() {
    return this._absoluteRect.top;
  }
  get limiterIntersectionArea() {
    const n = this._options.limiterRect;
    return n ? n.getIntersectionArea(this._rect) : 0;
  }
  get viewportIntersectionArea() {
    return this._options.viewportRect.getIntersectionArea(this._rect);
  }
  get _rect() {
    return this._cachedRect || (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCoordinates.left, this._positioningFunctionCoordinates.top)), this._cachedRect;
  }
  get _absoluteRect() {
    return this._cachedAbsoluteRect || (this._cachedAbsoluteRect = this._rect.toAbsoluteRect()), this._cachedAbsoluteRect;
  }
}
function Eh(o) {
  const n = o.parentNode;
  n && n.removeChild(o);
}
function bC({ target: o, viewportOffset: n = 0, ancestorOffset: t = 0, alignToTop: e, forceScroll: i }) {
  const r = su(o);
  let s = r, a = null;
  for (n = /* @__PURE__ */ function(l) {
    return typeof l == "number" ? { top: l, bottom: l, left: l, right: l } : l;
  }(n); s; ) {
    let l;
    l = _C(s == r ? o : a), wC({ parent: l, getRect: () => Tl(o, s), alignToTop: e, ancestorOffset: t, forceScroll: i });
    let c = Tl(o, s);
    const d = Tl(l, s);
    if (c.height > d.height) {
      const u = c.getIntersection(d);
      u && (c = u);
    }
    if (kC({ window: s, rect: c, viewportOffset: n, alignToTop: e, forceScroll: i }), s.parent != s) {
      if (a = s.frameElement, s = s.parent, !a) return;
    } else s = null;
  }
}
function kC({ window: o, rect: n, alignToTop: t, forceScroll: e, viewportOffset: i }) {
  const r = n.clone().moveBy(0, i.bottom), s = n.clone().moveBy(0, -i.top), a = new K(o).excludeScrollbarsAndBorders(), l = t && e, c = [s, r].every((f) => a.contains(f));
  let { scrollX: d, scrollY: u } = o;
  const h = d, g = u;
  l ? u -= a.top - n.top + i.top : c || (Ak(s, a) ? u -= a.top - n.top + i.top : Ck(r, a) && (u += t ? n.top - a.top - i.top : n.bottom - a.bottom + i.bottom)), c || (xk(n, a) ? d -= a.left - n.left + i.left : Ek(n, a) && (d += n.right - a.right + i.right)), d == h && u === g || o.scrollTo(d, u);
}
function wC({ parent: o, getRect: n, alignToTop: t, forceScroll: e, ancestorOffset: i = 0, limiterElement: r }) {
  const s = su(o), a = t && e;
  let l, c, d;
  const u = r || s.document.body;
  for (; o != u; ) c = n(), l = new K(o).excludeScrollbarsAndBorders(), d = l.contains(c), a ? o.scrollTop -= l.top - c.top + i : d || (Ak(c, l) ? o.scrollTop -= l.top - c.top + i : Ck(c, l) && (o.scrollTop += t ? c.top - l.top - i : c.bottom - l.bottom + i)), d || (xk(c, l) ? o.scrollLeft -= l.left - c.left + i : Ek(c, l) && (o.scrollLeft += c.right - l.right + i)), o = o.parentNode;
}
function Ck(o, n) {
  return o.bottom > n.bottom;
}
function Ak(o, n) {
  return o.top < n.top;
}
function xk(o, n) {
  return o.left < n.left;
}
function Ek(o, n) {
  return o.right > n.right;
}
function su(o) {
  return ol(o) ? o.startContainer.ownerDocument.defaultView : o.ownerDocument.defaultView;
}
function _C(o) {
  if (ol(o)) {
    let n = o.commonAncestorContainer;
    return qt(n) && (n = n.parentNode), n;
  }
  return o.parentNode;
}
function Tl(o, n) {
  const t = su(o), e = new K(o);
  if (t === n) return e;
  {
    let i = t;
    for (; i != n; ) {
      const r = i.frameElement, s = new K(r).excludeScrollbarsAndBorders();
      e.moveBy(s.left, s.top), i = i.parent;
    }
  }
  return e;
}
const vC = { ctrl: "", cmd: "", alt: "", shift: "" }, yC = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" }, Th = { 37: "", 38: "", 39: "", 40: "", 9: "", 33: "Page Up", 34: "Page Down" }, nt = EC(), CC = Object.fromEntries(Object.entries(nt).map(([o, n]) => {
  let t;
  return t = n in Th ? Th[n] : o.charAt(0).toUpperCase() + o.slice(1), [n, t];
}));
function eo(o) {
  let n;
  if (typeof o == "string") {
    if (n = nt[o.toLowerCase()], !n) throw new v("keyboard-unknown-key", null, { key: o });
  } else n = o.keyCode + (o.altKey ? nt.alt : 0) + (o.ctrlKey ? nt.ctrl : 0) + (o.shiftKey ? nt.shift : 0) + (o.metaKey ? nt.cmd : 0);
  return n;
}
function ws(o) {
  return typeof o == "string" && (o = function(n) {
    return n.split("+").map((t) => t.trim());
  }(o)), o.map((n) => typeof n == "string" ? function(t) {
    if (t.endsWith("!")) return eo(t.slice(0, -1));
    const e = eo(t);
    return (H.isMac || H.isiOS) && e == nt.ctrl ? nt.cmd : e;
  }(n) : n).reduce((n, t) => t + n, 0);
}
function _a(o, n) {
  let t = ws(o);
  const e = H.isMac || H.isiOS;
  return Object.entries(e ? vC : yC).reduce((i, [r, s]) => (t & nt[r] && (t &= ~nt[r], i += s), i), "") + (t ? CC[t] : "");
}
function AC(o) {
  return o == nt.arrowright || o == nt.arrowleft || o == nt.arrowup || o == nt.arrowdown;
}
function rl(o, n) {
  const t = n === "ltr";
  switch (o) {
    case nt.arrowleft:
      return t ? "left" : "right";
    case nt.arrowright:
      return t ? "right" : "left";
    case nt.arrowup:
      return "up";
    case nt.arrowdown:
      return "down";
  }
}
function xC(o, n) {
  const t = rl(o, n);
  return t === "down" || t === "right";
}
function EC() {
  const o = { pageup: 33, pagedown: 34, end: 35, home: 36, arrowleft: 37, arrowup: 38, arrowright: 39, arrowdown: 40, backspace: 8, delete: 46, enter: 13, space: 32, esc: 27, tab: 9, ctrl: 1114112, shift: 2228224, alt: 4456448, cmd: 8912896 };
  for (let n = 65; n <= 90; n++)
    o[String.fromCharCode(n).toLowerCase()] = n;
  for (let n = 48; n <= 57; n++) o[n - 48] = n;
  for (let n = 112; n <= 123; n++) o["f" + (n - 111)] = n;
  return Object.assign(o, { "'": 222, ",": 108, "-": 109, ".": 110, "/": 111, ";": 186, "=": 187, "[": 219, "\\": 220, "]": 221, "`": 223 }), o;
}
const TC = ["ar", "ara", "dv", "div", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"];
function Sh(o) {
  return TC.includes(o) ? "rtl" : "ltr";
}
function Bt(o) {
  return Array.isArray(o) ? o : [o];
}
function SC(o, n, t = 1, e) {
  if (typeof t != "number") throw new v("translation-service-quantity-not-a-number", null, { quantity: t });
  const i = e || N.window.CKEDITOR_TRANSLATIONS, r = function(d) {
    return Object.keys(d).length;
  }(i);
  r === 1 && (o = Object.keys(i)[0]);
  const s = n.id || n.string;
  if (r === 0 || !function(d, u, h) {
    return !!h[d] && !!h[d].dictionary[u];
  }(o, s, i)) return t !== 1 ? n.plural : n.string;
  const a = i[o].dictionary, l = i[o].getPluralForm || ((d) => d === 1 ? 0 : 1), c = a[s];
  return typeof c == "string" ? c : c[Number(l(t))];
}
N.window.CKEDITOR_TRANSLATIONS || (N.window.CKEDITOR_TRANSLATIONS = {});
class IC {
  constructor({ uiLanguage: n = "en", contentLanguage: t, translations: e } = {}) {
    m(this, "uiLanguage");
    m(this, "uiLanguageDirection");
    m(this, "contentLanguage");
    m(this, "contentLanguageDirection");
    m(this, "t");
    m(this, "translations");
    this.uiLanguage = n, this.contentLanguage = t || this.uiLanguage, this.uiLanguageDirection = Sh(this.uiLanguage), this.contentLanguageDirection = Sh(this.contentLanguage), this.translations = function(i) {
      return Array.isArray(i) ? i.reduce((r, s) => ou(r, s)) : i;
    }(e), this.t = (i, r) => this._t(i, r);
  }
  get language() {
    return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage;
  }
  _t(n, t = []) {
    t = Bt(t), typeof n == "string" && (n = { string: n });
    const e = n.plural ? t[0] : 1;
    return function(i, r) {
      return i.replace(/%(\d+)/g, (s, a) => a < r.length ? r[a] : s);
    }(SC(this.uiLanguage, n, e, this.translations), t);
  }
}
class ne extends vt() {
  constructor(t = {}, e = {}) {
    super();
    m(this, "_items");
    m(this, "_itemMap");
    m(this, "_idProperty");
    m(this, "_bindToCollection");
    m(this, "_bindToExternalToInternalMap");
    m(this, "_bindToInternalToExternalMap");
    m(this, "_skippedIndexesFromExternal");
    const i = Ye(t);
    if (i || (e = t), this._items = [], this._itemMap = /* @__PURE__ */ new Map(), this._idProperty = e.idProperty || "id", this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap(), this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap(), this._skippedIndexesFromExternal = [], i) for (const r of t) this._items.push(r), this._itemMap.set(this._getItemIdBeforeAdding(r), r);
  }
  get length() {
    return this._items.length;
  }
  get first() {
    return this._items[0] || null;
  }
  get last() {
    return this._items[this.length - 1] || null;
  }
  add(t, e) {
    return this.addMany([t], e);
  }
  addMany(t, e) {
    if (e === void 0) e = this._items.length;
    else if (e > this._items.length || e < 0) throw new v("collection-add-item-invalid-index", this);
    let i = 0;
    for (const r of t) {
      const s = this._getItemIdBeforeAdding(r), a = e + i;
      this._items.splice(a, 0, r), this._itemMap.set(s, r), this.fire("add", r, a), i++;
    }
    return this.fire("change", { added: t, removed: [], index: e }), this;
  }
  get(t) {
    let e;
    if (typeof t == "string") e = this._itemMap.get(t);
    else {
      if (typeof t != "number") throw new v("collection-get-invalid-arg", this);
      e = this._items[t];
    }
    return e || null;
  }
  has(t) {
    if (typeof t == "string") return this._itemMap.has(t);
    {
      const e = t[this._idProperty];
      return e && this._itemMap.has(e);
    }
  }
  getIndex(t) {
    let e;
    return e = typeof t == "string" ? this._itemMap.get(t) : t, e ? this._items.indexOf(e) : -1;
  }
  remove(t) {
    const [e, i] = this._remove(t);
    return this.fire("change", { added: [], removed: [e], index: i }), e;
  }
  map(t, e) {
    return this._items.map(t, e);
  }
  forEach(t, e) {
    this._items.forEach(t, e);
  }
  find(t, e) {
    return this._items.find(t, e);
  }
  filter(t, e) {
    return this._items.filter(t, e);
  }
  clear() {
    this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null);
    const t = Array.from(this._items);
    for (; this.length; ) this._remove(0);
    this.fire("change", { added: [], removed: t, index: 0 });
  }
  bindTo(t) {
    if (this._bindToCollection) throw new v("collection-bind-to-rebind", this);
    return this._bindToCollection = t, { as: (e) => {
      this._setUpBindToBinding((i) => new e(i));
    }, using: (e) => {
      typeof e == "function" ? this._setUpBindToBinding(e) : this._setUpBindToBinding((i) => i[e]);
    } };
  }
  _setUpBindToBinding(t) {
    const e = this._bindToCollection, i = (r, s, a) => {
      const l = e._bindToCollection == this, c = e._bindToInternalToExternalMap.get(s);
      if (l && c) this._bindToExternalToInternalMap.set(s, c), this._bindToInternalToExternalMap.set(c, s);
      else {
        const d = t(s);
        if (!d) return void this._skippedIndexesFromExternal.push(a);
        let u = a;
        for (const h of this._skippedIndexesFromExternal) a > h && u--;
        for (const h of e._skippedIndexesFromExternal) u >= h && u++;
        this._bindToExternalToInternalMap.set(s, d), this._bindToInternalToExternalMap.set(d, s), this.add(d, u);
        for (let h = 0; h < e._skippedIndexesFromExternal.length; h++) u <= e._skippedIndexesFromExternal[h] && e._skippedIndexesFromExternal[h]++;
      }
    };
    for (const r of e) i(0, r, e.getIndex(r));
    this.listenTo(e, "add", i), this.listenTo(e, "remove", (r, s, a) => {
      const l = this._bindToExternalToInternalMap.get(s);
      l && this.remove(l), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((c, d) => (a < d && c.push(d - 1), a > d && c.push(d), c), []);
    });
  }
  _getItemIdBeforeAdding(t) {
    const e = this._idProperty;
    let i;
    if (e in t) {
      if (i = t[e], typeof i != "string") throw new v("collection-add-invalid-id", this);
      if (this.get(i)) throw new v("collection-add-item-already-exists", this);
    } else t[e] = i = Ee();
    return i;
  }
  _remove(t) {
    let e, i, r, s = !1;
    const a = this._idProperty;
    if (typeof t == "string" ? (i = t, r = this._itemMap.get(i), s = !r, r && (e = this._items.indexOf(r))) : typeof t == "number" ? (e = t, r = this._items[e], s = !r, r && (i = r[a])) : (r = t, i = r[a], e = this._items.indexOf(r), s = e == -1 || !this._itemMap.get(i)), s) throw new v("collection-remove-404", this);
    this._items.splice(e, 1), this._itemMap.delete(i);
    const l = this._bindToInternalToExternalMap.get(r);
    return this._bindToInternalToExternalMap.delete(r), this._bindToExternalToInternalMap.delete(l), this.fire("remove", r, e), [r, e];
  }
  [Symbol.iterator]() {
    return this._items[Symbol.iterator]();
  }
}
function yt(o) {
  const n = o.next();
  return n.done ? null : n.value;
}
class gt extends Pe(_t()) {
  constructor() {
    super();
    m(this, "_elements", /* @__PURE__ */ new Set());
    m(this, "_externalViews", /* @__PURE__ */ new Set());
    m(this, "_blurTimeout", null);
    this.set("isFocused", !1), this.set("focusedElement", null);
  }
  get elements() {
    return Array.from(this._elements.values());
  }
  get externalViews() {
    return Array.from(this._externalViews.values());
  }
  add(t) {
    if (Mh(t)) this._addElement(t);
    else if (Ih(t)) this._addView(t);
    else {
      if (!t.element) throw new v("focustracker-add-view-missing-element", { focusTracker: this, view: t });
      this._addElement(t.element);
    }
  }
  remove(t) {
    Mh(t) ? this._removeElement(t) : Ih(t) ? this._removeView(t) : this._removeElement(t.element);
  }
  _addElement(t) {
    if (this._elements.has(t)) throw new v("focustracker-add-element-already-exist", this);
    this.listenTo(t, "focus", () => {
      const e = this.externalViews.find((i) => function(r, s) {
        return Dh(r, s) ? !0 : !!s.focusTracker.externalViews.find((a) => Dh(r, a));
      }(t, i));
      e ? this._focus(e.element) : this._focus(t);
    }, { useCapture: !0 }), this.listenTo(t, "blur", () => {
      this._blur();
    }, { useCapture: !0 }), this._elements.add(t);
  }
  _removeElement(t) {
    this._elements.has(t) && (this.stopListening(t), this._elements.delete(t)), t === this.focusedElement && this._blur();
  }
  _addView(t) {
    t.element && this._addElement(t.element), this.listenTo(t.focusTracker, "change:focusedElement", () => {
      t.focusTracker.focusedElement ? t.element && this._focus(t.element) : this._blur();
    }), this._externalViews.add(t);
  }
  _removeView(t) {
    t.element && this._removeElement(t.element), this.stopListening(t.focusTracker), this._externalViews.delete(t);
  }
  destroy() {
    this.stopListening(), this._elements.clear(), this._externalViews.clear(), this.isFocused = !1, this.focusedElement = null;
  }
  _focus(t) {
    this._clearBlurTimeout(), this.focusedElement = t, this.isFocused = !0;
  }
  _blur() {
    this.elements.find((t) => t.contains(document.activeElement)) || this.externalViews.find((t) => t.focusTracker.isFocused && !t.focusTracker._blurTimeout) || (this._clearBlurTimeout(), this._blurTimeout = setTimeout(() => {
      this.focusedElement = null, this.isFocused = !1;
    }, 0));
  }
  _clearBlurTimeout() {
    clearTimeout(this._blurTimeout), this._blurTimeout = null;
  }
}
function Ih(o) {
  return "focusTracker" in o && o.focusTracker instanceof gt;
}
function Mh(o) {
  return Si(o);
}
function Dh(o, n) {
  return !!n.element && n.element.contains(document.activeElement) && o.contains(n.element);
}
class Mt {
  constructor() {
    m(this, "_listener");
    this._listener = new (Pe())();
  }
  listenTo(n) {
    this._listener.listenTo(n, "keydown", (t, e) => {
      this._listener.fire("_keydown:" + eo(e), e);
    });
  }
  set(n, t, e = {}) {
    const i = ws(n), r = e.priority;
    this._listener.listenTo(this._listener, "_keydown:" + i, (s, a) => {
      e.filter && !e.filter(a) || (t(a, () => {
        a.preventDefault(), a.stopPropagation(), s.stop();
      }), s.return = !0);
    }, { priority: r });
  }
  press(n) {
    return !!this._listener.fire("_keydown:" + eo(n), n);
  }
  stopListening(n) {
    this._listener.stopListening(n);
  }
  destroy() {
    this.stopListening();
  }
}
function wn(o) {
  return Ye(o) ? new Map(o) : function(n) {
    const t = /* @__PURE__ */ new Map();
    for (const e in n) t.set(e, n[e]);
    return t;
  }(o);
}
function Ph(o, n, t) {
  const e = o.length, i = n.length;
  for (let r = e - 1; r >= t; r--) o[r + i] = o[r];
  for (let r = 0; r < i; r++) o[t + r] = n[r];
}
function au(o, n) {
  let t;
  function e(...i) {
    e.cancel(), t = setTimeout(() => o(...i), n);
  }
  return e.cancel = () => {
    clearTimeout(t);
  }, e;
}
function lu(o) {
  try {
    if (!o.startsWith("ey")) return null;
    const n = atob(o.replace(/-/g, "+").replace(/_/g, "/"));
    return JSON.parse(n);
  } catch {
    return null;
  }
}
function MC(o) {
  const n = Array.isArray(o) ? o : [o], t = function() {
    const r = [];
    for (let s = 0; s < 256; s++) {
      let a = s;
      for (let l = 0; l < 8; l++) 1 & a ? a = 3988292384 ^ a >>> 1 : a >>>= 1;
      r[s] = a;
    }
    return r;
  }();
  let e = -1;
  const i = n.map((r) => Array.isArray(r) ? r.join("") : String(r)).join("");
  for (let r = 0; r < i.length; r++)
    e = e >>> 8 ^ t[255 & (e ^ i.charCodeAt(r))];
  return e = ~e >>> 0, e.toString(16).padStart(8, "0");
}
function DC(o) {
  return !!o && o.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(o);
}
function PC(o) {
  return !!o && o.length == 1 && /[\ud800-\udbff]/.test(o);
}
function LC(o) {
  return !!o && o.length == 1 && /[\udc00-\udfff]/.test(o);
}
function cu(o, n) {
  return PC(o.charAt(n - 1)) && LC(o.charAt(n));
}
function du(o, n) {
  return DC(o.charAt(n));
}
const BC = NC();
function Tk(o, n) {
  const t = String(o).matchAll(BC);
  return Array.from(t).some((e) => e.index < n && n < e.index + e[0].length);
}
function NC() {
  const o = new RegExp("\\p{Regional_Indicator}{2}", "u").source, n = "(?:" + [new RegExp("\\p{Emoji}[\\u{E0020}-\\u{E007E}]+\\u{E007F}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}?\\u{20E3}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}", "u"), new RegExp("(?=\\p{General_Category=Other_Symbol})\\p{Emoji}\\p{Emoji_Modifier}*", "u")].map((t) => t.source).join("|") + ")";
  return new RegExp(`${o}|${n}(?:${n})*`, "ug");
}
class A extends _t() {
  constructor(t) {
    super();
    m(this, "editor");
    m(this, "_disableStack", /* @__PURE__ */ new Set());
    this.editor = t, this.set("isEnabled", !0);
  }
  forceDisabled(t) {
    this._disableStack.add(t), this._disableStack.size == 1 && (this.on("set:isEnabled", Lh, { priority: "highest" }), this.isEnabled = !1);
  }
  clearForceDisabled(t) {
    this._disableStack.delete(t), this._disableStack.size == 0 && (this.off("set:isEnabled", Lh), this.isEnabled = !0);
  }
  destroy() {
    this.stopListening();
  }
  static get isContextPlugin() {
    return !1;
  }
  static get isOfficialPlugin() {
    return !1;
  }
  static get isPremiumPlugin() {
    return !1;
  }
}
function Lh(o) {
  o.return = !1, o.stop();
}
class q extends _t() {
  constructor(t) {
    super();
    m(this, "editor");
    m(this, "_isEnabledBasedOnSelection");
    m(this, "_affectsData");
    m(this, "_disableStack");
    this.editor = t, this.set("value", void 0), this.set("isEnabled", !1), this._affectsData = !0, this._isEnabledBasedOnSelection = !0, this._disableStack = /* @__PURE__ */ new Set(), this.decorate("execute"), this.listenTo(this.editor.model.document, "change", () => {
      this.refresh();
    }), this.listenTo(t, "change:isReadOnly", () => {
      this.refresh();
    }), this.on("set:isEnabled", (e) => {
      if (!this.affectsData) return;
      const i = t.model.document.selection, r = i.getFirstPosition().root.rootName != "$graveyard" && t.model.canEditAt(i);
      (t.isReadOnly || this._isEnabledBasedOnSelection && !r) && (e.return = !1, e.stop());
    }, { priority: "highest" }), this.on("execute", (e) => {
      this.isEnabled || e.stop();
    }, { priority: "high" });
  }
  get affectsData() {
    return this._affectsData;
  }
  set affectsData(t) {
    this._affectsData = t;
  }
  refresh() {
    this.isEnabled = !0;
  }
  forceDisabled(t) {
    this._disableStack.add(t), this._disableStack.size == 1 && (this.on("set:isEnabled", Bh, { priority: "highest" }), this.isEnabled = !1);
  }
  clearForceDisabled(t) {
    this._disableStack.delete(t), this._disableStack.size == 0 && (this.off("set:isEnabled", Bh), this.refresh());
  }
  execute(...t) {
  }
  destroy() {
    this.stopListening();
  }
}
function Bh(o) {
  o.return = !1, o.stop();
}
class Nh extends q {
  constructor() {
    super(...arguments);
    m(this, "_childCommandsDefinitions", []);
  }
  refresh() {
  }
  execute(...t) {
    const e = this._getFirstEnabledCommand();
    return !!e && e.execute(t);
  }
  registerChildCommand(t, e = {}) {
    Nb(this._childCommandsDefinitions, { command: t, priority: e.priority || "normal" }), t.on("change:isEnabled", () => this._checkEnabled()), this._checkEnabled();
  }
  _checkEnabled() {
    this.isEnabled = !!this._getFirstEnabledCommand();
  }
  _getFirstEnabledCommand() {
    const t = this._childCommandsDefinitions.find(({ command: e }) => e.isEnabled);
    return t && t.command;
  }
}
class Sk extends vt() {
  constructor(t, e = [], i = []) {
    super();
    m(this, "_context");
    m(this, "_plugins", /* @__PURE__ */ new Map());
    m(this, "_availablePlugins");
    m(this, "_contextPlugins");
    this._context = t, this._availablePlugins = /* @__PURE__ */ new Map();
    for (const r of e) r.pluginName && this._availablePlugins.set(r.pluginName, r);
    this._contextPlugins = /* @__PURE__ */ new Map();
    for (const [r, s] of i) this._contextPlugins.set(r, s), this._contextPlugins.set(s, r), r.pluginName && this._availablePlugins.set(r.pluginName, r);
  }
  *[Symbol.iterator]() {
    for (const t of this._plugins) typeof t[0] == "function" && (yield t);
  }
  get(t) {
    const e = this._plugins.get(t);
    if (!e) {
      let i = t;
      throw typeof t == "function" && (i = t.pluginName || t.name), new v("plugincollection-plugin-not-loaded", this._context, { plugin: i });
    }
    return e;
  }
  has(t) {
    return this._plugins.has(t);
  }
  init(t, e = [], i = []) {
    const r = this, s = this._context;
    (function p(b, k = /* @__PURE__ */ new Set()) {
      b.forEach((w) => {
        c(w) && (k.has(w) || (k.add(w), w.pluginName && !r._availablePlugins.has(w.pluginName) && r._availablePlugins.set(w.pluginName, w), w.requires && p(w.requires, k)));
      });
    })(t), g(t);
    const a = [...function p(b, k = /* @__PURE__ */ new Set()) {
      return b.map((w) => c(w) ? w : r._availablePlugins.get(w)).reduce((w, _) => k.has(_) ? w : (k.add(_), _.requires && (g(_.requires, _), p(_.requires, k).forEach((y) => w.add(y))), w.add(_)), /* @__PURE__ */ new Set());
    }(t.filter((p) => !u(p, e)))];
    (function(p, b) {
      for (const k of b) {
        if (typeof k != "function") throw new v("plugincollection-replace-plugin-invalid-type", null, { pluginItem: k });
        const w = k.pluginName;
        if (!w) throw new v("plugincollection-replace-plugin-missing-name", null, { pluginItem: k });
        if (k.requires && k.requires.length) throw new v("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, { pluginName: w });
        const _ = r._availablePlugins.get(w);
        if (!_) throw new v("plugincollection-plugin-for-replacing-not-exist", null, { pluginName: w });
        const y = p.indexOf(_);
        if (y === -1) {
          if (r._contextPlugins.has(_)) return;
          throw new v("plugincollection-plugin-for-replacing-not-loaded", null, { pluginName: w });
        }
        if (_.requires && _.requires.length) throw new v("plugincollection-replaced-plugin-cannot-have-dependencies", null, { pluginName: w });
        p.splice(y, 1, k), r._availablePlugins.set(w, k);
      }
    })(a, i);
    const l = function(p) {
      return p.map((b) => {
        let k = r._contextPlugins.get(b);
        return k = k || new b(s), r._add(b, k), k;
      });
    }(a);
    return f(l, "init").then(() => f(l, "afterInit")).then(() => l);
    function c(p) {
      return typeof p == "function";
    }
    function d(p) {
      return c(p) && !!p.isContextPlugin;
    }
    function u(p, b) {
      return b.some((k) => k === p || h(p) === k || h(k) === p);
    }
    function h(p) {
      return c(p) ? p.pluginName || p.name : p;
    }
    function g(p, b = null) {
      p.map((k) => c(k) ? k : r._availablePlugins.get(k) || k).forEach((k) => {
        (function(w, _) {
          if (!c(w))
            throw _ ? new v("plugincollection-soft-required", s, { missingPlugin: w, requiredBy: h(_) }) : new v("plugincollection-plugin-not-found", s, { plugin: w });
        })(k, b), function(w, _) {
          if (d(_) && !d(w))
            throw new v("plugincollection-context-required", s, { plugin: h(w), requiredBy: h(_) });
        }(k, b), function(w, _) {
          if (_ && u(w, e))
            throw new v("plugincollection-required", s, { plugin: h(w), requiredBy: h(_) });
        }(k, b);
      });
    }
    function f(p, b) {
      return p.reduce((k, w) => w[b] ? r._contextPlugins.has(w) ? k : k.then(w[b].bind(w)) : k, Promise.resolve());
    }
  }
  destroy() {
    const t = [];
    for (const [, e] of this) typeof e.destroy != "function" || this._contextPlugins.has(e) || t.push(e.destroy());
    return Promise.all(t);
  }
  _add(t, e) {
    this._plugins.set(t, e);
    const i = t.pluginName;
    if (i) {
      if (this._plugins.has(i)) throw new v("plugincollection-plugin-name-conflict", null, { pluginName: i, plugin1: this._plugins.get(i).constructor, plugin2: t });
      this._plugins.set(i, e);
    }
  }
}
class va {
  constructor(n) {
    m(this, "config");
    m(this, "plugins");
    m(this, "locale");
    m(this, "t");
    m(this, "editors");
    m(this, "_contextOwner", null);
    const { translations: t, ...e } = n || {};
    this.config = new fk(e, this.constructor.defaultConfig);
    const i = this.constructor.builtinPlugins;
    this.config.define("plugins", i), this.plugins = new Sk(this, i);
    const r = this.config.get("language") || {};
    this.locale = new IC({ uiLanguage: typeof r == "string" ? r : r.ui, contentLanguage: this.config.get("language.content"), translations: t }), this.t = this.locale.t, this.editors = new ne();
  }
  initPlugins() {
    const n = this.config.get("plugins") || [], t = this.config.get("substitutePlugins") || [];
    for (const e of n.concat(t)) {
      if (typeof e != "function") throw new v("context-initplugins-constructor-only", null, { Plugin: e });
      if (e.isContextPlugin !== !0) throw new v("context-initplugins-invalid-plugin", null, { Plugin: e });
    }
    return this.plugins.init(n, [], t);
  }
  destroy() {
    return Promise.all(Array.from(this.editors, (n) => n.destroy())).then(() => this.plugins.destroy());
  }
  _addEditor(n, t) {
    if (this._contextOwner) throw new v("context-addeditor-private-context");
    this.editors.add(n), t && (this._contextOwner = n);
  }
  _removeEditor(n) {
    return this.editors.has(n) && this.editors.remove(n), this._contextOwner === n ? this.destroy() : Promise.resolve();
  }
  _getEditorConfig() {
    const n = {};
    for (const t of this.config.names()) ["plugins", "removePlugins", "extraPlugins"].includes(t) || (n[t] = this.config.get(t));
    return n;
  }
  static create(n) {
    return new Promise((t) => {
      const e = new this(n);
      t(e.initPlugins().then(() => e));
    });
  }
}
m(va, "defaultConfig"), m(va, "builtinPlugins");
class Ik extends _t() {
  constructor(t) {
    super();
    m(this, "context");
    this.context = t;
  }
  destroy() {
    this.stopListening();
  }
  static get isContextPlugin() {
    return !0;
  }
  static get isOfficialPlugin() {
    return !1;
  }
  static get isPremiumPlugin() {
    return !1;
  }
}
const ur = /* @__PURE__ */ new WeakMap();
let zh = !1;
function uu({ view: o, element: n, text: t, isDirectHost: e = !0, keepOnFocus: i = !1 }) {
  const r = o.document;
  function s(a) {
    const l = { text: a, isDirectHost: e, keepOnFocus: i, hostElement: e ? n : null };
    ur.get(r).set(n, l), o.change((c) => Sl([[n, l]], c));
  }
  ur.has(r) || (ur.set(r, /* @__PURE__ */ new Map()), r.registerPostFixer((a) => Sl(ur.get(r), a)), r.on("change:isComposing", () => {
    o.change((a) => Sl(ur.get(r), a));
  }, { priority: "high" })), n.is("editableElement") && n.on("change:placeholder", (a, l, c) => s(c)), n.placeholder ? s(n.placeholder) : t && s(t), t && function() {
    zh || at("enableplaceholder-deprecated-text-option"), zh = !0;
  }();
}
function Mk(o, n) {
  return !n.hasClass("ck-placeholder") && (o.addClass("ck-placeholder", n), !0);
}
function Gc(o, n) {
  return !!n.hasClass("ck-placeholder") && (o.removeClass("ck-placeholder", n), !0);
}
function Dk(o, n) {
  if (!o.isAttached() || function(i) {
    for (const r of i.getChildren()) if (!r.is("uiElement")) return !0;
    return !1;
  }(o)) return !1;
  const t = o.document, e = t.selection.anchor;
  return (!t.isComposing || !e || e.parent !== o) && (!!n || !t.isFocused || !!e && e.parent !== o);
}
function Sl(o, n) {
  const t = [];
  let e = !1;
  for (const [i, r] of o) r.isDirectHost && (t.push(i), Oh(n, i, r) && (e = !0));
  for (const [i, r] of o) {
    if (r.isDirectHost) continue;
    const s = zC(i);
    s && (t.includes(s) || (r.hostElement = s, Oh(n, i, r) && (e = !0)));
  }
  return e;
}
function Oh(o, n, t) {
  const { text: e, isDirectHost: i, hostElement: r } = t;
  let s = !1;
  return r.getAttribute("data-placeholder") !== e && (o.setAttribute("data-placeholder", e, r), s = !0), (i || n.childCount == 1) && Dk(r, t.keepOnFocus) ? Mk(o, r) && (s = !0) : Gc(o, r) && (s = !0), s;
}
function zC(o) {
  if (o.childCount) {
    const n = o.getChild(0);
    if (n.is("element") && !n.is("uiElement") && !n.is("attributeElement")) return n;
  }
  return null;
}
let so = class {
  is() {
    throw new Error("is() method is abstract");
  }
}, ao = class extends vt(so) {
  constructor(n) {
    super();
    m(this, "document");
    m(this, "parent");
    this.document = n, this.parent = null;
  }
  get index() {
    let n;
    if (!this.parent) return null;
    if ((n = this.parent.getChildIndex(this)) == -1) throw new v("view-node-not-found-in-parent", this);
    return n;
  }
  get nextSibling() {
    const n = this.index;
    return n !== null && this.parent.getChild(n + 1) || null;
  }
  get previousSibling() {
    const n = this.index;
    return n !== null && this.parent.getChild(n - 1) || null;
  }
  get root() {
    let n = this;
    for (; n.parent; ) n = n.parent;
    return n;
  }
  isAttached() {
    return this.root.is("rootElement");
  }
  getPath() {
    const n = [];
    let t = this;
    for (; t.parent; ) n.unshift(t.index), t = t.parent;
    return n;
  }
  getAncestors(n = {}) {
    const t = [];
    let e = n.includeSelf ? this : this.parent;
    for (; e; ) t[n.parentFirst ? "push" : "unshift"](e), e = e.parent;
    return t;
  }
  getCommonAncestor(n, t = {}) {
    const e = this.getAncestors(t), i = n.getAncestors(t);
    let r = 0;
    for (; e[r] == i[r] && e[r]; ) r++;
    return r === 0 ? null : e[r - 1];
  }
  isBefore(n) {
    if (this == n || this.root !== n.root) return !1;
    const t = this.getPath(), e = n.getPath(), i = xe(t, e);
    switch (i) {
      case "prefix":
        return !0;
      case "extension":
        return !1;
      default:
        return t[i] < e[i];
    }
  }
  isAfter(n) {
    return this != n && this.root === n.root && !this.isBefore(n);
  }
  _remove() {
    this.parent._removeChildren(this.index);
  }
  _fireChange(n, t, e) {
    this.fire(`change:${n}`, t, e), this.parent && this.parent._fireChange(n, t, e);
  }
  toJSON() {
    const n = Jd(this);
    return delete n.parent, n;
  }
};
ao.prototype.is = function(o) {
  return o === "node" || o === "view:node";
};
let we = class Kc extends ao {
  constructor(t, e) {
    super(t);
    m(this, "_textData");
    this._textData = e;
  }
  get data() {
    return this._textData;
  }
  get _data() {
    return this.data;
  }
  set _data(t) {
    this._fireChange("text", this), this._textData = t;
  }
  isSimilar(t) {
    return t instanceof Kc && (this === t || this.data === t.data);
  }
  _clone() {
    return new Kc(this.document, this.data);
  }
};
we.prototype.is = function(o) {
  return o === "$text" || o === "view:$text" || o === "text" || o === "view:text" || o === "node" || o === "view:node";
};
let Kn = class extends so {
  constructor(n, t, e) {
    super();
    m(this, "textNode");
    m(this, "data");
    m(this, "offsetInText");
    if (this.textNode = n, t < 0 || t > n.data.length) throw new v("view-textproxy-wrong-offsetintext", this);
    if (e < 0 || t + e > n.data.length) throw new v("view-textproxy-wrong-length", this);
    this.data = n.data.substring(t, t + e), this.offsetInText = t;
  }
  get offsetSize() {
    return this.data.length;
  }
  get isPartial() {
    return this.data.length !== this.textNode.data.length;
  }
  get parent() {
    return this.textNode.parent;
  }
  get root() {
    return this.textNode.root;
  }
  get document() {
    return this.textNode.document;
  }
  getAncestors(n = {}) {
    const t = [];
    let e = n.includeSelf ? this.textNode : this.parent;
    for (; e !== null; ) t[n.parentFirst ? "push" : "unshift"](e), e = e.parent;
    return t;
  }
};
Kn.prototype.is = function(o) {
  return o === "$textProxy" || o === "view:$textProxy" || o === "textProxy" || o === "view:textProxy";
};
class ya {
  constructor() {
    m(this, "_consumables", /* @__PURE__ */ new Map());
  }
  add(n, t) {
    let e;
    n.is("$text") || n.is("documentFragment") ? this._consumables.set(n, !0) : (this._consumables.has(n) ? e = this._consumables.get(n) : (e = new OC(n), this._consumables.set(n, e)), e.add(t ? Mr(t) : n._getConsumables()));
  }
  test(n, t) {
    const e = this._consumables.get(n);
    return e === void 0 ? null : n.is("$text") || n.is("documentFragment") ? e : e.test(Mr(t));
  }
  consume(n, t) {
    if (n.is("$text") || n.is("documentFragment")) return !!this.test(n, t) && (this._consumables.set(n, !1), !0);
    const e = this._consumables.get(n);
    return e !== void 0 && e.consume(Mr(t));
  }
  revert(n, t) {
    const e = this._consumables.get(n);
    e !== void 0 && (n.is("$text") || n.is("documentFragment") ? this._consumables.set(n, !0) : e.revert(Mr(t)));
  }
  static createFrom(n, t) {
    if (t || (t = new ya()), n.is("$text")) t.add(n);
    else if (n.is("element") || n.is("documentFragment")) {
      t.add(n);
      for (const e of n.getChildren()) ya.createFrom(e, t);
    }
    return t;
  }
}
class OC {
  constructor(n) {
    m(this, "element");
    m(this, "_canConsumeName", null);
    m(this, "_attributes", /* @__PURE__ */ new Map());
    this.element = n;
  }
  add(n) {
    n.name && (this._canConsumeName = !0);
    for (const [t, e] of n.attributes) if (e) {
      let i = this._attributes.get(t);
      i && typeof i != "boolean" || (i = /* @__PURE__ */ new Map(), this._attributes.set(t, i)), i.set(e, !0);
    } else {
      if (t == "style" || t == "class") throw new v("viewconsumable-invalid-attribute", this);
      this._attributes.set(t, !0);
    }
  }
  test(n) {
    if (n.name && !this._canConsumeName) return this._canConsumeName;
    for (const [t, e] of n.attributes) {
      const i = this._attributes.get(t);
      if (i === void 0) return null;
      if (i === !1) return !1;
      if (i !== !0) {
        if (e) {
          const r = i.get(e);
          if (r === void 0) return null;
          if (!r) return !1;
        } else for (const r of i.values()) if (!r) return !1;
      }
    }
    return !0;
  }
  consume(n) {
    if (!this.test(n)) return !1;
    n.name && (this._canConsumeName = !1);
    for (const [t, e] of n.attributes) {
      const i = this._attributes.get(t);
      if (typeof i == "boolean") for (const [r] of this.element._getConsumables(t, e).attributes) this._attributes.set(r, !1);
      else if (e) for (const [, r] of this.element._getConsumables(t, e).attributes) i.set(r, !1);
      else for (const r of i.keys()) i.set(r, !1);
    }
    return !0;
  }
  revert(n) {
    n.name && (this._canConsumeName = !0);
    for (const [t, e] of n.attributes) {
      const i = this._attributes.get(t);
      if (i !== !1) {
        if (i !== void 0 && i !== !0) if (e)
          i.get(e) === !1 && i.set(e, !0);
        else for (const r of i.keys()) i.set(r, !0);
      } else this._attributes.set(t, !0);
    }
  }
}
function Mr(o) {
  const n = [];
  return "attributes" in o && o.attributes && Il(n, o.attributes), "classes" in o && o.classes && Il(n, o.classes, "class"), "styles" in o && o.styles && Il(n, o.styles, "style"), { name: o.name || !1, attributes: n };
}
function Il(o, n, t) {
  if (typeof n != "string") for (const e of n) Array.isArray(e) ? o.push(e) : o.push(t ? [t, e] : [e]);
  else o.push(t ? [t, n] : [n]);
}
class We {
  constructor(...n) {
    m(this, "_patterns", []);
    this.add(...n);
  }
  add(...n) {
    for (let t of n) (typeof t == "string" || t instanceof RegExp) && (t = { name: t }), this._patterns.push(t);
  }
  match(...n) {
    for (const t of n) for (const e of this._patterns) {
      const i = this._isElementMatching(t, e);
      if (i) return { element: t, pattern: e, match: i };
    }
    return null;
  }
  matchAll(...n) {
    const t = [];
    for (const e of n) for (const i of this._patterns) {
      const r = this._isElementMatching(e, i);
      r && t.push({ element: e, pattern: i, match: r });
    }
    return t.length > 0 ? t : null;
  }
  getElementName() {
    if (this._patterns.length !== 1) return null;
    const n = this._patterns[0], t = n.name;
    return typeof n == "function" || !t || t instanceof RegExp ? null : t;
  }
  _isElementMatching(n, t) {
    if (typeof t == "function") {
      const r = t(n);
      return r && typeof r == "object" ? Mr(r) : r;
    }
    const e = {};
    if (t.name && (e.name = function(r, s) {
      return r instanceof RegExp ? !!s.match(r) : r === s;
    }(t.name, n.name), !e.name)) return null;
    const i = [];
    return t.attributes && !function(r, s, a) {
      let l;
      return typeof r != "object" || r instanceof RegExp || Array.isArray(r) ? l = ["class", "style"] : (r.style !== void 0 && at("matcher-pattern-deprecated-attributes-style-key", r), r.class !== void 0 && at("matcher-pattern-deprecated-attributes-class-key", r)), s._collectAttributesMatch(Ml(r), a, l);
    }(t.attributes, n, i) || t.classes && !function(r, s, a) {
      return s._collectAttributesMatch(Ml(r, "class"), a);
    }(t.classes, n, i) || t.styles && !function(r, s, a) {
      return s._collectAttributesMatch(Ml(r, "style"), a);
    }(t.styles, n, i) ? null : (i.length && (e.attributes = i), e);
  }
}
function Ca(o, n) {
  return o === !0 || o === n || o instanceof RegExp && !!String(n).match(o);
}
function Ml(o, n) {
  if (Array.isArray(o)) return o.map((e) => typeof e != "object" || e instanceof RegExp ? n ? [n, e, !0] : [e, !0] : (e.key !== void 0 && e.value !== void 0 || at("matcher-pattern-missing-key-or-value", e), n ? [n, e.key, e.value] : [e.key, e.value]));
  if (typeof o != "object" || o instanceof RegExp) return [n ? [n, o, !0] : [o, !0]];
  const t = [];
  for (const e in o) Object.prototype.hasOwnProperty.call(o, e) && t.push(n ? [n, e, o[e]] : [e, o[e]]);
  return t;
}
class Fr {
  constructor(n) {
    m(this, "_styles");
    m(this, "_cachedStyleNames", null);
    m(this, "_cachedExpandedStyleNames", null);
    m(this, "_styleProcessor");
    this._styles = {}, this._styleProcessor = n;
  }
  get isEmpty() {
    return !Object.entries(this._styles).length;
  }
  get size() {
    return this.isEmpty ? 0 : this.getStyleNames().length;
  }
  setTo(n) {
    this.clear();
    const t = function(e) {
      let i = null, r = 0, s = 0, a = null;
      const l = /* @__PURE__ */ new Map();
      if (e === "") return l;
      e.charAt(e.length - 1) != ";" && (e += ";");
      for (let c = 0; c < e.length; c++) {
        const d = e.charAt(c);
        if (i === null) switch (d) {
          case ":":
            a || (a = e.substr(r, c - r), s = c + 1);
            break;
          case '"':
          case "'":
            i = d;
            break;
          case ";": {
            const u = e.substr(s, c - s);
            a && l.set(a.trim(), u.trim()), a = null, r = c + 1;
            break;
          }
        }
        else d === i && (i = null);
      }
      return l;
    }(n);
    for (const [e, i] of t) this._styleProcessor.toNormalizedForm(e, i, this._styles);
    return this;
  }
  has(n) {
    if (this.isEmpty) return !1;
    const t = this._styleProcessor.getReducedForm(n, this._styles).find(([e]) => e === n);
    return Array.isArray(t);
  }
  set(n, t) {
    if (this._cachedStyleNames = null, this._cachedExpandedStyleNames = null, bn(n)) for (const [e, i] of Object.entries(n)) this._styleProcessor.toNormalizedForm(e, i, this._styles);
    else this._styleProcessor.toNormalizedForm(n, t, this._styles);
  }
  remove(n) {
    for (const t of Bt(n)) {
      this._cachedStyleNames = null, this._cachedExpandedStyleNames = null;
      const e = Yc(t);
      cC(this._styles, e), delete this._styles[t], this._cleanEmptyObjectsOnPath(e);
    }
  }
  getNormalized(n) {
    return this._styleProcessor.getNormalized(n, this._styles);
  }
  toString() {
    return this.isEmpty ? "" : this.getStylesEntries().map((n) => n.join(":")).sort().join(";") + ";";
  }
  getAsString(n) {
    if (this.isEmpty) return;
    if (this._styles[n] && !bn(this._styles[n])) return this._styles[n];
    const t = this._styleProcessor.getReducedForm(n, this._styles).find(([e]) => e === n);
    return Array.isArray(t) ? t[1] : void 0;
  }
  getStyleNames(n = !1) {
    return this.isEmpty ? [] : n ? (this._cachedExpandedStyleNames || (this._cachedExpandedStyleNames = this._styleProcessor.getStyleNames(this._styles)), this._cachedExpandedStyleNames) : (this._cachedStyleNames || (this._cachedStyleNames = this.getStylesEntries().map(([t]) => t)), this._cachedStyleNames);
  }
  keys() {
    return this.getStyleNames();
  }
  clear() {
    this._styles = {}, this._cachedStyleNames = null, this._cachedExpandedStyleNames = null;
  }
  isSimilar(n) {
    if (this.size !== n.size) return !1;
    for (const t of this.getStyleNames()) if (!n.has(t) || n.getAsString(t) !== this.getAsString(t)) return !1;
    return !0;
  }
  getStylesEntries() {
    const n = [], t = Object.keys(this._styles);
    for (const e of t) n.push(...this._styleProcessor.getReducedForm(e, this._styles));
    return n;
  }
  _clone() {
    const n = new this.constructor(this._styleProcessor);
    return n.set(this.getNormalized()), n;
  }
  _getTokensMatch(n, t) {
    const e = [];
    for (const i of this.getStyleNames(!0)) if (Ca(n, i)) {
      if (t === !0) {
        e.push(i);
        continue;
      }
      Ca(t, this.getAsString(i)) && e.push(i);
    }
    return e.length ? e : void 0;
  }
  _getConsumables(n) {
    const t = [];
    if (n) {
      t.push(n);
      for (const e of this._styleProcessor.getRelatedStyles(n)) t.push(e);
    } else for (const e of this.getStyleNames()) {
      for (const i of this._styleProcessor.getRelatedStyles(e)) t.push(i);
      t.push(e);
    }
    return t;
  }
  _canMergeFrom(n) {
    for (const t of n.getStyleNames()) if (this.has(t) && this.getAsString(t) !== n.getAsString(t)) return !1;
    return !0;
  }
  _mergeFrom(n) {
    for (const t of n.getStyleNames()) this.has(t) || this.set(t, n.getAsString(t));
  }
  _isMatching(n) {
    for (const t of n.getStyleNames()) if (!this.has(t) || this.getAsString(t) !== n.getAsString(t)) return !1;
    return !0;
  }
  _cleanEmptyObjectsOnPath(n) {
    const t = n.split(".");
    if (!(t.length > 1)) return;
    const e = t.splice(0, t.length - 1).join("."), i = Ti(this._styles, e);
    i && !Object.keys(i).length && this.remove(e);
  }
}
class RC {
  constructor() {
    m(this, "_normalizers");
    m(this, "_extractors");
    m(this, "_reducers");
    m(this, "_consumables");
    this._normalizers = /* @__PURE__ */ new Map(), this._extractors = /* @__PURE__ */ new Map(), this._reducers = /* @__PURE__ */ new Map(), this._consumables = /* @__PURE__ */ new Map();
  }
  toNormalizedForm(n, t, e) {
    if (bn(t)) Dl(e, Yc(n), t);
    else if (this._normalizers.has(n)) {
      const i = this._normalizers.get(n), { path: r, value: s } = i(t);
      Dl(e, r, s);
    } else Dl(e, n, t);
  }
  getNormalized(n, t) {
    if (!n) return ou({}, t);
    if (t[n] !== void 0) return t[n];
    if (this._extractors.has(n)) {
      const e = this._extractors.get(n);
      if (typeof e == "string") return Ti(t, e);
      const i = e(n, t);
      if (i) return i;
    }
    return Ti(t, Yc(n));
  }
  getReducedForm(n, t) {
    const e = this.getNormalized(n, t);
    return e === void 0 ? [] : this._reducers.has(n) ? this._reducers.get(n)(e) : [[n, e]];
  }
  getStyleNames(n) {
    const t = /* @__PURE__ */ new Set();
    for (const e of this._consumables.keys()) {
      const i = this.getNormalized(e, n);
      i && (typeof i != "object" || Object.keys(i).length) && t.add(e);
    }
    for (const e of Object.keys(n)) t.add(e);
    return Array.from(t);
  }
  getRelatedStyles(n) {
    return this._consumables.get(n) || [];
  }
  setNormalizer(n, t) {
    this._normalizers.set(n, t);
  }
  setExtractor(n, t) {
    this._extractors.set(n, t);
  }
  setReducer(n, t) {
    this._reducers.set(n, t);
  }
  setStyleRelation(n, t) {
    this._mapStyleNames(n, t);
    for (const e of t) this._mapStyleNames(e, [n]);
  }
  _mapStyleNames(n, t) {
    this._consumables.has(n) || this._consumables.set(n, []), this._consumables.get(n).push(...t);
  }
}
function Yc(o) {
  return o.replace("-", ".");
}
function Dl(o, n, t) {
  let e = t;
  bn(t) && (e = ou({}, Ti(o, n), t)), ck(o, n, e);
}
class Pl {
  constructor() {
    m(this, "_set", /* @__PURE__ */ new Set());
  }
  get isEmpty() {
    return this._set.size == 0;
  }
  get size() {
    return this._set.size;
  }
  has(n) {
    return this._set.has(n);
  }
  keys() {
    return Array.from(this._set.keys());
  }
  setTo(n) {
    this.clear();
    for (const t of n.split(/\s+/)) t && this._set.add(t);
    return this;
  }
  set(n) {
    for (const t of Bt(n)) t && this._set.add(t);
  }
  remove(n) {
    for (const t of Bt(n)) this._set.delete(t);
  }
  clear() {
    this._set.clear();
  }
  toString() {
    return Array.from(this._set).join(" ");
  }
  isSimilar(n) {
    if (this.size !== n.size) return !1;
    for (const t of this.keys()) if (!n.has(t)) return !1;
    return !0;
  }
  _clone() {
    const n = new this.constructor();
    return n._set = new Set(this._set), n;
  }
  _getTokensMatch(n) {
    const t = [];
    if (n === !0) {
      for (const e of this._set.keys()) t.push(e);
      return t;
    }
    if (typeof n == "string") {
      for (const e of n.split(/\s+/)) {
        if (!this._set.has(e)) return;
        t.push(e);
      }
      return t;
    }
    for (const e of this._set.keys()) e.match(n) && t.push(e);
    return t.length ? t : void 0;
  }
  _getConsumables(n) {
    return n ? [n] : this.keys();
  }
  _canMergeFrom() {
    return !0;
  }
  _mergeFrom(n) {
    for (const t of n._set.keys()) this._set.has(t) || this._set.add(t);
  }
  _isMatching(n) {
    for (const t of n._set.keys()) if (!this._set.has(t)) return !1;
    return !0;
  }
}
let si = class Pk extends ao {
  constructor(t, e, i, r) {
    super(t);
    m(this, "name");
    m(this, "_unsafeAttributesToRender", []);
    m(this, "_attrs");
    m(this, "_children");
    m(this, "_customProperties", /* @__PURE__ */ new Map());
    this.name = e, this._attrs = this._parseAttributes(i), this._children = [], r && this._insertChild(0, r);
  }
  get _classes() {
    return this._attrs.get("class");
  }
  get _styles() {
    return this._attrs.get("style");
  }
  get childCount() {
    return this._children.length;
  }
  get isEmpty() {
    return this._children.length === 0;
  }
  getChild(t) {
    return this._children[t];
  }
  getChildIndex(t) {
    return this._children.indexOf(t);
  }
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  *getAttributeKeys() {
    this._classes && (yield "class"), this._styles && (yield "style");
    for (const t of this._attrs.keys()) t != "class" && t != "style" && (yield t);
  }
  *getAttributes() {
    for (const [t, e] of this._attrs.entries()) yield [t, String(e)];
  }
  getAttribute(t) {
    return this._attrs.has(t) ? String(this._attrs.get(t)) : void 0;
  }
  hasAttribute(t, e) {
    return !!this._attrs.has(t) && (e === void 0 || (wo(this.name, t) || hr(this.name, t) ? this._attrs.get(t).has(e) : this._attrs.get(t) === e));
  }
  isSimilar(t) {
    if (!(t instanceof Pk)) return !1;
    if (this === t) return !0;
    if (this.name != t.name || this._attrs.size !== t._attrs.size) return !1;
    for (const [e, i] of this._attrs) {
      const r = t._attrs.get(e);
      if (r === void 0) return !1;
      if (typeof i == "string" || typeof r == "string") {
        if (r !== i) return !1;
      } else if (!i.isSimilar(r)) return !1;
    }
    return !0;
  }
  hasClass(...t) {
    for (const e of t) if (!this._classes || !this._classes.has(e)) return !1;
    return !0;
  }
  getClassNames() {
    const t = this._classes ? this._classes.keys() : [], e = t[Symbol.iterator]();
    return Object.assign(t, { next: e.next.bind(e) });
  }
  getStyle(t) {
    return this._styles && this._styles.getAsString(t);
  }
  getNormalizedStyle(t) {
    return this._styles && this._styles.getNormalized(t);
  }
  getStyleNames(t) {
    return this._styles ? this._styles.getStyleNames(t) : [];
  }
  hasStyle(...t) {
    for (const e of t) if (!this._styles || !this._styles.has(e)) return !1;
    return !0;
  }
  findAncestor(...t) {
    const e = new We(...t);
    let i = this.parent;
    for (; i && !i.is("documentFragment"); ) {
      if (e.match(i)) return i;
      i = i.parent;
    }
    return null;
  }
  getCustomProperty(t) {
    return this._customProperties.get(t);
  }
  *getCustomProperties() {
    yield* this._customProperties.entries();
  }
  getIdentity() {
    const t = this._classes ? this._classes.keys().sort().join(",") : "", e = this._styles && String(this._styles), i = Array.from(this._attrs).filter(([r]) => r != "style" && r != "class").map((r) => `${r[0]}="${r[1]}"`).sort().join(" ");
    return this.name + (t == "" ? "" : ` class="${t}"`) + (e ? ` style="${e}"` : "") + (i == "" ? "" : ` ${i}`);
  }
  shouldRenderUnsafeAttribute(t) {
    return this._unsafeAttributesToRender.includes(t);
  }
  _clone(t = !1) {
    const e = [];
    if (t) for (const r of this.getChildren()) e.push(r._clone(t));
    const i = new this.constructor(this.document, this.name, this._attrs, e);
    return i._customProperties = new Map(this._customProperties), i.getFillerOffset = this.getFillerOffset, i._unsafeAttributesToRender = this._unsafeAttributesToRender, i;
  }
  _appendChild(t) {
    return this._insertChild(this.childCount, t);
  }
  _insertChild(t, e) {
    this._fireChange("children", this, { index: t });
    let i = 0;
    const r = function(s, a) {
      if (typeof a == "string") return [new we(s, a)];
      Ye(a) || (a = [a]);
      const l = [];
      for (const c of a) typeof c == "string" ? l.push(new we(s, c)) : c instanceof Kn ? l.push(new we(s, c.data)) : l.push(c);
      return l;
    }(this.document, e);
    for (const s of r) s.parent !== null && s._remove(), s.parent = this, s.document = this.document, this._children.splice(t, 0, s), t++, i++;
    return i;
  }
  _removeChildren(t, e = 1) {
    this._fireChange("children", this, { index: t });
    for (let i = t; i < t + e; i++) this._children[i].parent = null;
    return this._children.splice(t, e);
  }
  _setAttribute(t, e, i = !0) {
    if (this._fireChange("attributes", this), wo(this.name, t) || hr(this.name, t)) {
      let r = this._attrs.get(t);
      r || (r = wo(this.name, t) ? new Fr(this.document.stylesProcessor) : new Pl(), this._attrs.set(t, r)), i ? r.setTo(String(e)) : wo(this.name, t) ? Array.isArray(e) ? r.set(e[0], e[1]) : r.set(e) : r.set(typeof e == "string" ? e.split(/\s+/) : e);
    } else this._attrs.set(t, String(e));
  }
  _removeAttribute(t, e) {
    if (this._fireChange("attributes", this), e !== void 0 && (wo(this.name, t) || hr(this.name, t))) {
      const i = this._attrs.get(t);
      return !!i && (hr(this.name, t) && typeof e == "string" && (e = e.split(/\s+/)), i.remove(e), !!i.isEmpty && this._attrs.delete(t));
    }
    return this._attrs.delete(t);
  }
  _addClass(t) {
    this._setAttribute("class", t, !1);
  }
  _removeClass(t) {
    this._removeAttribute("class", t);
  }
  _setStyle(t, e) {
    typeof t != "string" ? this._setAttribute("style", t, !1) : this._setAttribute("style", [t, e], !1);
  }
  _removeStyle(t) {
    this._removeAttribute("style", t);
  }
  _collectAttributesMatch(t, e, i) {
    for (const [r, s, a] of t) {
      let l = !1, c = !1;
      for (const [d, u] of this._attrs) if (!(i && i.includes(d) || !Ca(r, d))) if (l = !0, typeof u == "string") {
        if (Ca(s, u)) e.push([d]), c = !0;
        else if (!(r instanceof RegExp)) return !1;
      } else {
        const h = u._getTokensMatch(s, a || !0);
        if (h) {
          c = !0;
          for (const g of h) e.push([d, g]);
        } else if (!(r instanceof RegExp)) return !1;
      }
      if (!l || !c) return !1;
    }
    return !0;
  }
  _getConsumables(t, e) {
    const i = [];
    if (t) {
      const r = this._attrs.get(t);
      if (r !== void 0) if (typeof r == "string") i.push([t]);
      else for (const s of r._getConsumables(e)) i.push([t, s]);
    } else for (const [r, s] of this._attrs) if (typeof s == "string") i.push([r]);
    else for (const a of s._getConsumables()) i.push([r, a]);
    return { name: !t, attributes: i };
  }
  _canMergeAttributesFrom(t) {
    if (this.name != t.name) return !1;
    for (const [e, i] of t._attrs) {
      const r = this._attrs.get(e);
      if (r !== void 0) {
        if (typeof r == "string" || typeof i == "string") {
          if (r !== i) return !1;
        } else if (!r._canMergeFrom(i)) return !1;
      }
    }
    return !0;
  }
  _mergeAttributesFrom(t) {
    this._fireChange("attributes", this);
    for (const [e, i] of t._attrs) {
      const r = this._attrs.get(e);
      r === void 0 || typeof r == "string" || typeof i == "string" ? this._setAttribute(e, i) : r._mergeFrom(i);
    }
  }
  _canSubtractAttributesOf(t) {
    if (this.name != t.name) return !1;
    for (const [e, i] of t._attrs) {
      const r = this._attrs.get(e);
      if (r === void 0) return !1;
      if (typeof r == "string" || typeof i == "string") {
        if (r !== i) return !1;
      } else if (!r._isMatching(i)) return !1;
    }
    return !0;
  }
  _subtractAttributesOf(t) {
    this._fireChange("attributes", this);
    for (const [e, i] of t._attrs) {
      const r = this._attrs.get(e);
      typeof r == "string" || typeof i == "string" ? this._attrs.delete(e) : (r.remove(i.keys()), r.isEmpty && this._attrs.delete(e));
    }
  }
  _setCustomProperty(t, e) {
    this._customProperties.set(t, e);
  }
  _removeCustomProperty(t) {
    return this._customProperties.delete(t);
  }
  _parseAttributes(t) {
    const e = wn(t);
    for (const [i, r] of e) if (r === null) e.delete(i);
    else if (wo(this.name, i)) {
      const s = r instanceof Fr ? r._clone() : new Fr(this.document.stylesProcessor).setTo(String(r));
      e.set(i, s);
    } else if (hr(this.name, i)) {
      const s = r instanceof Pl ? r._clone() : new Pl().setTo(String(r));
      e.set(i, s);
    } else typeof r != "string" && e.set(i, String(r));
    return e;
  }
};
function hr(o, n) {
  return n == "class" || o == "a" && n == "rel";
}
function wo(o, n) {
  return n == "style";
}
si.prototype.is = function(o, n) {
  return n ? n === this.name && (o === "element" || o === "view:element") : o === "element" || o === "view:element" || o === "node" || o === "view:node";
};
class ts extends si {
  constructor(n, t, e, i) {
    super(n, t, e, i), this.getFillerOffset = VC;
  }
}
function VC() {
  const o = [...this.getChildren()], n = o[this.childCount - 1];
  if (n && n.is("element", "br")) return this.childCount;
  for (const t of o) if (!t.is("uiElement")) return null;
  return this.childCount;
}
ts.prototype.is = function(o, n) {
  return n ? n === this.name && (o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element") : o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
};
class sl extends _t(ts) {
  constructor(n, t, e, i) {
    super(n, t, e, i), this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("placeholder", void 0), this.bind("isReadOnly").to(n), this.bind("isFocused").to(n, "isFocused", (r) => r && n.selection.editableElement == this), this.listenTo(n.selection, "change", () => {
      this.isFocused = n.isFocused && n.selection.editableElement == this;
    });
  }
  destroy() {
    this.stopListening();
  }
}
sl.prototype.is = function(o, n) {
  return n ? n === this.name && (o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element") : o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
};
const Rh = Symbol("rootName");
class Lk extends sl {
  constructor(n, t) {
    super(n, t), this.rootName = "main";
  }
  get rootName() {
    return this.getCustomProperty(Rh);
  }
  set rootName(n) {
    this._setCustomProperty(Rh, n);
  }
  set _name(n) {
    this.name = n;
  }
}
Lk.prototype.is = function(o, n) {
  return n ? n === this.name && (o === "rootElement" || o === "view:rootElement" || o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element") : o === "rootElement" || o === "view:rootElement" || o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
};
let Ki = class {
  constructor(o = {}) {
    m(this, "direction");
    m(this, "boundaries");
    m(this, "singleCharacters");
    m(this, "shallow");
    m(this, "ignoreElementEnd");
    m(this, "_position");
    m(this, "_boundaryStartParent");
    m(this, "_boundaryEndParent");
    if (!o.boundaries && !o.startPosition) throw new v("view-tree-walker-no-start-position", null);
    if (o.direction && o.direction != "forward" && o.direction != "backward") throw new v("view-tree-walker-unknown-direction", o.startPosition, { direction: o.direction });
    this.boundaries = o.boundaries || null, o.startPosition ? this._position = B._createAt(o.startPosition) : this._position = B._createAt(o.boundaries[o.direction == "backward" ? "end" : "start"]), this.direction = o.direction || "forward", this.singleCharacters = !!o.singleCharacters, this.shallow = !!o.shallow, this.ignoreElementEnd = !!o.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
  }
  [Symbol.iterator]() {
    return this;
  }
  get position() {
    return this._position;
  }
  skip(o) {
    let n, t;
    do
      t = this.position, n = this.next();
    while (!n.done && o(n.value));
    n.done || (this._position = t);
  }
  jumpTo(o) {
    this._boundaryStartParent && o.isBefore(this.boundaries.start) ? o = this.boundaries.start : this._boundaryEndParent && o.isAfter(this.boundaries.end) && (o = this.boundaries.end), this._position = o.clone();
  }
  next() {
    return this.direction == "forward" ? this._next() : this._previous();
  }
  _next() {
    let o = this.position.clone();
    const n = this.position, t = o.parent;
    if (t.parent === null && o.offset === t.childCount) return { done: !0, value: void 0 };
    if (t === this._boundaryEndParent && o.offset == this.boundaries.end.offset) return { done: !0, value: void 0 };
    let e;
    if (t && t.is("view:$text")) {
      if (o.isAtEnd) return this._position = B._createAfter(t), this._next();
      e = t.data[o.offset];
    } else e = t.getChild(o.offset);
    if (typeof e == "string") {
      let i;
      this.singleCharacters ? i = 1 : i = (t === this._boundaryEndParent ? this.boundaries.end.offset : t.data.length) - o.offset;
      const r = new Kn(t, o.offset, i);
      return o.offset += i, this._position = o, this._formatReturnValue("text", r, n, o, i);
    }
    if (e && e.is("view:element")) {
      if (this.shallow) {
        if (this.boundaries && this.boundaries.end.isBefore(o)) return { done: !0, value: void 0 };
        o.offset++;
      } else o = new B(e, 0);
      return this._position = o, this._formatReturnValue("elementStart", e, n, o, 1);
    }
    if (e && e.is("view:$text")) {
      if (this.singleCharacters) return o = new B(e, 0), this._position = o, this._next();
      let i, r = e.data.length;
      return e == this._boundaryEndParent ? (r = this.boundaries.end.offset, i = new Kn(e, 0, r), o = B._createAfter(i)) : (i = new Kn(e, 0, e.data.length), o.offset++), this._position = o, this._formatReturnValue("text", i, n, o, r);
    }
    return o = B._createAfter(t), this._position = o, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", t, n, o);
  }
  _previous() {
    let o = this.position.clone();
    const n = this.position, t = o.parent;
    if (t.parent === null && o.offset === 0) return { done: !0, value: void 0 };
    if (t == this._boundaryStartParent && o.offset == this.boundaries.start.offset) return { done: !0, value: void 0 };
    let e;
    if (t.is("view:$text")) {
      if (o.isAtStart) return this._position = B._createBefore(t), this._previous();
      e = t.data[o.offset - 1];
    } else e = t.getChild(o.offset - 1);
    if (typeof e == "string") {
      let i;
      if (this.singleCharacters) i = 1;
      else {
        const s = t === this._boundaryStartParent ? this.boundaries.start.offset : 0;
        i = o.offset - s;
      }
      o.offset -= i;
      const r = new Kn(t, o.offset, i);
      return this._position = o, this._formatReturnValue("text", r, n, o, i);
    }
    if (e && e.is("view:element")) return this.shallow ? (o.offset--, this._position = o, this._formatReturnValue("elementStart", e, n, o, 1)) : (o = new B(e, e.childCount), this._position = o, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", e, n, o));
    if (e && e.is("view:$text")) {
      if (this.singleCharacters) return o = new B(e, e.data.length), this._position = o, this._previous();
      let i, r = e.data.length;
      if (e == this._boundaryStartParent) {
        const s = this.boundaries.start.offset;
        i = new Kn(e, s, e.data.length - s), r = i.data.length, o = B._createBefore(i);
      } else i = new Kn(e, 0, e.data.length), o.offset--;
      return this._position = o, this._formatReturnValue("text", i, n, o, r);
    }
    return o = B._createBefore(t), this._position = o, this._formatReturnValue("elementStart", t, n, o, 1);
  }
  _formatReturnValue(o, n, t, e, i) {
    return n.is("view:$textProxy") && (n.offsetInText + n.data.length == n.textNode.data.length && (this.direction != "forward" || this.boundaries && this.boundaries.end.isEqual(this.position) ? t = B._createAfter(n.textNode) : (e = B._createAfter(n.textNode), this._position = e)), n.offsetInText === 0 && (this.direction != "backward" || this.boundaries && this.boundaries.start.isEqual(this.position) ? t = B._createBefore(n.textNode) : (e = B._createBefore(n.textNode), this._position = e))), { done: !1, value: { type: o, item: n, previousPosition: t, nextPosition: e, length: i } };
  }
}, B = class Wn extends so {
  constructor(t, e) {
    super();
    m(this, "parent");
    m(this, "offset");
    this.parent = t, this.offset = e;
  }
  get nodeAfter() {
    return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null;
  }
  get nodeBefore() {
    return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null;
  }
  get isAtStart() {
    return this.offset === 0;
  }
  get isAtEnd() {
    const t = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
    return this.offset === t;
  }
  get root() {
    return this.parent.root;
  }
  get editableElement() {
    let t = this.parent;
    for (; !(t instanceof sl); ) {
      if (!t.parent) return null;
      t = t.parent;
    }
    return t;
  }
  getShiftedBy(t) {
    const e = Wn._createAt(this), i = e.offset + t;
    return e.offset = i < 0 ? 0 : i, e;
  }
  getLastMatchingPosition(t, e = {}) {
    e.startPosition = this;
    const i = new Ki(e);
    return i.skip(t), i.position;
  }
  getAncestors() {
    return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({ includeSelf: !0 });
  }
  getCommonAncestor(t) {
    const e = this.getAncestors(), i = t.getAncestors();
    let r = 0;
    for (; e[r] == i[r] && e[r]; ) r++;
    return r === 0 ? null : e[r - 1];
  }
  isEqual(t) {
    return this.parent == t.parent && this.offset == t.offset;
  }
  isBefore(t) {
    return this.compareWith(t) == "before";
  }
  isAfter(t) {
    return this.compareWith(t) == "after";
  }
  compareWith(t) {
    if (this.root !== t.root) return "different";
    if (this.isEqual(t)) return "same";
    const e = this.parent.is("node") ? this.parent.getPath() : [], i = t.parent.is("node") ? t.parent.getPath() : [];
    e.push(this.offset), i.push(t.offset);
    const r = xe(e, i);
    switch (r) {
      case "prefix":
        return "before";
      case "extension":
        return "after";
      default:
        return e[r] < i[r] ? "before" : "after";
    }
  }
  getWalker(t = {}) {
    return t.startPosition = this, new Ki(t);
  }
  clone() {
    return new Wn(this.parent, this.offset);
  }
  static _createAt(t, e) {
    if (t instanceof Wn) return new this(t.parent, t.offset);
    {
      const i = t;
      if (e == "end") e = i.is("$text") ? i.data.length : i.childCount;
      else {
        if (e == "before") return this._createBefore(i);
        if (e == "after") return this._createAfter(i);
        if (e !== 0 && !e) throw new v("view-createpositionat-offset-required", i);
      }
      return new Wn(i, e);
    }
  }
  static _createAfter(t) {
    if (t.is("$textProxy")) return new Wn(t.textNode, t.offsetInText + t.data.length);
    if (!t.parent) throw new v("view-position-after-root", t, { root: t });
    return new Wn(t.parent, t.index + 1);
  }
  static _createBefore(t) {
    if (t.is("$textProxy")) return new Wn(t.textNode, t.offsetInText);
    if (!t.parent) throw new v("view-position-before-root", t, { root: t });
    return new Wn(t.parent, t.index);
  }
};
B.prototype.is = function(o) {
  return o === "position" || o === "view:position";
};
let st = class pi extends so {
  constructor(t, e = null) {
    super();
    m(this, "start");
    m(this, "end");
    this.start = t.clone(), this.end = e ? e.clone() : t.clone();
  }
  *[Symbol.iterator]() {
    yield* new Ki({ boundaries: this, ignoreElementEnd: !0 });
  }
  get isCollapsed() {
    return this.start.isEqual(this.end);
  }
  get isFlat() {
    return this.start.parent === this.end.parent;
  }
  get root() {
    return this.start.root;
  }
  getEnlarged() {
    let t = this.start.getLastMatchingPosition(Ps, { direction: "backward" }), e = this.end.getLastMatchingPosition(Ps);
    return t.parent.is("$text") && t.isAtStart && (t = B._createBefore(t.parent)), e.parent.is("$text") && e.isAtEnd && (e = B._createAfter(e.parent)), new pi(t, e);
  }
  getTrimmed() {
    let t = this.start.getLastMatchingPosition(Ps);
    if (t.isAfter(this.end) || t.isEqual(this.end)) return new pi(t, t);
    let e = this.end.getLastMatchingPosition(Ps, { direction: "backward" });
    const i = t.nodeAfter, r = e.nodeBefore;
    return i && i.is("$text") && (t = new B(i, 0)), r && r.is("$text") && (e = new B(r, r.data.length)), new pi(t, e);
  }
  isEqual(t) {
    return this == t || this.start.isEqual(t.start) && this.end.isEqual(t.end);
  }
  containsPosition(t) {
    return t.isAfter(this.start) && t.isBefore(this.end);
  }
  containsRange(t, e = !1) {
    t.isCollapsed && (e = !1);
    const i = this.containsPosition(t.start) || e && this.start.isEqual(t.start), r = this.containsPosition(t.end) || e && this.end.isEqual(t.end);
    return i && r;
  }
  getDifference(t) {
    const e = [];
    return this.isIntersecting(t) ? (this.containsPosition(t.start) && e.push(new pi(this.start, t.start)), this.containsPosition(t.end) && e.push(new pi(t.end, this.end))) : e.push(this.clone()), e;
  }
  getIntersection(t) {
    if (this.isIntersecting(t)) {
      let e = this.start, i = this.end;
      return this.containsPosition(t.start) && (e = t.start), this.containsPosition(t.end) && (i = t.end), new pi(e, i);
    }
    return null;
  }
  getWalker(t = {}) {
    return t.boundaries = this, new Ki(t);
  }
  getCommonAncestor() {
    return this.start.getCommonAncestor(this.end);
  }
  getContainedElement() {
    if (this.isCollapsed) return null;
    let t = this.start.nodeAfter, e = this.end.nodeBefore;
    return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (t = this.start.parent.nextSibling), this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (e = this.end.parent.previousSibling), t && t.is("element") && t === e ? t : null;
  }
  clone() {
    return new pi(this.start, this.end);
  }
  *getItems(t = {}) {
    t.boundaries = this, t.ignoreElementEnd = !0;
    const e = new Ki(t);
    for (const i of e) yield i.item;
  }
  *getPositions(t = {}) {
    t.boundaries = this;
    const e = new Ki(t);
    yield e.position;
    for (const i of e) yield i.nextPosition;
  }
  isIntersecting(t) {
    return this.start.isBefore(t.end) && this.end.isAfter(t.start);
  }
  static _createFromParentsAndOffsets(t, e, i, r) {
    return new this(new B(t, e), new B(i, r));
  }
  static _createFromPositionAndShift(t, e) {
    const i = t, r = t.getShiftedBy(e);
    return e > 0 ? new this(i, r) : new this(r, i);
  }
  static _createIn(t) {
    return this._createFromParentsAndOffsets(t, 0, t, t.childCount);
  }
  static _createOn(t) {
    const e = t.is("$textProxy") ? t.offsetSize : 1;
    return this._createFromPositionAndShift(B._createBefore(t), e);
  }
};
function Ps(o) {
  return !(!o.item.is("attributeElement") && !o.item.is("uiElement"));
}
st.prototype.is = function(o) {
  return o === "range" || o === "view:range";
};
let ei = class Bk extends vt(so) {
  constructor(...t) {
    super();
    m(this, "_ranges");
    m(this, "_lastRangeBackward");
    m(this, "_isFake");
    m(this, "_fakeSelectionLabel");
    this._ranges = [], this._lastRangeBackward = !1, this._isFake = !1, this._fakeSelectionLabel = "", t.length && this.setTo(...t);
  }
  get isFake() {
    return this._isFake;
  }
  get fakeSelectionLabel() {
    return this._fakeSelectionLabel;
  }
  get anchor() {
    if (!this._ranges.length) return null;
    const t = this._ranges[this._ranges.length - 1];
    return (this._lastRangeBackward ? t.end : t.start).clone();
  }
  get focus() {
    if (!this._ranges.length) return null;
    const t = this._ranges[this._ranges.length - 1];
    return (this._lastRangeBackward ? t.start : t.end).clone();
  }
  get isCollapsed() {
    return this.rangeCount === 1 && this._ranges[0].isCollapsed;
  }
  get rangeCount() {
    return this._ranges.length;
  }
  get isBackward() {
    return !this.isCollapsed && this._lastRangeBackward;
  }
  get editableElement() {
    return this.anchor ? this.anchor.editableElement : null;
  }
  *getRanges() {
    for (const t of this._ranges) yield t.clone();
  }
  getFirstRange() {
    let t = null;
    for (const e of this._ranges) t && !e.start.isBefore(t.start) || (t = e);
    return t ? t.clone() : null;
  }
  getLastRange() {
    let t = null;
    for (const e of this._ranges) t && !e.end.isAfter(t.end) || (t = e);
    return t ? t.clone() : null;
  }
  getFirstPosition() {
    const t = this.getFirstRange();
    return t ? t.start.clone() : null;
  }
  getLastPosition() {
    const t = this.getLastRange();
    return t ? t.end.clone() : null;
  }
  isEqual(t) {
    if (this.isFake != t.isFake || this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel || this.rangeCount != t.rangeCount) return !1;
    if (this.rangeCount === 0) return !0;
    if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) return !1;
    for (const e of this._ranges) {
      let i = !1;
      for (const r of t._ranges) if (e.isEqual(r)) {
        i = !0;
        break;
      }
      if (!i) return !1;
    }
    return !0;
  }
  isSimilar(t) {
    if (this.isBackward != t.isBackward) return !1;
    const e = qc(this.getRanges());
    if (e != qc(t.getRanges())) return !1;
    if (e == 0) return !0;
    for (let i of this.getRanges()) {
      i = i.getTrimmed();
      let r = !1;
      for (let s of t.getRanges()) if (s = s.getTrimmed(), i.start.isEqual(s.start) && i.end.isEqual(s.end)) {
        r = !0;
        break;
      }
      if (!r) return !1;
    }
    return !0;
  }
  getSelectedElement() {
    return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
  }
  setTo(...t) {
    let [e, i, r] = t;
    if (typeof i == "object" && (r = i, i = void 0), e === null) this._setRanges([]), this._setFakeOptions(r);
    else if (e instanceof Bk || e instanceof hu) this._setRanges(e.getRanges(), e.isBackward), this._setFakeOptions({ fake: e.isFake, label: e.fakeSelectionLabel });
    else if (e instanceof st) this._setRanges([e], r && r.backward), this._setFakeOptions(r);
    else if (e instanceof B) this._setRanges([new st(e)]), this._setFakeOptions(r);
    else if (e instanceof ao) {
      const s = !!r && !!r.backward;
      let a;
      if (i === void 0) throw new v("view-selection-setto-required-second-parameter", this);
      a = i == "in" ? st._createIn(e) : i == "on" ? st._createOn(e) : new st(B._createAt(e, i)), this._setRanges([a], s), this._setFakeOptions(r);
    } else {
      if (!Ye(e)) throw new v("view-selection-setto-not-selectable", this);
      this._setRanges(e, r && r.backward), this._setFakeOptions(r);
    }
    this.fire("change");
  }
  setFocus(t, e) {
    if (this.anchor === null) throw new v("view-selection-setfocus-no-ranges", this);
    const i = B._createAt(t, e);
    if (i.compareWith(this.focus) == "same") return;
    const r = this.anchor;
    this._ranges.pop(), i.compareWith(r) == "before" ? this._addRange(new st(i, r), !0) : this._addRange(new st(r, i)), this.fire("change");
  }
  _setRanges(t, e = !1) {
    t = Array.from(t), this._ranges = [];
    for (const i of t) this._addRange(i);
    this._lastRangeBackward = !!e;
  }
  _setFakeOptions(t = {}) {
    this._isFake = !!t.fake, this._fakeSelectionLabel = t.fake && t.label || "";
  }
  _addRange(t, e = !1) {
    if (!(t instanceof st)) throw new v("view-selection-add-range-not-range", this);
    this._pushRange(t), this._lastRangeBackward = !!e;
  }
  _pushRange(t) {
    for (const e of this._ranges) if (t.isIntersecting(e)) throw new v("view-selection-range-intersects", this, { addedRange: t, intersectingRange: e });
    this._ranges.push(new st(t.start, t.end));
  }
};
ei.prototype.is = function(o) {
  return o === "selection" || o === "view:selection";
};
let hu = class extends vt(so) {
  constructor(...n) {
    super();
    m(this, "_selection");
    this._selection = new ei(), this._selection.delegate("change").to(this), n.length && this._selection.setTo(...n);
  }
  get isFake() {
    return this._selection.isFake;
  }
  get fakeSelectionLabel() {
    return this._selection.fakeSelectionLabel;
  }
  get anchor() {
    return this._selection.anchor;
  }
  get focus() {
    return this._selection.focus;
  }
  get isCollapsed() {
    return this._selection.isCollapsed;
  }
  get rangeCount() {
    return this._selection.rangeCount;
  }
  get isBackward() {
    return this._selection.isBackward;
  }
  get editableElement() {
    return this._selection.editableElement;
  }
  get _ranges() {
    return this._selection._ranges;
  }
  *getRanges() {
    yield* this._selection.getRanges();
  }
  getFirstRange() {
    return this._selection.getFirstRange();
  }
  getLastRange() {
    return this._selection.getLastRange();
  }
  getFirstPosition() {
    return this._selection.getFirstPosition();
  }
  getLastPosition() {
    return this._selection.getLastPosition();
  }
  getSelectedElement() {
    return this._selection.getSelectedElement();
  }
  isEqual(n) {
    return this._selection.isEqual(n);
  }
  isSimilar(n) {
    return this._selection.isSimilar(n);
  }
  _setTo(...n) {
    this._selection.setTo(...n);
  }
  _setFocus(n, t) {
    this._selection.setFocus(n, t);
  }
};
hu.prototype.is = function(o) {
  return o === "selection" || o == "documentSelection" || o == "view:selection" || o == "view:documentSelection";
};
class Jo extends oi {
  constructor(t, e, i) {
    super(t, e);
    m(this, "startRange");
    m(this, "_eventPhase");
    m(this, "_currentTarget");
    this.startRange = i, this._eventPhase = "none", this._currentTarget = null;
  }
  get eventPhase() {
    return this._eventPhase;
  }
  get currentTarget() {
    return this._currentTarget;
  }
}
const Ll = Symbol("bubbling contexts");
function Zc(o) {
  return class extends o {
    fire(n, ...t) {
      try {
        const e = n instanceof oi ? n : new oi(this, n), i = Bl(this);
        if (!i.size) return;
        if (mr(e, "capturing", this), _o(i, "$capture", e, ...t)) return e.return;
        const r = e.startRange || this.selection.getFirstRange(), s = r ? r.getContainedElement() : null, a = !!s && !!Nk(i, s);
        let l = s || function(c) {
          if (!c) return null;
          const d = c.start.parent, u = c.end.parent, h = d.getPath(), g = u.getPath();
          return h.length > g.length ? d : u;
        }(r);
        if (mr(e, "atTarget", l), !a) {
          if (_o(i, "$text", e, ...t)) return e.return;
          mr(e, "bubbling", l);
        }
        for (; l; ) {
          if (l.is("rootElement")) {
            if (_o(i, "$root", e, ...t)) return e.return;
          } else if (l.is("element") && _o(i, l.name, e, ...t)) return e.return;
          if (_o(i, l, e, ...t)) return e.return;
          l = l.parent, mr(e, "bubbling", l);
        }
        return mr(e, "bubbling", this), _o(i, "$document", e, ...t), e.return;
      } catch (e) {
        v.rethrowUnexpectedError(e, this);
      }
    }
    _addEventListener(n, t, e) {
      const i = Bt(e.context || "$document"), r = Bl(this);
      for (const s of i) {
        let a = r.get(s);
        a || (a = new (vt())(), r.set(s, a)), this.listenTo(a, n, t, e);
      }
    }
    _removeEventListener(n, t) {
      const e = Bl(this);
      for (const i of e.values()) this.stopListening(i, n, t);
    }
  };
}
{
  const o = Zc(Object);
  ["fire", "_addEventListener", "_removeEventListener"].forEach((n) => {
    Zc[n] = o.prototype[n];
  });
}
function mr(o, n, t) {
  o instanceof Jo && (o._eventPhase = n, o._currentTarget = t);
}
function _o(o, n, t, ...e) {
  const i = typeof n == "string" ? o.get(n) : Nk(o, n);
  return !!i && (i.fire(t, ...e), t.stop.called);
}
function Nk(o, n) {
  for (const [t, e] of o) if (typeof t == "function" && t(n)) return e;
  return null;
}
function Bl(o) {
  return o[Ll] || (o[Ll] = /* @__PURE__ */ new Map()), o[Ll];
}
let al = class extends Zc(_t()) {
  constructor(n) {
    super();
    m(this, "selection");
    m(this, "roots");
    m(this, "stylesProcessor");
    m(this, "_postFixers", /* @__PURE__ */ new Set());
    this.selection = new hu(), this.roots = new ne({ idProperty: "rootName" }), this.stylesProcessor = n, this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("isSelecting", !1), this.set("isComposing", !1);
  }
  getRoot(n = "main") {
    return this.roots.get(n);
  }
  registerPostFixer(n) {
    this._postFixers.add(n);
  }
  destroy() {
    this.roots.forEach((n) => n.destroy()), this.stopListening();
  }
  _callPostFixers(n) {
    let t = !1;
    do
      for (const e of this._postFixers) if (t = e(n), t) break;
    while (t);
  }
};
class Qi extends si {
  constructor(t, e, i, r) {
    super(t, e, i, r);
    m(this, "_priority", 10);
    m(this, "_id", null);
    m(this, "_clonesGroup", null);
    this.getFillerOffset = FC;
  }
  get priority() {
    return this._priority;
  }
  get id() {
    return this._id;
  }
  getElementsWithSameId() {
    if (this.id === null) throw new v("attribute-element-get-elements-with-same-id-no-id", this);
    return new Set(this._clonesGroup);
  }
  isSimilar(t) {
    return this.id !== null || t.id !== null ? this.id === t.id : super.isSimilar(t) && this.priority == t.priority;
  }
  _clone(t = !1) {
    const e = super._clone(t);
    return e._priority = this._priority, e._id = this._id, e;
  }
  _canMergeAttributesFrom(t) {
    return this.id === null && t.id === null && this.priority === t.priority && super._canMergeAttributesFrom(t);
  }
  _canSubtractAttributesOf(t) {
    return this.id === null && t.id === null && this.priority === t.priority && super._canSubtractAttributesOf(t);
  }
}
m(Qi, "DEFAULT_PRIORITY", 10);
function FC() {
  if (Nl(this)) return null;
  let o = this.parent;
  for (; o && o.is("attributeElement"); ) {
    if (Nl(o) > 1) return null;
    o = o.parent;
  }
  return !o || Nl(o) > 1 ? null : this.childCount;
}
function Nl(o) {
  return Array.from(o.getChildren()).filter((n) => !n.is("uiElement")).length;
}
Qi.prototype.is = function(o, n) {
  return n ? n === this.name && (o === "attributeElement" || o === "view:attributeElement" || o === "element" || o === "view:element") : o === "attributeElement" || o === "view:attributeElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
};
class mu extends si {
  constructor(n, t, e, i) {
    super(n, t, e, i), this.getFillerOffset = jC;
  }
  _insertChild(n, t) {
    if (t && (t instanceof ao || Array.from(t).length > 0)) throw new v("view-emptyelement-cannot-add", [this, t]);
    return 0;
  }
}
function jC() {
  return null;
}
mu.prototype.is = function(o, n) {
  return n ? n === this.name && (o === "emptyElement" || o === "view:emptyElement" || o === "element" || o === "view:element") : o === "emptyElement" || o === "view:emptyElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
};
class ll extends si {
  constructor(n, t, e, i) {
    super(n, t, e, i), this.getFillerOffset = UC;
  }
  _insertChild(n, t) {
    if (t && (t instanceof ao || Array.from(t).length > 0)) throw new v("view-uielement-cannot-add", [this, t]);
    return 0;
  }
  render(n, t) {
    return this.toDomElement(n);
  }
  toDomElement(n) {
    const t = n.createElement(this.name);
    for (const e of this.getAttributeKeys()) t.setAttribute(e, this.getAttribute(e));
    return t;
  }
}
function HC(o) {
  o.document.on("arrowKey", (n, t) => function(e, i, r) {
    if (i.keyCode == nt.arrowright) {
      const s = i.domTarget.ownerDocument.defaultView.getSelection(), a = s.rangeCount == 1 && s.getRangeAt(0).collapsed;
      if (a || i.shiftKey) {
        const l = s.focusNode, c = s.focusOffset, d = r.domPositionToView(l, c);
        if (d === null) return;
        let u = !1;
        const h = d.getLastMatchingPosition((g) => (g.item.is("uiElement") && (u = !0), !(!g.item.is("uiElement") && !g.item.is("attributeElement"))));
        if (u) {
          const g = r.viewPositionToDom(h);
          a ? s.collapse(g.parent, g.offset) : s.extend(g.parent, g.offset);
        }
      }
    }
  }(0, t, o.domConverter), { priority: "low" });
}
function UC() {
  return null;
}
ll.prototype.is = function(o, n) {
  return n ? n === this.name && (o === "uiElement" || o === "view:uiElement" || o === "element" || o === "view:element") : o === "uiElement" || o === "view:uiElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
};
class gu extends si {
  constructor(n, t, e, i) {
    super(n, t, e, i), this.getFillerOffset = $C;
  }
  _insertChild(n, t) {
    if (t && (t instanceof ao || Array.from(t).length > 0)) throw new v("view-rawelement-cannot-add", [this, t]);
    return 0;
  }
  render(n, t) {
  }
}
function $C() {
  return null;
}
gu.prototype.is = function(o, n) {
  return n ? n === this.name && (o === "rawElement" || o === "view:rawElement" || o === "element" || o === "view:element") : o === "rawElement" || o === "view:rawElement" || o === this.name || o === "view:" + this.name || o === "element" || o === "view:element" || o === "node" || o === "view:node";
};
let Ji = class extends vt(so) {
  constructor(n, t) {
    super();
    m(this, "document");
    m(this, "_children", []);
    m(this, "_customProperties", /* @__PURE__ */ new Map());
    this.document = n, t && this._insertChild(0, t);
  }
  [Symbol.iterator]() {
    return this._children[Symbol.iterator]();
  }
  get childCount() {
    return this._children.length;
  }
  get isEmpty() {
    return this.childCount === 0;
  }
  get root() {
    return this;
  }
  get parent() {
    return null;
  }
  get name() {
  }
  get getFillerOffset() {
  }
  getCustomProperty(n) {
    return this._customProperties.get(n);
  }
  *getCustomProperties() {
    yield* this._customProperties.entries();
  }
  _appendChild(n) {
    return this._insertChild(this.childCount, n);
  }
  getChild(n) {
    return this._children[n];
  }
  getChildIndex(n) {
    return this._children.indexOf(n);
  }
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  _insertChild(n, t) {
    this._fireChange("children", this, { index: n });
    let e = 0;
    const i = function(r, s) {
      return typeof s == "string" ? [new we(r, s)] : (Ye(s) || (s = [s]), Array.from(s).map((a) => typeof a == "string" ? new we(r, a) : a instanceof Kn ? new we(r, a.data) : a));
    }(this.document, t);
    for (const r of i) r.parent !== null && r._remove(), r.parent = this, this._children.splice(n, 0, r), n++, e++;
    return e;
  }
  _removeChildren(n, t = 1) {
    this._fireChange("children", this, { index: n });
    for (let e = n; e < n + t; e++) this._children[e].parent = null;
    return this._children.splice(n, t);
  }
  _fireChange(n, t, e) {
    this.fire(`change:${n}`, t, e);
  }
  _setCustomProperty(n, t) {
    this._customProperties.set(n, t);
  }
  _removeCustomProperty(n) {
    return this._customProperties.delete(n);
  }
};
Ji.prototype.is = function(o) {
  return o === "documentFragment" || o === "view:documentFragment";
};
class fu {
  constructor(n) {
    m(this, "document");
    m(this, "_cloneGroups", /* @__PURE__ */ new Map());
    m(this, "_slotFactory", null);
    this.document = n;
  }
  setSelection(...n) {
    this.document.selection._setTo(...n);
  }
  setSelectionFocus(n, t) {
    this.document.selection._setFocus(n, t);
  }
  createDocumentFragment(n) {
    return new Ji(this.document, n);
  }
  createText(n) {
    return new we(this.document, n);
  }
  createAttributeElement(n, t, e = {}) {
    const i = new Qi(this.document, n, t);
    return typeof e.priority == "number" && (i._priority = e.priority), e.id && (i._id = e.id), e.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...e.renderUnsafeAttributes), i;
  }
  createContainerElement(n, t, e = {}, i = {}) {
    let r = null;
    In(e) ? i = e : r = e;
    const s = new ts(this.document, n, t, r);
    return i.renderUnsafeAttributes && s._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), s;
  }
  createEditableElement(n, t, e = {}) {
    const i = new sl(this.document, n, t);
    return e.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...e.renderUnsafeAttributes), i;
  }
  createEmptyElement(n, t, e = {}) {
    const i = new mu(this.document, n, t);
    return e.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...e.renderUnsafeAttributes), i;
  }
  createUIElement(n, t, e) {
    const i = new ll(this.document, n, t);
    return e && (i.render = e), i;
  }
  createRawElement(n, t, e, i = {}) {
    const r = new gu(this.document, n, t);
    return e && (r.render = e), i.renderUnsafeAttributes && r._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), r;
  }
  setAttribute(n, t, e, i) {
    i !== void 0 ? i._setAttribute(n, t, e) : e._setAttribute(n, t);
  }
  removeAttribute(n, t, e) {
    e !== void 0 ? e._removeAttribute(n, t) : t._removeAttribute(n);
  }
  addClass(n, t) {
    t._addClass(n);
  }
  removeClass(n, t) {
    t._removeClass(n);
  }
  setStyle(n, t, e) {
    In(n) && e === void 0 ? t._setStyle(n) : e._setStyle(n, t);
  }
  removeStyle(n, t) {
    t._removeStyle(n);
  }
  setCustomProperty(n, t, e) {
    e._setCustomProperty(n, t);
  }
  removeCustomProperty(n, t) {
    return t._removeCustomProperty(n);
  }
  breakAttributes(n) {
    return n instanceof B ? this._breakAttributes(n) : this._breakAttributesRange(n);
  }
  breakContainer(n) {
    const t = n.parent;
    if (!t.is("containerElement")) throw new v("view-writer-break-non-container-element", this.document);
    if (!t.parent) throw new v("view-writer-break-root", this.document);
    if (n.isAtStart) return B._createBefore(t);
    if (!n.isAtEnd) {
      const e = t._clone(!1);
      this.insert(B._createAfter(t), e);
      const i = new st(n, B._createAt(t, "end")), r = new B(e, 0);
      this.move(i, r);
    }
    return B._createAfter(t);
  }
  mergeAttributes(n) {
    const t = n.offset, e = n.parent;
    if (e.is("$text")) return n;
    if (e.is("attributeElement") && e.childCount === 0) {
      const s = e.parent, a = e.index;
      return e._remove(), this._removeFromClonedElementsGroup(e), this.mergeAttributes(new B(s, a));
    }
    const i = e.getChild(t - 1), r = e.getChild(t);
    if (!i || !r) return n;
    if (i.is("$text") && r.is("$text")) return Fh(i, r);
    if (i.is("attributeElement") && r.is("attributeElement") && i.isSimilar(r)) {
      const s = i.childCount;
      return i._appendChild(r.getChildren()), r._remove(), this._removeFromClonedElementsGroup(r), this.mergeAttributes(new B(i, s));
    }
    return n;
  }
  mergeContainers(n) {
    const t = n.nodeBefore, e = n.nodeAfter;
    if (!(t && e && t.is("containerElement") && e.is("containerElement"))) throw new v("view-writer-merge-containers-invalid-position", this.document);
    const i = t.getChild(t.childCount - 1), r = i instanceof we ? B._createAt(i, "end") : B._createAt(t, "end");
    return this.move(st._createIn(e), B._createAt(t, "end")), this.remove(st._createOn(e)), r;
  }
  insert(n, t) {
    zk(t = Ye(t) ? [...t] : [t], this.document);
    const e = t.reduce((s, a) => {
      const l = s[s.length - 1], c = !a.is("uiElement");
      return l && l.breakAttributes == c ? l.nodes.push(a) : s.push({ breakAttributes: c, nodes: [a] }), s;
    }, []);
    let i = null, r = n;
    for (const { nodes: s, breakAttributes: a } of e) {
      const l = this._insertNodes(r, s, a);
      i || (i = l.start), r = l.end;
    }
    return i ? new st(i, r) : new st(n);
  }
  remove(n) {
    const t = n instanceof st ? n : st._createOn(n);
    if (gr(t, this.document), t.isCollapsed) return new Ji(this.document);
    const { start: e, end: i } = this._breakAttributesRange(t, !0), r = e.parent, s = i.offset - e.offset, a = r._removeChildren(e.offset, s);
    for (const c of a) this._removeFromClonedElementsGroup(c);
    const l = this.mergeAttributes(e);
    return t.start = l, t.end = l.clone(), new Ji(this.document, a);
  }
  clear(n, t) {
    gr(n, this.document);
    const e = n.getWalker({ direction: "backward", ignoreElementEnd: !0 });
    for (const i of e) {
      const r = i.item;
      let s;
      if (r.is("element") && t.isSimilar(r)) s = st._createOn(r);
      else if (!i.nextPosition.isAfter(n.start) && r.is("$textProxy")) {
        const a = r.getAncestors().find((l) => l.is("element") && t.isSimilar(l));
        a && (s = st._createIn(a));
      }
      s && (s.end.isAfter(n.end) && (s.end = n.end), s.start.isBefore(n.start) && (s.start = n.start), this.remove(s));
    }
  }
  move(n, t) {
    let e;
    if (t.isAfter(n.end)) {
      const i = (t = this._breakAttributes(t, !0)).parent, r = i.childCount;
      n = this._breakAttributesRange(n, !0), e = this.remove(n), t.offset += i.childCount - r;
    } else e = this.remove(n);
    return this.insert(t, e);
  }
  wrap(n, t) {
    if (!(t instanceof Qi)) throw new v("view-writer-wrap-invalid-attribute", this.document);
    if (gr(n, this.document), n.isCollapsed) {
      let i = n.start;
      i.parent.is("element") && (e = i.parent, !Array.from(e.getChildren()).some((s) => !s.is("uiElement"))) && (i = i.getLastMatchingPosition((s) => s.item.is("uiElement"))), i = this._wrapPosition(i, t);
      const r = this.document.selection;
      return r.isCollapsed && r.getFirstPosition().isEqual(n.start) && this.setSelection(i), new st(i);
    }
    return this._wrapRange(n, t);
    var e;
  }
  unwrap(n, t) {
    if (!(t instanceof Qi)) throw new v("view-writer-unwrap-invalid-attribute", this.document);
    if (gr(n, this.document), n.isCollapsed) return n;
    const { start: e, end: i } = this._breakAttributesRange(n, !0), r = e.parent, s = this._unwrapChildren(r, e.offset, i.offset, t), a = this.mergeAttributes(s.start);
    a.isEqual(s.start) || s.end.offset--;
    const l = this.mergeAttributes(s.end);
    return new st(a, l);
  }
  rename(n, t) {
    const e = new ts(this.document, n, t.getAttributes());
    return this.insert(B._createAfter(t), e), this.move(st._createIn(t), B._createAt(e, 0)), this.remove(st._createOn(t)), e;
  }
  clearClonedElementsGroup(n) {
    this._cloneGroups.delete(n);
  }
  createPositionAt(n, t) {
    return B._createAt(n, t);
  }
  createPositionAfter(n) {
    return B._createAfter(n);
  }
  createPositionBefore(n) {
    return B._createBefore(n);
  }
  createRange(n, t) {
    return new st(n, t);
  }
  createRangeOn(n) {
    return st._createOn(n);
  }
  createRangeIn(n) {
    return st._createIn(n);
  }
  createSelection(...n) {
    return new ei(...n);
  }
  createSlot(n = "children") {
    if (!this._slotFactory) throw new v("view-writer-invalid-create-slot-context", this.document);
    return this._slotFactory(this, n);
  }
  _registerSlotFactory(n) {
    this._slotFactory = n;
  }
  _clearSlotFactory() {
    this._slotFactory = null;
  }
  _insertNodes(n, t, e) {
    let i, r;
    if (i = e ? Qc(n) : n.parent.is("$text") ? n.parent.parent : n.parent, !i) throw new v("view-writer-invalid-position-container", this.document);
    r = e ? this._breakAttributes(n, !0) : n.parent.is("$text") ? zl(n) : n;
    const s = i._insertChild(r.offset, t);
    for (const d of t) this._addToClonedElementsGroup(d);
    const a = r.getShiftedBy(s), l = this.mergeAttributes(r);
    l.isEqual(r) || a.offset--;
    const c = this.mergeAttributes(a);
    return new st(l, c);
  }
  _wrapChildren(n, t, e, i) {
    let r = t;
    const s = [];
    for (; r < e; ) {
      const l = n.getChild(r), c = l.is("$text"), d = l.is("attributeElement");
      if (d && l._canMergeAttributesFrom(i)) l._mergeAttributesFrom(i), s.push(new B(n, r));
      else if (c || !d || qC(i, l)) {
        const u = i._clone();
        l._remove(), u._appendChild(l), n._insertChild(r, u), this._addToClonedElementsGroup(u), s.push(new B(n, r));
      } else this._wrapChildren(l, 0, l.childCount, i);
      r++;
    }
    let a = 0;
    for (const l of s)
      l.offset -= a, l.offset != t && (this.mergeAttributes(l).isEqual(l) || (a++, e--));
    return st._createFromParentsAndOffsets(n, t, n, e);
  }
  _unwrapChildren(n, t, e, i) {
    let r = t;
    const s = [];
    for (; r < e; ) {
      const l = n.getChild(r);
      if (l.is("attributeElement")) if (l.isSimilar(i)) {
        const c = l.getChildren(), d = l.childCount;
        l._remove(), n._insertChild(r, c), this._removeFromClonedElementsGroup(l), s.push(new B(n, r), new B(n, r + d)), r += d, e += d - 1;
      } else l._canSubtractAttributesOf(i) ? (l._subtractAttributesOf(i), s.push(new B(n, r), new B(n, r + 1)), r++) : (this._unwrapChildren(l, 0, l.childCount, i), r++);
      else r++;
    }
    let a = 0;
    for (const l of s)
      l.offset -= a, !(l.offset == t || l.offset == e) && (this.mergeAttributes(l).isEqual(l) || (a++, e--));
    return st._createFromParentsAndOffsets(n, t, n, e);
  }
  _wrapRange(n, t) {
    const { start: e, end: i } = this._breakAttributesRange(n, !0), r = e.parent, s = this._wrapChildren(r, e.offset, i.offset, t), a = this.mergeAttributes(s.start);
    a.isEqual(s.start) || s.end.offset--;
    const l = this.mergeAttributes(s.end);
    return new st(a, l);
  }
  _wrapPosition(n, t) {
    if (t.isSimilar(n.parent)) return Vh(n.clone());
    n.parent.is("$text") && (n = zl(n));
    const e = this.createAttributeElement("_wrapPosition-fake-element");
    e._priority = Number.POSITIVE_INFINITY, e.isSimilar = () => !1, n.parent._insertChild(n.offset, e);
    const i = new st(n, n.getShiftedBy(1));
    this.wrap(i, t);
    const r = new B(e.parent, e.index);
    e._remove();
    const s = r.nodeBefore, a = r.nodeAfter;
    return s && s.is("view:$text") && a && a.is("view:$text") ? Fh(s, a) : Vh(r);
  }
  _breakAttributesRange(n, t = !1) {
    const e = n.start, i = n.end;
    if (gr(n, this.document), n.isCollapsed) {
      const l = this._breakAttributes(n.start, t);
      return new st(l, l);
    }
    const r = this._breakAttributes(i, t), s = r.parent.childCount, a = this._breakAttributes(e, t);
    return r.offset += r.parent.childCount - s, new st(a, r);
  }
  _breakAttributes(n, t = !1) {
    const e = n.offset, i = n.parent;
    if (n.parent.is("emptyElement")) throw new v("view-writer-cannot-break-empty-element", this.document);
    if (n.parent.is("uiElement")) throw new v("view-writer-cannot-break-ui-element", this.document);
    if (n.parent.is("rawElement")) throw new v("view-writer-cannot-break-raw-element", this.document);
    if (!t && i.is("$text") && Jc(i.parent) || Jc(i)) return n.clone();
    if (i.is("$text")) return this._breakAttributes(zl(n), t);
    if (e == i.childCount) {
      const r = new B(i.parent, i.index + 1);
      return this._breakAttributes(r, t);
    }
    if (e === 0) {
      const r = new B(i.parent, i.index);
      return this._breakAttributes(r, t);
    }
    {
      const r = i.index + 1, s = i._clone();
      i.parent._insertChild(r, s), this._addToClonedElementsGroup(s);
      const a = i.childCount - e, l = i._removeChildren(e, a);
      s._appendChild(l);
      const c = new B(i.parent, r);
      return this._breakAttributes(c, t);
    }
  }
  _addToClonedElementsGroup(n) {
    if (!n.root.is("rootElement")) return;
    if (n.is("element")) for (const i of n.getChildren()) this._addToClonedElementsGroup(i);
    const t = n.id;
    if (!t) return;
    let e = this._cloneGroups.get(t);
    e || (e = /* @__PURE__ */ new Set(), this._cloneGroups.set(t, e)), e.add(n), n._clonesGroup = e;
  }
  _removeFromClonedElementsGroup(n) {
    if (n.is("element")) for (const i of n.getChildren()) this._removeFromClonedElementsGroup(i);
    const t = n.id;
    if (!t) return;
    const e = this._cloneGroups.get(t);
    e && e.delete(n);
  }
}
function Qc(o) {
  let n = o.parent;
  for (; !Jc(n); ) {
    if (!n) return;
    n = n.parent;
  }
  return n;
}
function qC(o, n) {
  return o.priority < n.priority || !(o.priority > n.priority) && o.getIdentity() < n.getIdentity();
}
function Vh(o) {
  const n = o.nodeBefore;
  if (n && n.is("$text")) return new B(n, n.data.length);
  const t = o.nodeAfter;
  return t && t.is("$text") ? new B(t, 0) : o;
}
function zl(o) {
  if (o.offset == o.parent.data.length) return new B(o.parent.parent, o.parent.index + 1);
  if (o.offset === 0) return new B(o.parent.parent, o.parent.index);
  const n = o.parent.data.slice(o.offset);
  return o.parent._data = o.parent.data.slice(0, o.offset), o.parent.parent._insertChild(o.parent.index + 1, new we(o.root.document, n)), new B(o.parent.parent, o.parent.index + 1);
}
function Fh(o, n) {
  const t = o.data.length;
  return o._data += n.data, n._remove(), new B(o, t);
}
const WC = [we, Qi, ts, mu, gu, ll];
function zk(o, n) {
  for (const t of o) {
    if (!WC.some((e) => t instanceof e)) throw new v("view-writer-insert-invalid-node-type", n);
    t.is("$text") || zk(t.getChildren(), n);
  }
}
function Jc(o) {
  return o && (o.is("containerElement") || o.is("documentFragment"));
}
function gr(o, n) {
  const t = Qc(o.start), e = Qc(o.end);
  if (!t || !e || t !== e) throw new v("view-writer-invalid-range-container", n);
}
const Ok = (o) => o.createTextNode(""), Rk = (o) => {
  const n = o.createElement("span");
  return n.dataset.ckeFiller = "true", n.innerText = "", n;
}, Vk = (o) => {
  const n = o.createElement("br");
  return n.dataset.ckeFiller = "true", n;
}, es = "".repeat(7);
function $e(o) {
  return typeof o == "string" ? o.substr(0, 7) === es : qt(o) && o.data.substr(0, 7) === es;
}
function Ro(o) {
  return o.data.length == 7 && $e(o);
}
function jh(o) {
  const n = typeof o == "string" ? o : o.data;
  return $e(o) ? n.slice(7) : n;
}
function GC(o, n) {
  if (n.keyCode == nt.arrowleft) {
    const t = n.domTarget.ownerDocument.defaultView.getSelection();
    if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
      const e = t.getRangeAt(0).startContainer, i = t.getRangeAt(0).startOffset;
      $e(e) && i <= 7 && t.collapse(e, 0);
    }
  }
}
let KC = class extends _t() {
  constructor(n, t) {
    super();
    m(this, "domDocuments", /* @__PURE__ */ new Set());
    m(this, "domConverter");
    m(this, "markedAttributes", /* @__PURE__ */ new Set());
    m(this, "markedChildren", /* @__PURE__ */ new Set());
    m(this, "markedTexts", /* @__PURE__ */ new Set());
    m(this, "selection");
    m(this, "_inlineFiller", null);
    m(this, "_fakeSelectionContainer", null);
    this.domConverter = n, this.selection = t, this.set("isFocused", !1), this.set("isSelecting", !1), this.set("isComposing", !1), H.isBlink && !H.isAndroid && this.on("change:isSelecting", () => {
      this.isSelecting || this.render();
    });
  }
  markToSync(n, t) {
    if (n === "text") this.domConverter.mapViewToDom(t.parent) && this.markedTexts.add(t);
    else {
      if (!this.domConverter.mapViewToDom(t)) return;
      if (n === "attributes") this.markedAttributes.add(t);
      else {
        if (n !== "children") throw new v("view-renderer-unknown-type", this);
        this.markedChildren.add(t);
      }
    }
  }
  render() {
    if (this.isComposing && !H.isAndroid) return;
    let n = null;
    const t = !(H.isBlink && !H.isAndroid) || !this.isSelecting;
    for (const e of this.markedChildren) this._updateChildrenMappings(e);
    t ? (this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? n = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (n = this.selection.getFirstPosition(), this.markedChildren.add(n.parent))) : this._inlineFiller && this._inlineFiller.parentNode && (n = this.domConverter.domPositionToView(this._inlineFiller), n && n.parent.is("$text") && (n = B._createBefore(n.parent)));
    for (const e of this.markedAttributes) this._updateAttrs(e);
    for (const e of this.markedChildren) this._updateChildren(e, { inlineFillerPosition: n });
    for (const e of this.markedTexts) !this.markedChildren.has(e.parent) && this.domConverter.mapViewToDom(e.parent) && this._updateText(e, { inlineFillerPosition: n });
    if (t) if (n) {
      const e = this.domConverter.viewPositionToDom(n), i = e.parent.ownerDocument;
      $e(e.parent) ? this._inlineFiller = e.parent : this._inlineFiller = Hh(i, e.parent, e.offset);
    } else this._inlineFiller = null;
    this._updateFocus(), this._updateSelection(), this.domConverter._clearTemporaryCustomProperties(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear();
  }
  _updateChildrenMappings(n) {
    const t = this.domConverter.mapViewToDom(n);
    if (!t) return;
    const e = Array.from(t.childNodes), i = Array.from(this.domConverter.viewChildrenToDom(n, { withChildren: !1 })), r = this._diffNodeLists(e, i), s = this._findUpdateActions(r, e, i, YC);
    if (s.indexOf("update") !== -1) {
      const a = { equal: 0, insert: 0, delete: 0 };
      for (const l of s) if (l === "update") {
        const c = a.equal + a.insert, d = a.equal + a.delete, u = n.getChild(c);
        !u || u.is("uiElement") || u.is("rawElement") || this._updateElementMappings(u, e[d]), Eh(i[c]), a.equal++;
      } else a[l]++;
    }
  }
  _updateElementMappings(n, t) {
    this.domConverter.unbindDomElement(t), this.domConverter.bindElements(t, n), this.markedChildren.add(n), this.markedAttributes.add(n);
  }
  _getInlineFillerPosition() {
    const n = this.selection.getFirstPosition();
    return n.parent.is("$text") ? B._createBefore(n.parent) : n;
  }
  _isSelectionInInlineFiller() {
    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) return !1;
    const n = this.selection.getFirstPosition(), t = this.domConverter.viewPositionToDom(n);
    return !!(t && qt(t.parent) && $e(t.parent));
  }
  _removeInlineFiller() {
    const n = this._inlineFiller;
    if (!$e(n)) throw new v("view-renderer-filler-was-lost", this);
    Ro(n) ? n.remove() : n.data = n.data.substr(7), this._inlineFiller = null;
  }
  _needsInlineFillerAtSelection() {
    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) return !1;
    const n = this.selection.getFirstPosition(), t = n.parent, e = n.offset;
    if (!this.domConverter.mapViewToDom(t.root) || !t.is("element") || !function(s) {
      if (s.getAttribute("contenteditable") == "false") return !1;
      const a = s.findAncestor((l) => l.hasAttribute("contenteditable"));
      return !a || a.getAttribute("contenteditable") == "true";
    }(t)) return !1;
    const i = n.nodeBefore, r = n.nodeAfter;
    return !(i instanceof we || r instanceof we) && !!(e !== t.getFillerOffset() || i && i.is("element", "br")) && (!H.isAndroid || !i && !r);
  }
  _updateText(n, t) {
    const e = this.domConverter.findCorrespondingDomText(n);
    let i = this.domConverter.viewToDom(n).data;
    const r = t.inlineFillerPosition;
    r && r.parent == n.parent && r.offset == n.index && (i = es + i), this._updateTextNode(e, i);
  }
  _updateAttrs(n) {
    const t = this.domConverter.mapViewToDom(n);
    if (t) {
      for (const e of Array.from(t.attributes)) {
        const i = e.name;
        n.hasAttribute(i) || this.domConverter.removeDomElementAttribute(t, i);
      }
      for (const e of n.getAttributeKeys()) this.domConverter.setDomElementAttribute(t, e, n.getAttribute(e), n);
    }
  }
  _updateChildren(n, t) {
    const e = this.domConverter.mapViewToDom(n);
    if (!e) return;
    if (H.isAndroid) {
      let u = null;
      for (const h of Array.from(e.childNodes)) {
        if (u && qt(u) && qt(h)) {
          e.normalize();
          break;
        }
        u = h;
      }
    }
    const i = t.inlineFillerPosition, r = e.childNodes, s = Array.from(this.domConverter.viewChildrenToDom(n, { bind: !0 }));
    i && i.parent === n && Hh(e.ownerDocument, s, i.offset);
    const a = this._diffNodeLists(r, s), l = this._findUpdateActions(a, r, s, ZC);
    let c = 0;
    const d = /* @__PURE__ */ new Set();
    for (const u of l) u === "delete" ? (d.add(r[c]), Eh(r[c])) : u !== "equal" && u !== "update" || c++;
    c = 0;
    for (const u of l) u === "insert" ? (yk(e, c, s[c]), c++) : u === "update" ? (this._updateTextNode(r[c], s[c].data), c++) : u === "equal" && (this._markDescendantTextToSync(this.domConverter.domToView(s[c])), c++);
    for (const u of d) u.parentNode || this.domConverter.unbindDomElement(u);
  }
  _diffNodeLists(n, t) {
    return Go(n = function(e, i) {
      const r = Array.from(e);
      return r.length == 0 || !i || r[r.length - 1] == i && r.pop(), r;
    }(n, this._fakeSelectionContainer), t, QC.bind(null, this.domConverter));
  }
  _findUpdateActions(n, t, e, i) {
    if (n.indexOf("insert") === -1 || n.indexOf("delete") === -1) return n;
    let r = [], s = [], a = [];
    const l = { equal: 0, insert: 0, delete: 0 };
    for (const c of n) c === "insert" ? a.push(e[l.equal + l.insert]) : c === "delete" ? s.push(t[l.equal + l.delete]) : (r = r.concat(Go(s, a, i).map((d) => d === "equal" ? "update" : d)), r.push("equal"), s = [], a = []), l[c]++;
    return r.concat(Go(s, a, i).map((c) => c === "equal" ? "update" : c));
  }
  _updateTextNode(n, t) {
    const e = n.data;
    e != t && (H.isAndroid && this.isComposing && e.replace(/\u00A0/g, " ") == t.replace(/\u00A0/g, " ") || this._updateTextNodeInternal(n, t));
  }
  _updateTextNodeInternal(n, t) {
    const e = Bb(n.data, t);
    for (const i of e) i.type === "insert" ? n.insertData(i.index, i.values.join("")) : n.deleteData(i.index, i.howMany);
  }
  _markDescendantTextToSync(n) {
    if (n) {
      if (n.is("$text")) this.markedTexts.add(n);
      else if (n.is("element")) for (const t of n.getChildren()) this._markDescendantTextToSync(t);
    }
  }
  _updateSelection() {
    if (H.isBlink && !H.isAndroid && this.isSelecting && !this.markedChildren.size) return;
    if (this.selection.rangeCount === 0) return this._removeDomSelection(), void this._removeFakeSelection();
    const n = this.domConverter.mapViewToDom(this.selection.editableElement);
    this.isFocused && n && (this.selection.isFake ? this._updateFakeSelection(n) : this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected ? (this._removeFakeSelection(), this._updateDomSelection(n)) : this.isComposing && H.isAndroid || this._updateDomSelection(n));
  }
  _updateFakeSelection(n) {
    const t = n.ownerDocument;
    this._fakeSelectionContainer || (this._fakeSelectionContainer = function(s) {
      const a = s.createElement("div");
      return a.className = "ck-fake-selection-container", Object.assign(a.style, { position: "fixed", top: 0, left: "-9999px", width: "42px" }), a.textContent = "", a;
    }(t));
    const e = this._fakeSelectionContainer;
    if (this.domConverter.bindFakeSelection(e, this.selection), !this._fakeSelectionNeedsUpdate(n)) return;
    e.parentElement && e.parentElement == n || n.appendChild(e), e.textContent = this.selection.fakeSelectionLabel || "";
    const i = t.getSelection(), r = t.createRange();
    i.removeAllRanges(), r.selectNodeContents(e), i.addRange(r);
  }
  _updateDomSelection(n) {
    const t = n.ownerDocument.defaultView.getSelection();
    if (!this._domSelectionNeedsUpdate(t)) return;
    const e = this.domConverter.viewPositionToDom(this.selection.anchor), i = this.domConverter.viewPositionToDom(this.selection.focus);
    t.setBaseAndExtent(e.parent, e.offset, i.parent, i.offset), H.isGecko && function(r, s) {
      let a = r.parent, l = r.offset;
      if (qt(a) && Ro(a) && (l = Ir(a) + 1, a = a.parentNode), a.nodeType != Node.ELEMENT_NODE || l != a.childNodes.length - 1) return;
      const c = a.childNodes[l];
      c && c.tagName == "BR" && s.addRange(s.getRangeAt(0));
    }(i, t);
  }
  _domSelectionNeedsUpdate(n) {
    if (!this.domConverter.isDomSelectionCorrect(n)) return !0;
    const t = n && this.domConverter.domSelectionToView(n);
    return (!t || !this.selection.isEqual(t)) && !(!this.selection.isCollapsed && this.selection.isSimilar(t));
  }
  _fakeSelectionNeedsUpdate(n) {
    const t = this._fakeSelectionContainer, e = n.ownerDocument.getSelection();
    return !t || t.parentElement !== n || e.anchorNode !== t && !t.contains(e.anchorNode) || t.textContent !== this.selection.fakeSelectionLabel;
  }
  _removeDomSelection() {
    for (const n of this.domDocuments) {
      const t = n.getSelection();
      if (t.rangeCount) {
        const e = n.activeElement, i = this.domConverter.mapDomToView(e);
        e && i && t.removeAllRanges();
      }
    }
  }
  _removeFakeSelection() {
    const n = this._fakeSelectionContainer;
    n && n.remove();
  }
  _updateFocus() {
    if (this.isFocused) {
      const n = this.selection.editableElement;
      n && this.domConverter.focus(n);
    }
  }
};
function Hh(o, n, t) {
  const e = n instanceof Array ? n : n.childNodes, i = e[t];
  if (qt(i)) return i.data = es + i.data, i;
  {
    const r = o.createTextNode(es);
    return Array.isArray(n) ? e.splice(t, 0, r) : yk(n, t, r), r;
  }
}
function YC(o, n) {
  return Ii(o) && Ii(n) && !qt(o) && !qt(n) && !Vr(o) && !Vr(n) && o.tagName.toLowerCase() === n.tagName.toLowerCase();
}
function ZC(o, n) {
  return Ii(o) && Ii(n) && qt(o) && qt(n);
}
function QC(o, n, t) {
  return n === t || (qt(n) && qt(t) ? n.data === t.data : !(!o.isBlockFiller(n) || !o.isBlockFiller(t)));
}
const JC = Vk(N.document), XC = Ok(N.document), tA = Rk(N.document), Ls = "data-ck-unsafe-attribute-", Uh = "data-ck-unsafe-element";
class cl {
  constructor(n, { blockFillerMode: t, renderingMode: e = "editing" } = {}) {
    m(this, "document");
    m(this, "renderingMode");
    m(this, "blockFillerMode");
    m(this, "preElements");
    m(this, "blockElements");
    m(this, "inlineObjectElements");
    m(this, "unsafeElements");
    m(this, "_domDocument");
    m(this, "_domToViewMapping", /* @__PURE__ */ new WeakMap());
    m(this, "_viewToDomMapping", /* @__PURE__ */ new WeakMap());
    m(this, "_fakeSelectionMapping", /* @__PURE__ */ new WeakMap());
    m(this, "_rawContentElementMatcher", new We());
    m(this, "_inlineObjectElementMatcher", new We());
    m(this, "_elementsWithTemporaryCustomProperties", /* @__PURE__ */ new Set());
    this.document = n, this.renderingMode = e, this.blockFillerMode = t || (e === "editing" ? "br" : "nbsp"), this.preElements = ["pre", "textarea"], this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"], this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"], this.unsafeElements = ["script", "style"], this._domDocument = this.renderingMode === "editing" ? N.document : N.document.implementation.createHTMLDocument("");
  }
  get domDocument() {
    return this._domDocument;
  }
  bindFakeSelection(n, t) {
    this._fakeSelectionMapping.set(n, new ei(t));
  }
  fakeSelectionToView(n) {
    return this._fakeSelectionMapping.get(n);
  }
  bindElements(n, t) {
    this._domToViewMapping.set(n, t), this._viewToDomMapping.set(t, n);
  }
  unbindDomElement(n) {
    const t = this._domToViewMapping.get(n);
    if (t) {
      this._domToViewMapping.delete(n), this._viewToDomMapping.delete(t);
      for (const e of n.children) this.unbindDomElement(e);
    }
  }
  bindDocumentFragments(n, t) {
    this._domToViewMapping.set(n, t), this._viewToDomMapping.set(t, n);
  }
  shouldRenderAttribute(n, t, e) {
    return this.renderingMode === "data" || !(n = n.toLowerCase()).startsWith("on") && (n !== "srcdoc" || !t.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) && (e === "img" && (n === "src" || n === "srcset") || e === "source" && n === "srcset" || !t.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i));
  }
  setContentOf(n, t) {
    if (this.renderingMode === "data") return void (n.innerHTML = t);
    const e = new DOMParser().parseFromString(t, "text/html"), i = e.createDocumentFragment(), r = e.body.childNodes;
    for (; r.length > 0; ) i.appendChild(r[0]);
    const s = e.createTreeWalker(i, NodeFilter.SHOW_ELEMENT), a = [];
    let l;
    for (; l = s.nextNode(); ) a.push(l);
    for (const c of a) {
      for (const u of c.getAttributeNames()) this.setDomElementAttribute(c, u, c.getAttribute(u));
      const d = c.tagName.toLowerCase();
      this._shouldRenameElement(d) && (Gh(d), c.replaceWith(this._createReplacementDomElement(d, c)));
    }
    for (; n.firstChild; ) n.firstChild.remove();
    n.append(i);
  }
  viewToDom(n, t = {}) {
    if (n.is("$text")) {
      const e = this._processDataFromViewText(n);
      return this._domDocument.createTextNode(e);
    }
    {
      const e = n;
      if (this.mapViewToDom(e)) {
        if (!e.getCustomProperty("editingPipeline:doNotReuseOnce")) return this.mapViewToDom(e);
        this._elementsWithTemporaryCustomProperties.add(e);
      }
      let i;
      if (e.is("documentFragment")) i = this._domDocument.createDocumentFragment(), t.bind && this.bindDocumentFragments(i, e);
      else {
        if (e.is("uiElement")) return i = e.name === "$comment" ? this._domDocument.createComment(e.getCustomProperty("$rawContent")) : e.render(this._domDocument, this), t.bind && this.bindElements(i, e), i;
        this._shouldRenameElement(e.name) ? (Gh(e.name), i = this._createReplacementDomElement(e.name)) : i = e.hasAttribute("xmlns") ? this._domDocument.createElementNS(e.getAttribute("xmlns"), e.name) : this._domDocument.createElement(e.name), e.is("rawElement") && e.render(i, this), t.bind && this.bindElements(i, e);
        for (const r of e.getAttributeKeys()) this.setDomElementAttribute(i, r, e.getAttribute(r), e);
      }
      if (t.withChildren !== !1) for (const r of this.viewChildrenToDom(e, t)) i instanceof HTMLTemplateElement ? i.content.appendChild(r) : i.appendChild(r);
      return i;
    }
  }
  setDomElementAttribute(n, t, e, i) {
    const r = this.shouldRenderAttribute(t, e, n.tagName.toLowerCase()) || i && i.shouldRenderUnsafeAttribute(t);
    r || at("domconverter-unsafe-attribute-detected", { domElement: n, key: t, value: e }), pC(t) ? (n.hasAttribute(t) && !r ? n.removeAttribute(t) : n.hasAttribute(Ls + t) && r && n.removeAttribute(Ls + t), n.setAttribute(r ? t : Ls + t, e)) : at("domconverter-invalid-attribute-detected", { domElement: n, key: t, value: e });
  }
  removeDomElementAttribute(n, t) {
    t != Uh && (n.removeAttribute(t), n.removeAttribute(Ls + t));
  }
  *viewChildrenToDom(n, t = {}) {
    const e = n.getFillerOffset && n.getFillerOffset();
    let i = 0;
    for (const r of n.getChildren()) {
      e === i && (yield this._getBlockFiller());
      const s = r.is("element") && !!r.getCustomProperty("dataPipeline:transparentRendering") && !yt(r.getAttributes());
      if (s && this.renderingMode == "data") if (r.is("rawElement")) {
        const a = this._domDocument.createElement(r.name);
        r.render(a, this), yield* [...a.childNodes];
      } else yield* this.viewChildrenToDom(r, t);
      else s && at("domconverter-transparent-rendering-unsupported-in-editing-pipeline", { viewElement: r }), yield this.viewToDom(r, t);
      i++;
    }
    e === i && (yield this._getBlockFiller());
  }
  viewRangeToDom(n) {
    const t = this.viewPositionToDom(n.start), e = this.viewPositionToDom(n.end), i = this._domDocument.createRange();
    return i.setStart(t.parent, t.offset), i.setEnd(e.parent, e.offset), i;
  }
  viewPositionToDom(n) {
    const t = n.parent;
    if (t.is("$text")) {
      const e = this.findCorrespondingDomText(t);
      if (!e) return null;
      let i = n.offset;
      return $e(e) && (i += 7), { parent: e, offset: i };
    }
    {
      let e, i, r;
      if (n.offset === 0) {
        if (e = this.mapViewToDom(t), !e) return null;
        r = e.childNodes[0];
      } else {
        const s = n.nodeBefore;
        if (i = s.is("$text") ? this.findCorrespondingDomText(s) : this.mapViewToDom(s), !i) return null;
        e = i.parentNode, r = i.nextSibling;
      }
      return qt(r) && $e(r) ? { parent: r, offset: 7 } : { parent: e, offset: i ? Ir(i) + 1 : 0 };
    }
  }
  domToView(n, t = {}) {
    const e = [], i = this._domToView(n, t, e), r = i.next().value;
    return r ? (i.next(), this._processDomInlineNodes(null, e, t), this.blockFillerMode == "br" && qh(r) || r.is("$text") && r.data.length == 0 ? null : r) : null;
  }
  *domChildrenToView(n, t = {}, e = []) {
    let i = [];
    i = n instanceof HTMLTemplateElement ? [...n.content.childNodes] : [...n.childNodes];
    for (let r = 0; r < i.length; r++) {
      const s = i[r], a = this._domToView(s, t, e), l = a.next().value;
      l !== null && (this._isBlockViewElement(l) && this._processDomInlineNodes(n, e, t), this.blockFillerMode == "br" && qh(l) || (yield l), a.next());
    }
    this._processDomInlineNodes(n, e, t);
  }
  domSelectionToView(n) {
    if (function(i) {
      if (!H.isGecko || !i.rangeCount) return !1;
      const r = i.getRangeAt(0).startContainer;
      try {
        Object.prototype.toString.call(r);
      } catch {
        return !0;
      }
      return !1;
    }(n)) return new ei([]);
    if (n.rangeCount === 1) {
      let i = n.getRangeAt(0).startContainer;
      qt(i) && (i = i.parentNode);
      const r = this.fakeSelectionToView(i);
      if (r) return r;
    }
    const t = this.isDomSelectionBackward(n), e = [];
    for (let i = 0; i < n.rangeCount; i++) {
      const r = n.getRangeAt(i), s = this.domRangeToView(r);
      s && e.push(s);
    }
    return new ei(e, { backward: t });
  }
  domRangeToView(n) {
    const t = this.domPositionToView(n.startContainer, n.startOffset), e = this.domPositionToView(n.endContainer, n.endOffset);
    return t && e ? new st(t, e) : null;
  }
  domPositionToView(n, t = 0) {
    if (this.isBlockFiller(n)) return this.domPositionToView(n.parentNode, Ir(n));
    const e = this.mapDomToView(n);
    if (e && (e.is("uiElement") || e.is("rawElement"))) return B._createBefore(e);
    if (qt(n)) {
      if (Ro(n)) return this.domPositionToView(n.parentNode, Ir(n));
      const i = this.findCorrespondingViewText(n);
      let r = t;
      return i ? ($e(n) && (r -= 7, r = r < 0 ? 0 : r), new B(i, r)) : null;
    }
    if (t === 0) {
      const i = this.mapDomToView(n);
      if (i) return new B(i, 0);
    } else {
      const i = n.childNodes[t - 1];
      if (qt(i) && Ro(i) || i && this.isBlockFiller(i)) return this.domPositionToView(i.parentNode, Ir(i));
      const r = qt(i) ? this.findCorrespondingViewText(i) : this.mapDomToView(i);
      if (r && r.parent) return new B(r.parent, r.index + 1);
    }
    return null;
  }
  mapDomToView(n) {
    return this.getHostViewElement(n) || this._domToViewMapping.get(n);
  }
  findCorrespondingViewText(n) {
    if (Ro(n)) return null;
    const t = this.getHostViewElement(n);
    if (t) return t;
    const e = n.previousSibling;
    if (e) {
      if (!this.isElement(e)) return null;
      const i = this.mapDomToView(e);
      if (i) {
        const r = i.nextSibling;
        return r instanceof we ? r : null;
      }
    } else {
      const i = this.mapDomToView(n.parentNode);
      if (i) {
        const r = i.getChild(0);
        return r instanceof we ? r : null;
      }
    }
    return null;
  }
  mapViewToDom(n) {
    return this._viewToDomMapping.get(n);
  }
  findCorrespondingDomText(n) {
    const t = n.previousSibling;
    return t && this.mapViewToDom(t) ? this.mapViewToDom(t).nextSibling : !t && n.parent && this.mapViewToDom(n.parent) ? this.mapViewToDom(n.parent).childNodes[0] : null;
  }
  focus(n) {
    const t = this.mapViewToDom(n);
    if (!t || t.ownerDocument.activeElement === t) return;
    const { scrollX: e, scrollY: i } = N.window, r = [];
    $h(t, (s) => {
      const { scrollLeft: a, scrollTop: l } = s;
      r.push([a, l]);
    }), t.focus(), $h(t, (s) => {
      const [a, l] = r.shift();
      s.scrollLeft = a, s.scrollTop = l;
    }), N.window.scrollTo(e, i);
  }
  _clearDomSelection() {
    const n = this.mapViewToDom(this.document.selection.editableElement);
    if (!n) return;
    const t = n.ownerDocument.defaultView.getSelection(), e = this.domSelectionToView(t);
    e && e.rangeCount > 0 && t.removeAllRanges();
  }
  isElement(n) {
    return n && n.nodeType == Node.ELEMENT_NODE;
  }
  isDocumentFragment(n) {
    return n && n.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
  }
  isBlockFiller(n) {
    return this.blockFillerMode == "br" ? n.isEqualNode(JC) : !!Wh(n, this.blockElements) || n.isEqualNode(tA) || function(t, e) {
      return t.isEqualNode(XC) && Fk(t, e) && t.parentNode.childNodes.length === 1;
    }(n, this.blockElements);
  }
  isDomSelectionBackward(n) {
    if (n.isCollapsed) return !1;
    const t = this._domDocument.createRange();
    try {
      t.setStart(n.anchorNode, n.anchorOffset), t.setEnd(n.focusNode, n.focusOffset);
    } catch {
      return !1;
    }
    const e = t.collapsed;
    return t.detach(), e;
  }
  getHostViewElement(n) {
    const t = kk(n);
    for (t.pop(); t.length; ) {
      const e = t.pop(), i = this._domToViewMapping.get(e);
      if (i && (i.is("uiElement") || i.is("rawElement"))) return i;
    }
    return null;
  }
  isDomSelectionCorrect(n) {
    return this._isDomSelectionPositionCorrect(n.anchorNode, n.anchorOffset) && this._isDomSelectionPositionCorrect(n.focusNode, n.focusOffset);
  }
  registerRawContentMatcher(n) {
    this._rawContentElementMatcher.add(n);
  }
  registerInlineObjectMatcher(n) {
    this._inlineObjectElementMatcher.add(n);
  }
  _clearTemporaryCustomProperties() {
    for (const n of this._elementsWithTemporaryCustomProperties) n._removeCustomProperty("editingPipeline:doNotReuseOnce");
    this._elementsWithTemporaryCustomProperties.clear();
  }
  _getBlockFiller() {
    switch (this.blockFillerMode) {
      case "nbsp":
        return Ok(this._domDocument);
      case "markedNbsp":
        return Rk(this._domDocument);
      case "br":
        return Vk(this._domDocument);
    }
  }
  _isDomSelectionPositionCorrect(n, t) {
    if (qt(n) && $e(n) && t < 7 || this.isElement(n) && $e(n.childNodes[t])) return !1;
    const e = this.mapDomToView(n);
    return !e || !e.is("uiElement") && !e.is("rawElement");
  }
  *_domToView(n, t, e) {
    if (this.blockFillerMode != "br" && Wh(n, this.blockElements)) return null;
    const i = this.getHostViewElement(n);
    if (i) return i;
    if (Vr(n) && t.skipComments) return null;
    if (qt(n)) {
      if (Ro(n)) return null;
      {
        const r = n.data;
        if (r === "") return null;
        const s = new we(this.document, r);
        return e.push(s), s;
      }
    }
    {
      let r = this.mapDomToView(n);
      if (r) return this._isInlineObjectElement(r) && e.push(r), r;
      if (this.isDocumentFragment(n)) r = new Ji(this.document), t.bind && this.bindDocumentFragments(n, r);
      else {
        r = this._createViewElement(n, t), t.bind && this.bindElements(n, r);
        const a = n.attributes;
        if (a) for (let l = a.length, c = 0; c < l; c++) r._setAttribute(a[c].name, a[c].value);
        if (this._isViewElementWithRawContent(r, t)) return r._setCustomProperty("$rawContent", n.innerHTML), this._isBlockViewElement(r) || e.push(r), r;
        if (Vr(n)) return r._setCustomProperty("$rawContent", n.data), r;
      }
      yield r;
      const s = [];
      if (t.withChildren !== !1) for (const a of this.domChildrenToView(n, t, s)) r._appendChild(a);
      if (this._isInlineObjectElement(r)) e.push(r), this._processDomInlineNodes(null, s, t);
      else for (const a of s) e.push(a);
    }
  }
  _processDomInlineNodes(n, t, e) {
    if (!t.length || n && !this.isDocumentFragment(n) && !this._isBlockDomElement(n)) return;
    let i = !1;
    for (let r = 0; r < t.length; r++) {
      const s = t[r];
      if (!s.is("$text")) {
        i = !1;
        continue;
      }
      let a, l = !1;
      if (this._isPreFormatted(s)) a = jh(s.data);
      else {
        a = s.data.replace(/[ \n\t\r]{1,}/g, " "), l = /[^\S\u00A0]/.test(a.charAt(a.length - 1));
        const c = r > 0 ? t[r - 1] : null, d = r + 1 < t.length ? t[r + 1] : null, u = !c || c.is("element") && c.name == "br" || i, h = !d && !$e(s.data);
        e.withChildren !== !1 && (u && (a = a.replace(/^ /, "")), h && (a = a.replace(/ $/, ""))), a = jh(a), this.blockFillerMode != "br" && s.parent && (nA(s.parent, a) ? (a = "", s.parent.parent && (s.parent.parent._setCustomProperty("$hasBlockFiller", !0), s.parent._remove())) : eA(s.parent, a, this.blockElements) && (a = "", s.parent._setCustomProperty("$hasBlockFiller", !0))), a = a.replace(/ \u00A0/g, "  ");
        const g = d && d.is("element") && d.name != "br", f = d && d.is("$text") && d.data.charAt(0) == " ";
        (/[ \u00A0]\u00A0$/.test(a) || !d || g || f) && (a = a.replace(/\u00A0$/, " ")), (u || c && c.is("element") && c.name != "br") && (a = a.replace(/^\u00A0/, " "));
      }
      a.length == 0 && s.parent ? (s._remove(), t.splice(r, 1), r--) : (s._data = a, i = l);
    }
    t.length = 0;
  }
  _processDataFromViewText(n) {
    let t = n.data;
    if (this._isPreFormatted(n)) return t;
    if (t.charAt(0) == " ") {
      const e = this._getTouchingInlineViewNode(n, !1);
      !(e && e.is("$textProxy") && this._nodeEndsWithSpace(e)) && e || (t = "" + t.substr(1));
    }
    if (t.charAt(t.length - 1) == " ") {
      const e = this._getTouchingInlineViewNode(n, !0), i = e && e.is("$textProxy") && e.data.charAt(0) == " ";
      t.charAt(t.length - 2) != " " && e && !i || (t = t.substr(0, t.length - 1) + "");
    }
    return t.replace(/ {2}/g, " ");
  }
  _nodeEndsWithSpace(n) {
    if (this._isPreFormatted(n)) return !1;
    const t = this._processDataFromViewText(n);
    return t.charAt(t.length - 1) == " ";
  }
  _isPreFormatted(n) {
    if (function(t, e) {
      return t.getAncestors().some((i) => i.is("element") && e.includes(i.name));
    }(n, this.preElements)) return !0;
    for (const t of n.getAncestors({ parentFirst: !0 })) if (t.is("element") && t.hasStyle("white-space") && t.getStyle("white-space") !== "inherit") return ["pre", "pre-wrap", "break-spaces"].includes(t.getStyle("white-space"));
    return !1;
  }
  _getTouchingInlineViewNode(n, t) {
    const e = new Ki({ startPosition: t ? B._createAfter(n) : B._createBefore(n), direction: t ? "forward" : "backward" });
    for (const { item: i } of e) {
      if (i.is("$textProxy")) return i;
      if (!i.is("element") || !i.getCustomProperty("dataPipeline:transparentRendering")) {
        if (i.is("element", "br")) return null;
        if (this._isInlineObjectElement(i)) return i;
        if (i.is("containerElement")) return null;
      }
    }
    return null;
  }
  _isBlockDomElement(n) {
    return this.isElement(n) && this.blockElements.includes(n.tagName.toLowerCase());
  }
  _isBlockViewElement(n) {
    return n.is("element") && this.blockElements.includes(n.name);
  }
  _isInlineObjectElement(n) {
    return !!n.is("element") && (n.name == "br" || this.inlineObjectElements.includes(n.name) || !!this._inlineObjectElementMatcher.match(n));
  }
  _createViewElement(n, t) {
    if (Vr(n)) return new ll(this.document, "$comment");
    const e = t.keepOriginalCase ? n.tagName : n.tagName.toLowerCase();
    return new si(this.document, e);
  }
  _isViewElementWithRawContent(n, t) {
    return t.withChildren !== !1 && n.is("element") && !!this._rawContentElementMatcher.match(n);
  }
  _shouldRenameElement(n) {
    const t = n.toLowerCase();
    return this.renderingMode === "editing" && this.unsafeElements.includes(t);
  }
  _createReplacementDomElement(n, t) {
    const e = this._domDocument.createElement("span");
    if (e.setAttribute(Uh, n), t) {
      for (; t.firstChild; ) e.appendChild(t.firstChild);
      for (const i of t.getAttributeNames()) e.setAttribute(i, t.getAttribute(i));
    }
    return e;
  }
}
function $h(o, n) {
  let t = o;
  for (; t; ) n(t), t = t.parentElement;
}
function Fk(o, n) {
  const t = o.parentNode;
  return !!t && !!t.tagName && n.includes(t.tagName.toLowerCase());
}
function eA(o, n, t) {
  return n == "" && o && o.is("element") && o.childCount == 1 && t.includes(o.name);
}
function nA(o, n) {
  return n == "" && o && o.is("element", "span") && o.childCount == 1 && o.hasAttribute("data-cke-filler");
}
function qh(o) {
  return o.is("element", "br") && o.hasAttribute("data-cke-filler");
}
function Wh(o, n) {
  return o.tagName === "BR" && Fk(o, n) && o.parentNode.childNodes.length === 1;
}
function Gh(o) {
  o === "script" && at("domconverter-unsafe-script-element-detected"), o === "style" && at("domconverter-unsafe-style-element-detected");
}
class yn extends Pe() {
  constructor(t) {
    super();
    m(this, "view");
    m(this, "document");
    m(this, "_isEnabled", !1);
    this.view = t, this.document = t.document;
  }
  get isEnabled() {
    return this._isEnabled;
  }
  enable() {
    this._isEnabled = !0;
  }
  disable() {
    this._isEnabled = !1;
  }
  destroy() {
    this.disable(), this.stopListening();
  }
  checkShouldIgnoreEventFromTarget(t) {
    return t && t.nodeType === 3 && (t = t.parentNode), !(!t || t.nodeType !== 1) && t.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
  }
}
class Xo {
  constructor(n, t, e) {
    m(this, "view");
    m(this, "document");
    m(this, "domEvent");
    m(this, "domTarget");
    this.view = n, this.document = n.document, this.domEvent = t, this.domTarget = t.target, uk(this, e);
  }
  get target() {
    return this.view.domConverter.mapDomToView(this.domTarget);
  }
  preventDefault() {
    this.domEvent.preventDefault();
  }
  stopPropagation() {
    this.domEvent.stopPropagation();
  }
}
class Fn extends yn {
  constructor() {
    super(...arguments);
    m(this, "useCapture", !1);
    m(this, "usePassive", !1);
  }
  observe(t) {
    (typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType).forEach((e) => {
      this.listenTo(t, e, (i, r) => {
        this.isEnabled && !this.checkShouldIgnoreEventFromTarget(r.target) && this.onDomEvent(r);
      }, { useCapture: this.useCapture, usePassive: this.usePassive });
    });
  }
  stopObserving(t) {
    this.stopListening(t);
  }
  fire(t, e, i) {
    this.isEnabled && this.document.fire(t, new Xo(this.view, e, i));
  }
}
class iA extends Fn {
  constructor() {
    super(...arguments);
    m(this, "domEventType", ["keydown", "keyup"]);
  }
  onDomEvent(t) {
    const e = { keyCode: t.keyCode, altKey: t.altKey, ctrlKey: t.ctrlKey, shiftKey: t.shiftKey, metaKey: t.metaKey, get keystroke() {
      return eo(this);
    } };
    this.fire(t.type, t, e);
  }
}
class oA extends yn {
  constructor(t) {
    super(t);
    m(this, "_fireSelectionChangeDoneDebounced");
    this._fireSelectionChangeDoneDebounced = kn((e) => {
      this.document.fire("selectionChangeDone", e);
    }, 200);
  }
  observe() {
    const t = this.document;
    t.on("arrowKey", (e, i) => {
      t.selection.isFake && this.isEnabled && i.preventDefault();
    }, { context: "$capture" }), t.on("arrowKey", (e, i) => {
      t.selection.isFake && this.isEnabled && this._handleSelectionMove(i.keyCode);
    }, { priority: "lowest" });
  }
  stopObserving() {
  }
  destroy() {
    super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
  }
  _handleSelectionMove(t) {
    const e = this.document.selection, i = new ei(e.getRanges(), { backward: e.isBackward, fake: !1 });
    t != nt.arrowleft && t != nt.arrowup || i.setTo(i.getFirstPosition()), t != nt.arrowright && t != nt.arrowdown || i.setTo(i.getLastPosition());
    const r = { oldSelection: e, newSelection: i, domSelection: null };
    this.document.fire("selectionChange", r), this._fireSelectionChangeDoneDebounced(r);
  }
}
let jk = class extends yn {
  constructor(n) {
    super(n);
    m(this, "domConverter");
    m(this, "_config");
    m(this, "_domElements");
    m(this, "_mutationObserver");
    this._config = { childList: !0, characterData: !0, subtree: !0 }, this.domConverter = n.domConverter, this._domElements = /* @__PURE__ */ new Set(), this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
  }
  flush() {
    this._onMutations(this._mutationObserver.takeRecords());
  }
  observe(n) {
    this._domElements.add(n), this.isEnabled && this._mutationObserver.observe(n, this._config);
  }
  stopObserving(n) {
    if (this._domElements.delete(n), this.isEnabled) {
      this._mutationObserver.disconnect();
      for (const t of this._domElements) this._mutationObserver.observe(t, this._config);
    }
  }
  enable() {
    super.enable();
    for (const n of this._domElements) this._mutationObserver.observe(n, this._config);
  }
  disable() {
    super.disable(), this._mutationObserver.disconnect();
  }
  destroy() {
    super.destroy(), this._mutationObserver.disconnect();
  }
  _onMutations(n) {
    if (n.length === 0) return;
    const t = this.domConverter, e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
    for (const s of n) {
      const a = t.mapDomToView(s.target);
      a && (a.is("uiElement") || a.is("rawElement") || s.type !== "childList" || this._isBogusBrMutation(s) || i.add(a));
    }
    for (const s of n) {
      const a = t.mapDomToView(s.target);
      if ((!a || !a.is("uiElement") && !a.is("rawElement")) && s.type === "characterData") {
        const l = t.findCorrespondingViewText(s.target);
        l && !i.has(l.parent) ? e.add(l) : !l && $e(s.target) && i.add(t.mapDomToView(s.target.parentNode));
      }
    }
    const r = [];
    for (const s of e) r.push({ type: "text", node: s });
    for (const s of i) {
      const a = t.mapViewToDom(s);
      hk(Array.from(s.getChildren()), Array.from(t.domChildrenToView(a, { withChildren: !1 })), rA) || r.push({ type: "children", node: s });
    }
    r.length && this.document.fire("mutations", { mutations: r });
  }
  _isBogusBrMutation(n) {
    let t = null;
    return n.nextSibling === null && n.removedNodes.length === 0 && n.addedNodes.length == 1 && (t = this.domConverter.domToView(n.addedNodes[0], { withChildren: !1 })), t && t.is("element", "br");
  }
};
function rA(o, n) {
  if (!Array.isArray(o)) return o === n || !(!o.is("$text") || !n.is("$text")) && o.data === n.data;
}
class Aa extends Fn {
  constructor(t) {
    super(t);
    m(this, "_renderTimeoutId", null);
    m(this, "_isFocusChanging", !1);
    m(this, "domEventType", ["focus", "blur"]);
    this.useCapture = !0;
    const e = this.document;
    e.on("focus", () => this._handleFocus()), e.on("blur", (i, r) => this._handleBlur(r)), e.on("beforeinput", () => {
      e.isFocused || this._handleFocus();
    }, { priority: "highest" });
  }
  flush() {
    this._isFocusChanging && (this._isFocusChanging = !1, this.document.isFocused = !0);
  }
  onDomEvent(t) {
    this.fire(t.type, t);
  }
  destroy() {
    this._clearTimeout(), super.destroy();
  }
  _handleFocus() {
    this._clearTimeout(), this._isFocusChanging = !0, this._renderTimeoutId = setTimeout(() => {
      this._renderTimeoutId = null, this.flush(), this.view.change(() => {
      });
    }, 50);
  }
  _handleBlur(t) {
    const e = this.document.selection.editableElement;
    e !== null && e !== t.target || (this.document.isFocused = !1, this._isFocusChanging = !1, this.view.change(() => {
    }));
  }
  _clearTimeout() {
    this._renderTimeoutId && (clearTimeout(this._renderTimeoutId), this._renderTimeoutId = null);
  }
}
class sA extends yn {
  constructor(t) {
    super(t);
    m(this, "mutationObserver");
    m(this, "focusObserver");
    m(this, "selection");
    m(this, "domConverter");
    m(this, "_documents", /* @__PURE__ */ new WeakSet());
    m(this, "_fireSelectionChangeDoneDebounced");
    m(this, "_clearInfiniteLoopInterval");
    m(this, "_documentIsSelectingInactivityTimeoutDebounced");
    m(this, "_loopbackCounter", 0);
    m(this, "_pendingSelectionChange", /* @__PURE__ */ new Set());
    this.mutationObserver = t.getObserver(jk), this.focusObserver = t.getObserver(Aa), this.selection = this.document.selection, this.domConverter = t.domConverter, this._fireSelectionChangeDoneDebounced = kn((e) => {
      this.document.fire("selectionChangeDone", e);
    }, 200), this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3), this._documentIsSelectingInactivityTimeoutDebounced = kn(() => this.document.isSelecting = !1, 5e3), this.view.document.on("change:isFocused", (e, i, r) => {
      if (r && this._pendingSelectionChange.size) {
        for (const s of Array.from(this._pendingSelectionChange)) this._handleSelectionChange(s);
        this._pendingSelectionChange.clear();
      }
    });
  }
  observe(t) {
    const e = t.ownerDocument, i = () => {
      this.document.isSelecting && (this._handleSelectionChange(e), this.document.isSelecting = !1, this._documentIsSelectingInactivityTimeoutDebounced.cancel());
    };
    this.listenTo(t, "selectstart", () => {
      this.document.isSelecting = !0, this._documentIsSelectingInactivityTimeoutDebounced();
    }, { priority: "highest" }), this.listenTo(t, "keydown", i, { priority: "highest", useCapture: !0 }), this.listenTo(t, "keyup", i, { priority: "highest", useCapture: !0 }), this._documents.has(e) || (this.listenTo(e, "mouseup", i, { priority: "highest", useCapture: !0 }), this.listenTo(e, "selectionchange", () => {
      this.document.isComposing && !H.isAndroid || (this._handleSelectionChange(e), this._documentIsSelectingInactivityTimeoutDebounced());
    }), this.listenTo(this.view.document, "compositionstart", () => {
      this._handleSelectionChange(e);
    }, { priority: "lowest" }), this._documents.add(e));
  }
  stopObserving(t) {
    this.stopListening(t);
  }
  destroy() {
    super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel(), this._documentIsSelectingInactivityTimeoutDebounced.cancel();
  }
  _reportInfiniteLoop() {
  }
  _handleSelectionChange(t) {
    if (!this.isEnabled) return;
    const e = t.defaultView.getSelection();
    if (this.checkShouldIgnoreEventFromTarget(e.anchorNode)) return;
    this.mutationObserver.flush();
    const i = this.domConverter.domSelectionToView(e);
    if (i.rangeCount != 0) if (this.view.hasDomSelection = !0, this.focusObserver.flush(), this.view.document.isFocused) {
      if (this._pendingSelectionChange.delete(t), !this.selection.isEqual(i) || !this.domConverter.isDomSelectionCorrect(e)) if (++this._loopbackCounter > 60) this._reportInfiniteLoop();
      else if (this.selection.isSimilar(i)) this.view.forceRender();
      else {
        const r = { oldSelection: this.selection, newSelection: i, domSelection: e };
        this.document.fire("selectionChange", r), this._fireSelectionChangeDoneDebounced(r);
      }
    } else this._pendingSelectionChange.add(t);
    else this.view.hasDomSelection = !1;
  }
  _clearInfiniteLoop() {
    this._loopbackCounter = 0;
  }
}
class aA extends Fn {
  constructor(t) {
    super(t);
    m(this, "domEventType", ["compositionstart", "compositionupdate", "compositionend"]);
    const e = this.document;
    e.on("compositionstart", () => {
      e.isComposing = !0;
    }, { priority: "low" }), e.on("compositionend", () => {
      e.isComposing = !1;
    }, { priority: "low" });
  }
  onDomEvent(t) {
    this.fire(t.type, t, { data: t.data });
  }
}
class Hk {
  constructor(n, t = {}) {
    m(this, "_files");
    m(this, "_native");
    this._files = t.cacheFiles ? Kh(n) : null, this._native = n;
  }
  get files() {
    return this._files || (this._files = Kh(this._native)), this._files;
  }
  get types() {
    return this._native.types;
  }
  getData(n) {
    return this._native.getData(n);
  }
  setData(n, t) {
    this._native.setData(n, t);
  }
  set effectAllowed(n) {
    this._native.effectAllowed = n;
  }
  get effectAllowed() {
    return this._native.effectAllowed;
  }
  set dropEffect(n) {
    this._native.dropEffect = n;
  }
  get dropEffect() {
    return this._native.dropEffect;
  }
  setDragImage(n, t, e) {
    this._native.setDragImage(n, t, e);
  }
  get isCanceled() {
    return this._native.dropEffect == "none" || !!this._native.mozUserCancelled;
  }
}
function Kh(o) {
  const n = Array.from(o.files || []), t = Array.from(o.items || []);
  return n.length ? n : t.filter((e) => e.kind === "file").map((e) => e.getAsFile());
}
class lA extends Fn {
  constructor() {
    super(...arguments);
    m(this, "domEventType", "beforeinput");
  }
  onDomEvent(t) {
    const e = t.getTargetRanges(), i = this.view, r = i.document;
    let s = null, a = null, l = [];
    if (t.dataTransfer && (s = new Hk(t.dataTransfer)), t.data !== null ? a = t.data : s && (a = s.getData("text/plain")), r.selection.isFake) l = Array.from(r.selection.getRanges());
    else if (e.length) l = e.map((c) => {
      const d = i.domConverter.domPositionToView(c.startContainer, c.startOffset), u = i.domConverter.domPositionToView(c.endContainer, c.endOffset);
      return d ? i.createRange(d, u) : u ? i.createRange(u) : void 0;
    }).filter((c) => !!c);
    else if (H.isAndroid) {
      const c = t.target.ownerDocument.defaultView.getSelection();
      l = Array.from(i.domConverter.domSelectionToView(c).getRanges());
    }
    if (H.isAndroid && t.inputType == "insertCompositionText" && a && a.endsWith(`
`)) this.fire(t.type, t, { inputType: "insertParagraph", targetRanges: [i.createRange(l[0].end)] });
    else if (t.inputType == "insertText" && a && a.includes(`
`)) {
      const c = a.split(/\n{1,2}/g);
      let d = l;
      for (let u = 0; u < c.length; u++) {
        const h = c[u];
        h != "" && (this.fire(t.type, t, { data: h, dataTransfer: s, targetRanges: d, inputType: t.inputType, isComposing: t.isComposing }), d = [r.selection.getFirstRange()]), u + 1 < c.length && (this.fire(t.type, t, { inputType: "insertParagraph", targetRanges: d }), d = [r.selection.getFirstRange()]);
      }
    } else this.fire(t.type, t, { data: a, dataTransfer: s, targetRanges: l, inputType: t.inputType, isComposing: t.isComposing });
  }
}
class cA extends yn {
  constructor(n) {
    super(n), this.document.on("keydown", (t, e) => {
      if (this.isEnabled && AC(e.keyCode)) {
        const i = new Jo(this.document, "arrowKey", this.document.selection.getFirstRange());
        this.document.fire(i, e), i.stop.called && t.stop();
      }
    });
  }
  observe() {
  }
  stopObserving() {
  }
}
class dA extends yn {
  constructor(n) {
    super(n);
    const t = this.document;
    t.on("keydown", (e, i) => {
      if (!this.isEnabled || i.keyCode != nt.tab || i.ctrlKey) return;
      const r = new Jo(t, "tab", t.selection.getFirstRange());
      t.fire(r, i), r.stop.called && e.stop();
    });
  }
  observe() {
  }
  stopObserving() {
  }
}
let uA = class extends _t() {
  constructor(n) {
    super();
    m(this, "document");
    m(this, "domConverter");
    m(this, "domRoots", /* @__PURE__ */ new Map());
    m(this, "_renderer");
    m(this, "_initialDomRootAttributes", /* @__PURE__ */ new WeakMap());
    m(this, "_observers", /* @__PURE__ */ new Map());
    m(this, "_writer");
    m(this, "_ongoingChange", !1);
    m(this, "_postFixersInProgress", !1);
    m(this, "_renderingDisabled", !1);
    m(this, "_hasChangedSinceTheLastRendering", !1);
    this.document = new al(n), this.domConverter = new cl(this.document), this.set("isRenderingInProgress", !1), this.set("hasDomSelection", !1), this._renderer = new KC(this.domConverter, this.document.selection), this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"), this._writer = new fu(this.document), this.addObserver(jk), this.addObserver(Aa), this.addObserver(sA), this.addObserver(iA), this.addObserver(oA), this.addObserver(aA), this.addObserver(cA), this.addObserver(lA), this.addObserver(dA), this.document.on("arrowKey", GC, { priority: "low" }), HC(this), this.on("render", () => {
      this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = !1;
    }), this.listenTo(this.document.selection, "change", () => {
      this._hasChangedSinceTheLastRendering = !0;
    }), this.listenTo(this.document, "change:isFocused", () => {
      this._hasChangedSinceTheLastRendering = !0;
    }), H.isiOS && this.listenTo(this.document, "blur", (t, e) => {
      this.domConverter.mapDomToView(e.domEvent.relatedTarget) || this.domConverter._clearDomSelection();
    }), this.listenTo(this.document, "mutations", (t, { mutations: e }) => {
      e.forEach((i) => this._renderer.markToSync(i.type, i.node));
    }, { priority: "low" }), this.listenTo(this.document, "mutations", () => {
      this.forceRender();
    }, { priority: "lowest" });
  }
  attachDomRoot(n, t = "main") {
    const e = this.document.getRoot(t);
    e._name = n.tagName.toLowerCase();
    const i = {};
    for (const { name: s, value: a } of Array.from(n.attributes)) i[s] = a, s === "class" ? this._writer.addClass(a.split(" "), e) : e.hasAttribute(s) || this._writer.setAttribute(s, a, e);
    this._initialDomRootAttributes.set(n, i);
    const r = () => {
      this._writer.setAttribute("contenteditable", (!e.isReadOnly).toString(), e), e.isReadOnly ? this._writer.addClass("ck-read-only", e) : this._writer.removeClass("ck-read-only", e);
    };
    r(), this.domRoots.set(t, n), this.domConverter.bindElements(n, e), this._renderer.markToSync("children", e), this._renderer.markToSync("attributes", e), this._renderer.domDocuments.add(n.ownerDocument), e.on("change:children", (s, a) => this._renderer.markToSync("children", a)), e.on("change:attributes", (s, a) => this._renderer.markToSync("attributes", a)), e.on("change:text", (s, a) => this._renderer.markToSync("text", a)), e.on("change:isReadOnly", () => this.change(r)), e.on("change", () => {
      this._hasChangedSinceTheLastRendering = !0;
    });
    for (const s of this._observers.values()) s.observe(n, t);
  }
  detachDomRoot(n) {
    const t = this.domRoots.get(n);
    Array.from(t.attributes).forEach(({ name: i }) => t.removeAttribute(i));
    const e = this._initialDomRootAttributes.get(t);
    for (const i in e) t.setAttribute(i, e[i]);
    this.domRoots.delete(n), this.domConverter.unbindDomElement(t);
    for (const i of this._observers.values()) i.stopObserving(t);
  }
  getDomRoot(n = "main") {
    return this.domRoots.get(n);
  }
  addObserver(n) {
    let t = this._observers.get(n);
    if (t) return t;
    t = new n(this), this._observers.set(n, t);
    for (const [e, i] of this.domRoots) t.observe(i, e);
    return t.enable(), t;
  }
  getObserver(n) {
    return this._observers.get(n);
  }
  disableObservers() {
    for (const n of this._observers.values()) n.disable();
  }
  enableObservers() {
    for (const n of this._observers.values()) n.enable();
  }
  scrollToTheSelection({ alignToTop: n, forceScroll: t, viewportOffset: e = 20, ancestorOffset: i = 20 } = {}) {
    const r = this.document.selection.getFirstRange();
    if (!r) return;
    const s = Ge({ alignToTop: n, forceScroll: t, viewportOffset: e, ancestorOffset: i });
    typeof e == "number" && (e = { top: e, bottom: e, left: e, right: e });
    const a = { target: this.domConverter.viewRangeToDom(r), viewportOffset: e, ancestorOffset: i, alignToTop: n, forceScroll: t };
    this.fire("scrollToTheSelection", a, s), bC(a);
  }
  focus() {
    if (!this.document.isFocused) {
      const n = this.document.selection.editableElement;
      n && (this.domConverter.focus(n), this.forceRender());
    }
  }
  change(n) {
    if (this.isRenderingInProgress || this._postFixersInProgress) throw new v("cannot-change-view-tree", this);
    try {
      if (this._ongoingChange) return n(this._writer);
      this._ongoingChange = !0;
      const t = n(this._writer);
      return this._ongoingChange = !1, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = !0, this.document._callPostFixers(this._writer), this._postFixersInProgress = !1, this.fire("render")), t;
    } catch (t) {
      v.rethrowUnexpectedError(t, this);
    }
  }
  forceRender() {
    this._hasChangedSinceTheLastRendering = !0, this.getObserver(Aa).flush(), this.change(() => {
    });
  }
  destroy() {
    for (const n of this._observers.values()) n.destroy();
    this.document.destroy(), this.stopListening();
  }
  createPositionAt(n, t) {
    return B._createAt(n, t);
  }
  createPositionAfter(n) {
    return B._createAfter(n);
  }
  createPositionBefore(n) {
    return B._createBefore(n);
  }
  createRange(n, t) {
    return new st(n, t);
  }
  createRangeOn(n) {
    return st._createOn(n);
  }
  createRangeIn(n) {
    return st._createIn(n);
  }
  createSelection(...n) {
    return new ei(...n);
  }
  _disableRendering(n) {
    this._renderingDisabled = n, n == 0 && this.change(() => {
    });
  }
  _render() {
    this.isRenderingInProgress = !0, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = !1;
  }
};
class Bi {
  is() {
    throw new Error("is() method is abstract");
  }
}
class gn extends Bi {
  constructor(t, e, i) {
    super();
    m(this, "textNode");
    m(this, "data");
    m(this, "offsetInText");
    if (this.textNode = t, e < 0 || e > t.offsetSize) throw new v("model-textproxy-wrong-offsetintext", this);
    if (i < 0 || e + i > t.offsetSize) throw new v("model-textproxy-wrong-length", this);
    this.data = t.data.substring(e, e + i), this.offsetInText = e;
  }
  get startOffset() {
    return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
  }
  get offsetSize() {
    return this.data.length;
  }
  get endOffset() {
    return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
  }
  get isPartial() {
    return this.offsetSize !== this.textNode.offsetSize;
  }
  get parent() {
    return this.textNode.parent;
  }
  get root() {
    return this.textNode.root;
  }
  getPath() {
    const t = this.textNode.getPath();
    return t.length > 0 && (t[t.length - 1] += this.offsetInText), t;
  }
  getAncestors(t = {}) {
    const e = [];
    let i = t.includeSelf ? this : this.parent;
    for (; i; ) e[t.parentFirst ? "push" : "unshift"](i), i = i.parent;
    return e;
  }
  hasAttribute(t) {
    return this.textNode.hasAttribute(t);
  }
  getAttribute(t) {
    return this.textNode.getAttribute(t);
  }
  getAttributes() {
    return this.textNode.getAttributes();
  }
  getAttributeKeys() {
    return this.textNode.getAttributeKeys();
  }
}
gn.prototype.is = function(o) {
  return o === "$textProxy" || o === "model:$textProxy" || o === "textProxy" || o === "model:textProxy";
};
class Jn {
  constructor(n) {
    m(this, "direction");
    m(this, "boundaries");
    m(this, "singleCharacters");
    m(this, "shallow");
    m(this, "ignoreElementEnd");
    m(this, "_position");
    m(this, "_boundaryStartParent");
    m(this, "_boundaryEndParent");
    m(this, "_visitedParent");
    if (!n || !n.boundaries && !n.startPosition) throw new v("model-tree-walker-no-start-position", null);
    const t = n.direction || "forward";
    if (t != "forward" && t != "backward") throw new v("model-tree-walker-unknown-direction", n, { direction: t });
    this.direction = t, this.boundaries = n.boundaries || null, n.startPosition ? this._position = n.startPosition.clone() : this._position = S._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!n.singleCharacters, this.shallow = !!n.shallow, this.ignoreElementEnd = !!n.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent;
  }
  [Symbol.iterator]() {
    return this;
  }
  get position() {
    return this._position;
  }
  skip(n) {
    let t, e, i, r;
    do
      i = this.position, r = this._visitedParent, { done: t, value: e } = this.next();
    while (!t && n(e));
    t || (this._position = i, this._visitedParent = r);
  }
  jumpTo(n) {
    this._boundaryStartParent && n.isBefore(this.boundaries.start) ? n = this.boundaries.start : this._boundaryEndParent && n.isAfter(this.boundaries.end) && (n = this.boundaries.end), this._position = n.clone(), this._visitedParent = n.parent;
  }
  next() {
    return this.direction == "forward" ? this._next() : this._previous();
  }
  _next() {
    const n = this.position, t = this.position.clone(), e = this._visitedParent;
    if (e.parent === null && t.offset === e.maxOffset) return { done: !0, value: void 0 };
    if (e === this._boundaryEndParent && t.offset == this.boundaries.end.offset) return { done: !0, value: void 0 };
    const i = jr(t, e), r = i || Uk(t, e, i);
    if (r && r.is("model:element")) {
      if (this.shallow) {
        if (this.boundaries && this.boundaries.end.isBefore(t)) return { done: !0, value: void 0 };
        t.offset++;
      } else t.path.push(0), this._visitedParent = r;
      return this._position = t, Fi("elementStart", r, n, t, 1);
    }
    if (r && r.is("model:$text")) {
      let s;
      if (this.singleCharacters) s = 1;
      else {
        let c = r.endOffset;
        this._boundaryEndParent == e && this.boundaries.end.offset < c && (c = this.boundaries.end.offset), s = c - t.offset;
      }
      const a = t.offset - r.startOffset, l = new gn(r, a, s);
      return t.offset += s, this._position = t, Fi("text", l, n, t, s);
    }
    return t.path.pop(), t.offset++, this._position = t, this._visitedParent = e.parent, this.ignoreElementEnd ? this._next() : Fi("elementEnd", e, n, t);
  }
  _previous() {
    const n = this.position, t = this.position.clone(), e = this._visitedParent;
    if (e.parent === null && t.offset === 0) return { done: !0, value: void 0 };
    if (e == this._boundaryStartParent && t.offset == this.boundaries.start.offset) return { done: !0, value: void 0 };
    const i = t.parent, r = jr(t, i), s = r || $k(t, i, r);
    if (s && s.is("model:element")) return t.offset--, this.shallow ? (this._position = t, Fi("elementStart", s, n, t, 1)) : (t.path.push(s.maxOffset), this._position = t, this._visitedParent = s, this.ignoreElementEnd ? this._previous() : Fi("elementEnd", s, n, t));
    if (s && s.is("model:$text")) {
      let a;
      if (this.singleCharacters) a = 1;
      else {
        let d = s.startOffset;
        this._boundaryStartParent == e && this.boundaries.start.offset > d && (d = this.boundaries.start.offset), a = t.offset - d;
      }
      const l = t.offset - s.startOffset, c = new gn(s, l - a, a);
      return t.offset -= a, this._position = t, Fi("text", c, n, t, a);
    }
    return t.path.pop(), this._position = t, this._visitedParent = e.parent, Fi("elementStart", e, n, t, 1);
  }
}
function Fi(o, n, t, e, i) {
  return { done: !1, value: { type: o, item: n, previousPosition: t, nextPosition: e, length: i } };
}
class S extends Bi {
  constructor(t, e, i = "toNone") {
    super();
    m(this, "root");
    m(this, "path");
    m(this, "stickiness");
    if (!t.is("element") && !t.is("documentFragment")) throw new v("model-position-root-invalid", t);
    if (!Array.isArray(e) || e.length === 0) throw new v("model-position-path-incorrect-format", t, { path: e });
    t.is("rootElement") ? e = e.slice() : (e = [...t.getPath(), ...e], t = t.root), this.root = t, this.path = e, this.stickiness = i;
  }
  get offset() {
    return this.path[this.path.length - 1];
  }
  set offset(t) {
    this.path[this.path.length - 1] = t;
  }
  get parent() {
    let t = this.root;
    for (let e = 0; e < this.path.length - 1; e++) if (t = t.getChildAtOffset(this.path[e]), !t) throw new v("model-position-path-incorrect", this, { position: this });
    if (t.is("$text")) throw new v("model-position-path-incorrect", this, { position: this });
    return t;
  }
  get index() {
    return this.parent.offsetToIndex(this.offset);
  }
  get textNode() {
    return jr(this, this.parent);
  }
  get nodeAfter() {
    const t = this.parent;
    return Uk(this, t, jr(this, t));
  }
  get nodeBefore() {
    const t = this.parent;
    return $k(this, t, jr(this, t));
  }
  get isAtStart() {
    return this.offset === 0;
  }
  get isAtEnd() {
    return this.offset == this.parent.maxOffset;
  }
  isValid() {
    if (this.offset < 0) return !1;
    let t = this.root;
    for (let e = 0; e < this.path.length - 1; e++) if (t = t.getChildAtOffset(this.path[e]), !t) return !1;
    return this.offset <= t.maxOffset;
  }
  compareWith(t) {
    if (this.root != t.root) return "different";
    const e = xe(this.path, t.path);
    switch (e) {
      case "same":
        return "same";
      case "prefix":
        return "before";
      case "extension":
        return "after";
      default:
        return this.path[e] < t.path[e] ? "before" : "after";
    }
  }
  getLastMatchingPosition(t, e = {}) {
    e.startPosition = this;
    const i = new Jn(e);
    return i.skip(t), i.position;
  }
  getParentPath() {
    return this.path.slice(0, -1);
  }
  getAncestors() {
    const t = this.parent;
    return t.is("documentFragment") ? [t] : t.getAncestors({ includeSelf: !0 });
  }
  findAncestor(t) {
    const e = this.parent;
    return e.is("element") ? e.findAncestor(t, { includeSelf: !0 }) : null;
  }
  getCommonPath(t) {
    if (this.root != t.root) return [];
    const e = xe(this.path, t.path), i = typeof e == "string" ? Math.min(this.path.length, t.path.length) : e;
    return this.path.slice(0, i);
  }
  getCommonAncestor(t) {
    const e = this.getAncestors(), i = t.getAncestors();
    let r = 0;
    for (; e[r] == i[r] && e[r]; ) r++;
    return r === 0 ? null : e[r - 1];
  }
  getShiftedBy(t) {
    const e = this.clone(), i = e.offset + t;
    return e.offset = i < 0 ? 0 : i, e;
  }
  isAfter(t) {
    return this.compareWith(t) == "after";
  }
  isBefore(t) {
    return this.compareWith(t) == "before";
  }
  isEqual(t) {
    return this.compareWith(t) == "same";
  }
  isTouching(t) {
    if (this.root !== t.root) return !1;
    const e = Math.min(this.path.length, t.path.length);
    for (let i = 0; i < e; i++) {
      const r = this.path[i] - t.path[i];
      if (r < -1 || r > 1) return !1;
      if (r === 1) return Yh(t, this, i);
      if (r === -1) return Yh(this, t, i);
    }
    return this.path.length === t.path.length || (this.path.length > t.path.length ? Xc(this.path, e) : Xc(t.path, e));
  }
  hasSameParentAs(t) {
    return this.root !== t.root ? !1 : xe(this.getParentPath(), t.getParentPath()) == "same";
  }
  getTransformedByOperation(t) {
    let e;
    switch (t.type) {
      case "insert":
        e = this._getTransformedByInsertOperation(t);
        break;
      case "move":
      case "remove":
      case "reinsert":
        e = this._getTransformedByMoveOperation(t);
        break;
      case "split":
        e = this._getTransformedBySplitOperation(t);
        break;
      case "merge":
        e = this._getTransformedByMergeOperation(t);
        break;
      default:
        e = S._createAt(this);
    }
    return e;
  }
  _getTransformedByInsertOperation(t) {
    return this._getTransformedByInsertion(t.position, t.howMany);
  }
  _getTransformedByMoveOperation(t) {
    return this._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany);
  }
  _getTransformedBySplitOperation(t) {
    const e = t.movedRange;
    return e.containsPosition(this) || e.start.isEqual(this) && this.stickiness == "toNext" ? this._getCombined(t.splitPosition, t.moveTargetPosition) : t.graveyardPosition ? this._getTransformedByMove(t.graveyardPosition, t.insertionPosition, 1) : this._getTransformedByInsertion(t.insertionPosition, 1);
  }
  _getTransformedByMergeOperation(t) {
    const e = t.movedRange;
    let i;
    return e.containsPosition(this) || e.start.isEqual(this) ? (i = this._getCombined(t.sourcePosition, t.targetPosition), t.sourcePosition.isBefore(t.targetPosition) && (i = i._getTransformedByDeletion(t.deletionPosition, 1))) : i = this.isEqual(t.deletionPosition) ? S._createAt(t.deletionPosition) : this._getTransformedByMove(t.deletionPosition, t.graveyardPosition, 1), i;
  }
  _getTransformedByDeletion(t, e) {
    const i = S._createAt(this);
    if (this.root != t.root) return i;
    if (xe(t.getParentPath(), this.getParentPath()) == "same") {
      if (t.offset < this.offset) {
        if (t.offset + e > this.offset) return null;
        i.offset -= e;
      }
    } else if (xe(t.getParentPath(), this.getParentPath()) == "prefix") {
      const r = t.path.length - 1;
      if (t.offset <= this.path[r]) {
        if (t.offset + e > this.path[r]) return null;
        i.path[r] -= e;
      }
    }
    return i;
  }
  _getTransformedByInsertion(t, e) {
    const i = S._createAt(this);
    if (this.root != t.root) return i;
    if (xe(t.getParentPath(), this.getParentPath()) == "same") (t.offset < this.offset || t.offset == this.offset && this.stickiness != "toPrevious") && (i.offset += e);
    else if (xe(t.getParentPath(), this.getParentPath()) == "prefix") {
      const r = t.path.length - 1;
      t.offset <= this.path[r] && (i.path[r] += e);
    }
    return i;
  }
  _getTransformedByMove(t, e, i) {
    if (e = e._getTransformedByDeletion(t, i), t.isEqual(e)) return S._createAt(this);
    const r = this._getTransformedByDeletion(t, i);
    return r === null || t.isEqual(this) && this.stickiness == "toNext" || t.getShiftedBy(i).isEqual(this) && this.stickiness == "toPrevious" ? this._getCombined(t, e) : r._getTransformedByInsertion(e, i);
  }
  _getCombined(t, e) {
    const i = t.path.length - 1, r = S._createAt(e);
    return r.stickiness = this.stickiness, r.offset = r.offset + this.path[i] - t.offset, r.path = [...r.path, ...this.path.slice(i + 1)], r;
  }
  toJSON() {
    return { root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness };
  }
  clone() {
    return new this.constructor(this.root, this.path, this.stickiness);
  }
  static _createAt(t, e, i = "toNone") {
    if (t.is("model:position")) return new S(t.root, t.path, t.stickiness);
    {
      const r = t;
      if (e == "end") e = r.maxOffset;
      else {
        if (e == "before") return this._createBefore(r, i);
        if (e == "after") return this._createAfter(r, i);
        if (e !== 0 && !e) throw new v("model-createpositionat-offset-required", [this, t]);
      }
      if (!r.is("element") && !r.is("documentFragment")) throw new v("model-position-parent-incorrect", [this, t]);
      const s = r.getPath();
      return s.push(e), new this(r.root, s, i);
    }
  }
  static _createAfter(t, e) {
    if (!t.parent) throw new v("model-position-after-root", [this, t], { root: t });
    return this._createAt(t.parent, t.endOffset, e);
  }
  static _createBefore(t, e) {
    if (!t.parent) throw new v("model-position-before-root", t, { root: t });
    return this._createAt(t.parent, t.startOffset, e);
  }
  static fromJSON(t, e) {
    if (t.root === "$graveyard") {
      const i = new S(e.graveyard, t.path);
      return i.stickiness = t.stickiness, i;
    }
    if (!e.getRoot(t.root)) throw new v("model-position-fromjson-no-root", e, { rootName: t.root });
    return new S(e.getRoot(t.root), t.path, t.stickiness);
  }
}
function jr(o, n) {
  const t = n.getChildAtOffset(o.offset);
  return t && t.is("$text") && t.startOffset < o.offset ? t : null;
}
function Uk(o, n, t) {
  return t !== null ? null : n.getChildAtOffset(o.offset);
}
function $k(o, n, t) {
  return t !== null ? null : n.getChild(n.offsetToIndex(o.offset) - 1);
}
function Yh(o, n, t) {
  return t + 1 !== o.path.length && !!Xc(n.path, t + 1) && !!function(e, i) {
    let r = e.parent, s = e.path.length - 1, a = 0;
    for (; s >= i; ) {
      if (e.path[s] + a !== r.maxOffset) return !1;
      a = 1, s--, r = r.parent;
    }
    return !0;
  }(o, t + 1);
}
function Xc(o, n) {
  for (; n < o.length; ) {
    if (o[n] !== 0) return !1;
    n++;
  }
  return !0;
}
S.prototype.is = function(o) {
  return o === "position" || o === "model:position";
};
class E extends Bi {
  constructor(t, e) {
    super();
    m(this, "start");
    m(this, "end");
    this.start = S._createAt(t), this.end = e ? S._createAt(e) : S._createAt(t), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
  }
  *[Symbol.iterator]() {
    yield* new Jn({ boundaries: this, ignoreElementEnd: !0 });
  }
  get isCollapsed() {
    return this.start.isEqual(this.end);
  }
  get isFlat() {
    return xe(this.start.getParentPath(), this.end.getParentPath()) == "same";
  }
  get root() {
    return this.start.root;
  }
  containsPosition(t) {
    return t.isAfter(this.start) && t.isBefore(this.end);
  }
  containsRange(t, e = !1) {
    t.isCollapsed && (e = !1);
    const i = this.containsPosition(t.start) || e && this.start.isEqual(t.start), r = this.containsPosition(t.end) || e && this.end.isEqual(t.end);
    return i && r;
  }
  containsItem(t) {
    const e = S._createBefore(t);
    return this.containsPosition(e) || this.start.isEqual(e);
  }
  isEqual(t) {
    return this.start.isEqual(t.start) && this.end.isEqual(t.end);
  }
  isIntersecting(t) {
    return this.start.isBefore(t.end) && this.end.isAfter(t.start);
  }
  getDifference(t) {
    const e = [];
    return this.isIntersecting(t) ? (this.containsPosition(t.start) && e.push(new E(this.start, t.start)), this.containsPosition(t.end) && e.push(new E(t.end, this.end))) : e.push(new E(this.start, this.end)), e;
  }
  getIntersection(t) {
    if (this.isIntersecting(t)) {
      let e = this.start, i = this.end;
      return this.containsPosition(t.start) && (e = t.start), this.containsPosition(t.end) && (i = t.end), new E(e, i);
    }
    return null;
  }
  getJoined(t, e = !1) {
    let i = this.isIntersecting(t);
    if (i || (i = this.start.isBefore(t.start) ? e ? this.end.isTouching(t.start) : this.end.isEqual(t.start) : e ? t.end.isTouching(this.start) : t.end.isEqual(this.start)), !i) return null;
    let r = this.start, s = this.end;
    return t.start.isBefore(r) && (r = t.start), t.end.isAfter(s) && (s = t.end), new E(r, s);
  }
  getMinimalFlatRanges() {
    const t = [], e = this.start.getCommonPath(this.end).length, i = S._createAt(this.start);
    let r = i.parent;
    for (; i.path.length > e + 1; ) {
      const s = r.maxOffset - i.offset;
      s !== 0 && t.push(new E(i, i.getShiftedBy(s))), i.path = i.path.slice(0, -1), i.offset++, r = r.parent;
    }
    for (; i.path.length <= this.end.path.length; ) {
      const s = this.end.path[i.path.length - 1], a = s - i.offset;
      a !== 0 && t.push(new E(i, i.getShiftedBy(a))), i.offset = s, i.path.push(0);
    }
    return t;
  }
  getWalker(t = {}) {
    return t.boundaries = this, new Jn(t);
  }
  *getItems(t = {}) {
    t.boundaries = this, t.ignoreElementEnd = !0;
    const e = new Jn(t);
    for (const i of e) yield i.item;
  }
  *getPositions(t = {}) {
    t.boundaries = this;
    const e = new Jn(t);
    yield e.position;
    for (const i of e) yield i.nextPosition;
  }
  getTransformedByOperation(t) {
    switch (t.type) {
      case "insert":
        return this._getTransformedByInsertOperation(t);
      case "move":
      case "remove":
      case "reinsert":
        return this._getTransformedByMoveOperation(t);
      case "split":
        return [this._getTransformedBySplitOperation(t)];
      case "merge":
        return [this._getTransformedByMergeOperation(t)];
    }
    return [new E(this.start, this.end)];
  }
  getTransformedByOperations(t) {
    const e = [new E(this.start, this.end)];
    for (const i of t) for (let r = 0; r < e.length; r++) {
      const s = e[r].getTransformedByOperation(i);
      e.splice(r, 1, ...s), r += s.length - 1;
    }
    for (let i = 0; i < e.length; i++) {
      const r = e[i];
      for (let s = i + 1; s < e.length; s++) {
        const a = e[s];
        (r.containsRange(a) || a.containsRange(r) || r.isEqual(a)) && e.splice(s, 1);
      }
    }
    return e;
  }
  getCommonAncestor() {
    return this.start.getCommonAncestor(this.end);
  }
  getContainedElement() {
    if (this.isCollapsed) return null;
    const t = this.start.nodeAfter, e = this.end.nodeBefore;
    return t && t.is("element") && t === e ? t : null;
  }
  toJSON() {
    return { start: this.start.toJSON(), end: this.end.toJSON() };
  }
  clone() {
    return new this.constructor(this.start, this.end);
  }
  _getTransformedByInsertOperation(t, e = !1) {
    return this._getTransformedByInsertion(t.position, t.howMany, e);
  }
  _getTransformedByMoveOperation(t, e = !1) {
    const i = t.sourcePosition, r = t.howMany, s = t.targetPosition;
    return this._getTransformedByMove(i, s, r, e);
  }
  _getTransformedBySplitOperation(t) {
    const e = this.start._getTransformedBySplitOperation(t);
    let i = this.end._getTransformedBySplitOperation(t);
    return this.end.isEqual(t.insertionPosition) && (i = this.end.getShiftedBy(1)), e.root != i.root && (i = this.end.getShiftedBy(-1)), new E(e, i);
  }
  _getTransformedByMergeOperation(t) {
    if (this.start.isEqual(t.targetPosition) && this.end.isEqual(t.deletionPosition)) return new E(this.start);
    let e = this.start._getTransformedByMergeOperation(t), i = this.end._getTransformedByMergeOperation(t);
    return e.root != i.root && (i = this.end.getShiftedBy(-1)), e.isAfter(i) ? (t.sourcePosition.isBefore(t.targetPosition) ? (e = S._createAt(i), e.offset = 0) : (t.deletionPosition.isEqual(e) || (i = t.deletionPosition), e = t.targetPosition), new E(e, i)) : new E(e, i);
  }
  _getTransformedByInsertion(t, e, i = !1) {
    if (i && this.containsPosition(t)) return [new E(this.start, t), new E(t.getShiftedBy(e), this.end._getTransformedByInsertion(t, e))];
    {
      const r = new E(this.start, this.end);
      return r.start = r.start._getTransformedByInsertion(t, e), r.end = r.end._getTransformedByInsertion(t, e), [r];
    }
  }
  _getTransformedByMove(t, e, i, r = !1) {
    if (this.isCollapsed) {
      const h = this.start._getTransformedByMove(t, e, i);
      return [new E(h)];
    }
    const s = E._createFromPositionAndShift(t, i), a = e._getTransformedByDeletion(t, i);
    if (this.containsPosition(e) && !r && (s.containsPosition(this.start) || s.containsPosition(this.end))) {
      const h = this.start._getTransformedByMove(t, e, i), g = this.end._getTransformedByMove(t, e, i);
      return [new E(h, g)];
    }
    let l;
    const c = this.getDifference(s);
    let d = null;
    const u = this.getIntersection(s);
    if (c.length == 1 ? d = new E(c[0].start._getTransformedByDeletion(t, i), c[0].end._getTransformedByDeletion(t, i)) : c.length == 2 && (d = new E(this.start, this.end._getTransformedByDeletion(t, i))), l = d ? d._getTransformedByInsertion(a, i, u !== null || r) : [], u) {
      const h = new E(u.start._getCombined(s.start, a), u.end._getCombined(s.start, a));
      l.length == 2 ? l.splice(1, 0, h) : l.push(h);
    }
    return l;
  }
  _getTransformedByDeletion(t, e) {
    let i = this.start._getTransformedByDeletion(t, e), r = this.end._getTransformedByDeletion(t, e);
    return i == null && r == null ? null : (i == null && (i = t), r == null && (r = t), new E(i, r));
  }
  static _createFromPositionAndShift(t, e) {
    const i = t, r = t.getShiftedBy(e);
    return e > 0 ? new this(i, r) : new this(r, i);
  }
  static _createIn(t) {
    return new this(S._createAt(t, 0), S._createAt(t, t.maxOffset));
  }
  static _createOn(t) {
    return this._createFromPositionAndShift(S._createBefore(t), t.offsetSize);
  }
  static _createFromRanges(t) {
    if (t.length === 0) throw new v("range-create-from-ranges-empty-array", null);
    if (t.length == 1) return t[0].clone();
    const e = t[0];
    t.sort((s, a) => s.start.isAfter(a.start) ? 1 : -1);
    const i = t.indexOf(e), r = new this(e.start, e.end);
    for (let s = i - 1; s >= 0 && t[s].end.isEqual(r.start); s--) r.start = S._createAt(t[s].start);
    for (let s = i + 1; s < t.length && t[s].start.isEqual(r.end); s++) r.end = S._createAt(t[s].end);
    return r;
  }
  static fromJSON(t, e) {
    return new this(S.fromJSON(t.start, e), S.fromJSON(t.end, e));
  }
}
E.prototype.is = function(o) {
  return o === "range" || o === "model:range";
};
class qk extends vt() {
  constructor() {
    super();
    m(this, "_modelToViewMapping", /* @__PURE__ */ new WeakMap());
    m(this, "_viewToModelMapping", /* @__PURE__ */ new WeakMap());
    m(this, "_viewToModelLengthCallbacks", /* @__PURE__ */ new Map());
    m(this, "_markerNameToElements", /* @__PURE__ */ new Map());
    m(this, "_elementToMarkerNames", /* @__PURE__ */ new Map());
    m(this, "_deferredBindingRemovals", /* @__PURE__ */ new Map());
    m(this, "_unboundMarkerNames", /* @__PURE__ */ new Set());
    m(this, "_cache", new hA());
    this.on("modelToViewPosition", (t, e) => {
      if (e.viewPosition) return;
      const i = this._modelToViewMapping.get(e.modelPosition.parent);
      if (!i) throw new v("mapping-model-position-view-parent-not-found", this, { modelPosition: e.modelPosition });
      e.viewPosition = this.findPositionIn(i, e.modelPosition.offset);
    }, { priority: "low" }), this.on("viewToModelPosition", (t, e) => {
      if (e.modelPosition) return;
      const i = this.findMappedViewAncestor(e.viewPosition), r = this._viewToModelMapping.get(i), s = this._toModelOffset(e.viewPosition.parent, e.viewPosition.offset, i);
      e.modelPosition = S._createAt(r, s);
    }, { priority: "low" });
  }
  bindElements(t, e) {
    this._modelToViewMapping.set(t, e), this._viewToModelMapping.set(e, t);
  }
  unbindViewElement(t, e = {}) {
    const i = this.toModelElement(t);
    if (this._elementToMarkerNames.has(t)) for (const r of this._elementToMarkerNames.get(t)) this._unboundMarkerNames.add(r);
    e.defer ? this._deferredBindingRemovals.set(t, t.root) : (this._viewToModelMapping.delete(t) && this._cache.stopTracking(t), this._modelToViewMapping.get(i) == t && this._modelToViewMapping.delete(i));
  }
  unbindModelElement(t) {
    const e = this.toViewElement(t);
    this._modelToViewMapping.delete(t), this._viewToModelMapping.get(e) == t && this._viewToModelMapping.delete(e) && this._cache.stopTracking(e);
  }
  bindElementToMarker(t, e) {
    const i = this._markerNameToElements.get(e) || /* @__PURE__ */ new Set();
    i.add(t);
    const r = this._elementToMarkerNames.get(t) || /* @__PURE__ */ new Set();
    r.add(e), this._markerNameToElements.set(e, i), this._elementToMarkerNames.set(t, r);
  }
  unbindElementFromMarkerName(t, e) {
    const i = this._markerNameToElements.get(e);
    i && (i.delete(t), i.size == 0 && this._markerNameToElements.delete(e));
    const r = this._elementToMarkerNames.get(t);
    r && (r.delete(e), r.size == 0 && this._elementToMarkerNames.delete(t));
  }
  flushUnboundMarkerNames() {
    const t = Array.from(this._unboundMarkerNames);
    return this._unboundMarkerNames.clear(), t;
  }
  flushDeferredBindings() {
    for (const [t, e] of this._deferredBindingRemovals) t.root == e && this.unbindViewElement(t);
    this._deferredBindingRemovals = /* @__PURE__ */ new Map();
  }
  clearBindings() {
    this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this._deferredBindingRemovals = /* @__PURE__ */ new Map();
  }
  toModelElement(t) {
    return this._viewToModelMapping.get(t);
  }
  toViewElement(t) {
    return this._modelToViewMapping.get(t);
  }
  toModelRange(t) {
    return new E(this.toModelPosition(t.start), this.toModelPosition(t.end));
  }
  toViewRange(t) {
    return new st(this.toViewPosition(t.start), this.toViewPosition(t.end));
  }
  toModelPosition(t) {
    const e = { viewPosition: t, mapper: this };
    return this.fire("viewToModelPosition", e), e.modelPosition;
  }
  toViewPosition(t, e = {}) {
    const i = { modelPosition: t, mapper: this, isPhantom: e.isPhantom };
    return this.fire("modelToViewPosition", i), i.viewPosition;
  }
  markerNameToElements(t) {
    const e = this._markerNameToElements.get(t);
    if (!e) return null;
    const i = /* @__PURE__ */ new Set();
    for (const r of e) if (r.is("attributeElement")) for (const s of r.getElementsWithSameId()) i.add(s);
    else i.add(r);
    return i;
  }
  registerViewToModelLength(t, e) {
    this._viewToModelLengthCallbacks.set(t, e);
  }
  findMappedViewAncestor(t) {
    let e = t.parent;
    for (; !this._viewToModelMapping.has(e); ) e = e.parent;
    return e;
  }
  _toModelOffset(t, e, i) {
    if (i != t)
      return this._toModelOffset(t.parent, t.index, i) + this._toModelOffset(t, e, t);
    if (t.is("$text")) return e;
    let r = 0;
    for (let s = 0; s < e; s++) r += this.getModelLength(t.getChild(s));
    return r;
  }
  getModelLength(t) {
    const e = [t];
    let i = 0;
    for (; e.length > 0; ) {
      const r = e.pop(), s = r.name && this._viewToModelLengthCallbacks.size > 0 && this._viewToModelLengthCallbacks.get(r.name);
      if (s) i += s(r);
      else if (this._viewToModelMapping.has(r)) i += 1;
      else if (r.is("$text")) i += r.data.length;
      else {
        if (r.is("uiElement")) continue;
        for (const a of r.getChildren()) e.push(a);
      }
    }
    return i;
  }
  findPositionIn(t, e) {
    if (e === 0) return this._moveViewPositionToTextNode(new B(t, 0));
    if (this._viewToModelLengthCallbacks.size == 0 && this._viewToModelMapping.has(t)) {
      const i = this._cache.getClosest(t, e);
      return this._findPositionStartingFrom(i.viewPosition, i.modelOffset, e, t, !0);
    }
    return this._findPositionStartingFrom(new B(t, 0), 0, e, t, !1);
  }
  _findPositionStartingFrom(t, e, i, r, s) {
    let a, l = t.parent, c = t.offset;
    if (l.is("$text")) return new B(l, i - e);
    let d = e, u = 0;
    for (; d < i; ) if (a = l.getChild(c), a) u = this.getModelLength(a), d += u, c++, s && this._cache.save(l, c, r, d);
    else {
      if (l == r) throw new v("mapping-model-offset-not-found", this, { modelOffset: i, viewContainer: r });
      c = l.parent.getChildIndex(l) + 1, l = l.parent;
    }
    return d == i ? this._moveViewPositionToTextNode(new B(l, c)) : this._findPositionStartingFrom(new B(a, 0), d - u, i, r, s);
  }
  _moveViewPositionToTextNode(t) {
    const e = t.nodeBefore, i = t.nodeAfter;
    return e && e.is("view:$text") ? new B(e, e.data.length) : i && i.is("view:$text") ? new B(i, 0) : t;
  }
}
class hA extends vt() {
  constructor() {
    super(...arguments);
    m(this, "_cachedMapping", /* @__PURE__ */ new WeakMap());
    m(this, "_nodeToCacheListIndex", /* @__PURE__ */ new WeakMap());
    m(this, "_invalidateOnChildrenChangeCallback", (t, e, i) => {
      this._clearCacheInsideParent(e, i.index);
    });
    m(this, "_invalidateOnTextChangeCallback", (t, e) => {
      this._clearCacheStartingBefore(e);
    });
  }
  save(t, e, i, r) {
    const s = this._cachedMapping.get(i), a = s.cacheMap.get(r);
    if (a) {
      const d = t.getChild(e - 1), u = a.viewPosition.nodeBefore ? this._nodeToCacheListIndex.get(a.viewPosition.nodeBefore) : 0;
      return void this._nodeToCacheListIndex.set(d, u);
    }
    const l = { viewPosition: new B(t, e), modelOffset: r };
    s.maxModelOffset = r > s.maxModelOffset ? r : s.maxModelOffset, s.cacheMap.set(r, l);
    let c = s.cacheList.length - 1;
    for (; c >= 0 && s.cacheList[c].modelOffset > r; ) c--;
    if (s.cacheList.splice(c + 1, 0, l), e > 0) {
      const d = t.getChild(e - 1);
      this._nodeToCacheListIndex.set(d, c + 1);
    }
  }
  getClosest(t, e) {
    const i = this._cachedMapping.get(t);
    let r;
    i ? e > i.maxModelOffset ? r = i.cacheList[i.cacheList.length - 1] : r = i.cacheMap.get(e) || this._findInCacheList(i.cacheList, e) : r = this.startTracking(t);
    const s = this._hoistViewPosition(r.viewPosition);
    return { modelOffset: r.modelOffset, viewPosition: s };
  }
  _hoistViewPosition(t) {
    for (; t.parent.parent && !this._cachedMapping.has(t.parent) && t.isAtEnd; ) {
      const e = t.parent.parent, i = e.getChildIndex(t.parent) + 1;
      t = new B(e, i);
    }
    return t;
  }
  startTracking(t) {
    const e = { viewPosition: new B(t, 0), modelOffset: 0 }, i = { maxModelOffset: 0, cacheList: [e], cacheMap: /* @__PURE__ */ new Map([[0, e]]) };
    return this._cachedMapping.set(t, i), t.on("change:children", this._invalidateOnChildrenChangeCallback), t.on("change:text", this._invalidateOnTextChangeCallback), e;
  }
  stopTracking(t) {
    t.off("change:children", this._invalidateOnChildrenChangeCallback), t.off("change:text", this._invalidateOnTextChangeCallback), this._cachedMapping.delete(t);
  }
  _clearCacheInsideParent(t, e) {
    if (e == 0) this._cachedMapping.has(t) ? this._clearCacheAll(t) : this._clearCacheStartingBefore(t);
    else {
      const i = t.getChild(e - 1);
      this._clearCacheStartingBefore(i);
    }
  }
  _clearCacheAll(t) {
    const e = this._cachedMapping.get(t);
    e.maxModelOffset > 0 && (e.maxModelOffset = 0, e.cacheList.length = 1, e.cacheMap.clear(), e.cacheMap.set(0, e.cacheList[0]));
  }
  _clearCacheStartingBefore(t) {
    const e = this._nodeToCacheListIndex.get(t);
    if (e === void 0) {
      const r = t.parent;
      return void (this._cachedMapping.has(r) || this._clearCacheStartingBefore(r));
    }
    let i = t.parent;
    for (; !this._cachedMapping.has(i); ) i = i.parent;
    this._clearCacheFromIndex(i, e);
  }
  _clearCacheFromIndex(t, e) {
    e === 0 && (e = 1);
    const i = this._cachedMapping.get(t), r = i.cacheList[e - 1];
    if (!r) return;
    i.maxModelOffset = r.modelOffset;
    const s = i.cacheList.splice(e);
    for (const a of s) {
      i.cacheMap.delete(a.modelOffset);
      const l = a.viewPosition.nodeBefore;
      this._nodeToCacheListIndex.delete(l);
    }
  }
  _findInCacheList(t, e) {
    let i = 0, r = t.length - 1, s = r - i >> 1, a = t[s];
    for (; i < r; ) a.modelOffset < e ? i = s + 1 : r = s - 1, s = i + (r - i >> 1), a = t[s];
    return a.modelOffset <= e ? a : t[s - 1];
  }
}
class mA {
  constructor() {
    m(this, "_consumable", /* @__PURE__ */ new Map());
    m(this, "_textProxyRegistry", /* @__PURE__ */ new Map());
  }
  add(n, t) {
    t = Bs(t), n instanceof gn && (n = this._getSymbolForTextProxy(n)), this._consumable.has(n) || this._consumable.set(n, /* @__PURE__ */ new Map()), this._consumable.get(n).set(t, !0);
  }
  consume(n, t) {
    return t = Bs(t), n instanceof gn && (n = this._getSymbolForTextProxy(n)), !!this.test(n, t) && (this._consumable.get(n).set(t, !1), !0);
  }
  test(n, t) {
    t = Bs(t), n instanceof gn && (n = this._getSymbolForTextProxy(n));
    const e = this._consumable.get(n);
    if (e === void 0) return null;
    const i = e.get(t);
    return i === void 0 ? null : i;
  }
  revert(n, t) {
    t = Bs(t), n instanceof gn && (n = this._getSymbolForTextProxy(n));
    const e = this.test(n, t);
    return e === !1 ? (this._consumable.get(n).set(t, !0), !0) : e !== !0 && null;
  }
  verifyAllConsumed(n) {
    const t = [];
    for (const [e, i] of this._consumable) for (const [r, s] of i) {
      const a = r.split(":")[0];
      s && n == a && t.push({ event: r, item: e.name || e.description });
    }
    if (t.length) throw new v("conversion-model-consumable-not-consumed", null, { items: t });
  }
  _getSymbolForTextProxy(n) {
    let t = null;
    const e = this._textProxyRegistry.get(n.startOffset);
    if (e) {
      const i = e.get(n.endOffset);
      i && (t = i.get(n.parent));
    }
    return t || (t = this._addSymbolForTextProxy(n)), t;
  }
  _addSymbolForTextProxy(n) {
    const t = n.startOffset, e = n.endOffset, i = n.parent, r = Symbol("$textProxy:" + n.data);
    let s, a;
    return s = this._textProxyRegistry.get(t), s || (s = /* @__PURE__ */ new Map(), this._textProxyRegistry.set(t, s)), a = s.get(e), a || (a = /* @__PURE__ */ new Map(), s.set(e, a)), a.set(i, r), r;
  }
}
function Bs(o) {
  const n = o.split(":");
  return n[0] == "insert" ? n[0] : n[0] == "addMarker" || n[0] == "removeMarker" ? o : n.length > 1 ? n[0] + ":" + n[1] : n[0];
}
class Wk extends vt() {
  constructor(t) {
    super();
    m(this, "_conversionApi");
    m(this, "_firedEventsMap");
    this._conversionApi = { dispatcher: this, ...t }, this._firedEventsMap = /* @__PURE__ */ new WeakMap();
  }
  convertChanges(t, e, i) {
    const r = this._createConversionApi(i, t.getRefreshedItems());
    for (const a of t.getMarkersToRemove()) this._convertMarkerRemove(a.name, a.range, r);
    const s = this._reduceChanges(t.getChanges());
    for (const a of s) a.type === "insert" ? this._convertInsert(E._createFromPositionAndShift(a.position, a.length), r) : a.type === "reinsert" ? this._convertReinsert(E._createFromPositionAndShift(a.position, a.length), r) : a.type === "remove" ? this._convertRemove(a.position, a.length, a.name, r) : this._convertAttribute(a.range, a.attributeKey, a.attributeOldValue, a.attributeNewValue, r);
    r.mapper.flushDeferredBindings();
    for (const a of r.mapper.flushUnboundMarkerNames()) {
      const l = e.get(a).getRange();
      this._convertMarkerRemove(a, l, r), this._convertMarkerAdd(a, l, r);
    }
    for (const a of t.getMarkersToAdd()) this._convertMarkerAdd(a.name, a.range, r);
    r.consumable.verifyAllConsumed("insert");
  }
  convert(t, e, i, r = {}) {
    const s = this._createConversionApi(i, void 0, r);
    this._convertInsert(t, s);
    for (const [a, l] of e) this._convertMarkerAdd(a, l, s);
    s.consumable.verifyAllConsumed("insert");
  }
  convertSelection(t, e, i) {
    const r = this._createConversionApi(i);
    this.fire("cleanSelection", { selection: t }, r);
    const s = t.getFirstPosition().root;
    if (!r.mapper.toViewElement(s)) return;
    const a = Array.from(e.getMarkersAtPosition(t.getFirstPosition()));
    if (this._addConsumablesForSelection(r.consumable, t, a), this.fire("selection", { selection: t }, r), t.isCollapsed) {
      for (const l of a) if (r.consumable.test(t, "addMarker:" + l.name)) {
        const c = l.getRange();
        if (!gA(t.getFirstPosition(), l, r.mapper)) continue;
        const d = { item: t, markerName: l.name, markerRange: c };
        this.fire(`addMarker:${l.name}`, d, r);
      }
      for (const l of t.getAttributeKeys()) if (r.consumable.test(t, "attribute:" + l)) {
        const c = { item: t, range: t.getFirstRange(), attributeKey: l, attributeOldValue: null, attributeNewValue: t.getAttribute(l) };
        this.fire(`attribute:${l}:$text`, c, r);
      }
    }
  }
  _convertInsert(t, e, i = {}) {
    i.doNotAddConsumables || this._addConsumablesForInsert(e.consumable, t);
    for (const r of t.getWalker({ shallow: !0 })) this._testAndFire("insert", Zh(r), e);
  }
  _convertRemove(t, e, i, r) {
    this.fire(`remove:${i}`, { position: t, length: e }, r);
  }
  _convertAttribute(t, e, i, r, s) {
    this._addConsumablesForRange(s.consumable, t, `attribute:${e}`);
    for (const a of t) {
      const l = { item: a.item, range: E._createFromPositionAndShift(a.previousPosition, a.length), attributeKey: e, attributeOldValue: i, attributeNewValue: r };
      this._testAndFire(`attribute:${e}`, l, s);
    }
  }
  _convertReinsert(t, e) {
    const i = Array.from(t.getWalker({ shallow: !0 }));
    this._addConsumablesForInsert(e.consumable, i);
    for (const r of i.map(Zh)) this._testAndFire("insert", { ...r, reconversion: !0 }, e);
  }
  _convertMarkerAdd(t, e, i) {
    if (e.root.rootName == "$graveyard") return;
    const r = `addMarker:${t}`;
    if (i.consumable.add(e, r), this.fire(r, { markerName: t, markerRange: e }, i), i.consumable.consume(e, r)) {
      this._addConsumablesForRange(i.consumable, e, r);
      for (const s of e.getItems()) {
        if (!i.consumable.test(s, r)) continue;
        const a = { item: s, range: E._createOn(s), markerName: t, markerRange: e };
        this.fire(r, a, i);
      }
    }
  }
  _convertMarkerRemove(t, e, i) {
    e.root.rootName != "$graveyard" && this.fire(`removeMarker:${t}`, { markerName: t, markerRange: e }, i);
  }
  _reduceChanges(t) {
    const e = { changes: t };
    return this.fire("reduceChanges", e), e.changes;
  }
  _addConsumablesForInsert(t, e) {
    for (const i of e) {
      const r = i.item;
      if (t.test(r, "insert") === null) {
        t.add(r, "insert");
        for (const s of r.getAttributeKeys()) t.add(r, "attribute:" + s);
      }
    }
    return t;
  }
  _addConsumablesForRange(t, e, i) {
    for (const r of e.getItems()) t.add(r, i);
    return t;
  }
  _addConsumablesForSelection(t, e, i) {
    t.add(e, "selection");
    for (const r of i) t.add(e, "addMarker:" + r.name);
    for (const r of e.getAttributeKeys()) t.add(e, "attribute:" + r);
    return t;
  }
  _testAndFire(t, e, i) {
    const r = function(c, d) {
      const u = d.item.is("element") ? d.item.name : "$text";
      return `${c}:${u}`;
    }(t, e), s = e.item.is("$textProxy") ? i.consumable._getSymbolForTextProxy(e.item) : e.item, a = this._firedEventsMap.get(i), l = a.get(s);
    if (l) {
      if (l.has(r)) return;
      l.add(r);
    } else a.set(s, /* @__PURE__ */ new Set([r]));
    this.fire(r, e, i);
  }
  _testAndFireAddAttributes(t, e) {
    const i = { item: t, range: E._createOn(t) };
    for (const r of i.item.getAttributeKeys()) i.attributeKey = r, i.attributeOldValue = null, i.attributeNewValue = i.item.getAttribute(r), this._testAndFire(`attribute:${r}`, i, e);
  }
  _createConversionApi(t, e = /* @__PURE__ */ new Set(), i = {}) {
    const r = { ...this._conversionApi, consumable: new mA(), writer: t, options: i, convertItem: (s) => this._convertInsert(E._createOn(s), r), convertChildren: (s) => this._convertInsert(E._createIn(s), r, { doNotAddConsumables: !0 }), convertAttributes: (s) => this._testAndFireAddAttributes(s, r), canReuseView: (s) => !e.has(r.mapper.toModelElement(s)) };
    return this._firedEventsMap.set(r, /* @__PURE__ */ new Map()), r;
  }
}
function gA(o, n, t) {
  const e = n.getRange(), i = Array.from(o.getAncestors());
  return i.shift(), i.reverse(), !i.some((r) => {
    if (e.containsItem(r))
      return !!t.toViewElement(r).getCustomProperty("addHighlight");
  });
}
function Zh(o) {
  return { item: o.item, range: E._createFromPositionAndShift(o.previousPosition, o.length) };
}
let lo = class extends Bi {
  constructor(n) {
    super();
    m(this, "parent", null);
    m(this, "_attrs");
    m(this, "_index", null);
    m(this, "_startOffset", null);
    this._attrs = wn(n);
  }
  get document() {
    return null;
  }
  get index() {
    return this._index;
  }
  get startOffset() {
    return this._startOffset;
  }
  get offsetSize() {
    return 1;
  }
  get endOffset() {
    return this.startOffset === null ? null : this.startOffset + this.offsetSize;
  }
  get nextSibling() {
    const n = this.index;
    return n !== null && this.parent.getChild(n + 1) || null;
  }
  get previousSibling() {
    const n = this.index;
    return n !== null && this.parent.getChild(n - 1) || null;
  }
  get root() {
    let n = this;
    for (; n.parent; ) n = n.parent;
    return n;
  }
  isAttached() {
    return this.parent !== null && this.root.isAttached();
  }
  getPath() {
    const n = [];
    let t = this;
    for (; t.parent; ) n.unshift(t.startOffset), t = t.parent;
    return n;
  }
  getAncestors(n = {}) {
    const t = [];
    let e = n.includeSelf ? this : this.parent;
    for (; e; ) t[n.parentFirst ? "push" : "unshift"](e), e = e.parent;
    return t;
  }
  getCommonAncestor(n, t = {}) {
    const e = this.getAncestors(t), i = n.getAncestors(t);
    let r = 0;
    for (; e[r] == i[r] && e[r]; ) r++;
    return r === 0 ? null : e[r - 1];
  }
  isBefore(n) {
    if (this == n || this.root !== n.root) return !1;
    const t = this.getPath(), e = n.getPath(), i = xe(t, e);
    switch (i) {
      case "prefix":
        return !0;
      case "extension":
        return !1;
      default:
        return t[i] < e[i];
    }
  }
  isAfter(n) {
    return this != n && this.root === n.root && !this.isBefore(n);
  }
  hasAttribute(n) {
    return this._attrs.has(n);
  }
  getAttribute(n) {
    return this._attrs.get(n);
  }
  getAttributes() {
    return this._attrs.entries();
  }
  getAttributeKeys() {
    return this._attrs.keys();
  }
  toJSON() {
    const n = {};
    return this._attrs.size && (n.attributes = Array.from(this._attrs).reduce((t, e) => (t[e[0]] = e[1], t), {})), n;
  }
  _clone(n) {
    return new this.constructor(this._attrs);
  }
  _remove() {
    this.parent._removeChildren(this.index);
  }
  _setAttribute(n, t) {
    this._attrs.set(n, t);
  }
  _setAttributesTo(n) {
    this._attrs = wn(n);
  }
  _removeAttribute(n) {
    return this._attrs.delete(n);
  }
  _clearAttributes() {
    this._attrs.clear();
  }
};
lo.prototype.is = function(o) {
  return o === "node" || o === "model:node";
};
class qe extends vt(Bi) {
  constructor(...t) {
    super();
    m(this, "_lastRangeBackward", !1);
    m(this, "_attrs", /* @__PURE__ */ new Map());
    m(this, "_ranges", []);
    t.length && this.setTo(...t);
  }
  get anchor() {
    if (this._ranges.length > 0) {
      const t = this._ranges[this._ranges.length - 1];
      return this._lastRangeBackward ? t.end : t.start;
    }
    return null;
  }
  get focus() {
    if (this._ranges.length > 0) {
      const t = this._ranges[this._ranges.length - 1];
      return this._lastRangeBackward ? t.start : t.end;
    }
    return null;
  }
  get isCollapsed() {
    return this._ranges.length === 1 && this._ranges[0].isCollapsed;
  }
  get rangeCount() {
    return this._ranges.length;
  }
  get isBackward() {
    return !this.isCollapsed && this._lastRangeBackward;
  }
  isEqual(t) {
    if (this.rangeCount != t.rangeCount) return !1;
    if (this.rangeCount === 0) return !0;
    if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) return !1;
    for (const e of this._ranges) {
      let i = !1;
      for (const r of t._ranges) if (e.isEqual(r)) {
        i = !0;
        break;
      }
      if (!i) return !1;
    }
    return !0;
  }
  *getRanges() {
    for (const t of this._ranges) yield new E(t.start, t.end);
  }
  getFirstRange() {
    let t = null;
    for (const e of this._ranges) t && !e.start.isBefore(t.start) || (t = e);
    return t ? new E(t.start, t.end) : null;
  }
  getLastRange() {
    let t = null;
    for (const e of this._ranges) t && !e.end.isAfter(t.end) || (t = e);
    return t ? new E(t.start, t.end) : null;
  }
  getFirstPosition() {
    const t = this.getFirstRange();
    return t ? t.start.clone() : null;
  }
  getLastPosition() {
    const t = this.getLastRange();
    return t ? t.end.clone() : null;
  }
  setTo(...t) {
    let [e, i, r] = t;
    if (typeof i == "object" && (r = i, i = void 0), e === null) this._setRanges([]);
    else if (e instanceof qe) this._setRanges(e.getRanges(), e.isBackward);
    else if (e && typeof e.getRanges == "function") this._setRanges(e.getRanges(), e.isBackward);
    else if (e instanceof E) this._setRanges([e], !!r && !!r.backward);
    else if (e instanceof S) this._setRanges([new E(e)]);
    else if (e instanceof lo) {
      const s = !!r && !!r.backward;
      let a;
      if (i == "in") a = E._createIn(e);
      else if (i == "on") a = E._createOn(e);
      else {
        if (i === void 0) throw new v("model-selection-setto-required-second-parameter", [this, e]);
        a = new E(S._createAt(e, i));
      }
      this._setRanges([a], s);
    } else {
      if (!Ye(e)) throw new v("model-selection-setto-not-selectable", [this, e]);
      this._setRanges(e, r && !!r.backward);
    }
  }
  _setRanges(t, e = !1) {
    const i = Array.from(t), r = i.some((s) => {
      if (!(s instanceof E)) throw new v("model-selection-set-ranges-not-range", [this, t]);
      return this._ranges.every((a) => !a.isEqual(s));
    });
    (i.length !== this._ranges.length || r) && (this._replaceAllRanges(i), this._lastRangeBackward = !!e, this.fire("change:range", { directChange: !0 }));
  }
  setFocus(t, e) {
    if (this.anchor === null) throw new v("model-selection-setfocus-no-ranges", [this, t]);
    const i = S._createAt(t, e);
    if (i.compareWith(this.focus) == "same") return;
    const r = this.anchor;
    this._ranges.length && this._popRange(), i.compareWith(r) == "before" ? (this._pushRange(new E(i, r)), this._lastRangeBackward = !0) : (this._pushRange(new E(r, i)), this._lastRangeBackward = !1), this.fire("change:range", { directChange: !0 });
  }
  getAttribute(t) {
    return this._attrs.get(t);
  }
  getAttributes() {
    return this._attrs.entries();
  }
  getAttributeKeys() {
    return this._attrs.keys();
  }
  hasAttribute(t) {
    return this._attrs.has(t);
  }
  removeAttribute(t) {
    this.hasAttribute(t) && (this._attrs.delete(t), this.fire("change:attribute", { attributeKeys: [t], directChange: !0 }));
  }
  setAttribute(t, e) {
    this.getAttribute(t) !== e && (this._attrs.set(t, e), this.fire("change:attribute", { attributeKeys: [t], directChange: !0 }));
  }
  getSelectedElement() {
    return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
  }
  *getSelectedBlocks() {
    const t = /* @__PURE__ */ new WeakSet();
    for (const e of this.getRanges()) {
      const i = Qh(e.start, t);
      pA(i, e) && (yield i);
      const r = e.getWalker();
      for (const a of r) {
        const l = a.item;
        a.type == "elementEnd" && fA(l, t, e) ? yield l : a.type == "elementStart" && l.is("model:element") && l.root.document.model.schema.isBlock(l) && r.jumpTo(S._createAt(l, "end"));
      }
      const s = Qh(e.end, t);
      bA(s, e) && (yield s);
    }
  }
  containsEntireContent(t = this.anchor.root) {
    const e = S._createAt(t, 0), i = S._createAt(t, "end");
    return e.isTouching(this.getFirstPosition()) && i.isTouching(this.getLastPosition());
  }
  _pushRange(t) {
    this._checkRange(t), this._ranges.push(new E(t.start, t.end));
  }
  _checkRange(t) {
    for (let e = 0; e < this._ranges.length; e++) if (t.isIntersecting(this._ranges[e])) throw new v("model-selection-range-intersects", [this, t], { addedRange: t, intersectingRange: this._ranges[e] });
  }
  _replaceAllRanges(t) {
    this._removeAllRanges();
    for (const e of t) this._pushRange(e);
  }
  _removeAllRanges() {
    for (; this._ranges.length > 0; ) this._popRange();
  }
  _popRange() {
    this._ranges.pop();
  }
}
function Gk(o, n) {
  return !n.has(o) && (n.add(o), o.root.document.model.schema.isBlock(o) && !!o.parent);
}
function fA(o, n, t) {
  return Gk(o, n) && pu(o, t);
}
function Qh(o, n) {
  const t = o.parent.root.document.model.schema, e = o.parent.getAncestors({ parentFirst: !0, includeSelf: !0 });
  let i = !1;
  const r = e.find((s) => !i && (i = t.isLimit(s), !i && Gk(s, n)));
  return e.forEach((s) => n.add(s)), r;
}
function pu(o, n) {
  const t = function(e) {
    const i = e.root.document.model.schema;
    let r = e.parent;
    for (; r; ) {
      if (i.isBlock(r)) return r;
      r = r.parent;
    }
  }(o);
  return t ? !n.containsRange(E._createOn(t), !0) : !0;
}
function pA(o, n) {
  return !!o && (!(!n.isCollapsed && !o.isEmpty) || !n.start.isTouching(S._createAt(o, o.maxOffset)) && pu(o, n));
}
function bA(o, n) {
  return !!o && (!(!n.isCollapsed && !o.isEmpty) || !n.end.isTouching(S._createAt(o, 0)) && pu(o, n));
}
qe.prototype.is = function(o) {
  return o === "selection" || o === "model:selection";
};
class Ie extends vt(E) {
  constructor(n, t) {
    super(n, t), kA.call(this);
  }
  detach() {
    this.stopListening();
  }
  toRange() {
    return new E(this.start, this.end);
  }
  static fromRange(n) {
    return new Ie(n.start, n.end);
  }
}
function kA() {
  this.listenTo(this.root.document.model, "applyOperation", (o, n) => {
    const t = n[0];
    t.isDocumentOperation && wA.call(this, t);
  }, { priority: "low" });
}
function wA(o) {
  const n = this.getTransformedByOperation(o), t = E._createFromRanges(n), e = !t.isEqual(this), i = function(s, a) {
    switch (a.type) {
      case "insert":
        return s.containsPosition(a.position);
      case "move":
      case "remove":
      case "reinsert":
      case "merge":
        return s.containsPosition(a.sourcePosition) || s.start.isEqual(a.sourcePosition) || s.containsPosition(a.targetPosition);
      case "split":
        return s.containsPosition(a.splitPosition) || s.containsPosition(a.insertionPosition);
    }
    return !1;
  }(this, o);
  let r = null;
  if (e) {
    t.root.rootName == "$graveyard" && (r = o.type == "remove" ? o.sourcePosition : o.deletionPosition);
    const s = this.toRange();
    this.start = t.start, this.end = t.end, this.fire("change:range", s, { deletionPosition: r });
  } else i && this.fire("change:content", this.toRange(), { deletionPosition: r });
}
Ie.prototype.is = function(o) {
  return o === "liveRange" || o === "model:liveRange" || o == "range" || o === "model:range";
};
class Rt extends lo {
  constructor(t, e) {
    super(e);
    m(this, "_data");
    this._data = t || "";
  }
  get offsetSize() {
    return this.data.length;
  }
  get data() {
    return this._data;
  }
  toJSON() {
    const t = super.toJSON();
    return t.data = this.data, t;
  }
  _clone() {
    return new Rt(this.data, this.getAttributes());
  }
  static fromJSON(t) {
    return new Rt(t.data, t.attributes);
  }
}
Rt.prototype.is = function(o) {
  return o === "$text" || o === "model:$text" || o === "text" || o === "model:text" || o === "node" || o === "model:node";
};
const xa = "selection:";
class _n extends vt(Bi) {
  constructor(t) {
    super();
    m(this, "_selection");
    this._selection = new _A(t), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this);
  }
  get isCollapsed() {
    return this._selection.isCollapsed;
  }
  get anchor() {
    return this._selection.anchor;
  }
  get focus() {
    return this._selection.focus;
  }
  get rangeCount() {
    return this._selection.rangeCount;
  }
  get hasOwnRange() {
    return this._selection.hasOwnRange;
  }
  get isBackward() {
    return this._selection.isBackward;
  }
  get isGravityOverridden() {
    return this._selection.isGravityOverridden;
  }
  get markers() {
    return this._selection.markers;
  }
  get _ranges() {
    return this._selection._ranges;
  }
  getRanges() {
    return this._selection.getRanges();
  }
  getFirstPosition() {
    return this._selection.getFirstPosition();
  }
  getLastPosition() {
    return this._selection.getLastPosition();
  }
  getFirstRange() {
    return this._selection.getFirstRange();
  }
  getLastRange() {
    return this._selection.getLastRange();
  }
  getSelectedBlocks() {
    return this._selection.getSelectedBlocks();
  }
  getSelectedElement() {
    return this._selection.getSelectedElement();
  }
  containsEntireContent(t) {
    return this._selection.containsEntireContent(t);
  }
  destroy() {
    this._selection.destroy();
  }
  getAttributeKeys() {
    return this._selection.getAttributeKeys();
  }
  getAttributes() {
    return this._selection.getAttributes();
  }
  getAttribute(t) {
    return this._selection.getAttribute(t);
  }
  hasAttribute(t) {
    return this._selection.hasAttribute(t);
  }
  refresh() {
    this._selection.updateMarkers(), this._selection._updateAttributes(!1);
  }
  observeMarkers(t) {
    this._selection.observeMarkers(t);
  }
  _setFocus(t, e) {
    this._selection.setFocus(t, e);
  }
  _setTo(...t) {
    this._selection.setTo(...t);
  }
  _setAttribute(t, e) {
    this._selection.setAttribute(t, e);
  }
  _removeAttribute(t) {
    this._selection.removeAttribute(t);
  }
  _getStoredAttributes() {
    return this._selection.getStoredAttributes();
  }
  _overrideGravity() {
    return this._selection.overrideGravity();
  }
  _restoreGravity(t) {
    this._selection.restoreGravity(t);
  }
  static _getStoreAttributeKey(t) {
    return xa + t;
  }
  static _isStoreAttributeKey(t) {
    return t.startsWith(xa);
  }
}
_n.prototype.is = function(o) {
  return o === "selection" || o == "model:selection" || o == "documentSelection" || o == "model:documentSelection";
};
class _A extends qe {
  constructor(t) {
    super();
    m(this, "markers", new ne({ idProperty: "name" }));
    m(this, "_model");
    m(this, "_document");
    m(this, "_attributePriority", /* @__PURE__ */ new Map());
    m(this, "_selectionRestorePosition", null);
    m(this, "_hasChangedRange", !1);
    m(this, "_overriddenGravityRegister", /* @__PURE__ */ new Set());
    m(this, "_observedMarkers", /* @__PURE__ */ new Set());
    this._model = t.model, this._document = t, this.listenTo(this._model, "applyOperation", (e, i) => {
      const r = i[0];
      r.isDocumentOperation && r.type != "marker" && r.type != "rename" && r.type != "noop" && (this._ranges.length == 0 && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition), this._selectionRestorePosition = null, this._hasChangedRange && (this._hasChangedRange = !1, this.fire("change:range", { directChange: !1 })));
    }, { priority: "lowest" }), this.on("change:range", () => {
      this._validateSelectionRanges(this.getRanges());
    }), this.listenTo(this._model.markers, "update", (e, i, r, s) => {
      this._updateMarker(i, s);
    }), this.listenTo(this._document, "change", (e, i) => {
      (function(r, s) {
        const a = r.document.differ;
        for (const l of a.getChanges()) {
          if (l.type != "insert") continue;
          const c = l.position.parent;
          l.length === c.maxOffset && r.enqueueChange(s, (d) => {
            const u = Array.from(c.getAttributeKeys()).filter((h) => h.startsWith(xa));
            for (const h of u) d.removeAttribute(h, c);
          });
        }
      })(this._model, i);
    });
  }
  get isCollapsed() {
    return this._ranges.length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
  }
  get anchor() {
    return super.anchor || this._document._getDefaultRange().start;
  }
  get focus() {
    return super.focus || this._document._getDefaultRange().end;
  }
  get rangeCount() {
    return this._ranges.length ? this._ranges.length : 1;
  }
  get hasOwnRange() {
    return this._ranges.length > 0;
  }
  get isGravityOverridden() {
    return !!this._overriddenGravityRegister.size;
  }
  destroy() {
    for (let t = 0; t < this._ranges.length; t++) this._ranges[t].detach();
    this.stopListening();
  }
  *getRanges() {
    this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange();
  }
  getFirstRange() {
    return super.getFirstRange() || this._document._getDefaultRange();
  }
  getLastRange() {
    return super.getLastRange() || this._document._getDefaultRange();
  }
  setTo(...t) {
    super.setTo(...t), this._updateAttributes(!0), this.updateMarkers();
  }
  setFocus(t, e) {
    super.setFocus(t, e), this._updateAttributes(!0), this.updateMarkers();
  }
  setAttribute(t, e) {
    if (this._setAttribute(t, e)) {
      const i = [t];
      this.fire("change:attribute", { attributeKeys: i, directChange: !0 });
    }
  }
  removeAttribute(t) {
    if (this._removeAttribute(t)) {
      const e = [t];
      this.fire("change:attribute", { attributeKeys: e, directChange: !0 });
    }
  }
  overrideGravity() {
    const t = Ee();
    return this._overriddenGravityRegister.add(t), this._overriddenGravityRegister.size === 1 && this._updateAttributes(!0), t;
  }
  restoreGravity(t) {
    if (!this._overriddenGravityRegister.has(t)) throw new v("document-selection-gravity-wrong-restore", this, { uid: t });
    this._overriddenGravityRegister.delete(t), this.isGravityOverridden || this._updateAttributes(!0);
  }
  observeMarkers(t) {
    this._observedMarkers.add(t), this.updateMarkers();
  }
  _replaceAllRanges(t) {
    this._validateSelectionRanges(t), super._replaceAllRanges(t);
  }
  _popRange() {
    this._ranges.pop().detach();
  }
  _pushRange(t) {
    const e = this._prepareRange(t);
    e && this._ranges.push(e);
  }
  _validateSelectionRanges(t) {
    for (const e of t) if (!this._document._validateSelectionRange(e)) throw new v("document-selection-wrong-position", this, { range: e });
  }
  _prepareRange(t) {
    if (this._checkRange(t), t.root == this._document.graveyard) return;
    const e = Ie.fromRange(t);
    return e.on("change:range", (i, r, s) => {
      if (this._hasChangedRange = !0, e.root == this._document.graveyard) {
        this._selectionRestorePosition = s.deletionPosition;
        const a = this._ranges.indexOf(e);
        this._ranges.splice(a, 1), e.detach();
      }
    }), e;
  }
  updateMarkers() {
    if (!this._observedMarkers.size) return;
    const t = [];
    let e = !1;
    for (const r of this._model.markers) {
      const s = r.name.split(":", 1)[0];
      if (!this._observedMarkers.has(s)) continue;
      const a = r.getRange();
      for (const l of this.getRanges()) a.containsRange(l, !l.isCollapsed) && t.push(r);
    }
    const i = Array.from(this.markers);
    for (const r of t) this.markers.has(r) || (this.markers.add(r), e = !0);
    for (const r of Array.from(this.markers)) t.includes(r) || (this.markers.remove(r), e = !0);
    e && this.fire("change:marker", { oldMarkers: i, directChange: !1 });
  }
  _updateMarker(t, e) {
    const i = t.name.split(":", 1)[0];
    if (!this._observedMarkers.has(i)) return;
    let r = !1;
    const s = Array.from(this.markers), a = this.markers.has(t);
    if (e) {
      let l = !1;
      for (const c of this.getRanges()) if (e.containsRange(c, !c.isCollapsed)) {
        l = !0;
        break;
      }
      l && !a ? (this.markers.add(t), r = !0) : !l && a && (this.markers.remove(t), r = !0);
    } else a && (this.markers.remove(t), r = !0);
    r && this.fire("change:marker", { oldMarkers: s, directChange: !1 });
  }
  _updateAttributes(t) {
    const e = wn(this._getSurroundingAttributes()), i = wn(this.getAttributes());
    if (t) this._attributePriority = /* @__PURE__ */ new Map(), this._attrs = /* @__PURE__ */ new Map();
    else for (const [s, a] of this._attributePriority) a == "low" && (this._attrs.delete(s), this._attributePriority.delete(s));
    this._setAttributesTo(e);
    const r = [];
    for (const [s, a] of this.getAttributes()) i.has(s) && i.get(s) === a || r.push(s);
    for (const [s] of i) this.hasAttribute(s) || r.push(s);
    r.length > 0 && this.fire("change:attribute", { attributeKeys: r, directChange: !1 });
  }
  _setAttribute(t, e, i = !0) {
    const r = i ? "normal" : "low";
    return r == "low" && this._attributePriority.get(t) == "normal" ? !1 : super.getAttribute(t) !== e && (this._attrs.set(t, e), this._attributePriority.set(t, r), !0);
  }
  _removeAttribute(t, e = !0) {
    const i = e ? "normal" : "low";
    return (i != "low" || this._attributePriority.get(t) != "normal") && (this._attributePriority.set(t, i), !!super.hasAttribute(t) && (this._attrs.delete(t), !0));
  }
  _setAttributesTo(t) {
    const e = /* @__PURE__ */ new Set();
    for (const [i, r] of this.getAttributes()) t.get(i) !== r && this._removeAttribute(i, !1);
    for (const [i, r] of t)
      this._setAttribute(i, r, !1) && e.add(i);
    return e;
  }
  *getStoredAttributes() {
    const t = this.getFirstPosition().parent;
    if (this.isCollapsed && t.isEmpty) for (const e of t.getAttributeKeys()) e.startsWith(xa) && (yield [e.substr(10), t.getAttribute(e)]);
  }
  _getSurroundingAttributes() {
    const t = this.getFirstPosition(), e = this._model.schema;
    if (t.root.rootName == "$graveyard") return null;
    let i = null;
    if (this.isCollapsed) {
      const r = t.textNode ? t.textNode : t.nodeBefore, s = t.textNode ? t.textNode : t.nodeAfter;
      if (this.isGravityOverridden || (i = fr(r, e)), i || (i = fr(s, e)), !this.isGravityOverridden && !i) {
        let a = r;
        for (; a && !i; ) a = a.previousSibling, i = fr(a, e);
      }
      if (!i) {
        let a = s;
        for (; a && !i; ) a = a.nextSibling, i = fr(a, e);
      }
      i || (i = this.getStoredAttributes());
    } else {
      const r = this.getFirstRange();
      for (const s of r) {
        if (s.item.is("element") && e.isObject(s.item)) {
          i = fr(s.item, e);
          break;
        }
        if (s.type == "text") {
          i = s.item.getAttributes();
          break;
        }
      }
    }
    return i;
  }
  _fixGraveyardSelection(t) {
    const e = this._model.schema.getNearestSelectionRange(t);
    e && this._pushRange(e);
  }
}
function fr(o, n) {
  if (!o) return null;
  if (o instanceof gn || o instanceof Rt) return o.getAttributes();
  if (!n.isInline(o)) return null;
  if (!n.isObject(o)) return [];
  const t = [];
  for (const [e, i] of o.getAttributes()) n.checkAttribute("$text", e) && n.getAttributeProperties(e).copyFromObject !== !1 && t.push([e, i]);
  return t;
}
class Hr {
  constructor(n) {
    m(this, "_nodes", []);
    m(this, "_offsetToNode", []);
    n && this._insertNodes(0, n);
  }
  [Symbol.iterator]() {
    return this._nodes[Symbol.iterator]();
  }
  get length() {
    return this._nodes.length;
  }
  get maxOffset() {
    return this._offsetToNode.length;
  }
  getNode(n) {
    return this._nodes[n] || null;
  }
  getNodeAtOffset(n) {
    return this._offsetToNode[n] || null;
  }
  getNodeIndex(n) {
    return n.index;
  }
  getNodeStartOffset(n) {
    return n.startOffset;
  }
  indexToOffset(n) {
    if (n == this._nodes.length) return this.maxOffset;
    const t = this._nodes[n];
    if (!t) throw new v("model-nodelist-index-out-of-bounds", this);
    return this.getNodeStartOffset(t);
  }
  offsetToIndex(n) {
    if (n == this._offsetToNode.length) return this._nodes.length;
    const t = this._offsetToNode[n];
    if (!t) throw new v("model-nodelist-offset-out-of-bounds", this, { offset: n, nodeList: this });
    return this.getNodeIndex(t);
  }
  _insertNodes(n, t) {
    const e = [];
    for (const r of t) {
      if (!(r instanceof lo)) throw new v("model-nodelist-insertnodes-not-node", this);
      e.push(r);
    }
    let i = this.indexToOffset(n);
    Ph(this._nodes, e, n), Ph(this._offsetToNode, function(r) {
      const s = [];
      let a = 0;
      for (const l of r) for (let c = 0; c < l.offsetSize; c++) s[a++] = l;
      return s;
    }(e), i);
    for (let r = n; r < this._nodes.length; r++) this._nodes[r]._index = r, this._nodes[r]._startOffset = i, i += this._nodes[r].offsetSize;
  }
  _removeNodes(n, t = 1) {
    if (t == 0) return [];
    let e = this.indexToOffset(n);
    const i = this._nodes.splice(n, t), r = i[i.length - 1], s = r.startOffset + r.offsetSize - e;
    this._offsetToNode.splice(e, s);
    for (const a of i) a._index = null, a._startOffset = null;
    for (let a = n; a < this._nodes.length; a++) this._nodes[a]._index = a, this._nodes[a]._startOffset = e, e += this._nodes[a].offsetSize;
    return i;
  }
  _removeNodesArray(n) {
    if (n.length == 0) return;
    for (const e of n) e._index = null, e._startOffset = null;
    this._nodes = this._nodes.filter((e) => e.index !== null), this._offsetToNode = this._offsetToNode.filter((e) => e.index !== null);
    let t = 0;
    for (let e = 0; e < this._nodes.length; e++) this._nodes[e]._index = e, this._nodes[e]._startOffset = t, t += this._nodes[e].offsetSize;
  }
  toJSON() {
    return this._nodes.map((n) => n.toJSON());
  }
}
class Lt extends lo {
  constructor(t, e, i) {
    super(e);
    m(this, "name");
    m(this, "_children", new Hr());
    this.name = t, i && this._insertChild(0, i);
  }
  get childCount() {
    return this._children.length;
  }
  get maxOffset() {
    return this._children.maxOffset;
  }
  get isEmpty() {
    return this.childCount === 0;
  }
  getChild(t) {
    return this._children.getNode(t);
  }
  getChildAtOffset(t) {
    return this._children.getNodeAtOffset(t);
  }
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  getChildIndex(t) {
    return this._children.getNodeIndex(t);
  }
  getChildStartOffset(t) {
    return this._children.getNodeStartOffset(t);
  }
  offsetToIndex(t) {
    return this._children.offsetToIndex(t);
  }
  getNodeByPath(t) {
    let e = this;
    for (const i of t) e = e.getChildAtOffset(i);
    return e;
  }
  findAncestor(t, e = {}) {
    let i = e.includeSelf ? this : this.parent;
    for (; i; ) {
      if (i.name === t) return i;
      i = i.parent;
    }
    return null;
  }
  toJSON() {
    const t = super.toJSON();
    if (t.name = this.name, this._children.length > 0) {
      t.children = [];
      for (const e of this._children) t.children.push(e.toJSON());
    }
    return t;
  }
  _clone(t = !1) {
    const e = t ? function(i) {
      const r = [];
      for (const s of i) r.push(s._clone(!0));
      return r;
    }(this._children) : void 0;
    return new Lt(this.name, this.getAttributes(), e);
  }
  _appendChild(t) {
    this._insertChild(this.childCount, t);
  }
  _insertChild(t, e) {
    const i = function(r) {
      if (typeof r == "string") return [new Rt(r)];
      Ye(r) || (r = [r]);
      const s = [];
      for (const a of r) typeof a == "string" ? s.push(new Rt(a)) : a instanceof gn ? s.push(new Rt(a.data, a.getAttributes())) : s.push(a);
      return s;
    }(e);
    for (const r of i) r.parent !== null && r._remove(), r.parent = this;
    this._children._insertNodes(t, i);
  }
  _removeChildren(t, e = 1) {
    const i = this._children._removeNodes(t, e);
    for (const r of i) r.parent = null;
    return i;
  }
  _removeChildrenArray(t) {
    this._children._removeNodesArray(t);
    for (const e of t) e.parent = null;
  }
  static fromJSON(t) {
    let e;
    if (t.children) {
      e = [];
      for (const i of t.children) i.name ? e.push(Lt.fromJSON(i)) : e.push(Rt.fromJSON(i));
    }
    return new Lt(t.name, t.attributes, e);
  }
}
Lt.prototype.is = function(o, n) {
  return n ? n === this.name && (o === "element" || o === "model:element") : o === "element" || o === "model:element" || o === "node" || o === "model:node";
};
class Kk {
  constructor(n) {
    m(this, "_dispatchers");
    this._dispatchers = n;
  }
  add(n) {
    for (const t of this._dispatchers) n(t);
    return this;
  }
}
class vA extends Kk {
  elementToElement(n) {
    return this.add(function(t) {
      const e = tm(t.model), i = pr(t.view, "container");
      return e.attributes.length && (e.children = !0), (r) => {
        r.on(`insert:${e.name}`, CA(i, om(e)), { priority: t.converterPriority || "normal" }), (e.children || e.attributes.length) && r.on("reduceChanges", im(e), { priority: "low" });
      };
    }(n));
  }
  elementToStructure(n) {
    return this.add(function(t) {
      const e = tm(t.model), i = pr(t.view, "container");
      return e.children = !0, (r) => {
        if (r._conversionApi.schema.checkChild(e.name, "$text")) throw new v("conversion-element-to-structure-disallowed-text", r, { elementName: e.name });
        var s, a;
        r.on(`insert:${e.name}`, (s = i, a = om(e), (l, c, d) => {
          if (!a(c.item, d.consumable, { preflight: !0 })) return;
          const u = /* @__PURE__ */ new Map();
          d.writer._registerSlotFactory(/* @__PURE__ */ function(f, p, b) {
            return (k, w) => {
              const _ = k.createContainerElement("$slot");
              let y = null;
              if (w === "children") y = Array.from(f.getChildren());
              else {
                if (typeof w != "function") throw new v("conversion-slot-mode-unknown", b.dispatcher, { modeOrFilter: w });
                y = Array.from(f.getChildren()).filter((C) => w(C));
              }
              return p.set(_, y), _;
            };
          }(c.item, u, d));
          const h = s(c.item, d, c);
          if (d.writer._clearSlotFactory(), !h) return;
          (function(f, p, b) {
            const k = Array.from(p.values()).flat(), w = new Set(k);
            if (w.size != k.length) throw new v("conversion-slot-filter-overlap", b.dispatcher, { element: f });
            if (w.size != f.childCount) throw new v("conversion-slot-filter-incomplete", b.dispatcher, { element: f });
          })(c.item, u, d), a(c.item, d.consumable);
          const g = d.mapper.toViewPosition(c.range.start);
          d.mapper.bindElements(c.item, h), d.writer.insert(g, h), d.convertAttributes(c.item), function(f, p, b, k) {
            b.mapper.on("modelToViewPosition", y, { priority: "highest" });
            let w = null, _ = null;
            for ([w, _] of p) Yk(f, _, b, k), b.writer.move(b.writer.createRangeIn(w), b.writer.createPositionBefore(w)), b.writer.remove(w);
            function y(C, x) {
              const I = x.modelPosition.nodeAfter, P = _.indexOf(I);
              P < 0 || (x.viewPosition = x.mapper.findPositionIn(w, P));
            }
            b.mapper.off("modelToViewPosition", y);
          }(h, u, d, { reconversion: c.reconversion });
        }), { priority: t.converterPriority || "normal" }), r.on("reduceChanges", im(e), { priority: "low" });
      };
    }(n));
  }
  attributeToElement(n) {
    return this.add(function(t) {
      t = Ge(t);
      let e = t.model;
      typeof e == "string" && (e = { key: e });
      let i = `attribute:${e.key}`;
      if (e.name && (i += ":" + e.name), e.values) for (const s of e.values) t.view[s] = pr(t.view[s], "attribute");
      else t.view = pr(t.view, "attribute");
      const r = em(t);
      return (s) => {
        s.on(i, yA(r), { priority: t.converterPriority || "normal" });
      };
    }(n));
  }
  attributeToAttribute(n) {
    return this.add(function(t) {
      t = Ge(t);
      let e = t.model;
      typeof e == "string" && (e = { key: e });
      let i = `attribute:${e.key}`;
      if (e.name && (i += ":" + e.name), e.values) for (const s of e.values) t.view[s] = nm(t.view[s]);
      else t.view = nm(t.view);
      const r = em(t);
      return (s) => {
        var a;
        s.on(i, (a = r, (l, c, d) => {
          if (!d.consumable.test(c.item, l.name)) return;
          const u = a(c.attributeOldValue, d, c), h = a(c.attributeNewValue, d, c);
          if (!u && !h) return;
          d.consumable.consume(c.item, l.name);
          const g = d.mapper.toViewElement(c.item), f = d.writer;
          if (!g) throw new v("conversion-attribute-to-attribute-on-text", d.dispatcher, c);
          if (c.attributeOldValue !== null && u) {
            let p = u.value;
            u.key == "style" && (p = typeof u.value == "string" ? new Fr(f.document.stylesProcessor).setTo(u.value).getStylesEntries().map(([b]) => b) : Object.keys(u.value)), f.removeAttribute(u.key, p, g);
          }
          if (c.attributeNewValue !== null && h) {
            let p = h.value;
            h.key == "style" && typeof h.value == "string" && (p = Object.fromEntries(new Fr(f.document.stylesProcessor).setTo(h.value).getStylesEntries())), f.setAttribute(h.key, p, !1, g);
          }
        }), { priority: t.converterPriority || "normal" });
      };
    }(n));
  }
  markerToElement(n) {
    return this.add(function(t) {
      const e = pr(t.view, "ui");
      return (i) => {
        i.on(`addMarker:${t.model}`, AA(e), { priority: t.converterPriority || "normal" }), i.on(`removeMarker:${t.model}`, (r, s, a) => {
          const l = a.mapper.markerNameToElements(s.markerName);
          if (l) {
            for (const c of l) a.mapper.unbindElementFromMarkerName(c, s.markerName), a.writer.clear(a.writer.createRangeOn(c), c);
            a.writer.clearClonedElementsGroup(s.markerName), r.stop();
          }
        }, { priority: t.converterPriority || "normal" });
      };
    }(n));
  }
  markerToHighlight(n) {
    return this.add(/* @__PURE__ */ function(t) {
      return (e) => {
        var i;
        e.on(`addMarker:${t.model}`, (i = t.view, (r, s, a) => {
          if (!s.item || !(s.item instanceof qe || s.item instanceof _n || s.item.is("$textProxy"))) return;
          const l = Ol(i, s, a);
          if (!l || !a.consumable.consume(s.item, r.name)) return;
          const c = a.writer, d = Jh(c, l), u = c.document.selection;
          if (s.item instanceof qe || s.item instanceof _n) c.wrap(u.getFirstRange(), d);
          else {
            const h = a.mapper.toViewRange(s.range), g = c.wrap(h, d);
            for (const f of g.getItems()) if (f.is("attributeElement") && f.isSimilar(d)) {
              a.mapper.bindElementToMarker(f, s.markerName);
              break;
            }
          }
        }), { priority: t.converterPriority || "normal" }), e.on(`addMarker:${t.model}`, /* @__PURE__ */ function(r) {
          return (s, a, l) => {
            if (!a.item || !(a.item instanceof Lt)) return;
            const c = Ol(r, a, l);
            if (!c || !l.consumable.test(a.item, s.name)) return;
            const d = l.mapper.toViewElement(a.item);
            if (d && d.getCustomProperty("addHighlight")) {
              l.consumable.consume(a.item, s.name);
              for (const u of E._createIn(a.item)) l.consumable.consume(u.item, s.name);
              d.getCustomProperty("addHighlight")(d, c, l.writer), l.mapper.bindElementToMarker(d, a.markerName);
            }
          };
        }(t.view), { priority: t.converterPriority || "normal" }), e.on(`removeMarker:${t.model}`, /* @__PURE__ */ function(r) {
          return (s, a, l) => {
            if (a.markerRange.isCollapsed) return;
            const c = Ol(r, a, l);
            if (!c) return;
            const d = Jh(l.writer, c), u = l.mapper.markerNameToElements(a.markerName);
            if (u) {
              for (const h of u) l.mapper.unbindElementFromMarkerName(h, a.markerName), h.is("attributeElement") ? l.writer.unwrap(l.writer.createRangeOn(h), d) : h.getCustomProperty("removeHighlight")(h, c.id, l.writer);
              l.writer.clearClonedElementsGroup(a.markerName), s.stop();
            }
          };
        }(t.view), { priority: t.converterPriority || "normal" });
      };
    }(n));
  }
  markerToData(n) {
    return this.add(function(t) {
      t = Ge(t);
      const e = t.model;
      let i = t.view;
      return i || (i = (r) => ({ group: e, name: r.substr(t.model.length + 1) })), (r) => {
        var s;
        r.on(`addMarker:${e}`, (s = i, (a, l, c) => {
          const d = s(l.markerName, c);
          if (!d) return;
          const u = l.markerRange;
          c.consumable.consume(u, a.name) && (Xh(u, !1, c, l, d), Xh(u, !0, c, l, d), a.stop());
        }), { priority: t.converterPriority || "normal" }), r.on(`removeMarker:${e}`, /* @__PURE__ */ function(a) {
          return (l, c, d) => {
            const u = a(c.markerName, d);
            if (!u) return;
            const h = d.mapper.markerNameToElements(c.markerName);
            if (h) {
              for (const f of h) d.mapper.unbindElementFromMarkerName(f, c.markerName), f.is("containerElement") ? (g(`data-${u.group}-start-before`, f), g(`data-${u.group}-start-after`, f), g(`data-${u.group}-end-before`, f), g(`data-${u.group}-end-after`, f)) : d.writer.clear(d.writer.createRangeOn(f), f);
              d.writer.clearClonedElementsGroup(c.markerName), l.stop();
            }
            function g(f, p) {
              if (p.hasAttribute(f)) {
                const b = new Set(p.getAttribute(f).split(","));
                b.delete(u.name), b.size == 0 ? d.writer.removeAttribute(f, p) : d.writer.setAttribute(f, Array.from(b).join(","), p);
              }
            }
          };
        }(i), { priority: t.converterPriority || "normal" });
      };
    }(n));
  }
}
function Jh(o, n) {
  const t = o.createAttributeElement("span", n.attributes);
  return n.classes && t._addClass(n.classes), typeof n.priority == "number" && (t._priority = n.priority), t._id = n.id, t;
}
function yA(o) {
  return (n, t, e) => {
    if (!e.consumable.test(t.item, n.name)) return;
    const i = o(t.attributeOldValue, e, t), r = o(t.attributeNewValue, e, t);
    if (!i && !r) return;
    e.consumable.consume(t.item, n.name);
    const s = e.writer, a = s.document.selection;
    if (t.item instanceof qe || t.item instanceof _n) s.wrap(a.getFirstRange(), r);
    else {
      let l = e.mapper.toViewRange(t.range);
      t.attributeOldValue !== null && i && (l = s.unwrap(l, i)), t.attributeNewValue !== null && r && s.wrap(l, r);
    }
  };
}
function CA(o, n = EA) {
  return (t, e, i) => {
    if (!n(e.item, i.consumable, { preflight: !0 })) return;
    const r = o(e.item, i, e);
    if (!r) return;
    n(e.item, i.consumable);
    const s = i.mapper.toViewPosition(e.range.start);
    i.mapper.bindElements(e.item, r), i.writer.insert(s, r), i.convertAttributes(e.item), Yk(r, e.item.getChildren(), i, { reconversion: e.reconversion });
  };
}
function AA(o) {
  return (n, t, e) => {
    t.isOpening = !0;
    const i = o(t, e);
    t.isOpening = !1;
    const r = o(t, e);
    if (!i || !r) return;
    const s = t.markerRange;
    if (s.isCollapsed && !e.consumable.consume(s, n.name)) return;
    for (const c of s) if (!e.consumable.consume(c.item, n.name)) return;
    const a = e.mapper, l = e.writer;
    l.insert(a.toViewPosition(s.start), i), e.mapper.bindElementToMarker(i, t.markerName), s.isCollapsed || (l.insert(a.toViewPosition(s.end), r), e.mapper.bindElementToMarker(r, t.markerName)), n.stop();
  };
}
function Xh(o, n, t, e, i) {
  const r = n ? o.start : o.end, s = r.nodeAfter && r.nodeAfter.is("element") ? r.nodeAfter : null, a = r.nodeBefore && r.nodeBefore.is("element") ? r.nodeBefore : null;
  if (s || a) {
    let l, c;
    n && s || !n && !a ? (l = s, c = !0) : (l = a, c = !1);
    const d = t.mapper.toViewElement(l);
    if (d) return void function(u, h, g, f, p, b) {
      const k = `data-${b.group}-${h ? "start" : "end"}-${g ? "before" : "after"}`, w = u.hasAttribute(k) ? u.getAttribute(k).split(",") : [];
      w.unshift(b.name), f.writer.setAttribute(k, w.join(","), u), f.mapper.bindElementToMarker(u, p.markerName);
    }(d, n, c, t, e, i);
  }
  (function(l, c, d, u, h) {
    const g = `${h.group}-${c ? "start" : "end"}`, f = h.name ? { name: h.name } : null, p = d.writer.createUIElement(g, f);
    d.writer.insert(l, p), d.mapper.bindElementToMarker(p, u.markerName);
  })(t.mapper.toViewPosition(r), n, t, e, i);
}
function tm(o) {
  return typeof o == "string" && (o = { name: o }), { name: o.name, attributes: o.attributes ? Bt(o.attributes) : [], children: !!o.children };
}
function pr(o, n) {
  return typeof o == "function" ? o : (t, e) => function(i, r, s) {
    typeof i == "string" && (i = { name: i });
    let a;
    const l = r.writer, c = Object.assign({}, i.attributes);
    if (s == "container") a = l.createContainerElement(i.name, c);
    else if (s == "attribute") {
      const d = { priority: i.priority || Qi.DEFAULT_PRIORITY };
      a = l.createAttributeElement(i.name, c, d);
    } else a = l.createUIElement(i.name, c);
    if (i.styles) {
      const d = Object.keys(i.styles);
      for (const u of d) l.setStyle(u, i.styles[u], a);
    }
    if (i.classes) {
      const d = i.classes;
      if (typeof d == "string") l.addClass(d, a);
      else for (const u of d) l.addClass(u, a);
    }
    return a;
  }(o, e, n);
}
function em(o) {
  return o.model.values ? (n, t, e) => {
    const i = o.view[n];
    return i ? i(n, t, e) : null;
  } : o.view;
}
function nm(o) {
  return typeof o == "string" ? (n) => ({ key: o, value: n }) : typeof o == "object" ? o.value ? () => o : (n) => ({ key: o.key, value: n }) : o;
}
function Ol(o, n, t) {
  const e = typeof o == "function" ? o(n, t) : o;
  return e ? (e.priority || (e.priority = 10), e.id || (e.id = n.markerName), e) : null;
}
function im(o) {
  const n = /* @__PURE__ */ function(t) {
    return (e, i) => {
      if (!e.is("element", t.name)) return !1;
      if (i.type == "attribute") {
        if (t.attributes.includes(i.attributeKey)) return !0;
      } else if (t.children) return !0;
      return !1;
    };
  }(o);
  return (t, e) => {
    const i = [];
    e.reconvertedElements || (e.reconvertedElements = /* @__PURE__ */ new Set());
    for (const r of e.changes) {
      const s = r.type == "attribute" ? r.range.start.nodeAfter : r.position.parent;
      if (s && n(s, r)) {
        if (!e.reconvertedElements.has(s)) {
          e.reconvertedElements.add(s);
          const a = S._createBefore(s);
          let l = i.length;
          for (let c = i.length - 1; c >= 0; c--) {
            const d = i[c], u = (d.type == "attribute" ? d.range.start : d.position).compareWith(a);
            if (u == "before" || d.type == "remove" && u == "same") break;
            l = c;
          }
          i.splice(l, 0, { type: "remove", name: s.name, position: a, length: 1 }, { type: "reinsert", name: s.name, position: a, length: 1 });
        }
      } else i.push(r);
    }
    e.changes = i;
  };
}
function om(o) {
  return (n, t, e = {}) => {
    const i = ["insert"];
    for (const r of o.attributes) n.hasAttribute(r) && i.push(`attribute:${r}`);
    return !!i.every((r) => t.test(n, r)) && (e.preflight || i.forEach((r) => t.consume(n, r)), !0);
  };
}
function Yk(o, n, t, e) {
  for (const i of n) xA(o.root, i, t, e) || t.convertItem(i);
}
function xA(o, n, t, e) {
  const { writer: i, mapper: r } = t;
  if (!e.reconversion) return !1;
  const s = r.toViewElement(n);
  return !(!s || s.root == o) && !!t.canReuseView(s) && (i.move(i.createRangeOn(s), r.toViewPosition(S._createBefore(n))), !0);
}
function EA(o, n, { preflight: t } = {}) {
  return t ? n.test(o, "insert") : n.consume(o, "insert");
}
function Zk(o) {
  const { schema: n, document: t } = o.model;
  for (const e of t.getRoots()) if (e.isEmpty && !n.checkChild(e, "$text") && n.checkChild(e, "paragraph")) return o.insertElement("paragraph", e), !0;
  return !1;
}
function Qk(o, n, t) {
  const e = t.createContext(o);
  return !!t.checkChild(e, "paragraph") && !!t.checkChild(e.push("paragraph"), n);
}
function Jk(o, n) {
  const t = n.createElement("paragraph");
  return n.insert(t, o), n.createPositionAt(t, 0);
}
class TA extends Kk {
  elementToElement(n) {
    return this.add(rm(n));
  }
  elementToAttribute(n) {
    return this.add(function(t) {
      t = Ge(t), sm(t);
      const e = am(t, !1), i = bu(t.view), r = i ? `element:${i}` : "element";
      return (s) => {
        s.on(r, e, { priority: t.converterPriority || "low" });
      };
    }(n));
  }
  attributeToAttribute(n) {
    return this.add(function(t) {
      t = Ge(t);
      let e = null;
      (typeof t.view == "string" || t.view.key) && (e = function(r) {
        typeof r.view == "string" && (r.view = { key: r.view });
        const s = r.view.key, a = r.view.value === void 0 ? /[\s\S]*/ : r.view.value;
        let l;
        return s == "class" || s == "style" ? l = { [s == "class" ? "classes" : "styles"]: a } : l = { attributes: { [s]: a } }, r.view.name && (l.name = r.view.name), r.view = l, s;
      }(t)), sm(t, e);
      const i = am(t, !0);
      return (r) => {
        r.on("element", i, { priority: t.converterPriority || "low" });
      };
    }(n));
  }
  elementToMarker(n) {
    return this.add(function(t) {
      const e = /* @__PURE__ */ function(i) {
        return (r, s) => {
          const a = typeof i == "string" ? i : i(r, s);
          return s.writer.createElement("$marker", { "data-name": a });
        };
      }(t.model);
      return rm({ ...t, model: e });
    }(n));
  }
  dataToMarker(n) {
    return this.add(function(t) {
      t = Ge(t), t.model || (t.model = (s) => s ? t.view + ":" + s : t.view);
      const e = { view: t.view, model: t.model }, i = td(lm(e, "start")), r = td(lm(e, "end"));
      return (s) => {
        s.on(`element:${t.view}-start`, i, { priority: t.converterPriority || "normal" }), s.on(`element:${t.view}-end`, r, { priority: t.converterPriority || "normal" });
        const a = Ci.low, l = Ci.highest, c = Ci.get(t.converterPriority) / l;
        s.on("element", /* @__PURE__ */ function(d) {
          return (u, h, g) => {
            const f = `data-${d.view}`;
            function p(b, k) {
              for (const w of k) {
                const _ = d.model(w, g), y = g.writer.createElement("$marker", { "data-name": _ });
                g.writer.insert(y, b), h.modelCursor.isEqual(b) ? h.modelCursor = h.modelCursor.getShiftedBy(1) : h.modelCursor = h.modelCursor._getTransformedByInsertion(b, 1), h.modelRange = h.modelRange._getTransformedByInsertion(b, 1)[0];
              }
            }
            (g.consumable.test(h.viewItem, { attributes: f + "-end-after" }) || g.consumable.test(h.viewItem, { attributes: f + "-start-after" }) || g.consumable.test(h.viewItem, { attributes: f + "-end-before" }) || g.consumable.test(h.viewItem, { attributes: f + "-start-before" })) && (h.modelRange || Object.assign(h, g.convertChildren(h.viewItem, h.modelCursor)), g.consumable.consume(h.viewItem, { attributes: f + "-end-after" }) && p(h.modelRange.end, h.viewItem.getAttribute(f + "-end-after").split(",")), g.consumable.consume(h.viewItem, { attributes: f + "-start-after" }) && p(h.modelRange.end, h.viewItem.getAttribute(f + "-start-after").split(",")), g.consumable.consume(h.viewItem, { attributes: f + "-end-before" }) && p(h.modelRange.start, h.viewItem.getAttribute(f + "-end-before").split(",")), g.consumable.consume(h.viewItem, { attributes: f + "-start-before" }) && p(h.modelRange.start, h.viewItem.getAttribute(f + "-start-before").split(",")));
          };
        }(e), { priority: a + c });
      };
    }(n));
  }
}
function rm(o) {
  const n = td(o = Ge(o)), t = bu(o.view), e = t ? `element:${t}` : "element";
  return (i) => {
    i.on(e, n, { priority: o.converterPriority || "normal" });
  };
}
function bu(o) {
  return typeof o == "string" ? o : typeof o == "object" && typeof o.name == "string" ? o.name : null;
}
function td(o) {
  const n = new We(o.view);
  return (t, e, i) => {
    const r = n.match(e.viewItem);
    if (!r) return;
    const s = r.match;
    if (s.name = !0, !i.consumable.test(e.viewItem, s)) return;
    const a = function(l, c, d) {
      return l instanceof Function ? l(c, d) : d.writer.createElement(l);
    }(o.model, e.viewItem, i);
    a && i.safeInsert(a, e.modelCursor) && (i.consumable.consume(e.viewItem, s), i.convertChildren(e.viewItem, a), i.updateConversionResult(a, e));
  };
}
function sm(o, n = null) {
  const t = n === null || ((r) => r.getAttribute(n)), e = typeof o.model != "object" ? o.model : o.model.key, i = typeof o.model != "object" || o.model.value === void 0 ? t : o.model.value;
  o.model = { key: e, value: i };
}
function am(o, n) {
  const t = new We(o.view);
  return (e, i, r) => {
    if (!i.modelRange && n) return;
    const s = t.match(i.viewItem);
    if (!s || (function(d, u) {
      const h = typeof d == "function" ? d(u) : d;
      return typeof h == "object" && !bu(h) ? !1 : !h.classes && !h.attributes && !h.styles;
    }(o.view, i.viewItem) ? s.match.name = !0 : delete s.match.name, !r.consumable.test(i.viewItem, s.match))) return;
    const a = o.model.key, l = typeof o.model.value == "function" ? o.model.value(i.viewItem, r, i) : o.model.value;
    if (l === null) return;
    i.modelRange || Object.assign(i, r.convertChildren(i.viewItem, i.modelCursor)), function(d, u, h, g) {
      let f = !1;
      for (const p of Array.from(d.getItems({ shallow: h }))) g.schema.checkAttribute(p, u.key) && (f = !0, p.hasAttribute(u.key) || g.writer.setAttribute(u.key, u.value, p));
      return f;
    }(i.modelRange, { key: a, value: l }, n, r) && (r.consumable.test(i.viewItem, { name: !0 }) && (s.match.name = !0), r.consumable.consume(i.viewItem, s.match));
  };
}
function lm(o, n) {
  return { view: `${o.view}-${n}`, model: (t, e) => {
    const i = t.getAttribute("name"), r = o.model(i, e);
    return e.writer.createElement("$marker", { "data-name": r });
  } };
}
function SA(o) {
  o.document.registerPostFixer((n) => function(t, e) {
    const i = e.document.selection, r = e.schema, s = [];
    let a = !1;
    for (const l of i.getRanges()) {
      const c = Xk(l, r);
      c && !c.isEqual(l) ? (s.push(c), a = !0) : s.push(l);
    }
    return a && t.setSelection(function(l) {
      const c = [...l], d = /* @__PURE__ */ new Set();
      let u = 1;
      for (; u < c.length; ) {
        const h = c[u], g = c.slice(0, u);
        for (const [f, p] of g.entries()) if (!d.has(f)) {
          if (h.isEqual(p)) d.add(f);
          else if (h.isIntersecting(p)) {
            d.add(f), d.add(u);
            const b = h.getJoined(p);
            c.push(b);
          }
        }
        u++;
      }
      return c.filter((h, g) => !d.has(g));
    }(s), { backward: i.isBackward }), !1;
  }(n, o));
}
function Xk(o, n) {
  return o.isCollapsed ? function(t, e) {
    const i = t.start, r = e.getNearestSelectionRange(i);
    if (!r) {
      const a = i.getAncestors().reverse().find((l) => e.isObject(l));
      return a ? E._createOn(a) : null;
    }
    if (!r.isCollapsed) return r;
    const s = r.start;
    return i.isEqual(s) ? null : new E(s);
  }(o, n) : function(t, e) {
    const { start: i, end: r } = t, s = e.checkChild(i, "$text"), a = e.checkChild(r, "$text"), l = e.getLimitElement(i), c = e.getLimitElement(r);
    if (l === c) {
      if (s && a) return null;
      if (function(h, g, f) {
        const p = h.nodeAfter && !f.isLimit(h.nodeAfter) || f.checkChild(h, "$text"), b = g.nodeBefore && !f.isLimit(g.nodeBefore) || f.checkChild(g, "$text");
        return p || b;
      }(i, r, e)) {
        const h = i.nodeAfter && e.isSelectable(i.nodeAfter) ? null : e.getNearestSelectionRange(i, "forward"), g = r.nodeBefore && e.isSelectable(r.nodeBefore) ? null : e.getNearestSelectionRange(r, "backward"), f = h ? h.start : i, p = g ? g.end : r;
        return new E(f, p);
      }
    }
    const d = l && !l.is("rootElement"), u = c && !c.is("rootElement");
    if (d || u) {
      const h = i.nodeAfter && r.nodeBefore && i.nodeAfter.parent === r.nodeBefore.parent, g = d && (!h || !dm(i.nodeAfter, e)), f = u && (!h || !dm(r.nodeBefore, e));
      let p = i, b = r;
      return g && (p = S._createBefore(cm(l, e))), f && (b = S._createAfter(cm(c, e))), new E(p, b);
    }
    return null;
  }(o, n);
}
function cm(o, n) {
  let t = o, e = t;
  for (; n.isLimit(e) && e.parent; ) t = e, e = e.parent;
  return t;
}
function dm(o, n) {
  return o && n.isSelectable(o);
}
class IA extends _t() {
  constructor(t, e) {
    super();
    m(this, "model");
    m(this, "view");
    m(this, "mapper");
    m(this, "downcastDispatcher");
    this.model = t, this.view = new uA(e), this.mapper = new qk(), this.downcastDispatcher = new Wk({ mapper: this.mapper, schema: t.schema });
    const i = this.model.document, r = i.selection, s = this.model.markers;
    var a, l, c;
    this.listenTo(this.model, "_beforeChanges", () => {
      this.view._disableRendering(!0);
    }, { priority: "highest" }), this.listenTo(this.model, "_afterChanges", () => {
      this.view._disableRendering(!1);
    }, { priority: "lowest" }), this.listenTo(i, "change", () => {
      this.view.change((d) => {
        this.downcastDispatcher.convertChanges(i.differ, s, d), this.downcastDispatcher.convertSelection(r, s, d);
      });
    }, { priority: "low" }), this.listenTo(this.view.document, "selectionChange", /* @__PURE__ */ function(d, u) {
      return (h, g) => {
        const f = g.newSelection, p = [];
        for (const k of f.getRanges()) p.push(u.toModelRange(k));
        const b = d.createSelection(p, { backward: f.isBackward });
        b.isEqual(d.document.selection) || d.change((k) => {
          k.setSelection(b);
        });
      };
    }(this.model, this.mapper)), this.listenTo(this.view.document, "beforeinput", (a = this.mapper, l = this.model.schema, c = this.view, (d, u) => {
      if (!c.document.isComposing || H.isAndroid) for (let h = 0; h < u.targetRanges.length; h++) {
        const g = u.targetRanges[h], f = a.toModelRange(g), p = Xk(f, l);
        p && !p.isEqual(f) && (u.targetRanges[h] = a.toViewRange(p));
      }
    }), { priority: "high" }), this.downcastDispatcher.on("insert:$text", (d, u, h) => {
      if (!h.consumable.consume(u.item, d.name)) return;
      const g = h.writer, f = h.mapper.toViewPosition(u.range.start), p = g.createText(u.item.data);
      g.insert(f, p);
    }, { priority: "lowest" }), this.downcastDispatcher.on("insert", (d, u, h) => {
      h.convertAttributes(u.item), u.reconversion || !u.item.is("element") || u.item.isEmpty || h.convertChildren(u.item);
    }, { priority: "lowest" }), this.downcastDispatcher.on("remove", (d, u, h) => {
      const g = h.mapper.toViewPosition(u.position), f = u.position.getShiftedBy(u.length), p = h.mapper.toViewPosition(f, { isPhantom: !0 }), b = h.writer.createRange(g, p), k = h.writer.remove(b.getTrimmed());
      for (const w of h.writer.createRangeIn(k).getItems()) h.mapper.unbindViewElement(w, { defer: !0 });
    }, { priority: "low" }), this.downcastDispatcher.on("cleanSelection", (d, u, h) => {
      const g = h.writer, f = g.document.selection;
      for (const p of f.getRanges()) p.isCollapsed && p.end.parent.isAttached() && h.writer.mergeAttributes(p.start);
      g.setSelection(null);
    }), this.downcastDispatcher.on("selection", (d, u, h) => {
      const g = u.selection;
      if (g.isCollapsed || !h.consumable.consume(g, "selection")) return;
      const f = [];
      for (const p of g.getRanges()) f.push(h.mapper.toViewRange(p));
      h.writer.setSelection(f, { backward: g.isBackward });
    }, { priority: "low" }), this.downcastDispatcher.on("selection", (d, u, h) => {
      const g = u.selection;
      if (!g.isCollapsed || !h.consumable.consume(g, "selection")) return;
      const f = h.writer, p = g.getFirstPosition(), b = h.mapper.toViewPosition(p), k = f.breakAttributes(b);
      f.setSelection(k);
    }, { priority: "low" }), this.view.document.roots.bindTo(this.model.document.roots).using((d) => {
      if (d.rootName == "$graveyard") return null;
      const u = new Lk(this.view.document, d.name);
      return u.rootName = d.rootName, this.mapper.bindElements(d, u), u;
    });
  }
  destroy() {
    this.view.destroy(), this.stopListening();
  }
  reconvertMarker(t) {
    const e = typeof t == "string" ? t : t.name, i = this.model.markers.get(e);
    if (!i) throw new v("editingcontroller-reconvertmarker-marker-not-exist", this, { markerName: e });
    this.model.change(() => {
      this.model.markers._refresh(i);
    });
  }
  reconvertItem(t) {
    this.model.change(() => {
      this.model.document.differ._refreshItem(t);
    });
  }
}
class MA extends _t() {
  constructor() {
    super();
    m(this, "_sourceDefinitions", {});
    m(this, "_attributeProperties", /* @__PURE__ */ Object.create(null));
    m(this, "_customChildChecks", /* @__PURE__ */ new Map());
    m(this, "_customAttributeChecks", /* @__PURE__ */ new Map());
    m(this, "_genericCheckSymbol", Symbol("$generic"));
    m(this, "_compiledDefinitions");
    this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", (t, e) => {
      e[0] = new Ai(e[0]);
    }, { priority: "highest" }), this.on("checkChild", (t, e) => {
      e[0] = new Ai(e[0]), e[1] = this.getDefinition(e[1]);
    }, { priority: "highest" });
  }
  register(t, e) {
    if (this._sourceDefinitions[t]) throw new v("schema-cannot-register-item-twice", this, { itemName: t });
    this._sourceDefinitions[t] = [Object.assign({}, e)], this._clearCache();
  }
  extend(t, e) {
    if (!this._sourceDefinitions[t]) throw new v("schema-cannot-extend-missing-item", this, { itemName: t });
    this._sourceDefinitions[t].push(Object.assign({}, e)), this._clearCache();
  }
  getDefinitions() {
    return this._compiledDefinitions || this._compile(), this._compiledDefinitions;
  }
  getDefinition(t) {
    let e;
    return e = typeof t == "string" ? t : "is" in t && (t.is("$text") || t.is("$textProxy")) ? "$text" : t.name, this.getDefinitions()[e];
  }
  isRegistered(t) {
    return !!this.getDefinition(t);
  }
  isBlock(t) {
    const e = this.getDefinition(t);
    return !(!e || !e.isBlock);
  }
  isLimit(t) {
    const e = this.getDefinition(t);
    return !!e && !(!e.isLimit && !e.isObject);
  }
  isObject(t) {
    const e = this.getDefinition(t);
    return !!e && !!(e.isObject || e.isLimit && e.isSelectable && e.isContent);
  }
  isInline(t) {
    const e = this.getDefinition(t);
    return !(!e || !e.isInline);
  }
  isSelectable(t) {
    const e = this.getDefinition(t);
    return !!e && !(!e.isSelectable && !e.isObject);
  }
  isContent(t) {
    const e = this.getDefinition(t);
    return !!e && !(!e.isContent && !e.isObject);
  }
  checkChild(t, e) {
    return !!e && this._checkContextMatch(t, e);
  }
  checkAttribute(t, e) {
    const i = this.getDefinition(t.last);
    if (!i) return !1;
    const r = this._evaluateAttributeChecks(t, e);
    return r !== void 0 ? r : i.allowAttributes.includes(e);
  }
  checkMerge(t, e) {
    if (t instanceof S) {
      const i = t.nodeBefore, r = t.nodeAfter;
      if (!(i instanceof Lt)) throw new v("schema-check-merge-no-element-before", this);
      if (!(r instanceof Lt)) throw new v("schema-check-merge-no-element-after", this);
      return this.checkMerge(i, r);
    }
    if (this.isLimit(t) || this.isLimit(e)) return !1;
    for (const i of e.getChildren()) if (!this.checkChild(t, i)) return !1;
    return !0;
  }
  addChildCheck(t, e) {
    const i = e !== void 0 ? e : this._genericCheckSymbol, r = this._customChildChecks.get(i) || [];
    r.push(t), this._customChildChecks.set(i, r);
  }
  addAttributeCheck(t, e) {
    const i = e !== void 0 ? e : this._genericCheckSymbol, r = this._customAttributeChecks.get(i) || [];
    r.push(t), this._customAttributeChecks.set(i, r);
  }
  setAttributeProperties(t, e) {
    this._attributeProperties[t] = Object.assign(this.getAttributeProperties(t), e);
  }
  getAttributeProperties(t) {
    return this._attributeProperties[t] || /* @__PURE__ */ Object.create(null);
  }
  getLimitElement(t) {
    let e;
    for (t instanceof S ? e = t.parent : e = (t instanceof E ? [t] : Array.from(t.getRanges())).reduce((i, r) => {
      const s = r.getCommonAncestor();
      return i ? i.getCommonAncestor(s, { includeSelf: !0 }) : s;
    }, null); !this.isLimit(e) && e.parent; ) e = e.parent;
    return e;
  }
  checkAttributeInSelection(t, e) {
    if (t.isCollapsed) {
      const i = [...t.getFirstPosition().getAncestors(), new Rt("", t.getAttributes())];
      return this.checkAttribute(i, e);
    }
    {
      const i = t.getRanges();
      for (const r of i) for (const s of r) if (this.checkAttribute(s.item, e)) return !0;
    }
    return !1;
  }
  *getValidRanges(t, e) {
    t = function* (i) {
      for (const r of i) yield* r.getMinimalFlatRanges();
    }(t);
    for (const i of t) yield* this._getValidRangesForRange(i, e);
  }
  getNearestSelectionRange(t, e = "both") {
    if (t.root.rootName == "$graveyard") return null;
    if (this.checkChild(t, "$text")) return new E(t);
    let i, r;
    const s = t.getAncestors().reverse().find((a) => this.isLimit(a)) || t.root;
    e != "both" && e != "backward" || (i = new Jn({ boundaries: E._createIn(s), startPosition: t, direction: "backward" })), e != "both" && e != "forward" || (r = new Jn({ boundaries: E._createIn(s), startPosition: t }));
    for (const a of function* (l, c) {
      let d = !1;
      for (; !d; ) {
        if (d = !0, l) {
          const u = l.next();
          u.done || (d = !1, yield { walker: l, value: u.value });
        }
        if (c) {
          const u = c.next();
          u.done || (d = !1, yield { walker: c, value: u.value });
        }
      }
    }(i, r)) {
      const l = a.walker == i ? "elementEnd" : "elementStart", c = a.value;
      if (c.type == l && this.isObject(c.item)) return E._createOn(c.item);
      if (this.checkChild(c.nextPosition, "$text")) return new E(c.nextPosition);
    }
    return null;
  }
  findAllowedParent(t, e) {
    let i = t.parent;
    for (; i; ) {
      if (this.checkChild(i, e)) return i;
      if (this.isLimit(i)) return null;
      i = i.parent;
    }
    return null;
  }
  setAllowedAttributes(t, e, i) {
    const r = i.model;
    for (const [s, a] of Object.entries(e)) r.schema.checkAttribute(t, s) && i.setAttribute(s, a, t);
  }
  removeDisallowedAttributes(t, e) {
    for (const i of t) if (i.is("$text")) um(this, i, e);
    else {
      const r = E._createIn(i).getPositions();
      for (const s of r)
        um(this, s.nodeBefore || s.parent, e);
    }
  }
  getAttributesWithProperty(t, e, i) {
    const r = {};
    for (const [s, a] of t.getAttributes()) {
      const l = this.getAttributeProperties(s);
      l[e] !== void 0 && (i !== void 0 && i !== l[e] || (r[s] = a));
    }
    return r;
  }
  createContext(t) {
    return new Ai(t);
  }
  _clearCache() {
    this._compiledDefinitions = null;
  }
  _compile() {
    const t = {}, e = this._sourceDefinitions, i = Object.keys(e);
    for (const s of i) t[s] = DA(e[s], s);
    const r = Object.values(t);
    for (const s of r) PA(t, s), LA(t, s), BA(t, s), NA(t, s);
    for (const s of r) zA(t, s);
    for (const s of r) OA(t, s);
    for (const s of r) RA(t, s);
    for (const s of r) VA(t, s);
    for (const s of r) FA(t, s);
    this._compiledDefinitions = function(s) {
      const a = {};
      for (const l of Object.values(s)) a[l.name] = { name: l.name, isBlock: !!l.isBlock, isContent: !!l.isContent, isInline: !!l.isInline, isLimit: !!l.isLimit, isObject: !!l.isObject, isSelectable: !!l.isSelectable, allowIn: Array.from(l.allowIn).filter((c) => !!s[c]), allowChildren: Array.from(l.allowChildren).filter((c) => !!s[c]), allowAttributes: Array.from(l.allowAttributes) };
      return a;
    }(t);
  }
  _checkContextMatch(t, e) {
    const i = t.last;
    let r = this._evaluateChildChecks(t, e);
    if (r = r !== void 0 ? r : e.allowIn.includes(i.name), !r) return !1;
    const s = this.getDefinition(i), a = t.trimLast();
    return !!s && (a.length == 0 || this._checkContextMatch(a, s));
  }
  _evaluateChildChecks(t, e) {
    const i = this._customChildChecks.get(this._genericCheckSymbol) || [], r = this._customChildChecks.get(e.name) || [];
    for (const s of [...i, ...r]) {
      const a = s(t, e);
      if (a !== void 0) return a;
    }
  }
  _evaluateAttributeChecks(t, e) {
    const i = this._customAttributeChecks.get(this._genericCheckSymbol) || [], r = this._customAttributeChecks.get(e) || [];
    for (const s of [...i, ...r]) {
      const a = s(t, e);
      if (a !== void 0) return a;
    }
  }
  *_getValidRangesForRange(t, e) {
    let i = t.start, r = t.start;
    for (const s of t.getItems({ shallow: !0 })) s.is("element") && (yield* this._getValidRangesForRange(E._createIn(s), e)), this.checkAttribute(s, e) || (i.isEqual(r) || (yield new E(i, r)), i = S._createAfter(s)), r = S._createAfter(s);
    i.isEqual(r) || (yield new E(i, r));
  }
  findOptimalInsertionRange(t, e) {
    const i = t.getSelectedElement();
    if (i && this.isObject(i) && !this.isInline(i)) return e == "before" || e == "after" ? new E(S._createAt(i, e)) : E._createOn(i);
    const r = yt(t.getSelectedBlocks());
    if (!r) return new E(t.focus);
    if (r.isEmpty) return new E(S._createAt(r, 0));
    const s = S._createAfter(r);
    return t.focus.isTouching(s) ? new E(s) : new E(S._createBefore(r));
  }
}
class Ai {
  constructor(n) {
    m(this, "_items");
    if (n instanceof Ai) return n;
    let t;
    t = typeof n == "string" ? [n] : Array.isArray(n) ? n : n.getAncestors({ includeSelf: !0 }), this._items = t.map(jA);
  }
  get length() {
    return this._items.length;
  }
  get last() {
    return this._items[this._items.length - 1];
  }
  [Symbol.iterator]() {
    return this._items[Symbol.iterator]();
  }
  push(n) {
    const t = new Ai([n]);
    return t._items = [...this._items, ...t._items], t;
  }
  trimLast() {
    const n = new Ai([]);
    return n._items = this._items.slice(0, -1), n;
  }
  getItem(n) {
    return this._items[n];
  }
  *getNames() {
    yield* this._items.map((n) => n.name);
  }
  endsWith(n) {
    return Array.from(this.getNames()).join(" ").endsWith(n);
  }
  startsWith(n) {
    return Array.from(this.getNames()).join(" ").startsWith(n);
  }
}
function DA(o, n) {
  const t = { name: n, allowIn: /* @__PURE__ */ new Set(), allowChildren: /* @__PURE__ */ new Set(), disallowIn: /* @__PURE__ */ new Set(), disallowChildren: /* @__PURE__ */ new Set(), allowContentOf: /* @__PURE__ */ new Set(), allowWhere: /* @__PURE__ */ new Set(), allowAttributes: /* @__PURE__ */ new Set(), disallowAttributes: /* @__PURE__ */ new Set(), allowAttributesOf: /* @__PURE__ */ new Set(), inheritTypesFrom: /* @__PURE__ */ new Set() };
  return function(e, i) {
    for (const r of e) {
      const s = Object.keys(r).filter((a) => a.startsWith("is"));
      for (const a of s) i[a] = !!r[a];
    }
  }(o, t), xn(o, t, "allowIn"), xn(o, t, "allowChildren"), xn(o, t, "disallowIn"), xn(o, t, "disallowChildren"), xn(o, t, "allowContentOf"), xn(o, t, "allowWhere"), xn(o, t, "allowAttributes"), xn(o, t, "disallowAttributes"), xn(o, t, "allowAttributesOf"), xn(o, t, "inheritTypesFrom"), function(e, i) {
    for (const r of e) {
      const s = r.inheritAllFrom;
      s && (i.allowContentOf.add(s), i.allowWhere.add(s), i.allowAttributesOf.add(s), i.inheritTypesFrom.add(s));
    }
  }(o, t), t;
}
function PA(o, n) {
  for (const t of n.allowIn) {
    const e = o[t];
    e ? e.allowChildren.add(n.name) : n.allowIn.delete(t);
  }
}
function LA(o, n) {
  for (const t of n.allowChildren) {
    const e = o[t];
    e ? e.allowIn.add(n.name) : n.allowChildren.delete(t);
  }
}
function BA(o, n) {
  for (const t of n.disallowIn) {
    const e = o[t];
    e ? e.disallowChildren.add(n.name) : n.disallowIn.delete(t);
  }
}
function NA(o, n) {
  for (const t of n.disallowChildren) {
    const e = o[t];
    e ? e.disallowIn.add(n.name) : n.disallowChildren.delete(t);
  }
}
function zA(o, n) {
  for (const t of n.disallowChildren) n.allowChildren.delete(t);
  for (const t of n.disallowIn) n.allowIn.delete(t);
  for (const t of n.disallowAttributes) n.allowAttributes.delete(t);
}
function OA(o, n) {
  for (const t of n.allowContentOf) {
    const e = o[t];
    e && (e.disallowChildren.forEach((i) => {
      n.allowChildren.has(i) || (n.disallowChildren.add(i), o[i].disallowIn.add(n.name));
    }), e.allowChildren.forEach((i) => {
      n.disallowChildren.has(i) || (n.allowChildren.add(i), o[i].allowIn.add(n.name));
    }));
  }
}
function RA(o, n) {
  for (const t of n.allowWhere) {
    const e = o[t];
    e && (e.disallowIn.forEach((i) => {
      n.allowIn.has(i) || (n.disallowIn.add(i), o[i].disallowChildren.add(n.name));
    }), e.allowIn.forEach((i) => {
      n.disallowIn.has(i) || (n.allowIn.add(i), o[i].allowChildren.add(n.name));
    }));
  }
}
function VA(o, n) {
  for (const t of n.allowAttributesOf) {
    const e = o[t];
    if (!e) return;
    e.allowAttributes.forEach((i) => {
      n.disallowAttributes.has(i) || n.allowAttributes.add(i);
    });
  }
}
function FA(o, n) {
  for (const t of n.inheritTypesFrom) {
    const e = o[t];
    if (e) {
      const i = Object.keys(e).filter((r) => r.startsWith("is"));
      for (const r of i) r in n || (n[r] = e[r]);
    }
  }
}
function xn(o, n, t) {
  for (const e of o) {
    let i = e[t];
    typeof i == "string" && (i = [i]), Array.isArray(i) && i.forEach((r) => n[t].add(r));
  }
}
function jA(o) {
  return typeof o == "string" || o.is("documentFragment") ? { name: typeof o == "string" ? o : "$documentFragment", *getAttributeKeys() {
  }, getAttribute() {
  } } : { name: o.is("element") ? o.name : "$text", *getAttributeKeys() {
    yield* o.getAttributeKeys();
  }, getAttribute: (n) => o.getAttribute(n) };
}
function um(o, n, t) {
  for (const e of n.getAttributeKeys()) o.checkAttribute(n, e) || t.removeAttribute(e, n);
}
class HA extends vt() {
  constructor(t) {
    super();
    m(this, "conversionApi");
    m(this, "_splitParts", /* @__PURE__ */ new Map());
    m(this, "_cursorParents", /* @__PURE__ */ new Map());
    m(this, "_modelCursor", null);
    m(this, "_emptyElementsToKeep", /* @__PURE__ */ new Set());
    this.conversionApi = { ...t, consumable: null, writer: null, store: null, convertItem: (e, i) => this._convertItem(e, i), convertChildren: (e, i) => this._convertChildren(e, i), safeInsert: (e, i) => this._safeInsert(e, i), updateConversionResult: (e, i) => this._updateConversionResult(e, i), splitToAllowedParent: (e, i) => this._splitToAllowedParent(e, i), getSplitParts: (e) => this._getSplitParts(e), keepEmptyElement: (e) => this._keepEmptyElement(e) };
  }
  convert(t, e, i = ["$root"]) {
    this.fire("viewCleanup", t), this._modelCursor = function(a, l) {
      let c;
      for (const d of new Ai(a)) {
        const u = {};
        for (const g of d.getAttributeKeys()) u[g] = d.getAttribute(g);
        const h = l.createElement(d.name, u);
        c && l.insert(h, c), c = S._createAt(h, 0);
      }
      return c;
    }(i, e), this.conversionApi.writer = e, this.conversionApi.consumable = ya.createFrom(t), this.conversionApi.store = {};
    const { modelRange: r } = this._convertItem(t, this._modelCursor), s = e.createDocumentFragment();
    if (r) {
      this._removeEmptyElements();
      const a = this._modelCursor.parent, l = a._removeChildren(0, a.childCount);
      s._insertChild(0, l), s.markers = function(c, d) {
        const u = /* @__PURE__ */ new Set(), h = /* @__PURE__ */ new Map(), g = E._createIn(c).getItems();
        for (const f of g) f.is("element", "$marker") && u.add(f);
        for (const f of u) {
          const p = f.getAttribute("data-name"), b = d.createPositionBefore(f);
          h.has(p) ? h.get(p).end = b.clone() : h.set(p, new E(b.clone())), d.remove(f);
        }
        return h;
      }(s, e);
    }
    return this._modelCursor = null, this._splitParts.clear(), this._cursorParents.clear(), this._emptyElementsToKeep.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, s;
  }
  _convertItem(t, e) {
    const i = { viewItem: t, modelCursor: e, modelRange: null };
    if (t.is("element") ? this.fire(`element:${t.name}`, i, this.conversionApi) : t.is("$text") ? this.fire("text", i, this.conversionApi) : this.fire("documentFragment", i, this.conversionApi), i.modelRange && !(i.modelRange instanceof E)) throw new v("view-conversion-dispatcher-incorrect-result", this);
    return { modelRange: i.modelRange, modelCursor: i.modelCursor };
  }
  _convertChildren(t, e) {
    let i = e.is("position") ? e : S._createAt(e, 0);
    const r = new E(i);
    for (const s of Array.from(t.getChildren())) {
      const a = this._convertItem(s, i);
      a.modelRange instanceof E && (r.end = a.modelRange.end, i = a.modelCursor);
    }
    return { modelRange: r, modelCursor: i };
  }
  _safeInsert(t, e) {
    const i = this._splitToAllowedParent(t, e);
    return !!i && (this.conversionApi.writer.insert(t, i.position), !0);
  }
  _updateConversionResult(t, e) {
    const i = this._getSplitParts(t), r = this.conversionApi.writer;
    e.modelRange || (e.modelRange = r.createRange(r.createPositionBefore(t), r.createPositionAfter(i[i.length - 1])));
    const s = this._cursorParents.get(t);
    e.modelCursor = s ? r.createPositionAt(s, 0) : e.modelRange.end;
  }
  _splitToAllowedParent(t, e) {
    const { schema: i, writer: r } = this.conversionApi;
    let s = i.findAllowedParent(e, t);
    if (s) {
      if (s === e.parent) return { position: e };
      this._modelCursor.parent.getAncestors().includes(s) && (s = null);
    }
    if (!s) return Qk(e, t, i) ? { position: Jk(e, r) } : null;
    const a = this.conversionApi.writer.split(e, s), l = [];
    for (const d of a.range.getWalker()) if (d.type == "elementEnd") l.push(d.item);
    else {
      const u = l.pop(), h = d.item;
      this._registerSplitPair(u, h);
    }
    const c = a.range.end.parent;
    return this._cursorParents.set(t, c), { position: a.position, cursorParent: c };
  }
  _registerSplitPair(t, e) {
    this._splitParts.has(t) || this._splitParts.set(t, [t]);
    const i = this._splitParts.get(t);
    this._splitParts.set(e, i), i.push(e);
  }
  _getSplitParts(t) {
    let e;
    return e = this._splitParts.has(t) ? this._splitParts.get(t) : [t], e;
  }
  _keepEmptyElement(t) {
    this._emptyElementsToKeep.add(t);
  }
  _removeEmptyElements() {
    const t = /* @__PURE__ */ new Map();
    for (const e of this._splitParts.keys()) if (e.isEmpty && !this._emptyElementsToKeep.has(e)) {
      const i = t.get(e.parent) || [];
      i.push(e), this._splitParts.delete(e), t.set(e.parent, i);
    }
    for (const [e, i] of t) e._removeChildrenArray(i);
    t.size && this._removeEmptyElements();
  }
}
class UA {
  getHtml(n) {
    const t = N.document.implementation.createHTMLDocument("").createElement("div");
    return t.appendChild(n), t.innerHTML;
  }
}
class tw {
  constructor(n) {
    m(this, "domParser");
    m(this, "domConverter");
    m(this, "htmlWriter");
    m(this, "skipComments", !0);
    this.domParser = new DOMParser(), this.domConverter = new cl(n, { renderingMode: "data" }), this.htmlWriter = new UA();
  }
  toData(n) {
    const t = this.domConverter.viewToDom(n);
    return this.htmlWriter.getHtml(t);
  }
  toView(n) {
    const t = this._toDom(n);
    return this.domConverter.domToView(t, { skipComments: this.skipComments });
  }
  registerRawContentMatcher(n) {
    this.domConverter.registerRawContentMatcher(n);
  }
  useFillerType(n) {
    this.domConverter.blockFillerMode = n == "marked" ? "markedNbsp" : "nbsp";
  }
  _toDom(n) {
    /<(?:html|body|head|meta)(?:\s[^>]*)?>/i.test(n.trim().slice(0, 1e4)) || (n = `<body>${n}</body>`);
    const t = this.domParser.parseFromString(n, "text/html"), e = t.createDocumentFragment(), i = t.body.childNodes;
    for (; i.length > 0; ) e.appendChild(i[0]);
    return e;
  }
}
class $A extends vt() {
  constructor(t, e) {
    super();
    m(this, "model");
    m(this, "mapper");
    m(this, "downcastDispatcher");
    m(this, "upcastDispatcher");
    m(this, "viewDocument");
    m(this, "stylesProcessor");
    m(this, "htmlProcessor");
    m(this, "processor");
    m(this, "_viewWriter");
    this.model = t, this.mapper = new qk(), this.downcastDispatcher = new Wk({ mapper: this.mapper, schema: t.schema }), this.downcastDispatcher.on("insert:$text", (i, r, s) => {
      if (!s.consumable.consume(r.item, i.name)) return;
      const a = s.writer, l = s.mapper.toViewPosition(r.range.start), c = a.createText(r.item.data);
      a.insert(l, c);
    }, { priority: "lowest" }), this.downcastDispatcher.on("insert", (i, r, s) => {
      s.convertAttributes(r.item), r.reconversion || !r.item.is("element") || r.item.isEmpty || s.convertChildren(r.item);
    }, { priority: "lowest" }), this.upcastDispatcher = new HA({ schema: t.schema }), this.viewDocument = new al(e), this.stylesProcessor = e, this.htmlProcessor = new tw(this.viewDocument), this.processor = this.htmlProcessor, this._viewWriter = new fu(this.viewDocument), this.upcastDispatcher.on("text", (i, r, { schema: s, consumable: a, writer: l }) => {
      let c = r.modelCursor;
      if (!a.test(r.viewItem)) return;
      if (!s.checkChild(c, "$text")) {
        if (!Qk(c, "$text", s) || r.viewItem.data.trim().length == 0) return;
        c = Jk(c, l);
      }
      a.consume(r.viewItem);
      const d = l.createText(r.viewItem.data);
      l.insert(d, c), r.modelRange = l.createRange(c, c.getShiftedBy(d.offsetSize)), r.modelCursor = r.modelRange.end;
    }, { priority: "lowest" }), this.upcastDispatcher.on("element", (i, r, s) => {
      if (!r.modelRange && s.consumable.consume(r.viewItem, { name: !0 })) {
        const { modelRange: a, modelCursor: l } = s.convertChildren(r.viewItem, r.modelCursor);
        r.modelRange = a, r.modelCursor = l;
      }
    }, { priority: "lowest" }), this.upcastDispatcher.on("documentFragment", (i, r, s) => {
      if (!r.modelRange && s.consumable.consume(r.viewItem, { name: !0 })) {
        const { modelRange: a, modelCursor: l } = s.convertChildren(r.viewItem, r.modelCursor);
        r.modelRange = a, r.modelCursor = l;
      }
    }, { priority: "lowest" }), _t().prototype.decorate.call(this, "init"), _t().prototype.decorate.call(this, "set"), _t().prototype.decorate.call(this, "get"), _t().prototype.decorate.call(this, "toView"), _t().prototype.decorate.call(this, "toModel"), this.on("init", () => {
      this.fire("ready");
    }, { priority: "lowest" }), this.on("ready", () => {
      this.model.enqueueChange({ isUndoable: !1 }, Zk);
    }, { priority: "lowest" });
  }
  get(t = {}) {
    const { rootName: e = "main", trim: i = "empty" } = t;
    if (!this._checkIfRootsExists([e])) throw new v("datacontroller-get-non-existent-root", this);
    const r = this.model.document.getRoot(e);
    return r.isAttached() || at("datacontroller-get-detached-root", this), i !== "empty" || this.model.hasContent(r, { ignoreWhitespaces: !0 }) ? this.stringify(r, t) : "";
  }
  stringify(t, e = {}) {
    const i = this.toView(t, e);
    return this.processor.toData(i);
  }
  toView(t, e = {}) {
    const i = this.viewDocument, r = this._viewWriter;
    this.mapper.clearBindings();
    const s = E._createIn(t), a = new Ji(i);
    this.mapper.bindElements(t, a);
    const l = t.is("documentFragment") ? t.markers : function(c) {
      const d = [], u = c.root.document;
      if (!u) return /* @__PURE__ */ new Map();
      const h = E._createIn(c);
      for (const g of u.model.markers) {
        const f = g.getRange(), p = f.isCollapsed, b = f.start.isEqual(h.start) || f.end.isEqual(h.end);
        if (p && b) d.push([g.name, f]);
        else {
          const k = h.getIntersection(f);
          k && d.push([g.name, k]);
        }
      }
      return d.sort(([g, f], [p, b]) => {
        if (f.end.compareWith(b.start) !== "after") return 1;
        if (f.start.compareWith(b.end) !== "before") return -1;
        switch (f.start.compareWith(b.start)) {
          case "before":
            return 1;
          case "after":
            return -1;
          default:
            switch (f.end.compareWith(b.end)) {
              case "before":
                return 1;
              case "after":
                return -1;
              default:
                return p.localeCompare(g);
            }
        }
      }), new Map(d);
    }(t);
    return this.downcastDispatcher.convert(s, l, r, e), a;
  }
  init(t) {
    if (this.model.document.version) throw new v("datacontroller-init-document-not-empty", this);
    let e = {};
    if (typeof t == "string" ? e.main = t : e = t, !this._checkIfRootsExists(Object.keys(e))) throw new v("datacontroller-init-non-existent-root", this);
    return this.model.enqueueChange({ isUndoable: !1 }, (i) => {
      for (const r of Object.keys(e)) {
        const s = this.model.document.getRoot(r);
        i.insert(this.parse(e[r], s), s, 0);
      }
    }), Promise.resolve();
  }
  set(t, e = {}) {
    let i = {};
    if (typeof t == "string" ? i.main = t : i = t, !this._checkIfRootsExists(Object.keys(i))) throw new v("datacontroller-set-non-existent-root", this);
    this.model.enqueueChange(e.batchType || {}, (r) => {
      r.setSelection(null), r.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
      for (const s of Object.keys(i)) {
        const a = this.model.document.getRoot(s);
        r.remove(r.createRangeIn(a)), r.insert(this.parse(i[s], a), a, 0);
      }
    });
  }
  parse(t, e = "$root") {
    const i = this.processor.toView(t);
    return this.toModel(i, e);
  }
  toModel(t, e = "$root") {
    return this.model.change((i) => this.upcastDispatcher.convert(t, i, e));
  }
  addStyleProcessorRules(t) {
    t(this.stylesProcessor);
  }
  registerRawContentMatcher(t) {
    this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(t), this.htmlProcessor.registerRawContentMatcher(t);
  }
  destroy() {
    this.stopListening();
  }
  _checkIfRootsExists(t) {
    for (const e of t) if (!this.model.document.getRoot(e)) return !1;
    return !0;
  }
}
class qA {
  constructor(n, t) {
    m(this, "_helpers", /* @__PURE__ */ new Map());
    m(this, "_downcast");
    m(this, "_upcast");
    this._downcast = Bt(n), this._createConversionHelpers({ name: "downcast", dispatchers: this._downcast, isDowncast: !0 }), this._upcast = Bt(t), this._createConversionHelpers({ name: "upcast", dispatchers: this._upcast, isDowncast: !1 });
  }
  addAlias(n, t) {
    const e = this._downcast.includes(t);
    if (!this._upcast.includes(t) && !e) throw new v("conversion-add-alias-dispatcher-not-registered", this);
    this._createConversionHelpers({ name: n, dispatchers: [t], isDowncast: e });
  }
  for(n) {
    if (!this._helpers.has(n)) throw new v("conversion-for-unknown-group", this);
    return this._helpers.get(n);
  }
  elementToElement(n) {
    this.for("downcast").elementToElement(n);
    for (const { model: t, view: e } of Rl(n)) this.for("upcast").elementToElement({ model: t, view: e, converterPriority: n.converterPriority });
  }
  attributeToElement(n) {
    this.for("downcast").attributeToElement(n);
    for (const { model: t, view: e } of Rl(n)) this.for("upcast").elementToAttribute({ view: e, model: t, converterPriority: n.converterPriority });
  }
  attributeToAttribute(n) {
    this.for("downcast").attributeToAttribute(n);
    for (const { model: t, view: e } of Rl(n)) this.for("upcast").attributeToAttribute({ view: e, model: t });
  }
  _createConversionHelpers({ name: n, dispatchers: t, isDowncast: e }) {
    if (this._helpers.has(n)) throw new v("conversion-group-exists", this);
    const i = e ? new vA(t) : new TA(t);
    this._helpers.set(n, i);
  }
}
function* Rl(o) {
  if (o.model.values) for (const n of o.model.values) {
    const t = { key: o.model.key, value: n }, e = o.view[n], i = o.upcastAlso ? o.upcastAlso[n] : void 0;
    yield* hm(t, e, i);
  }
  else yield* hm(o.model, o.view, o.upcastAlso);
}
function* hm(o, n, t) {
  if (yield { model: o, view: n }, t) for (const e of Bt(t)) yield { model: o, view: e };
}
class Ze {
  constructor(n) {
    m(this, "baseVersion");
    m(this, "isDocumentOperation");
    m(this, "batch");
    this.baseVersion = n, this.isDocumentOperation = this.baseVersion !== null, this.batch = null;
  }
  _validate() {
  }
  toJSON() {
    const n = Object.assign({}, this);
    return n.__className = this.constructor.className, delete n.batch, delete n.isDocumentOperation, n;
  }
  static get className() {
    return "Operation";
  }
  static fromJSON(n, t) {
    return new this(n.baseVersion);
  }
}
function ku(o, n) {
  const t = nw(n), e = t.reduce((s, a) => s + a.offsetSize, 0), i = o.parent;
  os(o);
  const r = o.index;
  return i._insertChild(r, t), is(i, r + t.length), is(i, r), new E(o, o.getShiftedBy(e));
}
function ew(o) {
  if (!o.isFlat) throw new v("operation-utils-remove-range-not-flat", this);
  const n = o.start.parent;
  os(o.start), os(o.end);
  const t = n._removeChildren(o.start.index, o.end.index - o.start.index);
  return is(n, o.start.index), t;
}
function ns(o, n) {
  if (!o.isFlat) throw new v("operation-utils-move-range-not-flat", this);
  const t = ew(o);
  return ku(n = n._getTransformedByDeletion(o.start, o.end.offset - o.start.offset), t);
}
function nw(o) {
  const n = [];
  (function t(e) {
    if (typeof e == "string") n.push(new Rt(e));
    else if (e instanceof gn) n.push(new Rt(e.data, e.getAttributes()));
    else if (e instanceof lo) n.push(e);
    else if (Ye(e)) for (const i of e) t(i);
  })(o);
  for (let t = 1; t < n.length; t++) {
    const e = n[t], i = n[t - 1];
    e instanceof Rt && i instanceof Rt && iw(e, i) && (n.splice(t - 1, 2, new Rt(i.data + e.data, i.getAttributes())), t--);
  }
  return n;
}
function is(o, n) {
  const t = o.getChild(n - 1), e = o.getChild(n);
  if (t && e && t.is("$text") && e.is("$text") && iw(t, e)) {
    const i = new Rt(t.data + e.data, t.getAttributes());
    o._removeChildren(n - 1, 2), o._insertChild(n - 1, i);
  }
}
function os(o) {
  const n = o.textNode, t = o.parent;
  if (n) {
    const e = o.offset - n.startOffset, i = n.index;
    t._removeChildren(i, 1);
    const r = new Rt(n.data.substr(0, e), n.getAttributes()), s = new Rt(n.data.substr(e), n.getAttributes());
    t._insertChild(i, [r, s]);
  }
}
function iw(o, n) {
  const t = o.getAttributes(), e = n.getAttributes();
  for (const i of t) {
    if (i[1] !== n.getAttribute(i[0])) return !1;
    e.next();
  }
  return e.next().done;
}
class ht extends Ze {
  constructor(t, e, i, r) {
    super(r);
    m(this, "sourcePosition");
    m(this, "howMany");
    m(this, "targetPosition");
    this.sourcePosition = t.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = e, this.targetPosition = i.clone(), this.targetPosition.stickiness = "toNone";
  }
  get type() {
    return this.targetPosition.root.rootName == "$graveyard" ? "remove" : this.sourcePosition.root.rootName == "$graveyard" ? "reinsert" : "move";
  }
  get affectedSelectable() {
    return [E._createFromPositionAndShift(this.sourcePosition, this.howMany), E._createFromPositionAndShift(this.targetPosition, 0)];
  }
  clone() {
    return new ht(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
  }
  getMovedRangeStart() {
    return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
  }
  getReversed() {
    const t = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
    return new ht(this.getMovedRangeStart(), this.howMany, t, this.baseVersion + 1);
  }
  _validate() {
    const t = this.sourcePosition.parent, e = this.targetPosition.parent, i = this.sourcePosition.offset, r = this.targetPosition.offset;
    if (i + this.howMany > t.maxOffset) throw new v("move-operation-nodes-do-not-exist", this);
    if (t === e && i < r && r < i + this.howMany) throw new v("move-operation-range-into-itself", this);
    if (this.sourcePosition.root == this.targetPosition.root && xe(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
      const s = this.sourcePosition.path.length - 1;
      if (this.targetPosition.path[s] >= i && this.targetPosition.path[s] < i + this.howMany) throw new v("move-operation-node-into-itself", this);
    }
  }
  _execute() {
    ns(E._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
  }
  toJSON() {
    const t = super.toJSON();
    return t.sourcePosition = this.sourcePosition.toJSON(), t.targetPosition = this.targetPosition.toJSON(), t;
  }
  static get className() {
    return "MoveOperation";
  }
  static fromJSON(t, e) {
    const i = S.fromJSON(t.sourcePosition, e), r = S.fromJSON(t.targetPosition, e);
    return new this(i, t.howMany, r, t.baseVersion);
  }
}
class de extends Ze {
  constructor(t, e, i) {
    super(i);
    m(this, "position");
    m(this, "nodes");
    m(this, "shouldReceiveAttributes");
    this.position = t.clone(), this.position.stickiness = "toNone", this.nodes = new Hr(nw(e)), this.shouldReceiveAttributes = !1;
  }
  get type() {
    return "insert";
  }
  get howMany() {
    return this.nodes.maxOffset;
  }
  get affectedSelectable() {
    return this.position.clone();
  }
  clone() {
    const t = new Hr([...this.nodes].map((i) => i._clone(!0))), e = new de(this.position, t, this.baseVersion);
    return e.shouldReceiveAttributes = this.shouldReceiveAttributes, e;
  }
  getReversed() {
    const t = this.position.root.document.graveyard, e = new S(t, [0]);
    return new ht(this.position, this.nodes.maxOffset, e, this.baseVersion + 1);
  }
  _validate() {
    const t = this.position.parent;
    if (!t || t.maxOffset < this.position.offset) throw new v("insert-operation-position-invalid", this);
  }
  _execute() {
    const t = this.nodes;
    this.nodes = new Hr([...t].map((e) => e._clone(!0))), ku(this.position, t);
  }
  toJSON() {
    const t = super.toJSON();
    return t.position = this.position.toJSON(), t.nodes = this.nodes.toJSON(), t;
  }
  static get className() {
    return "InsertOperation";
  }
  static fromJSON(t, e) {
    const i = [];
    for (const s of t.nodes) s.name ? i.push(Lt.fromJSON(s)) : i.push(Rt.fromJSON(s));
    const r = new de(S.fromJSON(t.position, e), i, t.baseVersion);
    return r.shouldReceiveAttributes = t.shouldReceiveAttributes, r;
  }
}
class Tt extends Ze {
  constructor(t, e, i, r, s) {
    super(s);
    m(this, "splitPosition");
    m(this, "howMany");
    m(this, "insertionPosition");
    m(this, "graveyardPosition");
    this.splitPosition = t.clone(), this.splitPosition.stickiness = "toNext", this.howMany = e, this.insertionPosition = i, this.graveyardPosition = r ? r.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext");
  }
  get type() {
    return "split";
  }
  get moveTargetPosition() {
    const t = this.insertionPosition.path.slice();
    return t.push(0), new S(this.insertionPosition.root, t);
  }
  get movedRange() {
    const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
    return new E(this.splitPosition, t);
  }
  get affectedSelectable() {
    const t = [E._createFromPositionAndShift(this.splitPosition, 0), E._createFromPositionAndShift(this.insertionPosition, 0)];
    return this.graveyardPosition && t.push(E._createFromPositionAndShift(this.graveyardPosition, 0)), t;
  }
  clone() {
    return new Tt(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
  }
  getReversed() {
    const t = this.splitPosition.root.document.graveyard, e = new S(t, [0]);
    return new Wt(this.moveTargetPosition, this.howMany, this.splitPosition, e, this.baseVersion + 1);
  }
  _validate() {
    const t = this.splitPosition.parent, e = this.splitPosition.offset;
    if (!t || t.maxOffset < e) throw new v("split-operation-position-invalid", this);
    if (!t.parent) throw new v("split-operation-split-in-root", this);
    if (this.howMany != t.maxOffset - this.splitPosition.offset) throw new v("split-operation-how-many-invalid", this);
    if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) throw new v("split-operation-graveyard-position-invalid", this);
  }
  _execute() {
    const t = this.splitPosition.parent;
    if (this.graveyardPosition) ns(E._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
    else {
      const e = t._clone();
      ku(this.insertionPosition, e);
    }
    ns(new E(S._createAt(t, this.splitPosition.offset), S._createAt(t, t.maxOffset)), this.moveTargetPosition);
  }
  toJSON() {
    const t = super.toJSON();
    return t.splitPosition = this.splitPosition.toJSON(), t.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (t.graveyardPosition = this.graveyardPosition.toJSON()), t;
  }
  static get className() {
    return "SplitOperation";
  }
  static getInsertionPosition(t) {
    const e = t.path.slice(0, -1);
    return e[e.length - 1]++, new S(t.root, e, "toPrevious");
  }
  static fromJSON(t, e) {
    const i = S.fromJSON(t.splitPosition, e), r = S.fromJSON(t.insertionPosition, e), s = t.graveyardPosition ? S.fromJSON(t.graveyardPosition, e) : null;
    return new this(i, t.howMany, r, s, t.baseVersion);
  }
}
class Wt extends Ze {
  constructor(t, e, i, r, s) {
    super(s);
    m(this, "sourcePosition");
    m(this, "howMany");
    m(this, "targetPosition");
    m(this, "graveyardPosition");
    this.sourcePosition = t.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = e, this.targetPosition = i.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = r.clone();
  }
  get type() {
    return "merge";
  }
  get deletionPosition() {
    return new S(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
  }
  get movedRange() {
    const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
    return new E(this.sourcePosition, t);
  }
  get affectedSelectable() {
    const t = this.sourcePosition.parent;
    return [E._createOn(t), E._createFromPositionAndShift(this.targetPosition, 0), E._createFromPositionAndShift(this.graveyardPosition, 0)];
  }
  clone() {
    return new Wt(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
  }
  getReversed() {
    const t = this.targetPosition._getTransformedByMergeOperation(this), e = this.sourcePosition.path.slice(0, -1), i = new S(this.sourcePosition.root, e)._getTransformedByMergeOperation(this);
    return new Tt(t, this.howMany, i, this.graveyardPosition, this.baseVersion + 1);
  }
  _validate() {
    const t = this.sourcePosition.parent, e = this.targetPosition.parent;
    if (!t.parent) throw new v("merge-operation-source-position-invalid", this);
    if (!e.parent) throw new v("merge-operation-target-position-invalid", this);
    if (this.howMany != t.maxOffset) throw new v("merge-operation-how-many-invalid", this);
  }
  _execute() {
    const t = this.sourcePosition.parent;
    ns(E._createIn(t), this.targetPosition), ns(E._createOn(t), this.graveyardPosition);
  }
  toJSON() {
    const t = super.toJSON();
    return t.sourcePosition = t.sourcePosition.toJSON(), t.targetPosition = t.targetPosition.toJSON(), t.graveyardPosition = t.graveyardPosition.toJSON(), t;
  }
  static get className() {
    return "MergeOperation";
  }
  static fromJSON(t, e) {
    const i = S.fromJSON(t.sourcePosition, e), r = S.fromJSON(t.targetPosition, e), s = S.fromJSON(t.graveyardPosition, e);
    return new this(i, t.howMany, r, s, t.baseVersion);
  }
}
class Se extends Ze {
  constructor(t, e, i, r, s, a) {
    super(a);
    m(this, "name");
    m(this, "oldRange");
    m(this, "newRange");
    m(this, "affectsData");
    m(this, "_markers");
    this.name = t, this.oldRange = e ? e.clone() : null, this.newRange = i ? i.clone() : null, this.affectsData = s, this._markers = r;
  }
  get type() {
    return "marker";
  }
  get affectedSelectable() {
    const t = [];
    return this.oldRange && t.push(this.oldRange.clone()), this.newRange && (this.oldRange ? t.push(...this.newRange.getDifference(this.oldRange)) : t.push(this.newRange.clone())), t;
  }
  clone() {
    return new Se(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
  }
  getReversed() {
    return new Se(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
  }
  _execute() {
    this.newRange ? this._markers._set(this.name, this.newRange, !0, this.affectsData) : this._markers._remove(this.name);
  }
  toJSON() {
    const t = super.toJSON();
    return this.oldRange && (t.oldRange = this.oldRange.toJSON()), this.newRange && (t.newRange = this.newRange.toJSON()), delete t._markers, t;
  }
  static get className() {
    return "MarkerOperation";
  }
  static fromJSON(t, e) {
    return new Se(t.name, t.oldRange ? E.fromJSON(t.oldRange, e) : null, t.newRange ? E.fromJSON(t.newRange, e) : null, e.model.markers, t.affectsData, t.baseVersion);
  }
}
class Jt extends Ze {
  constructor(t, e, i, r, s) {
    super(s);
    m(this, "range");
    m(this, "key");
    m(this, "oldValue");
    m(this, "newValue");
    this.range = t.clone(), this.key = e, this.oldValue = i === void 0 ? null : i, this.newValue = r === void 0 ? null : r;
  }
  get type() {
    return this.oldValue === null ? "addAttribute" : this.newValue === null ? "removeAttribute" : "changeAttribute";
  }
  get affectedSelectable() {
    return this.range.clone();
  }
  clone() {
    return new Jt(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
  }
  getReversed() {
    return new Jt(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
  }
  toJSON() {
    const t = super.toJSON();
    return t.range = this.range.toJSON(), t;
  }
  _validate() {
    if (!this.range.isFlat) throw new v("attribute-operation-range-not-flat", this);
    for (const t of this.range.getItems({ shallow: !0 })) {
      if (this.oldValue !== null && !ba(t.getAttribute(this.key), this.oldValue)) throw new v("attribute-operation-wrong-old-value", this, { item: t, key: this.key, value: this.oldValue });
      if (this.oldValue === null && this.newValue !== null && t.hasAttribute(this.key)) throw new v("attribute-operation-attribute-exists", this, { node: t, key: this.key });
    }
  }
  _execute() {
    ba(this.oldValue, this.newValue) || function(t, e, i) {
      os(t.start), os(t.end);
      for (const r of t.getItems({ shallow: !0 })) {
        const s = r.is("$textProxy") ? r.textNode : r;
        i !== null ? s._setAttribute(e, i) : s._removeAttribute(e), is(s.parent, s.index);
      }
      is(t.end.parent, t.end.index);
    }(this.range, this.key, this.newValue);
  }
  static get className() {
    return "AttributeOperation";
  }
  static fromJSON(t, e) {
    return new Jt(E.fromJSON(t.range, e), t.key, t.oldValue, t.newValue, t.baseVersion);
  }
}
class re extends Ze {
  get type() {
    return "noop";
  }
  get affectedSelectable() {
    return null;
  }
  clone() {
    return new re(this.baseVersion);
  }
  getReversed() {
    return new re(this.baseVersion + 1);
  }
  _execute() {
  }
  static get className() {
    return "NoOperation";
  }
}
class Oe extends Ze {
  constructor(t, e, i, r) {
    super(r);
    m(this, "position");
    m(this, "oldName");
    m(this, "newName");
    this.position = t, this.position.stickiness = "toNext", this.oldName = e, this.newName = i;
  }
  get type() {
    return "rename";
  }
  get affectedSelectable() {
    return this.position.nodeAfter;
  }
  clone() {
    return new Oe(this.position.clone(), this.oldName, this.newName, this.baseVersion);
  }
  getReversed() {
    return new Oe(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
  }
  _validate() {
    const t = this.position.nodeAfter;
    if (!(t instanceof Lt)) throw new v("rename-operation-wrong-position", this);
    if (t.name !== this.oldName) throw new v("rename-operation-wrong-name", this);
  }
  _execute() {
    this.position.nodeAfter.name = this.newName;
  }
  toJSON() {
    const t = super.toJSON();
    return t.position = this.position.toJSON(), t;
  }
  static get className() {
    return "RenameOperation";
  }
  static fromJSON(t, e) {
    return new Oe(S.fromJSON(t.position, e), t.oldName, t.newName, t.baseVersion);
  }
}
class ni extends Ze {
  constructor(t, e, i, r, s) {
    super(s);
    m(this, "root");
    m(this, "key");
    m(this, "oldValue");
    m(this, "newValue");
    this.root = t, this.key = e, this.oldValue = i === void 0 ? null : i, this.newValue = r === void 0 ? null : r;
  }
  get type() {
    return this.oldValue === null ? "addRootAttribute" : this.newValue === null ? "removeRootAttribute" : "changeRootAttribute";
  }
  get affectedSelectable() {
    return this.root;
  }
  clone() {
    return new ni(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
  }
  getReversed() {
    return new ni(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
  }
  _validate() {
    if (this.root != this.root.root || this.root.is("documentFragment")) throw new v("rootattribute-operation-not-a-root", this, { root: this.root, key: this.key });
    if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) throw new v("rootattribute-operation-wrong-old-value", this, { root: this.root, key: this.key });
    if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) throw new v("rootattribute-operation-attribute-exists", this, { root: this.root, key: this.key });
  }
  _execute() {
    this.newValue !== null ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key);
  }
  toJSON() {
    const t = super.toJSON();
    return t.root = this.root.toJSON(), t;
  }
  static get className() {
    return "RootAttributeOperation";
  }
  static fromJSON(t, e) {
    if (!e.getRoot(t.root)) throw new v("rootattribute-operation-fromjson-no-root", this, { rootName: t.root });
    return new ni(e.getRoot(t.root), t.key, t.oldValue, t.newValue, t.baseVersion);
  }
}
class Pn extends Ze {
  constructor(t, e, i, r, s) {
    super(s);
    m(this, "rootName");
    m(this, "elementName");
    m(this, "isAdd");
    m(this, "_document");
    this.rootName = t, this.elementName = e, this.isAdd = i, this._document = r, !this._document.getRoot(this.rootName) && (this._document.createRoot(this.elementName, this.rootName)._isAttached = !1);
  }
  get type() {
    return this.isAdd ? "addRoot" : "detachRoot";
  }
  get affectedSelectable() {
    return this._document.getRoot(this.rootName);
  }
  clone() {
    return new Pn(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion);
  }
  getReversed() {
    return new Pn(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1);
  }
  _execute() {
    this._document.getRoot(this.rootName)._isAttached = this.isAdd;
  }
  toJSON() {
    const t = super.toJSON();
    return delete t._document, t;
  }
  static get className() {
    return "RootOperation";
  }
  static fromJSON(t, e) {
    return new Pn(t.rootName, t.elementName, t.isAdd, e, t.baseVersion);
  }
}
const Je = {};
Je[Jt.className] = Jt, Je[de.className] = de, Je[Se.className] = Se, Je[ht.className] = ht, Je[re.className] = re, Je[Ze.className] = Ze, Je[Oe.className] = Oe, Je[ni.className] = ni, Je[Pn.className] = Pn, Je[Tt.className] = Tt, Je[Wt.className] = Wt;
class WA {
  static fromJSON(n, t) {
    return Je[n.__className].fromJSON(n, t);
  }
}
const ed = /* @__PURE__ */ new Map();
function ut(o, n, t) {
  let e = ed.get(o);
  e || (e = /* @__PURE__ */ new Map(), ed.set(o, e)), e.set(n, t);
}
function GA(o) {
  return [o];
}
function mm(o, n, t = {}) {
  const e = function(i, r) {
    const s = ed.get(i);
    return s && s.has(r) ? s.get(r) : GA;
  }(o.constructor, n.constructor);
  try {
    return e(o = o.clone(), n, t);
  } catch (i) {
    throw i;
  }
}
function KA(o, n, t) {
  o = o.slice(), n = n.slice();
  const e = new YA(t.document, t.useRelations, t.forceWeakRemove);
  e.setOriginalOperations(o), e.setOriginalOperations(n);
  const i = e.originalOperations;
  if (o.length == 0 || n.length == 0) return { operationsA: o, operationsB: n, originalOperations: i };
  const r = /* @__PURE__ */ new WeakMap();
  for (const l of o) r.set(l, 0);
  const s = { nextBaseVersionA: o[o.length - 1].baseVersion + 1, nextBaseVersionB: n[n.length - 1].baseVersion + 1, originalOperationsACount: o.length, originalOperationsBCount: n.length };
  let a = 0;
  for (; a < o.length; ) {
    const l = o[a], c = r.get(l);
    if (c == n.length) {
      a++;
      continue;
    }
    const d = n[c], u = mm(l, d, e.getContext(l, d, !0)), h = mm(d, l, e.getContext(d, l, !1));
    e.updateRelation(l, d), e.setOriginalOperations(u, l), e.setOriginalOperations(h, d);
    for (const g of u) r.set(g, c + h.length);
    o.splice(a, 1, ...u), n.splice(c, 1, ...h);
  }
  return fm(o), fm(n), t.padWithNoOps, gm(o, s.nextBaseVersionB), gm(n, s.nextBaseVersionA), { operationsA: o, operationsB: n, originalOperations: i };
}
class YA {
  constructor(n, t, e = !1) {
    m(this, "originalOperations");
    m(this, "_history");
    m(this, "_useRelations");
    m(this, "_forceWeakRemove");
    m(this, "_relations");
    this.originalOperations = /* @__PURE__ */ new Map(), this._history = n.history, this._useRelations = t, this._forceWeakRemove = !!e, this._relations = /* @__PURE__ */ new Map();
  }
  setOriginalOperations(n, t = null) {
    const e = t ? this.originalOperations.get(t) : null;
    for (const i of n) this.originalOperations.set(i, e || i);
  }
  updateRelation(n, t) {
    if (n instanceof ht) t instanceof Wt ? n.targetPosition.isEqual(t.sourcePosition) || t.movedRange.containsPosition(n.targetPosition) ? this._setRelation(n, t, "insertAtSource") : n.targetPosition.isEqual(t.deletionPosition) ? this._setRelation(n, t, "insertBetween") : n.targetPosition.isAfter(t.sourcePosition) && this._setRelation(n, t, "moveTargetAfter") : t instanceof ht && (n.targetPosition.isEqual(t.sourcePosition) || n.targetPosition.isBefore(t.sourcePosition) ? this._setRelation(n, t, "insertBefore") : this._setRelation(n, t, "insertAfter"));
    else if (n instanceof Tt) {
      if (t instanceof Wt) n.splitPosition.isBefore(t.sourcePosition) && this._setRelation(n, t, "splitBefore");
      else if (t instanceof ht) if (n.splitPosition.isEqual(t.sourcePosition) || n.splitPosition.isBefore(t.sourcePosition)) this._setRelation(n, t, "splitBefore");
      else {
        const e = E._createFromPositionAndShift(t.sourcePosition, t.howMany);
        if (n.splitPosition.hasSameParentAs(t.sourcePosition) && e.containsPosition(n.splitPosition)) {
          const i = e.end.offset - n.splitPosition.offset, r = n.splitPosition.offset - e.start.offset;
          this._setRelation(n, t, { howMany: i, offset: r });
        }
      }
    } else if (n instanceof Wt) t instanceof Wt ? (n.targetPosition.isEqual(t.sourcePosition) || this._setRelation(n, t, "mergeTargetNotMoved"), n.sourcePosition.isEqual(t.targetPosition) && this._setRelation(n, t, "mergeSourceNotMoved"), n.sourcePosition.isEqual(t.sourcePosition) && this._setRelation(n, t, "mergeSameElement")) : t instanceof Tt ? n.sourcePosition.isEqual(t.splitPosition) && this._setRelation(n, t, "splitAtSource") : t instanceof ht && t.howMany > 0 && (n.sourcePosition.isEqual(t.sourcePosition.getShiftedBy(t.howMany)) && this._setRelation(n, t, "mergeSourceAffected"), n.targetPosition.isEqual(t.sourcePosition) && this._setRelation(n, t, "mergeTargetWasBefore"));
    else if (n instanceof Se) {
      const e = n.newRange;
      if (!e) return;
      if (t instanceof Wt) {
        const i = e.start.isEqual(t.targetPosition), r = e.start.isEqual(t.deletionPosition), s = e.end.isEqual(t.deletionPosition), a = e.end.isEqual(t.sourcePosition);
        (i || r || s || a) && this._setRelation(n, t, { wasInLeftElement: i, wasStartBeforeMergedElement: r, wasEndBeforeMergedElement: s, wasInRightElement: a });
      }
    }
  }
  getContext(n, t, e) {
    return { aIsStrong: e, aWasUndone: this._wasUndone(n), bWasUndone: this._wasUndone(t), abRelation: this._useRelations ? this._getRelation(n, t) : null, baRelation: this._useRelations ? this._getRelation(t, n) : null, forceWeakRemove: this._forceWeakRemove };
  }
  _wasUndone(n) {
    const t = this.originalOperations.get(n);
    return t.wasUndone || this._history.isUndoneOperation(t);
  }
  _getRelation(n, t) {
    const e = this.originalOperations.get(t), i = this._history.getUndoneOperation(e);
    if (!i) return null;
    const r = this.originalOperations.get(n), s = this._relations.get(r);
    return s && s.get(i) || null;
  }
  _setRelation(n, t, e) {
    const i = this.originalOperations.get(n), r = this.originalOperations.get(t);
    let s = this._relations.get(i);
    s || (s = /* @__PURE__ */ new Map(), this._relations.set(i, s)), s.set(r, e);
  }
}
function gm(o, n) {
  for (const t of o) t.baseVersion = n++;
}
function fm(o) {
  const n = /* @__PURE__ */ new Map();
  for (let t = 0; t < o.length; t++) {
    const e = o[t];
    e instanceof Se && (e.baseVersion !== -1 ? n.set(e.name, { op: e, ranges: e.newRange ? [e.newRange] : [] }) : (e.newRange && n.get(e.name).ranges.push(e.newRange), o.splice(t, 1), t--));
  }
  for (const { op: t, ranges: e } of n.values()) e.length ? t.newRange = E._createFromRanges(e) : t.newRange = null;
}
function pm(o, n, t) {
  const e = o.nodes.getNode(0).getAttribute(n);
  if (e == t) return null;
  const i = new E(o.position, o.position.getShiftedBy(o.howMany));
  return new Jt(i, n, e, t, 0);
}
function bm(o, n) {
  return o.targetPosition._getTransformedByDeletion(n.sourcePosition, n.howMany) === null;
}
function vo(o, n) {
  const t = [];
  for (let e = 0; e < o.length; e++) {
    const i = o[e], r = new ht(i.start, i.end.offset - i.start.offset, n, 0);
    t.push(r);
    for (let s = e + 1; s < o.length; s++) o[s] = o[s]._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)[0];
    n = n._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany);
  }
  return t;
}
ut(Jt, Jt, (o, n, t) => {
  if (o.key === n.key && o.range.start.hasSameParentAs(n.range.start)) {
    const e = o.range.getDifference(n.range).map((r) => new Jt(r, o.key, o.oldValue, o.newValue, 0)), i = o.range.getIntersection(n.range);
    return i && t.aIsStrong && e.push(new Jt(i, n.key, n.newValue, o.newValue, 0)), e.length == 0 ? [new re(0)] : e;
  }
  return [o];
}), ut(Jt, de, (o, n) => {
  if (o.range.start.hasSameParentAs(n.position) && o.range.containsPosition(n.position)) {
    const t = o.range._getTransformedByInsertion(n.position, n.howMany, !n.shouldReceiveAttributes).map((e) => new Jt(e, o.key, o.oldValue, o.newValue, o.baseVersion));
    if (n.shouldReceiveAttributes) {
      const e = pm(n, o.key, o.oldValue);
      e && t.unshift(e);
    }
    return t;
  }
  return o.range = o.range._getTransformedByInsertion(n.position, n.howMany, !1)[0], [o];
}), ut(Jt, Wt, (o, n) => {
  const t = [];
  o.range.start.hasSameParentAs(n.deletionPosition) && (o.range.containsPosition(n.deletionPosition) || o.range.start.isEqual(n.deletionPosition)) && t.push(E._createFromPositionAndShift(n.graveyardPosition, 1));
  const e = o.range._getTransformedByMergeOperation(n);
  return e.isCollapsed || t.push(e), t.map((i) => new Jt(i, o.key, o.oldValue, o.newValue, o.baseVersion));
}), ut(Jt, ht, (o, n) => function(e, i) {
  const r = E._createFromPositionAndShift(i.sourcePosition, i.howMany);
  let s = null, a = [];
  r.containsRange(e, !0) ? s = e : e.start.hasSameParentAs(r.start) ? (a = e.getDifference(r), s = e.getIntersection(r)) : a = [e];
  const l = [];
  for (let c of a) {
    c = c._getTransformedByDeletion(i.sourcePosition, i.howMany);
    const d = i.getMovedRangeStart(), u = c.start.hasSameParentAs(d), h = c._getTransformedByInsertion(d, i.howMany, u);
    l.push(...h);
  }
  return s && l.push(s._getTransformedByMove(i.sourcePosition, i.targetPosition, i.howMany, !1)[0]), l;
}(o.range, n).map((e) => new Jt(e, o.key, o.oldValue, o.newValue, o.baseVersion))), ut(Jt, Tt, (o, n) => {
  if (o.range.end.isEqual(n.insertionPosition)) return n.graveyardPosition || o.range.end.offset++, [o];
  if (o.range.start.hasSameParentAs(n.splitPosition) && o.range.containsPosition(n.splitPosition)) {
    const t = o.clone();
    return t.range = new E(n.moveTargetPosition.clone(), o.range.end._getCombined(n.splitPosition, n.moveTargetPosition)), o.range.end = n.splitPosition.clone(), o.range.end.stickiness = "toPrevious", [o, t];
  }
  return o.range = o.range._getTransformedBySplitOperation(n), [o];
}), ut(de, Jt, (o, n) => {
  const t = [o];
  if (o.shouldReceiveAttributes && o.position.hasSameParentAs(n.range.start) && n.range.containsPosition(o.position)) {
    const e = pm(o, n.key, n.newValue);
    e && t.push(e);
  }
  return t;
}), ut(de, de, (o, n, t) => (o.position.isEqual(n.position) && t.aIsStrong || (o.position = o.position._getTransformedByInsertOperation(n)), [o])), ut(de, ht, (o, n) => (o.position = o.position._getTransformedByMoveOperation(n), [o])), ut(de, Tt, (o, n) => (o.position = o.position._getTransformedBySplitOperation(n), [o])), ut(de, Wt, (o, n) => (o.position = o.position._getTransformedByMergeOperation(n), [o])), ut(Se, de, (o, n) => (o.oldRange && (o.oldRange = o.oldRange._getTransformedByInsertOperation(n)[0]), o.newRange && (o.newRange = o.newRange._getTransformedByInsertOperation(n)[0]), [o])), ut(Se, Se, (o, n, t) => {
  if (o.name == n.name) {
    if (!t.aIsStrong) return [new re(0)];
    o.oldRange = n.newRange ? n.newRange.clone() : null;
  }
  return [o];
}), ut(Se, Wt, (o, n) => (o.oldRange && (o.oldRange = o.oldRange._getTransformedByMergeOperation(n)), o.newRange && (o.newRange = o.newRange._getTransformedByMergeOperation(n)), [o])), ut(Se, ht, (o, n) => {
  const t = [o];
  if (o.oldRange && (o.oldRange = E._createFromRanges(o.oldRange._getTransformedByMoveOperation(n))), o.newRange) {
    const e = o.newRange._getTransformedByMoveOperation(n);
    o.newRange = e[0];
    for (let i = 1; i < e.length; i++) {
      const r = o.clone();
      r.oldRange = null, r.newRange = e[i], r.baseVersion = -1, t.push(r);
    }
  }
  return t;
}), ut(Se, Tt, (o, n, t) => {
  if (o.oldRange && (o.oldRange = o.oldRange._getTransformedBySplitOperation(n)), o.newRange) {
    if (t.abRelation) {
      const e = o.newRange._getTransformedBySplitOperation(n);
      return o.newRange.start.isEqual(n.splitPosition) && t.abRelation.wasStartBeforeMergedElement ? o.newRange.start = S._createAt(n.insertionPosition) : o.newRange.start.isEqual(n.splitPosition) && !t.abRelation.wasInLeftElement ? o.newRange.start = S._createAt(n.moveTargetPosition) : o.newRange.start = e.start, o.newRange.end.isEqual(n.splitPosition) && t.abRelation.wasInRightElement ? o.newRange.end = S._createAt(n.moveTargetPosition) : o.newRange.end.isEqual(n.splitPosition) && t.abRelation.wasEndBeforeMergedElement ? o.newRange.end = S._createAt(n.insertionPosition) : o.newRange.end = e.end, [o];
    }
    o.newRange = o.newRange._getTransformedBySplitOperation(n);
  }
  return [o];
}), ut(Wt, de, (o, n) => (o.sourcePosition.hasSameParentAs(n.position) && (o.howMany += n.howMany), o.sourcePosition = o.sourcePosition._getTransformedByInsertOperation(n), o.targetPosition = o.targetPosition._getTransformedByInsertOperation(n), [o])), ut(Wt, Wt, (o, n, t) => {
  if (o.sourcePosition.isEqual(n.sourcePosition) && o.targetPosition.isEqual(n.targetPosition)) {
    if (t.bWasUndone) {
      const e = n.graveyardPosition.path.slice();
      return e.push(0), o.sourcePosition = new S(n.graveyardPosition.root, e), o.howMany = 0, [o];
    }
    return [new re(0)];
  }
  if (o.sourcePosition.isEqual(n.sourcePosition) && !o.targetPosition.isEqual(n.targetPosition) && !t.bWasUndone && t.abRelation != "splitAtSource") {
    const e = o.targetPosition.root.rootName == "$graveyard", i = n.targetPosition.root.rootName == "$graveyard";
    if (i && !e || !(e && !i) && t.aIsStrong) {
      const r = n.targetPosition._getTransformedByMergeOperation(n), s = o.targetPosition._getTransformedByMergeOperation(n);
      return [new ht(r, o.howMany, s, 0)];
    }
    return [new re(0)];
  }
  return o.sourcePosition.hasSameParentAs(n.targetPosition) && (o.howMany += n.howMany), o.sourcePosition = o.sourcePosition._getTransformedByMergeOperation(n), o.targetPosition = o.targetPosition._getTransformedByMergeOperation(n), o.graveyardPosition.isEqual(n.graveyardPosition) && t.aIsStrong || (o.graveyardPosition = o.graveyardPosition._getTransformedByMergeOperation(n)), [o];
}), ut(Wt, ht, (o, n, t) => {
  const e = E._createFromPositionAndShift(n.sourcePosition, n.howMany);
  return n.type == "remove" && !t.bWasUndone && o.deletionPosition.hasSameParentAs(n.sourcePosition) && e.containsPosition(o.sourcePosition) ? [new re(0)] : (n.sourcePosition.getShiftedBy(n.howMany).isEqual(o.sourcePosition) ? o.sourcePosition.stickiness = "toNone" : n.targetPosition.isEqual(o.sourcePosition) && t.abRelation == "mergeSourceAffected" ? o.sourcePosition.stickiness = "toNext" : n.sourcePosition.isEqual(o.targetPosition) ? (o.targetPosition.stickiness = "toNone", o.howMany -= n.howMany) : n.targetPosition.isEqual(o.targetPosition) && t.abRelation == "mergeTargetWasBefore" ? (o.targetPosition.stickiness = "toPrevious", o.howMany += n.howMany) : (o.sourcePosition.hasSameParentAs(n.targetPosition) && (o.howMany += n.howMany), o.sourcePosition.hasSameParentAs(n.sourcePosition) && (o.howMany -= n.howMany)), o.sourcePosition = o.sourcePosition._getTransformedByMoveOperation(n), o.targetPosition = o.targetPosition._getTransformedByMoveOperation(n), o.sourcePosition.stickiness = "toPrevious", o.targetPosition.stickiness = "toNext", o.graveyardPosition.isEqual(n.targetPosition) || (o.graveyardPosition = o.graveyardPosition._getTransformedByMoveOperation(n)), [o]);
}), ut(Wt, Tt, (o, n, t) => {
  if (n.graveyardPosition && (o.graveyardPosition = o.graveyardPosition._getTransformedByDeletion(n.graveyardPosition, 1), o.deletionPosition.isEqual(n.graveyardPosition) && (o.howMany = n.howMany)), o.targetPosition.isEqual(n.splitPosition) && (n.graveyardPosition && o.deletionPosition.isEqual(n.graveyardPosition) || t.abRelation == "mergeTargetNotMoved"))
    return o.sourcePosition = o.sourcePosition._getTransformedBySplitOperation(n), [o];
  if (o.sourcePosition.isEqual(n.splitPosition)) {
    if (t.abRelation == "mergeSourceNotMoved") return o.howMany = 0, o.targetPosition = o.targetPosition._getTransformedBySplitOperation(n), [o];
    if (t.abRelation == "mergeSameElement" || o.sourcePosition.offset > 0) return o.sourcePosition = n.moveTargetPosition.clone(), o.targetPosition = o.targetPosition._getTransformedBySplitOperation(n), [o];
  }
  return o.sourcePosition.hasSameParentAs(n.splitPosition) && (o.howMany = n.splitPosition.offset), o.sourcePosition = o.sourcePosition._getTransformedBySplitOperation(n), o.targetPosition = o.targetPosition._getTransformedBySplitOperation(n), [o];
}), ut(ht, de, (o, n) => {
  const t = E._createFromPositionAndShift(o.sourcePosition, o.howMany)._getTransformedByInsertOperation(n, !1)[0];
  return o.sourcePosition = t.start, o.howMany = t.end.offset - t.start.offset, o.targetPosition.isEqual(n.position) || (o.targetPosition = o.targetPosition._getTransformedByInsertOperation(n)), [o];
}), ut(ht, ht, (o, n, t) => {
  const e = E._createFromPositionAndShift(o.sourcePosition, o.howMany), i = E._createFromPositionAndShift(n.sourcePosition, n.howMany);
  let r, s = t.aIsStrong, a = !t.aIsStrong;
  if (t.abRelation == "insertBefore" || t.baRelation == "insertAfter" ? a = !0 : t.abRelation != "insertAfter" && t.baRelation != "insertBefore" || (a = !1), r = o.targetPosition.isEqual(n.targetPosition) && a ? o.targetPosition._getTransformedByDeletion(n.sourcePosition, n.howMany) : o.targetPosition._getTransformedByMove(n.sourcePosition, n.targetPosition, n.howMany), bm(o, n) && bm(n, o)) return [n.getReversed()];
  if (e.containsPosition(n.targetPosition) && e.containsRange(i, !0)) return e.start = e.start._getTransformedByMove(n.sourcePosition, n.targetPosition, n.howMany), e.end = e.end._getTransformedByMove(n.sourcePosition, n.targetPosition, n.howMany), vo([e], r);
  if (i.containsPosition(o.targetPosition) && i.containsRange(e, !0)) return e.start = e.start._getCombined(n.sourcePosition, n.getMovedRangeStart()), e.end = e.end._getCombined(n.sourcePosition, n.getMovedRangeStart()), vo([e], r);
  const l = xe(o.sourcePosition.getParentPath(), n.sourcePosition.getParentPath());
  if (l == "prefix" || l == "extension") return e.start = e.start._getTransformedByMove(n.sourcePosition, n.targetPosition, n.howMany), e.end = e.end._getTransformedByMove(n.sourcePosition, n.targetPosition, n.howMany), vo([e], r);
  o.type != "remove" || n.type == "remove" || t.aWasUndone || t.forceWeakRemove ? o.type == "remove" || n.type != "remove" || t.bWasUndone || t.forceWeakRemove || (s = !1) : s = !0;
  const c = [], d = e.getDifference(i);
  for (const h of d) {
    h.start = h.start._getTransformedByDeletion(n.sourcePosition, n.howMany), h.end = h.end._getTransformedByDeletion(n.sourcePosition, n.howMany);
    const g = xe(h.start.getParentPath(), n.getMovedRangeStart().getParentPath()) == "same", f = h._getTransformedByInsertion(n.getMovedRangeStart(), n.howMany, g);
    c.push(...f);
  }
  const u = e.getIntersection(i);
  return u !== null && s && (u.start = u.start._getCombined(n.sourcePosition, n.getMovedRangeStart()), u.end = u.end._getCombined(n.sourcePosition, n.getMovedRangeStart()), c.length === 0 ? c.push(u) : c.length == 1 ? i.start.isBefore(e.start) || i.start.isEqual(e.start) ? c.unshift(u) : c.push(u) : c.splice(1, 0, u)), c.length === 0 ? [new re(o.baseVersion)] : vo(c, r);
}), ut(ht, Tt, (o, n, t) => {
  let e = o.targetPosition.clone();
  o.targetPosition.isEqual(n.insertionPosition) && n.graveyardPosition && t.abRelation != "moveTargetAfter" || (e = o.targetPosition._getTransformedBySplitOperation(n));
  const i = E._createFromPositionAndShift(o.sourcePosition, o.howMany);
  if (i.end.isEqual(n.insertionPosition)) return n.graveyardPosition || o.howMany++, o.targetPosition = e, [o];
  if (i.start.hasSameParentAs(n.splitPosition) && i.containsPosition(n.splitPosition)) {
    let s = new E(n.splitPosition, i.end);
    return s = s._getTransformedBySplitOperation(n), vo([new E(i.start, n.splitPosition), s], e);
  }
  o.targetPosition.isEqual(n.splitPosition) && t.abRelation == "insertAtSource" && (e = n.moveTargetPosition), o.targetPosition.isEqual(n.insertionPosition) && t.abRelation == "insertBetween" && (e = o.targetPosition);
  const r = [i._getTransformedBySplitOperation(n)];
  if (n.graveyardPosition) {
    const s = i.start.isEqual(n.graveyardPosition) || i.containsPosition(n.graveyardPosition);
    o.howMany > 1 && s && !t.aWasUndone && r.push(E._createFromPositionAndShift(n.insertionPosition, 1));
  }
  return vo(r, e);
}), ut(ht, Wt, (o, n, t) => {
  const e = E._createFromPositionAndShift(o.sourcePosition, o.howMany);
  if (n.deletionPosition.hasSameParentAs(o.sourcePosition) && e.containsPosition(n.sourcePosition)) {
    if (o.type != "remove" || t.forceWeakRemove) {
      if (o.howMany == 1) return t.bWasUndone ? (o.sourcePosition = n.graveyardPosition.clone(), o.targetPosition = o.targetPosition._getTransformedByMergeOperation(n), [o]) : [new re(0)];
    } else if (!t.aWasUndone) {
      const r = [];
      let s = n.graveyardPosition.clone(), a = n.targetPosition._getTransformedByMergeOperation(n);
      const l = o.targetPosition.getTransformedByOperation(n);
      o.howMany > 1 && (r.push(new ht(o.sourcePosition, o.howMany - 1, l, 0)), s = s._getTransformedByMove(o.sourcePosition, l, o.howMany - 1), a = a._getTransformedByMove(o.sourcePosition, l, o.howMany - 1));
      const c = n.deletionPosition._getCombined(o.sourcePosition, l), d = new ht(s, 1, c, 0), u = d.getMovedRangeStart().path.slice();
      u.push(0);
      const h = new S(d.targetPosition.root, u);
      a = a._getTransformedByMove(s, c, 1);
      const g = new ht(a, n.howMany, h, 0);
      return r.push(d), r.push(g), r;
    }
  }
  const i = E._createFromPositionAndShift(o.sourcePosition, o.howMany)._getTransformedByMergeOperation(n);
  return o.sourcePosition = i.start, o.howMany = i.end.offset - i.start.offset, o.targetPosition = o.targetPosition._getTransformedByMergeOperation(n), [o];
}), ut(Oe, de, (o, n) => (o.position = o.position._getTransformedByInsertOperation(n), [o])), ut(Oe, Wt, (o, n) => o.position.isEqual(n.deletionPosition) ? (o.position = n.graveyardPosition.clone(), o.position.stickiness = "toNext", [o]) : (o.position = o.position._getTransformedByMergeOperation(n), [o])), ut(Oe, ht, (o, n) => (o.position = o.position._getTransformedByMoveOperation(n), [o])), ut(Oe, Oe, (o, n, t) => {
  if (o.position.isEqual(n.position)) {
    if (!t.aIsStrong) return [new re(0)];
    o.oldName = n.newName;
  }
  return [o];
}), ut(Oe, Tt, (o, n) => {
  if (xe(o.position.path, n.splitPosition.getParentPath()) == "same" && !n.graveyardPosition) {
    const t = new Oe(o.position.getShiftedBy(1), o.oldName, o.newName, 0);
    return [o, t];
  }
  return o.position = o.position._getTransformedBySplitOperation(n), [o];
}), ut(ni, ni, (o, n, t) => {
  if (o.root === n.root && o.key === n.key) {
    if (!t.aIsStrong || o.newValue === n.newValue) return [new re(0)];
    o.oldValue = n.newValue;
  }
  return [o];
}), ut(Pn, Pn, (o, n) => o.rootName === n.rootName && o.isAdd === n.isAdd ? [new re(0)] : [o]), ut(Tt, de, (o, n) => (o.splitPosition.hasSameParentAs(n.position) && o.splitPosition.offset < n.position.offset && (o.howMany += n.howMany), o.splitPosition = o.splitPosition._getTransformedByInsertOperation(n), o.insertionPosition = o.insertionPosition._getTransformedByInsertOperation(n), [o])), ut(Tt, Wt, (o, n, t) => {
  if (!o.graveyardPosition && !t.bWasUndone && o.splitPosition.hasSameParentAs(n.sourcePosition)) {
    const e = n.graveyardPosition.path.slice();
    e.push(0);
    const i = new S(n.graveyardPosition.root, e), r = Tt.getInsertionPosition(new S(n.graveyardPosition.root, e)), s = new Tt(i, 0, r, null, 0);
    return o.splitPosition = o.splitPosition._getTransformedByMergeOperation(n), o.insertionPosition = Tt.getInsertionPosition(o.splitPosition), o.graveyardPosition = s.insertionPosition.clone(), o.graveyardPosition.stickiness = "toNext", [s, o];
  }
  return o.splitPosition.hasSameParentAs(n.deletionPosition) && !o.splitPosition.isAfter(n.deletionPosition) && o.howMany--, o.splitPosition.hasSameParentAs(n.targetPosition) && (o.howMany += n.howMany), o.splitPosition = o.splitPosition._getTransformedByMergeOperation(n), o.insertionPosition = Tt.getInsertionPosition(o.splitPosition), o.graveyardPosition && (o.graveyardPosition = o.graveyardPosition._getTransformedByMergeOperation(n)), [o];
}), ut(Tt, ht, (o, n, t) => {
  const e = E._createFromPositionAndShift(n.sourcePosition, n.howMany);
  if (o.graveyardPosition) {
    const r = e.start.isEqual(o.graveyardPosition) || e.containsPosition(o.graveyardPosition);
    if (!t.bWasUndone && r) {
      const s = o.splitPosition._getTransformedByMoveOperation(n), a = o.graveyardPosition._getTransformedByMoveOperation(n), l = a.path.slice();
      l.push(0);
      const c = new S(a.root, l);
      return [new ht(s, o.howMany, c, 0)];
    }
    o.graveyardPosition = o.graveyardPosition._getTransformedByMoveOperation(n);
  }
  const i = o.splitPosition.isEqual(n.targetPosition);
  if (i && (t.baRelation == "insertAtSource" || t.abRelation == "splitBefore")) return o.howMany += n.howMany, o.splitPosition = o.splitPosition._getTransformedByDeletion(n.sourcePosition, n.howMany), o.insertionPosition = Tt.getInsertionPosition(o.splitPosition), [o];
  if (i && t.abRelation && t.abRelation.howMany) {
    const { howMany: r, offset: s } = t.abRelation;
    return o.howMany += r, o.splitPosition = o.splitPosition.getShiftedBy(s), [o];
  }
  if (o.splitPosition.hasSameParentAs(n.sourcePosition) && e.containsPosition(o.splitPosition)) {
    const r = n.howMany - (o.splitPosition.offset - n.sourcePosition.offset);
    return o.howMany -= r, o.splitPosition.hasSameParentAs(n.targetPosition) && o.splitPosition.offset < n.targetPosition.offset && (o.howMany += n.howMany), o.splitPosition = n.sourcePosition.clone(), o.insertionPosition = Tt.getInsertionPosition(o.splitPosition), [o];
  }
  return n.sourcePosition.isEqual(n.targetPosition) || (o.splitPosition.hasSameParentAs(n.sourcePosition) && o.splitPosition.offset <= n.sourcePosition.offset && (o.howMany -= n.howMany), o.splitPosition.hasSameParentAs(n.targetPosition) && o.splitPosition.offset < n.targetPosition.offset && (o.howMany += n.howMany)), o.splitPosition.stickiness = "toNone", o.splitPosition = o.splitPosition._getTransformedByMoveOperation(n), o.splitPosition.stickiness = "toNext", o.graveyardPosition ? o.insertionPosition = o.insertionPosition._getTransformedByMoveOperation(n) : o.insertionPosition = Tt.getInsertionPosition(o.splitPosition), [o];
}), ut(Tt, Tt, (o, n, t) => {
  if (o.splitPosition.isEqual(n.splitPosition)) {
    if (!o.graveyardPosition && !n.graveyardPosition) return [new re(0)];
    if (o.graveyardPosition && n.graveyardPosition && o.graveyardPosition.isEqual(n.graveyardPosition)) return [new re(0)];
    if (t.abRelation == "splitBefore") return o.howMany = 0, o.graveyardPosition = o.graveyardPosition._getTransformedBySplitOperation(n), [o];
  }
  if (o.graveyardPosition && n.graveyardPosition && o.graveyardPosition.isEqual(n.graveyardPosition)) {
    const e = o.splitPosition.root.rootName == "$graveyard", i = n.splitPosition.root.rootName == "$graveyard";
    if (i && !e || !(e && !i) && t.aIsStrong) {
      const r = [];
      return n.howMany && r.push(new ht(n.moveTargetPosition, n.howMany, n.splitPosition, 0)), o.howMany && r.push(new ht(o.splitPosition, o.howMany, o.moveTargetPosition, 0)), r;
    }
    return [new re(0)];
  }
  if (o.graveyardPosition && (o.graveyardPosition = o.graveyardPosition._getTransformedBySplitOperation(n)), o.splitPosition.isEqual(n.insertionPosition) && t.abRelation == "splitBefore") return o.howMany++, [o];
  if (n.splitPosition.isEqual(o.insertionPosition) && t.baRelation == "splitBefore") {
    const e = n.insertionPosition.path.slice();
    e.push(0);
    const i = new S(n.insertionPosition.root, e);
    return [o, new ht(o.insertionPosition, 1, i, 0)];
  }
  return o.splitPosition.hasSameParentAs(n.splitPosition) && o.splitPosition.offset < n.splitPosition.offset && (o.howMany -= n.howMany), o.splitPosition = o.splitPosition._getTransformedBySplitOperation(n), o.insertionPosition = Tt.getInsertionPosition(o.splitPosition), [o];
});
class Gt extends vt(S) {
  constructor(n, t, e = "toNone") {
    if (super(n, t, e), !this.root.is("rootElement")) throw new v("model-liveposition-root-not-rootelement", n);
    ZA.call(this);
  }
  detach() {
    this.stopListening();
  }
  toPosition() {
    return new S(this.root, this.path.slice(), this.stickiness);
  }
  static fromPosition(n, t) {
    return new this(n.root, n.path.slice(), t || n.stickiness);
  }
}
function ZA() {
  this.listenTo(this.root.document.model, "applyOperation", (o, n) => {
    const t = n[0];
    t.isDocumentOperation && QA.call(this, t);
  }, { priority: "low" });
}
function QA(o) {
  const n = this.getTransformedByOperation(o);
  if (!this.isEqual(n)) {
    const t = this.toPosition();
    this.path = n.path, this.root = n.root, this.fire("change", t);
  }
}
Gt.prototype.is = function(o) {
  return o === "livePosition" || o === "model:livePosition" || o == "position" || o === "model:position";
};
class yo {
  constructor(n = {}) {
    m(this, "operations");
    m(this, "isUndoable");
    m(this, "isLocal");
    m(this, "isUndo");
    m(this, "isTyping");
    typeof n == "string" && (n = n === "transparent" ? { isUndoable: !1 } : {}, at("batch-constructor-deprecated-string-type"));
    const { isUndoable: t = !0, isLocal: e = !0, isUndo: i = !1, isTyping: r = !1 } = n;
    this.operations = [], this.isUndoable = t, this.isLocal = e, this.isUndo = i, this.isTyping = r;
  }
  get type() {
    return at("batch-type-deprecated"), "default";
  }
  get baseVersion() {
    for (const n of this.operations) if (n.baseVersion !== null) return n.baseVersion;
    return null;
  }
  addOperation(n) {
    return n.isDocumentOperation && (n.batch = this, this.operations.push(n)), n;
  }
}
const Kr = class Kr {
  constructor(n) {
    m(this, "_markerCollection");
    m(this, "_changesInElement", /* @__PURE__ */ new Map());
    m(this, "_elementsSnapshots", /* @__PURE__ */ new Map());
    m(this, "_elementChildrenSnapshots", /* @__PURE__ */ new Map());
    m(this, "_elementState", /* @__PURE__ */ new Map());
    m(this, "_changedMarkers", /* @__PURE__ */ new Map());
    m(this, "_changedRoots", /* @__PURE__ */ new Map());
    m(this, "_changeCount", 0);
    m(this, "_cachedChanges", null);
    m(this, "_cachedChangesWithGraveyard", null);
    m(this, "_refreshedItems", /* @__PURE__ */ new Set());
    this._markerCollection = n;
  }
  get isEmpty() {
    return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0;
  }
  bufferOperation(n) {
    const t = n;
    switch (t.type) {
      case "insert":
        if (this._isInInsertedElement(t.position.parent)) return;
        this._markInsert(t.position.parent, t.position.offset, t.nodes.maxOffset);
        break;
      case "addAttribute":
      case "removeAttribute":
      case "changeAttribute":
        for (const e of t.range.getItems({ shallow: !0 })) this._isInInsertedElement(e.parent) || this._markAttribute(e);
        break;
      case "remove":
      case "move":
      case "reinsert": {
        if (t.sourcePosition.isEqual(t.targetPosition) || t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition)) return;
        const e = this._isInInsertedElement(t.sourcePosition.parent), i = this._isInInsertedElement(t.targetPosition.parent);
        e || this._markRemove(t.sourcePosition.parent, t.sourcePosition.offset, t.howMany), i || this._markInsert(t.targetPosition.parent, t.getMovedRangeStart().offset, t.howMany);
        const r = E._createFromPositionAndShift(t.sourcePosition, t.howMany);
        for (const s of r.getItems({ shallow: !0 })) this._setElementState(s, "move");
        break;
      }
      case "rename": {
        if (this._isInInsertedElement(t.position.parent)) return;
        this._markRemove(t.position.parent, t.position.offset, 1), this._markInsert(t.position.parent, t.position.offset, 1);
        const e = E._createFromPositionAndShift(t.position, 1);
        for (const i of this._markerCollection.getMarkersIntersectingRange(e)) {
          const r = i.getData();
          this.bufferMarkerChange(i.name, r, r);
        }
        this._setElementState(t.position.nodeAfter, "rename");
        break;
      }
      case "split": {
        const e = t.splitPosition.parent;
        if (!this._isInInsertedElement(e)) {
          this._markRemove(e, t.splitPosition.offset, t.howMany);
          const i = E._createFromPositionAndShift(t.splitPosition, t.howMany);
          for (const r of i.getItems({ shallow: !0 })) this._setElementState(r, "move");
        }
        this._isInInsertedElement(t.insertionPosition.parent) || this._markInsert(t.insertionPosition.parent, t.insertionPosition.offset, 1), t.graveyardPosition && (this._markRemove(t.graveyardPosition.parent, t.graveyardPosition.offset, 1), this._setElementState(t.graveyardPosition.nodeAfter, "move"));
        break;
      }
      case "merge": {
        const e = t.sourcePosition.parent;
        this._isInInsertedElement(e.parent) || this._markRemove(e.parent, e.startOffset, 1);
        const i = t.graveyardPosition.parent;
        this._markInsert(i, t.graveyardPosition.offset, 1), this._setElementState(e, "move");
        const r = t.targetPosition.parent;
        if (!this._isInInsertedElement(r)) {
          this._markInsert(r, t.targetPosition.offset, e.maxOffset);
          const s = E._createFromPositionAndShift(t.sourcePosition, t.howMany);
          for (const a of s.getItems({ shallow: !0 })) this._setElementState(a, "move");
        }
        break;
      }
      case "detachRoot":
      case "addRoot": {
        const e = t.affectedSelectable;
        if (!e._isLoaded || e.isAttached() == t.isAdd) return;
        this._bufferRootStateChange(t.rootName, t.isAdd);
        break;
      }
      case "addRootAttribute":
      case "removeRootAttribute":
      case "changeRootAttribute": {
        if (!t.root._isLoaded) return;
        const e = t.root.rootName;
        this._bufferRootAttributeChange(e, t.key, t.oldValue, t.newValue);
        break;
      }
    }
    this._cachedChanges = null;
  }
  bufferMarkerChange(n, t, e) {
    t.range && t.range.root.is("rootElement") && !t.range.root._isLoaded && (t.range = null), e.range && e.range.root.is("rootElement") && !e.range.root._isLoaded && (e.range = null);
    let i = this._changedMarkers.get(n);
    i ? i.newMarkerData = e : (i = { newMarkerData: e, oldMarkerData: t }, this._changedMarkers.set(n, i)), i.oldMarkerData.range == null && e.range == null && this._changedMarkers.delete(n);
  }
  getMarkersToRemove() {
    const n = [];
    for (const [t, e] of this._changedMarkers) e.oldMarkerData.range != null && n.push({ name: t, range: e.oldMarkerData.range });
    return n;
  }
  getMarkersToAdd() {
    const n = [];
    for (const [t, e] of this._changedMarkers) e.newMarkerData.range != null && n.push({ name: t, range: e.newMarkerData.range });
    return n;
  }
  getChangedMarkers() {
    return Array.from(this._changedMarkers).map(([n, t]) => ({ name: n, data: { oldRange: t.oldMarkerData.range, newRange: t.newMarkerData.range } }));
  }
  hasDataChanges() {
    if (this.getChanges().length || this._changedRoots.size > 0) return !0;
    for (const { newMarkerData: n, oldMarkerData: t } of this._changedMarkers.values()) {
      if (n.affectsData !== t.affectsData) return !0;
      if (n.affectsData) {
        const e = n.range && !t.range, i = !n.range && t.range, r = n.range && t.range && !n.range.isEqual(t.range);
        if (e || i || r) return !0;
      }
    }
    return !1;
  }
  getChanges(n = {}) {
    if (this._cachedChanges) return n.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
    let t = [];
    for (const e of this._changesInElement.keys()) {
      const i = this._changesInElement.get(e).sort((d, u) => d.offset === u.offset ? d.type != u.type ? d.type == "remove" ? -1 : 1 : 0 : d.offset < u.offset ? -1 : 1), r = this._elementChildrenSnapshots.get(e), s = wm(e.getChildren()), a = JA(r.length, i);
      let l = 0, c = 0;
      for (const d of a) if (d === "i") {
        const u = this._getDiffActionForNode(s[l].node, "insert"), h = this._elementsSnapshots.get(s[l].node), g = this._getInsertDiff(e, l, u, s[l], h);
        t.push(g), l++;
      } else if (d === "r") {
        const u = this._getDiffActionForNode(r[c].node, "remove"), h = this._getRemoveDiff(e, l, u, r[c]);
        t.push(h), c++;
      } else if (d === "a") {
        const u = r[c].attributes, h = s[l].attributes;
        let g;
        if (s[l].name == "$text") g = new E(S._createAt(e, l), S._createAt(e, l + 1));
        else {
          const p = e.offsetToIndex(l);
          g = new E(S._createAt(e, l), S._createAt(e.getChild(p), 0));
        }
        const f = this._getAttributesDiff(g, u, h);
        t.push(...f), l++, c++;
      } else l++, c++;
    }
    t.sort((e, i) => e.position.root != i.position.root ? e.position.root.rootName < i.position.root.rootName ? -1 : 1 : e.position.isEqual(i.position) ? e.changeCount - i.changeCount : e.position.isBefore(i.position) ? -1 : 1);
    for (let e = 1, i = 0; e < t.length; e++) {
      const r = t[i], s = t[e], a = r.type == "remove" && s.type == "remove" && r.name == "$text" && s.name == "$text" && r.position.isEqual(s.position), l = r.type == "insert" && s.type == "insert" && r.name == "$text" && s.name == "$text" && r.position.parent == s.position.parent && r.position.offset + r.length == s.position.offset, c = r.type == "attribute" && s.type == "attribute" && r.position.parent == s.position.parent && r.range.isFlat && s.range.isFlat && r.position.offset + r.length == s.position.offset && r.attributeKey == s.attributeKey && r.attributeOldValue == s.attributeOldValue && r.attributeNewValue == s.attributeNewValue;
      a || l || c ? (r.length++, c && (r.range.end = r.range.end.getShiftedBy(1)), t[e] = null) : i = e;
    }
    t = t.filter((e) => e);
    for (const e of t) delete e.changeCount, e.type == "attribute" && (delete e.position, delete e.length);
    return this._changeCount = 0, this._cachedChangesWithGraveyard = t, this._cachedChanges = t.filter(XA), n.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
  }
  getChangedRoots() {
    return Array.from(this._changedRoots.values()).map((n) => {
      const t = { ...n };
      return t.state !== void 0 && delete t.attributes, t;
    });
  }
  getRefreshedItems() {
    return new Set(this._refreshedItems);
  }
  reset() {
    this._changesInElement.clear(), this._elementChildrenSnapshots.clear(), this._elementsSnapshots.clear(), this._elementState.clear(), this._changedMarkers.clear(), this._changedRoots.clear(), this._refreshedItems.clear(), this._cachedChanges = null;
  }
  _refreshItem(n) {
    if (this._isInInsertedElement(n.parent)) return;
    this._markRemove(n.parent, n.startOffset, n.offsetSize), this._markInsert(n.parent, n.startOffset, n.offsetSize), this._refreshedItems.add(n), this._setElementState(n, "refresh");
    const t = E._createOn(n);
    for (const e of this._markerCollection.getMarkersIntersectingRange(t)) {
      const i = e.getData();
      this.bufferMarkerChange(e.name, i, i);
    }
    this._cachedChanges = null;
  }
  _bufferRootLoad(n) {
    if (n.isAttached()) {
      this._bufferRootStateChange(n.rootName, !0), this._markInsert(n, 0, n.maxOffset);
      for (const t of n.getAttributeKeys()) this._bufferRootAttributeChange(n.rootName, t, null, n.getAttribute(t));
      for (const t of this._markerCollection) if (t.getRange().root == n) {
        const e = t.getData();
        this.bufferMarkerChange(t.name, { ...e, range: null }, e);
      }
    }
  }
  _bufferRootStateChange(n, t) {
    if (!this._changedRoots.has(n)) return void this._changedRoots.set(n, { name: n, state: t ? "attached" : "detached" });
    const e = this._changedRoots.get(n);
    e.state !== void 0 ? (delete e.state, e.attributes === void 0 && this._changedRoots.delete(n)) : e.state = t ? "attached" : "detached";
  }
  _bufferRootAttributeChange(n, t, e, i) {
    const r = this._changedRoots.get(n) || { name: n }, s = r.attributes || {};
    if (s[t]) {
      const a = s[t];
      i === a.oldValue ? delete s[t] : a.newValue = i;
    } else s[t] = { oldValue: e, newValue: i };
    Object.entries(s).length === 0 ? (delete r.attributes, r.state === void 0 && this._changedRoots.delete(n)) : (r.attributes = s, this._changedRoots.set(n, r));
  }
  _markInsert(n, t, e) {
    if (n.root.is("rootElement") && !n.root._isLoaded) return;
    const i = { type: "insert", offset: t, howMany: e, count: this._changeCount++ };
    this._markChange(n, i);
  }
  _markRemove(n, t, e) {
    if (n.root.is("rootElement") && !n.root._isLoaded) return;
    const i = { type: "remove", offset: t, howMany: e, count: this._changeCount++ };
    this._markChange(n, i), this._removeAllNestedChanges(n, t, e);
  }
  _markAttribute(n) {
    if (n.root.is("rootElement") && !n.root._isLoaded) return;
    const t = { type: "attribute", offset: n.startOffset, howMany: n.offsetSize, count: this._changeCount++ };
    this._markChange(n.parent, t);
  }
  _markChange(n, t) {
    this._makeSnapshots(n);
    const e = this._getChangesForElement(n);
    this._handleChange(t, e), e.push(t);
    for (let i = 0; i < e.length; i++) e[i].howMany < 1 && (e.splice(i, 1), i--);
  }
  _setElementState(n, t) {
    if (!n.is("element")) return;
    const e = Kr._statesPriority.indexOf(this._elementState.get(n));
    Kr._statesPriority.indexOf(t) > e && this._elementState.set(n, t);
  }
  _getDiffActionForNode(n, t) {
    if (!n.is("element") || !this._elementsSnapshots.has(n)) return t;
    const e = this._elementState.get(n);
    return e && e != "move" ? e : t;
  }
  _getChangesForElement(n) {
    let t;
    return this._changesInElement.has(n) ? t = this._changesInElement.get(n) : (t = [], this._changesInElement.set(n, t)), t;
  }
  _makeSnapshots(n) {
    if (this._elementChildrenSnapshots.has(n)) return;
    const t = wm(n.getChildren());
    this._elementChildrenSnapshots.set(n, t);
    for (const e of t) this._elementsSnapshots.set(e.node, e);
  }
  _handleChange(n, t) {
    n.nodesToHandle = n.howMany;
    for (const e of t) {
      const i = n.offset + n.howMany, r = e.offset + e.howMany;
      if (n.type == "insert" && (e.type == "insert" && (n.offset <= e.offset ? e.offset += n.howMany : n.offset < r && (e.howMany += n.nodesToHandle, n.nodesToHandle = 0)), e.type == "remove" && n.offset < e.offset && (e.offset += n.howMany), e.type == "attribute")) {
        if (n.offset <= e.offset) e.offset += n.howMany;
        else if (n.offset < r) {
          const s = e.howMany;
          e.howMany = n.offset - e.offset, t.unshift({ type: "attribute", offset: i, howMany: s - e.howMany, count: this._changeCount++ });
        }
      }
      if (n.type == "remove") {
        if (e.type == "insert") {
          if (i <= e.offset) e.offset -= n.howMany;
          else if (i <= r) if (n.offset < e.offset) {
            const s = i - e.offset;
            e.offset = n.offset, e.howMany -= s, n.nodesToHandle -= s;
          } else e.howMany -= n.nodesToHandle, n.nodesToHandle = 0;
          else if (n.offset <= e.offset) n.nodesToHandle -= e.howMany, e.howMany = 0;
          else if (n.offset < r) {
            const s = r - n.offset;
            e.howMany -= s, n.nodesToHandle -= s;
          }
        }
        if (e.type == "remove" && (i <= e.offset ? e.offset -= n.howMany : n.offset < e.offset && (n.nodesToHandle += e.howMany, e.howMany = 0)), e.type == "attribute") {
          if (i <= e.offset) e.offset -= n.howMany;
          else if (n.offset < e.offset) {
            const s = i - e.offset;
            e.offset = n.offset, e.howMany -= s;
          } else if (n.offset < r) if (i <= r) {
            const s = e.howMany;
            e.howMany = n.offset - e.offset;
            const a = s - e.howMany - n.nodesToHandle;
            t.unshift({ type: "attribute", offset: n.offset, howMany: a, count: this._changeCount++ });
          } else e.howMany -= r - n.offset;
        }
      }
      if (n.type == "attribute") {
        if (e.type == "insert") if (n.offset < e.offset && i > e.offset) {
          if (i > r) {
            const s = { type: "attribute", offset: r, howMany: i - r, count: this._changeCount++ };
            this._handleChange(s, t), t.push(s);
          }
          n.nodesToHandle = e.offset - n.offset, n.howMany = n.nodesToHandle;
        } else n.offset >= e.offset && n.offset < r && (i > r ? (n.nodesToHandle = i - r, n.offset = r) : n.nodesToHandle = 0);
        if (e.type == "remove" && n.offset < e.offset && i > e.offset) {
          const s = { type: "attribute", offset: e.offset, howMany: i - e.offset, count: this._changeCount++ };
          this._handleChange(s, t), t.push(s), n.nodesToHandle = e.offset - n.offset, n.howMany = n.nodesToHandle;
        }
        e.type == "attribute" && (n.offset >= e.offset && i <= r ? (n.nodesToHandle = 0, n.howMany = 0, n.offset = 0) : n.offset <= e.offset && i >= r && (e.howMany = 0));
      }
    }
    n.howMany = n.nodesToHandle, delete n.nodesToHandle;
  }
  _getInsertDiff(n, t, e, i, r) {
    const s = { type: "insert", position: S._createAt(n, t), name: i.name, attributes: new Map(i.attributes), length: 1, changeCount: this._changeCount++, action: e };
    return e != "insert" && r && (s.before = { name: r.name, attributes: new Map(r.attributes) }), s;
  }
  _getRemoveDiff(n, t, e, i) {
    return { type: "remove", action: e, position: S._createAt(n, t), name: i.name, attributes: new Map(i.attributes), length: 1, changeCount: this._changeCount++ };
  }
  _getAttributesDiff(n, t, e) {
    const i = [];
    e = new Map(e);
    for (const [r, s] of t) {
      const a = e.has(r) ? e.get(r) : null;
      a !== s && i.push({ type: "attribute", position: n.start, range: n.clone(), length: 1, attributeKey: r, attributeOldValue: s, attributeNewValue: a, changeCount: this._changeCount++ }), e.delete(r);
    }
    for (const [r, s] of e) i.push({ type: "attribute", position: n.start, range: n.clone(), length: 1, attributeKey: r, attributeOldValue: null, attributeNewValue: s, changeCount: this._changeCount++ });
    return i;
  }
  _isInInsertedElement(n) {
    const t = n.parent;
    if (!t) return !1;
    const e = this._changesInElement.get(t), i = n.startOffset;
    if (e) {
      for (const r of e) if (r.type == "insert" && i >= r.offset && i < r.offset + r.howMany) return !0;
    }
    return this._isInInsertedElement(t);
  }
  _removeAllNestedChanges(n, t, e) {
    const i = new E(S._createAt(n, t), S._createAt(n, t + e));
    for (const r of i.getItems({ shallow: !0 })) r.is("element") && (this._changesInElement.delete(r), this._removeAllNestedChanges(r, 0, r.maxOffset));
  }
};
m(Kr, "_statesPriority", [void 0, "refresh", "rename", "move"]);
let nd = Kr;
function km(o) {
  return { node: o, name: o.is("$text") ? "$text" : o.name, attributes: new Map(o.getAttributes()) };
}
function wm(o) {
  const n = [];
  for (const t of o) if (t.is("$text")) for (let e = 0; e < t.data.length; ++e) n.push(km(t));
  else n.push(km(t));
  return n;
}
function JA(o, n) {
  const t = [];
  let e = 0, i = 0;
  for (const r of n) {
    if (r.offset > e) {
      for (let s = 0; s < r.offset - e; s++) t.push("e");
      i += r.offset - e;
    }
    if (r.type == "insert") {
      for (let s = 0; s < r.howMany; s++) t.push("i");
      e = r.offset + r.howMany;
    } else if (r.type == "remove") {
      for (let s = 0; s < r.howMany; s++) t.push("r");
      e = r.offset, i += r.howMany;
    } else {
      if (r.howMany > 1500) for (let s = 0; s < r.howMany; s++) t.push("a");
      else t.push(..."a".repeat(r.howMany).split(""));
      e = r.offset + r.howMany, i += r.howMany;
    }
  }
  if (i < o) for (let r = 0; r < o - i - e; r++) t.push("e");
  return t;
}
function XA(o) {
  const n = "position" in o && o.position.root.rootName == "$graveyard", t = "range" in o && o.range.root.rootName == "$graveyard";
  return !n && !t;
}
class tx {
  constructor() {
    m(this, "_operations", []);
    m(this, "_undoPairs", /* @__PURE__ */ new Map());
    m(this, "_undoneOperations", /* @__PURE__ */ new Set());
    m(this, "_baseVersionToOperationIndex", /* @__PURE__ */ new Map());
    m(this, "_version", 0);
    m(this, "_gaps", /* @__PURE__ */ new Map());
  }
  get version() {
    return this._version;
  }
  set version(n) {
    this._operations.length && n > this._version + 1 && this._gaps.set(this._version, n), this._version = n;
  }
  get lastOperation() {
    return this._operations[this._operations.length - 1];
  }
  addOperation(n) {
    if (n.baseVersion !== this.version) throw new v("model-document-history-addoperation-incorrect-version", this, { operation: n, historyVersion: this.version });
    this._operations.push(n), this._version++, this._baseVersionToOperationIndex.set(n.baseVersion, this._operations.length - 1);
  }
  getOperations(n, t = this.version) {
    if (!this._operations.length) return [];
    const e = this._operations[0];
    n === void 0 && (n = e.baseVersion);
    let i = t - 1;
    for (const [a, l] of this._gaps) n > a && n < l && (n = l), i > a && i < l && (i = a - 1);
    if (i < e.baseVersion || n > this.lastOperation.baseVersion) return [];
    let r = this._baseVersionToOperationIndex.get(n);
    r === void 0 && (r = 0);
    let s = this._baseVersionToOperationIndex.get(i);
    return s === void 0 && (s = this._operations.length - 1), this._operations.slice(r, s + 1);
  }
  getOperation(n) {
    const t = this._baseVersionToOperationIndex.get(n);
    if (t !== void 0) return this._operations[t];
  }
  setOperationAsUndone(n, t) {
    this._undoPairs.set(t, n), this._undoneOperations.add(n);
  }
  isUndoingOperation(n) {
    return this._undoPairs.has(n);
  }
  isUndoneOperation(n) {
    return this._undoneOperations.has(n);
  }
  getUndoneOperation(n) {
    return this._undoPairs.get(n);
  }
  reset() {
    this._version = 0, this._undoPairs = /* @__PURE__ */ new Map(), this._operations = [], this._undoneOperations = /* @__PURE__ */ new Set(), this._gaps = /* @__PURE__ */ new Map(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map();
  }
}
class Ea extends Lt {
  constructor(t, e, i = "main") {
    super(e);
    m(this, "rootName");
    m(this, "_document");
    m(this, "_isAttached", !0);
    m(this, "_isLoaded", !0);
    this._document = t, this.rootName = i;
  }
  get document() {
    return this._document;
  }
  isAttached() {
    return this._isAttached;
  }
  toJSON() {
    return this.rootName;
  }
}
Ea.prototype.is = function(o, n) {
  return n ? n === this.name && (o === "rootElement" || o === "model:rootElement" || o === "element" || o === "model:element") : o === "rootElement" || o === "model:rootElement" || o === "element" || o === "model:element" || o === "node" || o === "model:node";
};
const _m = "$graveyard";
class ex extends vt() {
  constructor(t) {
    super();
    m(this, "model");
    m(this, "history");
    m(this, "selection");
    m(this, "roots");
    m(this, "differ");
    m(this, "isReadOnly");
    m(this, "_postFixers");
    m(this, "_hasSelectionChangedFromTheLastChangeBlock");
    this.model = t, this.history = new tx(), this.selection = new _n(this), this.roots = new ne({ idProperty: "rootName" }), this.differ = new nd(t.markers), this.isReadOnly = !1, this._postFixers = /* @__PURE__ */ new Set(), this._hasSelectionChangedFromTheLastChangeBlock = !1, this.createRoot("$root", _m), this.listenTo(t, "applyOperation", (e, i) => {
      const r = i[0];
      r.isDocumentOperation && this.differ.bufferOperation(r);
    }, { priority: "high" }), this.listenTo(t, "applyOperation", (e, i) => {
      const r = i[0];
      r.isDocumentOperation && this.history.addOperation(r);
    }, { priority: "low" }), this.listenTo(this.selection, "change", () => {
      this._hasSelectionChangedFromTheLastChangeBlock = !0;
    }), this.listenTo(t.markers, "update", (e, i, r, s, a) => {
      const l = { ...i.getData(), range: s };
      this.differ.bufferMarkerChange(i.name, a, l), r === null && i.on("change", (c, d) => {
        const u = i.getData();
        this.differ.bufferMarkerChange(i.name, { ...u, range: d }, u);
      });
    }), this.registerPostFixer((e) => {
      let i = !1;
      for (const r of this.roots) r.isAttached() || r.isEmpty || (e.remove(e.createRangeIn(r)), i = !0);
      for (const r of this.model.markers) r.getRange().root.isAttached() || (e.removeMarker(r), i = !0);
      return i;
    });
  }
  get version() {
    return this.history.version;
  }
  set version(t) {
    this.history.version = t;
  }
  get graveyard() {
    return this.getRoot(_m);
  }
  createRoot(t = "$root", e = "main") {
    if (this.roots.get(e)) throw new v("model-document-createroot-name-exists", this, { name: e });
    const i = new Ea(this, t, e);
    return this.roots.add(i), i;
  }
  destroy() {
    this.selection.destroy(), this.stopListening();
  }
  getRoot(t = "main") {
    return this.roots.get(t);
  }
  getRootNames(t = !1) {
    return this.getRoots(t).map((e) => e.rootName);
  }
  getRoots(t = !1) {
    return this.roots.filter((e) => e != this.graveyard && (t || e.isAttached()) && e._isLoaded);
  }
  registerPostFixer(t) {
    this._postFixers.add(t);
  }
  toJSON() {
    const t = Jd(this);
    return t.selection = "[engine.model.DocumentSelection]", t.model = "[engine.model.Model]", t;
  }
  _handleChangeBlock(t) {
    this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(t), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", t.batch) : this.fire("change", t.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = !1;
  }
  _hasDocumentChangedFromTheLastChangeBlock() {
    return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
  }
  _getDefaultRoot() {
    const t = this.getRoots();
    return t.length ? t[0] : this.graveyard;
  }
  _getDefaultRange() {
    const t = this._getDefaultRoot(), e = this.model, i = e.schema, r = e.createPositionFromPath(t, [0]);
    return i.getNearestSelectionRange(r) || e.createRange(r);
  }
  _validateSelectionRange(t) {
    return t.start.isValid() && t.end.isValid() && vm(t.start) && vm(t.end);
  }
  _callPostFixers(t) {
    let e = !1;
    do
      for (const i of this._postFixers) if (this.selection.refresh(), e = i(t), e) break;
    while (e);
  }
}
function vm(o) {
  const n = o.textNode;
  if (n) {
    const t = n.data, e = o.offset - n.startOffset;
    return !cu(t, e) && !du(t, e);
  }
  return !0;
}
class nx extends vt() {
  constructor() {
    super(...arguments);
    m(this, "_markers", /* @__PURE__ */ new Map());
  }
  [Symbol.iterator]() {
    return this._markers.values();
  }
  has(t) {
    const e = t instanceof Do ? t.name : t;
    return this._markers.has(e);
  }
  get(t) {
    return this._markers.get(t) || null;
  }
  _set(t, e, i = !1, r = !1) {
    const s = t instanceof Do ? t.name : t;
    if (s.includes(",")) throw new v("markercollection-incorrect-marker-name", this);
    const a = this._markers.get(s);
    if (a) {
      const d = a.getData(), u = a.getRange();
      let h = !1;
      return u.isEqual(e) || (a._attachLiveRange(Ie.fromRange(e)), h = !0), i != a.managedUsingOperations && (a._managedUsingOperations = i, h = !0), typeof r == "boolean" && r != a.affectsData && (a._affectsData = r, h = !0), h && this.fire(`update:${s}`, a, u, e, d), a;
    }
    const l = Ie.fromRange(e), c = new Do(s, l, i, r);
    return this._markers.set(s, c), this.fire(`update:${s}`, c, null, e, { ...c.getData(), range: null }), c;
  }
  _remove(t) {
    const e = t instanceof Do ? t.name : t, i = this._markers.get(e);
    return !!i && (this._markers.delete(e), this.fire(`update:${e}`, i, i.getRange(), null, i.getData()), this._destroyMarker(i), !0);
  }
  _refresh(t) {
    const e = t instanceof Do ? t.name : t, i = this._markers.get(e);
    if (!i) throw new v("markercollection-refresh-marker-not-exists", this);
    const r = i.getRange();
    this.fire(`update:${e}`, i, r, r, i.getData());
  }
  *getMarkersAtPosition(t) {
    for (const e of this) e.getRange().containsPosition(t) && (yield e);
  }
  *getMarkersIntersectingRange(t) {
    for (const e of this) e.getRange().getIntersection(t) !== null && (yield e);
  }
  destroy() {
    for (const t of this._markers.values()) this._destroyMarker(t);
    this._markers = null, this.stopListening();
  }
  *getMarkersGroup(t) {
    for (const e of this._markers.values()) e.name.startsWith(t + ":") && (yield e);
  }
  _destroyMarker(t) {
    t.stopListening(), t._detachLiveRange();
  }
}
class Do extends vt(Bi) {
  constructor(t, e, i, r) {
    super();
    m(this, "name");
    m(this, "_managedUsingOperations");
    m(this, "_affectsData");
    m(this, "_liveRange");
    this.name = t, this._liveRange = this._attachLiveRange(e), this._managedUsingOperations = i, this._affectsData = r;
  }
  get managedUsingOperations() {
    if (!this._liveRange) throw new v("marker-destroyed", this);
    return this._managedUsingOperations;
  }
  get affectsData() {
    if (!this._liveRange) throw new v("marker-destroyed", this);
    return this._affectsData;
  }
  getData() {
    return { range: this.getRange(), affectsData: this.affectsData, managedUsingOperations: this.managedUsingOperations };
  }
  getStart() {
    if (!this._liveRange) throw new v("marker-destroyed", this);
    return this._liveRange.start.clone();
  }
  getEnd() {
    if (!this._liveRange) throw new v("marker-destroyed", this);
    return this._liveRange.end.clone();
  }
  getRange() {
    if (!this._liveRange) throw new v("marker-destroyed", this);
    return this._liveRange.toRange();
  }
  _attachLiveRange(t) {
    return this._liveRange && this._detachLiveRange(), t.delegate("change:range").to(this), t.delegate("change:content").to(this), this._liveRange = t, t;
  }
  _detachLiveRange() {
    this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null;
  }
}
Do.prototype.is = function(o) {
  return o === "marker" || o === "model:marker";
};
class ix extends Ze {
  constructor(t, e) {
    super(null);
    m(this, "sourcePosition");
    m(this, "howMany");
    this.sourcePosition = t.clone(), this.howMany = e;
  }
  get type() {
    return "detach";
  }
  get affectedSelectable() {
    return null;
  }
  toJSON() {
    const t = super.toJSON();
    return t.sourcePosition = this.sourcePosition.toJSON(), t;
  }
  _validate() {
    if (this.sourcePosition.root.document) throw new v("detach-operation-on-document-node", this);
  }
  _execute() {
    ew(E._createFromPositionAndShift(this.sourcePosition, this.howMany));
  }
  static get className() {
    return "DetachOperation";
  }
}
class Tn extends Bi {
  constructor(t) {
    super();
    m(this, "markers", /* @__PURE__ */ new Map());
    m(this, "_children", new Hr());
    t && this._insertChild(0, t);
  }
  [Symbol.iterator]() {
    return this.getChildren();
  }
  get childCount() {
    return this._children.length;
  }
  get maxOffset() {
    return this._children.maxOffset;
  }
  get isEmpty() {
    return this.childCount === 0;
  }
  get nextSibling() {
    return null;
  }
  get previousSibling() {
    return null;
  }
  get root() {
    return this;
  }
  get parent() {
    return null;
  }
  get document() {
    return null;
  }
  isAttached() {
    return !1;
  }
  getAncestors() {
    return [];
  }
  getChild(t) {
    return this._children.getNode(t);
  }
  getChildAtOffset(t) {
    return this._children.getNodeAtOffset(t);
  }
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  getChildIndex(t) {
    return this._children.getNodeIndex(t);
  }
  getChildStartOffset(t) {
    return this._children.getNodeStartOffset(t);
  }
  getPath() {
    return [];
  }
  getNodeByPath(t) {
    let e = this;
    for (const i of t) e = e.getChildAtOffset(i);
    return e;
  }
  offsetToIndex(t) {
    return this._children.offsetToIndex(t);
  }
  toJSON() {
    const t = [];
    for (const e of this._children) t.push(e.toJSON());
    return t;
  }
  static fromJSON(t) {
    const e = [];
    for (const i of t) i.name ? e.push(Lt.fromJSON(i)) : e.push(Rt.fromJSON(i));
    return new Tn(e);
  }
  _appendChild(t) {
    this._insertChild(this.childCount, t);
  }
  _insertChild(t, e) {
    const i = function(r) {
      return typeof r == "string" ? [new Rt(r)] : (Ye(r) || (r = [r]), Array.from(r).map((s) => typeof s == "string" ? new Rt(s) : s instanceof gn ? new Rt(s.data, s.getAttributes()) : s));
    }(e);
    for (const r of i) r.parent !== null && r._remove(), r.parent = this;
    this._children._insertNodes(t, i);
  }
  _removeChildren(t, e = 1) {
    const i = this._children._removeNodes(t, e);
    for (const r of i) r.parent = null;
    return i;
  }
  _removeChildrenArray(t) {
    this._children._removeNodesArray(t);
    for (const e of t) e.parent = null;
  }
}
Tn.prototype.is = function(o) {
  return o === "documentFragment" || o === "model:documentFragment";
};
class ox {
  constructor(n, t) {
    m(this, "model");
    m(this, "batch");
    this.model = n, this.batch = t;
  }
  createText(n, t) {
    return new Rt(n, t);
  }
  createElement(n, t) {
    return new Lt(n, t);
  }
  createDocumentFragment() {
    return new Tn();
  }
  cloneElement(n, t = !0) {
    return n._clone(t);
  }
  insert(n, t, e = 0) {
    if (this._assertWriterUsedCorrectly(), n instanceof Rt && n.data == "") return;
    const i = S._createAt(t, e);
    if (n.parent) {
      if (Am(n.root, i.root)) return void this.move(E._createOn(n), i);
      if (n.root.document) throw new v("model-writer-insert-forbidden-move", this);
      this.remove(n);
    }
    const r = i.root.document ? i.root.document.version : null, s = n instanceof Tn ? n._removeChildren(0, n.childCount) : n, a = new de(i, s, r);
    if (n instanceof Rt && (a.shouldReceiveAttributes = !0), this.batch.addOperation(a), this.model.applyOperation(a), n instanceof Tn) for (const [l, c] of n.markers) {
      const d = S._createAt(c.root, 0), u = { range: new E(c.start._getCombined(d, i), c.end._getCombined(d, i)), usingOperation: !0, affectsData: !0 };
      this.model.markers.has(l) ? this.updateMarker(l, u) : this.addMarker(l, u);
    }
  }
  insertText(n, t, e, i) {
    t instanceof Tn || t instanceof Lt || t instanceof S ? this.insert(this.createText(n), t, e) : this.insert(this.createText(n, t), e, i);
  }
  insertElement(n, t, e, i) {
    t instanceof Tn || t instanceof Lt || t instanceof S ? this.insert(this.createElement(n), t, e) : this.insert(this.createElement(n, t), e, i);
  }
  append(n, t) {
    this.insert(n, t, "end");
  }
  appendText(n, t, e) {
    t instanceof Tn || t instanceof Lt ? this.insert(this.createText(n), t, "end") : this.insert(this.createText(n, t), e, "end");
  }
  appendElement(n, t, e) {
    t instanceof Tn || t instanceof Lt ? this.insert(this.createElement(n), t, "end") : this.insert(this.createElement(n, t), e, "end");
  }
  setAttribute(n, t, e) {
    if (this._assertWriterUsedCorrectly(), e instanceof E) {
      const i = e.getMinimalFlatRanges();
      for (const r of i) ym(this, n, t, r);
    } else Cm(this, n, t, e);
  }
  setAttributes(n, t) {
    for (const [e, i] of wn(n)) this.setAttribute(e, i, t);
  }
  removeAttribute(n, t) {
    if (this._assertWriterUsedCorrectly(), t instanceof E) {
      const e = t.getMinimalFlatRanges();
      for (const i of e) ym(this, n, null, i);
    } else Cm(this, n, null, t);
  }
  clearAttributes(n) {
    this._assertWriterUsedCorrectly();
    const t = (e) => {
      for (const i of e.getAttributeKeys()) this.removeAttribute(i, e);
    };
    if (n instanceof E) for (const e of n.getItems()) t(e);
    else t(n);
  }
  move(n, t, e) {
    if (this._assertWriterUsedCorrectly(), !(n instanceof E)) throw new v("writer-move-invalid-range", this);
    if (!n.isFlat) throw new v("writer-move-range-not-flat", this);
    const i = S._createAt(t, e);
    if (i.isEqual(n.start)) return;
    if (this._addOperationForAffectedMarkers("move", n), !Am(n.root, i.root)) throw new v("writer-move-different-document", this);
    const r = n.root.document ? n.root.document.version : null, s = new ht(n.start, n.end.offset - n.start.offset, i, r);
    this.batch.addOperation(s), this.model.applyOperation(s);
  }
  remove(n) {
    this._assertWriterUsedCorrectly();
    const t = (n instanceof E ? n : E._createOn(n)).getMinimalFlatRanges().reverse();
    for (const e of t) this._addOperationForAffectedMarkers("move", e), rx(e.start, e.end.offset - e.start.offset, this.batch, this.model);
  }
  merge(n) {
    this._assertWriterUsedCorrectly();
    const t = n.nodeBefore, e = n.nodeAfter;
    if (this._addOperationForAffectedMarkers("merge", n), !(t instanceof Lt)) throw new v("writer-merge-no-element-before", this);
    if (!(e instanceof Lt)) throw new v("writer-merge-no-element-after", this);
    n.root.document ? this._merge(n) : this._mergeDetached(n);
  }
  createPositionFromPath(n, t, e) {
    return this.model.createPositionFromPath(n, t, e);
  }
  createPositionAt(n, t) {
    return this.model.createPositionAt(n, t);
  }
  createPositionAfter(n) {
    return this.model.createPositionAfter(n);
  }
  createPositionBefore(n) {
    return this.model.createPositionBefore(n);
  }
  createRange(n, t) {
    return this.model.createRange(n, t);
  }
  createRangeIn(n) {
    return this.model.createRangeIn(n);
  }
  createRangeOn(n) {
    return this.model.createRangeOn(n);
  }
  createSelection(...n) {
    return this.model.createSelection(...n);
  }
  _mergeDetached(n) {
    const t = n.nodeBefore, e = n.nodeAfter;
    this.move(E._createIn(e), S._createAt(t, "end")), this.remove(e);
  }
  _merge(n) {
    const t = S._createAt(n.nodeBefore, "end"), e = S._createAt(n.nodeAfter, 0), i = n.root.document.graveyard, r = new S(i, [0]), s = n.root.document.version, a = new Wt(e, n.nodeAfter.maxOffset, t, r, s);
    this.batch.addOperation(a), this.model.applyOperation(a);
  }
  rename(n, t) {
    if (this._assertWriterUsedCorrectly(), !(n instanceof Lt)) throw new v("writer-rename-not-element-instance", this);
    const e = n.root.document ? n.root.document.version : null, i = new Oe(S._createBefore(n), n.name, t, e);
    this.batch.addOperation(i), this.model.applyOperation(i);
  }
  split(n, t) {
    this._assertWriterUsedCorrectly();
    let e, i, r = n.parent;
    if (!r.parent) throw new v("writer-split-element-no-parent", this);
    if (t || (t = r.parent), !n.parent.getAncestors({ includeSelf: !0 }).includes(t)) throw new v("writer-split-invalid-limit-element", this);
    do {
      const s = r.root.document ? r.root.document.version : null, a = r.maxOffset - n.offset, l = Tt.getInsertionPosition(n), c = new Tt(n, a, l, null, s);
      this.batch.addOperation(c), this.model.applyOperation(c), e || i || (e = r, i = n.parent.nextSibling), r = (n = this.createPositionAfter(n.parent)).parent;
    } while (r !== t);
    return { position: n, range: new E(S._createAt(e, "end"), S._createAt(i, 0)) };
  }
  wrap(n, t) {
    if (this._assertWriterUsedCorrectly(), !n.isFlat) throw new v("writer-wrap-range-not-flat", this);
    const e = t instanceof Lt ? t : new Lt(t);
    if (e.childCount > 0) throw new v("writer-wrap-element-not-empty", this);
    if (e.parent !== null) throw new v("writer-wrap-element-attached", this);
    this.insert(e, n.start);
    const i = new E(n.start.getShiftedBy(1), n.end.getShiftedBy(1));
    this.move(i, S._createAt(e, 0));
  }
  unwrap(n) {
    if (this._assertWriterUsedCorrectly(), n.parent === null) throw new v("writer-unwrap-element-no-parent", this);
    this.move(E._createIn(n), this.createPositionAfter(n)), this.remove(n);
  }
  addMarker(n, t) {
    if (this._assertWriterUsedCorrectly(), !t || typeof t.usingOperation != "boolean") throw new v("writer-addmarker-no-usingoperation", this);
    const e = t.usingOperation, i = t.range, r = t.affectsData !== void 0 && t.affectsData;
    if (this.model.markers.has(n)) throw new v("writer-addmarker-marker-exists", this);
    if (!i) throw new v("writer-addmarker-no-range", this);
    return e ? (br(this, n, null, i, r), this.model.markers.get(n)) : this.model.markers._set(n, i, e, r);
  }
  updateMarker(n, t) {
    this._assertWriterUsedCorrectly();
    const e = typeof n == "string" ? n : n.name, i = this.model.markers.get(e);
    if (!i) throw new v("writer-updatemarker-marker-not-exists", this);
    if (!t) return at("writer-updatemarker-reconvert-using-editingcontroller", { markerName: e }), void this.model.markers._refresh(i);
    const r = typeof t.usingOperation == "boolean", s = typeof t.affectsData == "boolean", a = s ? t.affectsData : i.affectsData;
    if (!r && !t.range && !s) throw new v("writer-updatemarker-wrong-options", this);
    const l = i.getRange(), c = t.range ? t.range : l;
    r && t.usingOperation !== i.managedUsingOperations ? t.usingOperation ? br(this, e, null, c, a) : (br(this, e, l, null, a), this.model.markers._set(e, c, void 0, a)) : i.managedUsingOperations ? br(this, e, l, c, a) : this.model.markers._set(e, c, void 0, a);
  }
  removeMarker(n) {
    this._assertWriterUsedCorrectly();
    const t = typeof n == "string" ? n : n.name;
    if (!this.model.markers.has(t)) throw new v("writer-removemarker-no-marker", this);
    const e = this.model.markers.get(t);
    if (!e.managedUsingOperations) return void this.model.markers._remove(t);
    br(this, t, e.getRange(), null, e.affectsData);
  }
  addRoot(n, t = "$root") {
    this._assertWriterUsedCorrectly();
    const e = this.model.document.getRoot(n);
    if (e && e.isAttached()) throw new v("writer-addroot-root-exists", this);
    const i = this.model.document, r = new Pn(n, t, !0, i, i.version);
    return this.batch.addOperation(r), this.model.applyOperation(r), this.model.document.getRoot(n);
  }
  detachRoot(n) {
    this._assertWriterUsedCorrectly();
    const t = typeof n == "string" ? this.model.document.getRoot(n) : n;
    if (!t || !t.isAttached()) throw new v("writer-detachroot-no-root", this);
    for (const r of this.model.markers) r.getRange().root === t && this.removeMarker(r);
    for (const r of t.getAttributeKeys()) this.removeAttribute(r, t);
    this.remove(this.createRangeIn(t));
    const e = this.model.document, i = new Pn(t.rootName, t.name, !1, e, e.version);
    this.batch.addOperation(i), this.model.applyOperation(i);
  }
  setSelection(...n) {
    this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(...n);
  }
  setSelectionFocus(n, t) {
    this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(n, t);
  }
  setSelectionAttribute(n, t) {
    if (this._assertWriterUsedCorrectly(), typeof n == "string") this._setSelectionAttribute(n, t);
    else for (const [e, i] of wn(n)) this._setSelectionAttribute(e, i);
  }
  removeSelectionAttribute(n) {
    if (this._assertWriterUsedCorrectly(), typeof n == "string") this._removeSelectionAttribute(n);
    else for (const t of n) this._removeSelectionAttribute(t);
  }
  overrideSelectionGravity() {
    return this.model.document.selection._overrideGravity();
  }
  restoreSelectionGravity(n) {
    this.model.document.selection._restoreGravity(n);
  }
  _setSelectionAttribute(n, t) {
    const e = this.model.document.selection;
    if (e.isCollapsed && e.anchor.parent.isEmpty) {
      const i = _n._getStoreAttributeKey(n);
      this.setAttribute(i, t, e.anchor.parent);
    }
    e._setAttribute(n, t);
  }
  _removeSelectionAttribute(n) {
    const t = this.model.document.selection;
    if (t.isCollapsed && t.anchor.parent.isEmpty) {
      const e = _n._getStoreAttributeKey(n);
      this.removeAttribute(e, t.anchor.parent);
    }
    t._removeAttribute(n);
  }
  _assertWriterUsedCorrectly() {
    if (this.model._currentWriter !== this) throw new v("writer-incorrect-use", this);
  }
  _addOperationForAffectedMarkers(n, t) {
    for (const e of this.model.markers) {
      if (!e.managedUsingOperations) continue;
      const i = e.getRange();
      let r = !1;
      if (n === "move") {
        const s = t;
        r = s.containsPosition(i.start) || s.start.isEqual(i.start) || s.containsPosition(i.end) || s.end.isEqual(i.end);
      } else {
        const s = t, a = s.nodeBefore, l = s.nodeAfter, c = i.start.parent == a && i.start.isAtEnd, d = i.end.parent == l && i.end.offset == 0, u = i.end.nodeAfter == l, h = i.start.nodeAfter == l;
        r = c || d || u || h;
      }
      r && this.updateMarker(e.name, { range: i });
    }
  }
}
function ym(o, n, t, e) {
  const i = o.model, r = i.document;
  let s, a, l, c = e.start;
  for (const u of e.getWalker({ shallow: !0 })) l = u.item.getAttribute(n), s && a != l && (a != t && d(), c = s), s = u.nextPosition, a = l;
  function d() {
    const u = new E(c, s), h = u.root.document ? r.version : null, g = new Jt(u, n, a, t, h);
    o.batch.addOperation(g), i.applyOperation(g);
  }
  s instanceof S && s != c && a != t && d();
}
function Cm(o, n, t, e) {
  const i = o.model, r = i.document, s = e.getAttribute(n);
  let a, l;
  if (s != t) {
    if (e.root === e) {
      const c = e.document ? r.version : null;
      l = new ni(e, n, s, t, c);
    } else {
      a = new E(S._createBefore(e), o.createPositionAfter(e));
      const c = a.root.document ? r.version : null;
      l = new Jt(a, n, s, t, c);
    }
    o.batch.addOperation(l), i.applyOperation(l);
  }
}
function br(o, n, t, e, i) {
  const r = o.model, s = r.document, a = new Se(n, t, e, r.markers, !!i, s.version);
  o.batch.addOperation(a), r.applyOperation(a);
}
function rx(o, n, t, e) {
  let i;
  if (o.root.document) {
    const r = e.document, s = new S(r.graveyard, [0]);
    i = new ht(o, n, s, r.version);
  } else i = new ix(o, n);
  t.addOperation(i), e.applyOperation(i);
}
function Am(o, n) {
  return o === n || o instanceof Ea && n instanceof Ea;
}
function sx(o, n, t = {}) {
  if (n.isCollapsed) return;
  const e = n.getFirstRange();
  if (e.root.rootName == "$graveyard") return;
  const i = o.schema;
  o.change((r) => {
    if (!t.doNotResetEntireContent && function(c, d) {
      const u = c.getLimitElement(d);
      if (!d.containsEntireContent(u)) return !1;
      const h = d.getFirstRange();
      return h.start.parent == h.end.parent ? !1 : c.checkChild(u, "paragraph");
    }(i, n)) return void function(c, d) {
      const u = c.model.schema.getLimitElement(d);
      c.remove(c.createRangeIn(u)), xm(c, c.createPositionAt(u, 0), d);
    }(r, n);
    const s = {};
    if (!t.doNotAutoparagraph) {
      const c = n.getSelectedElement();
      c && Object.assign(s, i.getAttributesWithProperty(c, "copyOnReplace", !0));
    }
    const [a, l] = function(c) {
      const d = c.root.document.model, u = c.start;
      let h = c.end;
      if (d.hasContent(c, { ignoreMarkers: !0 })) {
        const g = function(f) {
          const p = f.parent, b = p.root.document.model.schema, k = p.getAncestors({ parentFirst: !0, includeSelf: !0 });
          for (const w of k) {
            if (b.isLimit(w)) return null;
            if (b.isBlock(w)) return w;
          }
        }(h);
        if (g && h.isTouching(d.createPositionAt(g, 0))) {
          const f = d.createSelection(c);
          d.modifySelection(f, { direction: "backward" });
          const p = f.getLastPosition(), b = d.createRange(p, h);
          d.hasContent(b, { ignoreMarkers: !0 }) || (h = p);
        }
      }
      return [Gt.fromPosition(u, "toPrevious"), Gt.fromPosition(h, "toNext")];
    }(e);
    a.isTouching(l) || r.remove(r.createRange(a, l)), t.leaveUnmerged || (function(c, d, u) {
      const h = c.model;
      if (!wu(c.model.schema, d, u)) return;
      const [g, f] = function(p, b) {
        const k = p.getAncestors(), w = b.getAncestors();
        let _ = 0;
        for (; k[_] && k[_] == w[_]; ) _++;
        return [k[_], w[_]];
      }(d, u);
      !g || !f || (!h.hasContent(g, { ignoreMarkers: !0 }) && h.hasContent(f, { ignoreMarkers: !0 }) ? rw(c, d, u, g.parent) : ow(c, d, u, g.parent));
    }(r, a, l), i.removeDisallowedAttributes(a.parent.getChildren(), r)), sw(r, n, a), !t.doNotAutoparagraph && function(c, d) {
      const u = c.checkChild(d, "$text"), h = c.checkChild(d, "paragraph");
      return !u && h;
    }(i, a) && xm(r, a, n, s), a.detach(), l.detach();
  });
}
function ow(o, n, t, e) {
  const i = n.parent, r = t.parent;
  if (i != e && r != e) {
    for (n = o.createPositionAfter(i), (t = o.createPositionBefore(r)).isEqual(n) || o.insert(r, n), o.merge(n); t.parent.isEmpty; ) {
      const s = t.parent;
      t = o.createPositionBefore(s), o.remove(s);
    }
    wu(o.model.schema, n, t) && ow(o, n, t, e);
  }
}
function rw(o, n, t, e) {
  const i = n.parent, r = t.parent;
  if (i != e && r != e) {
    for (n = o.createPositionAfter(i), (t = o.createPositionBefore(r)).isEqual(n) || o.insert(i, t); n.parent.isEmpty; ) {
      const s = n.parent;
      n = o.createPositionBefore(s), o.remove(s);
    }
    t = o.createPositionBefore(r), function(s, a) {
      const l = a.nodeBefore, c = a.nodeAfter;
      l.name != c.name && s.rename(l, c.name), s.clearAttributes(l), s.setAttributes(Object.fromEntries(c.getAttributes()), l), s.merge(a);
    }(o, t), wu(o.model.schema, n, t) && rw(o, n, t, e);
  }
}
function wu(o, n, t) {
  const e = n.parent, i = t.parent;
  return e != i && !o.isLimit(e) && !o.isLimit(i) && function(r, s, a) {
    const l = new E(r, s);
    for (const c of l.getWalker()) if (a.isLimit(c.item)) return !1;
    return !0;
  }(n, t, o);
}
function xm(o, n, t, e = {}) {
  const i = o.createElement("paragraph");
  o.model.schema.setAllowedAttributes(i, e, o), o.insert(i, n), sw(o, t, o.createPositionAt(i, 0));
}
function sw(o, n, t) {
  n instanceof _n ? o.setSelection(t) : n.setTo(t);
}
function Em(o, n) {
  const t = [];
  Array.from(o.getItems({ direction: "backward" })).map((e) => n.createRangeOn(e)).filter((e) => (e.start.isAfter(o.start) || e.start.isEqual(o.start)) && (e.end.isBefore(o.end) || e.end.isEqual(o.end))).forEach((e) => {
    t.push(e.start.parent), n.remove(e);
  }), t.forEach((e) => {
    let i = e;
    for (; i.parent && i.isEmpty; ) {
      const r = n.createRangeOn(i);
      i = i.parent, n.remove(r);
    }
  });
}
class ax {
  constructor(n, t, e) {
    m(this, "model");
    m(this, "writer");
    m(this, "position");
    m(this, "canMergeWith");
    m(this, "schema");
    m(this, "_documentFragment");
    m(this, "_documentFragmentPosition");
    m(this, "_firstNode", null);
    m(this, "_lastNode", null);
    m(this, "_lastAutoParagraph", null);
    m(this, "_filterAttributesOf", []);
    m(this, "_affectedStart", null);
    m(this, "_affectedEnd", null);
    m(this, "_nodeToSelect", null);
    this.model = n, this.writer = t, this.position = e, this.canMergeWith = /* @__PURE__ */ new Set([this.position.parent]), this.schema = n.schema, this._documentFragment = t.createDocumentFragment(), this._documentFragmentPosition = t.createPositionAt(this._documentFragment, 0);
  }
  handleNodes(n) {
    for (const t of Array.from(n)) this._handleNode(t);
    this._insertPartialFragment(), this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph), this._mergeOnRight(), this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = [];
  }
  _updateLastNodeFromAutoParagraph(n) {
    const t = this.writer.createPositionAfter(this._lastNode), e = this.writer.createPositionAfter(n);
    if (e.isAfter(t)) {
      if (this._lastNode = n, this.position.parent != n || !this.position.isAtEnd) throw new v("insertcontent-invalid-insertion-position", this);
      this.position = e, this._setAffectedBoundaries(this.position);
    }
  }
  getSelectionRange() {
    return this._nodeToSelect ? E._createOn(this._nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position);
  }
  getAffectedRange() {
    return this._affectedStart ? new E(this._affectedStart, this._affectedEnd) : null;
  }
  destroy() {
    this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach();
  }
  _handleNode(n) {
    this._checkAndSplitToAllowedPosition(n) ? (this._appendToFragment(n), this._firstNode || (this._firstNode = n), this._lastNode = n) : this.schema.isObject(n) || this._handleDisallowedNode(n);
  }
  _insertPartialFragment() {
    if (this._documentFragment.isEmpty) return;
    const n = Gt.fromPosition(this.position, "toNext");
    this._setAffectedBoundaries(this.position), this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position), this._mergeOnLeft(), this.position = n.toPosition()), this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position), this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0), this.position = n.toPosition(), n.detach();
  }
  _handleDisallowedNode(n) {
    n.is("element") && this.handleNodes(n.getChildren());
  }
  _appendToFragment(n) {
    if (!this.schema.checkChild(this.position, n)) throw new v("insertcontent-wrong-position", this, { node: n, position: this.position });
    this.writer.insert(n, this._documentFragmentPosition), this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(n.offsetSize), this.schema.isObject(n) && !this.schema.checkChild(this.position, "$text") ? this._nodeToSelect = n : this._nodeToSelect = null, this._filterAttributesOf.push(n);
  }
  _setAffectedBoundaries(n) {
    this._affectedStart || (this._affectedStart = Gt.fromPosition(n, "toPrevious")), this._affectedEnd && !this._affectedEnd.isBefore(n) || (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = Gt.fromPosition(n, "toNext"));
  }
  _mergeOnLeft() {
    const n = this._firstNode;
    if (!(n instanceof Lt) || !this._canMergeLeft(n)) return;
    const t = Gt._createBefore(n);
    t.stickiness = "toNext";
    const e = Gt.fromPosition(this.position, "toNext");
    this._affectedStart.isEqual(t) && (this._affectedStart.detach(), this._affectedStart = Gt._createAt(t.nodeBefore, "end", "toPrevious")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(), this._affectedEnd = Gt._createAt(t.nodeBefore, "end", "toNext")), this.position = e.toPosition(), e.detach(), this._filterAttributesOf.push(this.position.parent), t.detach();
  }
  _mergeOnRight() {
    const n = this._lastNode;
    if (!(n instanceof Lt) || !this._canMergeRight(n)) return;
    const t = Gt._createAfter(n);
    if (t.stickiness = "toNext", !this.position.isEqual(t)) throw new v("insertcontent-invalid-insertion-position", this);
    this.position = S._createAt(t.nodeBefore, "end");
    const e = Gt.fromPosition(this.position, "toPrevious");
    this._affectedEnd.isEqual(t) && (this._affectedEnd.detach(), this._affectedEnd = Gt._createAt(t.nodeBefore, "end", "toNext")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(), this._affectedStart = Gt._createAt(t.nodeBefore, 0, "toPrevious")), this.position = e.toPosition(), e.detach(), this._filterAttributesOf.push(this.position.parent), t.detach();
  }
  _canMergeLeft(n) {
    const t = n.previousSibling;
    return t instanceof Lt && this.canMergeWith.has(t) && this.model.schema.checkMerge(t, n);
  }
  _canMergeRight(n) {
    const t = n.nextSibling;
    return t instanceof Lt && this.canMergeWith.has(t) && this.model.schema.checkMerge(n, t);
  }
  _insertAutoParagraph() {
    this._insertPartialFragment();
    const n = this.writer.createElement("paragraph");
    this.writer.insert(n, this.position), this._setAffectedBoundaries(this.position), this._lastAutoParagraph = n, this.position = this.writer.createPositionAt(n, 0);
  }
  _checkAndSplitToAllowedPosition(n) {
    const t = this._getAllowedIn(this.position.parent, n);
    if (!t) return !1;
    for (t != this.position.parent && this._insertPartialFragment(); t != this.position.parent; ) if (this.position.isAtStart) {
      const e = this.position.parent;
      this.position = this.writer.createPositionBefore(e), e.isEmpty && e.parent === t && this.writer.remove(e);
    } else if (this.position.isAtEnd) this.position = this.writer.createPositionAfter(this.position.parent);
    else {
      const e = this.writer.createPositionAfter(this.position.parent);
      this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = e, this.canMergeWith.add(this.position.nodeAfter);
    }
    return this.schema.checkChild(this.position.parent, n) || this._insertAutoParagraph(), !0;
  }
  _getAllowedIn(n, t) {
    return this.schema.checkChild(n, t) || this.schema.checkChild(n, "paragraph") && this.schema.checkChild("paragraph", t) ? n : this.schema.isLimit(n) ? null : this._getAllowedIn(n.parent, t);
  }
}
function lx(o, n, t, e = {}) {
  if (!o.schema.isObject(n)) throw new v("insertobject-element-not-an-object", o, { object: n });
  const i = t || o.document.selection;
  let r = i;
  e.findOptimalPosition && o.schema.isBlock(n) && (r = o.createSelection(o.schema.findOptimalInsertionRange(i, e.findOptimalPosition)));
  const s = yt(i.getSelectedBlocks()), a = {};
  return s && Object.assign(a, o.schema.getAttributesWithProperty(s, "copyOnReplace", !0)), o.change((l) => {
    r.isCollapsed || o.deleteContent(r, { doNotAutoparagraph: !0 });
    let c = n;
    const d = r.anchor.parent;
    !o.schema.checkChild(d, n) && o.schema.checkChild(d, "paragraph") && o.schema.checkChild("paragraph", n) && (c = l.createElement("paragraph"), l.insert(n, c)), o.schema.setAllowedAttributes(c, a, l);
    const u = o.insertContent(c, r);
    return u.isCollapsed || e.setSelection && function(h, g, f, p) {
      const b = h.model;
      if (f == "on") return void h.setSelection(g, "on");
      if (f != "after") throw new v("insertobject-invalid-place-parameter-value", b);
      let k = g.nextSibling;
      if (b.schema.isInline(g)) return void h.setSelection(g, "after");
      !(k && b.schema.checkChild(k, "$text")) && b.schema.checkChild(g.parent, "paragraph") && (k = h.createElement("paragraph"), b.schema.setAllowedAttributes(k, p, h), b.insertContent(k, h.createPositionAfter(g))), k && h.setSelection(k, 0);
    }(l, n, e.setSelection, a), u;
  });
}
function cx(o, n) {
  const { isForward: t, walker: e, unit: i, schema: r, treatEmojiAsSingleUnit: s } = o, { type: a, item: l, nextPosition: c } = n;
  if (a == "text") return o.unit === "word" ? function(d, u) {
    let h = d.position.textNode;
    for (h || (h = u ? d.position.nodeAfter : d.position.nodeBefore); h && h.is("$text"); ) {
      const g = d.position.offset - h.startOffset;
      if (hx(h, g, u)) h = u ? d.position.nodeAfter : d.position.nodeBefore;
      else {
        if (ux(h.data, g, u)) break;
        d.next();
      }
    }
    return d.position;
  }(e, t) : function(d, u, h) {
    const g = d.position.textNode;
    if (g) {
      const f = g.data;
      let p = d.position.offset - g.startOffset;
      for (; cu(f, p) || u == "character" && du(f, p) || h && Tk(f, p); ) d.next(), p = d.position.offset - g.startOffset;
    }
    return d.position;
  }(e, i, s);
  if (a == (t ? "elementStart" : "elementEnd")) {
    if (r.isSelectable(l)) return S._createAt(l, t ? "after" : "before");
    if (r.checkChild(c, "$text")) return c;
  } else {
    if (r.isLimit(l)) return void e.skip(() => !0);
    if (r.checkChild(c, "$text")) return c;
  }
}
function dx(o, n) {
  const t = o.root, e = S._createAt(t, n ? "end" : 0);
  return n ? new E(o, e) : new E(e, o);
}
function ux(o, n, t) {
  const e = n + (t ? 0 : -1);
  return ' ,.?!:;"-()'.includes(o.charAt(e));
}
function hx(o, n, t) {
  return n === (t ? o.offsetSize : 0);
}
let mx = class extends _t() {
  constructor() {
    super();
    m(this, "markers");
    m(this, "document");
    m(this, "schema");
    m(this, "_pendingChanges");
    m(this, "_currentWriter");
    this.markers = new nx(), this.document = new ex(this), this.schema = new MA(), this._pendingChanges = [], this._currentWriter = null, ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((n) => this.decorate(n)), this.on("applyOperation", (n, t) => {
      t[0]._validate();
    }, { priority: "highest" }), this.schema.register("$root", { isLimit: !0 }), this.schema.register("$container", { allowIn: ["$root", "$container"] }), this.schema.register("$block", { allowIn: ["$root", "$container"], isBlock: !0 }), this.schema.register("$blockObject", { allowWhere: "$block", isBlock: !0, isObject: !0 }), this.schema.register("$inlineObject", { allowWhere: "$text", allowAttributesOf: "$text", isInline: !0, isObject: !0 }), this.schema.register("$text", { allowIn: "$block", isInline: !0, isContent: !0 }), this.schema.register("$clipboardHolder", { allowContentOf: "$root", allowChildren: "$text", isLimit: !0 }), this.schema.register("$documentFragment", { allowContentOf: "$root", allowChildren: "$text", isLimit: !0 }), this.schema.register("$marker"), this.schema.addChildCheck(() => !0, "$marker"), SA(this), this.document.registerPostFixer(Zk), this.on("insertContent", (n, [t, e]) => {
      n.return = function(i, r, s) {
        return i.change((a) => {
          const l = s || i.document.selection;
          l.isCollapsed || i.deleteContent(l, { doNotAutoparagraph: !0 });
          const c = new ax(i, a, l.anchor), d = [];
          let u;
          if (r.is("documentFragment")) {
            if (r.markers.size) {
              const f = [];
              for (const [p, b] of r.markers) {
                const { start: k, end: w } = b, _ = k.isEqual(w);
                f.push({ position: k, name: p, isCollapsed: _ }, { position: w, name: p, isCollapsed: _ });
              }
              f.sort(({ position: p }, { position: b }) => p.isBefore(b) ? 1 : -1);
              for (const { position: p, name: b, isCollapsed: k } of f) {
                let w = null, _ = null;
                const y = p.parent === r && p.isAtStart, C = p.parent === r && p.isAtEnd;
                y || C ? k && (_ = y ? "start" : "end") : (w = a.createElement("$marker"), a.insert(w, p)), d.push({ name: b, element: w, collapsed: _ });
              }
            }
            u = r.getChildren();
          } else u = [r];
          c.handleNodes(u);
          let h = c.getSelectionRange();
          if (r.is("documentFragment") && d.length) {
            const f = h ? Ie.fromRange(h) : null, p = {};
            for (let b = d.length - 1; b >= 0; b--) {
              const { name: k, element: w, collapsed: _ } = d[b], y = !p[k];
              if (y && (p[k] = []), w) {
                const C = a.createPositionAt(w, "before");
                p[k].push(C), a.remove(w);
              } else {
                const C = c.getAffectedRange();
                if (!C) {
                  _ && p[k].push(c.position);
                  continue;
                }
                _ ? p[k].push(C[_]) : p[k].push(y ? C.start : C.end);
              }
            }
            for (const [b, [k, w]] of Object.entries(p)) k && w && k.root === w.root && k.root.document && !a.model.markers.has(b) && a.addMarker(b, { usingOperation: !0, affectsData: !0, range: new E(k, w) });
            f && (h = f.toRange(), f.detach());
          }
          h && (l instanceof _n ? a.setSelection(h) : l.setTo(h));
          const g = c.getAffectedRange() || i.createRange(l.anchor);
          return c.destroy(), g;
        });
      }(this, t, e);
    }), this.on("insertObject", (n, [t, e, i]) => {
      n.return = lx(this, t, e, i);
    }), this.on("canEditAt", (n) => {
      const t = !this.document.isReadOnly;
      n.return = t, t || n.stop();
    });
  }
  change(n) {
    try {
      return this._pendingChanges.length === 0 ? (this._pendingChanges.push({ batch: new yo(), callback: n }), this._runPendingChanges()[0]) : n(this._currentWriter);
    } catch (t) {
      v.rethrowUnexpectedError(t, this);
    }
  }
  enqueueChange(n, t) {
    try {
      n ? typeof n == "function" ? (t = n, n = new yo()) : n instanceof yo || (n = new yo(n)) : n = new yo(), this._pendingChanges.push({ batch: n, callback: t }), this._pendingChanges.length == 1 && this._runPendingChanges();
    } catch (e) {
      v.rethrowUnexpectedError(e, this);
    }
  }
  applyOperation(n) {
    n._execute();
  }
  insertContent(n, t, e, ...i) {
    const r = Vl(t, e);
    return this.fire("insertContent", [n, r, e, ...i]);
  }
  insertObject(n, t, e, i, ...r) {
    const s = Vl(t, e);
    return this.fire("insertObject", [n, s, i, i, ...r]);
  }
  deleteContent(n, t) {
    sx(this, n, t);
  }
  modifySelection(n, t) {
    (function(e, i, r = {}) {
      const s = e.schema, a = r.direction != "backward", l = r.unit ? r.unit : "character", c = !!r.treatEmojiAsSingleUnit, d = i.focus, u = new Jn({ boundaries: dx(d, a), singleCharacters: !0, direction: a ? "forward" : "backward" }), h = { walker: u, schema: s, isForward: a, unit: l, treatEmojiAsSingleUnit: c };
      let g;
      for (; g = u.next(); ) {
        if (g.done) return;
        const f = cx(h, g.value);
        if (f) return void (i instanceof _n ? e.change((p) => {
          p.setSelectionFocus(f);
        }) : i.setFocus(f));
      }
    })(this, n, t);
  }
  getSelectedContent(n) {
    return function(t, e) {
      return t.change((i) => {
        const r = i.createDocumentFragment(), s = e.getFirstRange();
        if (!s || s.isCollapsed) return r;
        const a = s.start.root, l = s.start.getCommonPath(s.end), c = a.getNodeByPath(l);
        let d;
        d = s.start.parent == s.end.parent ? s : i.createRange(i.createPositionAt(c, s.start.path[l.length]), i.createPositionAt(c, s.end.path[l.length] + 1));
        const u = d.end.offset - d.start.offset;
        for (const h of d.getItems({ shallow: !0 })) h.is("$textProxy") ? i.appendText(h.data, h.getAttributes(), r) : i.append(i.cloneElement(h, !0), r);
        if (d != s) {
          const h = s._getTransformedByMove(d.start, i.createPositionAt(r, 0), u)[0], g = i.createRange(i.createPositionAt(r, 0), h.start);
          Em(i.createRange(h.end, i.createPositionAt(r, "end")), i), Em(g, i);
        }
        return r;
      });
    }(this, n);
  }
  hasContent(n, t = {}) {
    const e = n instanceof E ? n : E._createIn(n);
    if (e.isCollapsed) return !1;
    const { ignoreWhitespaces: i = !1, ignoreMarkers: r = !1 } = t;
    if (!r) {
      for (const s of this.markers.getMarkersIntersectingRange(e)) if (s.affectsData) return !0;
    }
    for (const s of e.getItems()) if (this.schema.isContent(s) && (!s.is("$textProxy") || !i || s.data.search(/\S/) !== -1))
      return !0;
    return !1;
  }
  canEditAt(n) {
    const t = Vl(n);
    return this.fire("canEditAt", [t]);
  }
  createPositionFromPath(n, t, e) {
    return new S(n, t, e);
  }
  createPositionAt(n, t) {
    return S._createAt(n, t);
  }
  createPositionAfter(n) {
    return S._createAfter(n);
  }
  createPositionBefore(n) {
    return S._createBefore(n);
  }
  createRange(n, t) {
    return new E(n, t);
  }
  createRangeIn(n) {
    return E._createIn(n);
  }
  createRangeOn(n) {
    return E._createOn(n);
  }
  createSelection(...n) {
    return new qe(...n);
  }
  createBatch(n) {
    return new yo(n);
  }
  createOperationFromJSON(n) {
    return WA.fromJSON(n, this.document);
  }
  destroy() {
    this.document.destroy(), this.stopListening();
  }
  _runPendingChanges() {
    const n = [];
    this.fire("_beforeChanges");
    try {
      for (; this._pendingChanges.length; ) {
        const t = this._pendingChanges[0].batch;
        this._currentWriter = new ox(this, t);
        const e = this._pendingChanges[0].callback(this._currentWriter);
        n.push(e), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null;
      }
    } finally {
      this._pendingChanges.length = 0, this._currentWriter = null, this.fire("_afterChanges");
    }
    return n;
  }
};
function Vl(o, n) {
  if (o) return o instanceof qe || o instanceof _n ? o : o instanceof lo ? n || n === 0 ? new qe(o, n) : o.is("rootElement") ? new qe(o, "in") : new qe(o, "on") : new qe(o);
}
class gx extends Fn {
  constructor() {
    super(...arguments);
    m(this, "domEventType", "click");
  }
  onDomEvent(t) {
    this.fire(t.type, t);
  }
}
class dl extends Fn {
  constructor() {
    super(...arguments);
    m(this, "domEventType", ["mousedown", "mouseup", "mouseover", "mouseout"]);
  }
  onDomEvent(t) {
    this.fire(t.type, t);
  }
}
class fx extends Fn {
  constructor() {
    super(...arguments);
    m(this, "domEventType", ["touchstart", "touchend", "touchmove"]);
  }
  onDomEvent(t) {
    this.fire(t.type, t);
  }
}
class Bn {
  constructor(n) {
    m(this, "document");
    this.document = n;
  }
  createDocumentFragment(n) {
    return new Ji(this.document, n);
  }
  createElement(n, t, e) {
    return new si(this.document, n, t, e);
  }
  createText(n) {
    return new we(this.document, n);
  }
  clone(n, t = !1) {
    return n._clone(t);
  }
  appendChild(n, t) {
    return t._appendChild(n);
  }
  insertChild(n, t, e) {
    return e._insertChild(n, t);
  }
  removeChildren(n, t, e) {
    return e._removeChildren(n, t);
  }
  remove(n) {
    const t = n.parent;
    return t ? this.removeChildren(t.getChildIndex(n), 1, t) : [];
  }
  replace(n, t) {
    const e = n.parent;
    if (e) {
      const i = e.getChildIndex(n);
      return this.removeChildren(i, 1, e), this.insertChild(i, t, e), !0;
    }
    return !1;
  }
  unwrapElement(n) {
    const t = n.parent;
    if (t) {
      const e = t.getChildIndex(n);
      this.remove(n), this.insertChild(e, n.getChildren(), t);
    }
  }
  rename(n, t) {
    const e = new si(this.document, n, t.getAttributes(), t.getChildren());
    return this.replace(t, e) ? e : null;
  }
  setAttribute(n, t, e) {
    e._setAttribute(n, t);
  }
  removeAttribute(n, t) {
    t._removeAttribute(n);
  }
  addClass(n, t) {
    t._addClass(n);
  }
  removeClass(n, t) {
    t._removeClass(n);
  }
  setStyle(n, t, e) {
    In(n) && e === void 0 ? t._setStyle(n) : e._setStyle(n, t);
  }
  removeStyle(n, t) {
    t._removeStyle(n);
  }
  setCustomProperty(n, t, e) {
    e._setCustomProperty(n, t);
  }
  removeCustomProperty(n, t) {
    return t._removeCustomProperty(n);
  }
  createPositionAt(n, t) {
    return B._createAt(n, t);
  }
  createPositionAfter(n) {
    return B._createAfter(n);
  }
  createPositionBefore(n) {
    return B._createBefore(n);
  }
  createRange(n, t) {
    return new st(n, t);
  }
  createRangeOn(n) {
    return st._createOn(n);
  }
  createRangeIn(n) {
    return st._createIn(n);
  }
  createSelection(...n) {
    return new ei(...n);
  }
}
const px = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i, bx = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i, kx = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i, wx = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i, _x = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i, vx = /\w+\((?:[^()]|\([^()]*\))*\)|\S+/gi, yx = /* @__PURE__ */ new Set(["black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange", "aliceblue", "antiquewhite", "aquamarine", "azure", "beige", "bisque", "blanchedalmond", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "gainsboro", "ghostwhite", "gold", "goldenrod", "greenyellow", "grey", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "limegreen", "linen", "magenta", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "oldlace", "olivedrab", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "thistle", "tomato", "turquoise", "violet", "wheat", "whitesmoke", "yellowgreen", "activeborder", "activecaption", "appworkspace", "background", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "captiontext", "graytext", "highlight", "highlighttext", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infobackground", "infotext", "menu", "menutext", "scrollbar", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "window", "windowframe", "windowtext", "rebeccapurple", "currentcolor", "transparent"]);
function Cx(o) {
  return o.startsWith("#") ? px.test(o) : o.startsWith("rgb") ? bx.test(o) || kx.test(o) : o.startsWith("hsl") ? wx.test(o) || _x.test(o) : yx.has(o.toLowerCase());
}
const Ax = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;
function xx(o) {
  return Ax.test(o);
}
const Ex = /^[+-]?[0-9]*([.][0-9]+)?%$/;
function Tx(o) {
  return Ex.test(o);
}
const Sx = ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"];
function Ix(o) {
  return Sx.includes(o);
}
const Mx = ["center", "top", "bottom", "left", "right"];
function Dx(o) {
  return Mx.includes(o);
}
const Px = ["fixed", "scroll", "local"];
function Lx(o) {
  return Px.includes(o);
}
const Bx = /^url\(/;
function Nx(o) {
  return Bx.test(o);
}
function zx(o = "") {
  if (o === "") return { top: void 0, right: void 0, bottom: void 0, left: void 0 };
  const n = aw(o), t = n[0], e = n[2] || t, i = n[1] || t;
  return { top: t, bottom: e, right: i, left: n[3] || i };
}
function Ox(o) {
  return (n) => {
    const { top: t, right: e, bottom: i, left: r } = n, s = [];
    return [t, e, r, i].every((a) => !!a) ? s.push([o, Rx(n)]) : (t && s.push([o + "-top", t]), e && s.push([o + "-right", e]), i && s.push([o + "-bottom", i]), r && s.push([o + "-left", r])), s;
  };
}
function Rx({ top: o, right: n, bottom: t, left: e }) {
  const i = [];
  return e !== n ? i.push(o, n, t, e) : t !== o ? i.push(o, n, t) : n !== o ? i.push(o, n) : i.push(o), i.join(" ");
}
function Vx(o) {
  return (n) => ({ path: o, value: zx(n) });
}
function aw(o) {
  const n = o.trim().slice(0, 1500).matchAll(vx);
  return Array.from(n).map((t) => t[0]);
}
function Fx(o) {
  o.setNormalizer("background", (n) => {
    const t = {}, e = aw(n);
    for (const i of e) Ix(i) ? (t.repeat = t.repeat || [], t.repeat.push(i)) : Dx(i) ? (t.position = t.position || [], t.position.push(i)) : Lx(i) ? t.attachment = i : Cx(i) ? t.color = i : Nx(i) && (t.image = i);
    return { path: "background", value: t };
  }), o.setNormalizer("background-color", (n) => ({ path: "background.color", value: n })), o.setReducer("background", (n) => {
    const t = [];
    return t.push(["background-color", n.color]), t;
  }), o.setStyleRelation("background", ["background-color"]);
}
function jx(o) {
  o.setNormalizer("margin", Vx("margin")), o.setNormalizer("margin-top", (n) => ({ path: "margin.top", value: n })), o.setNormalizer("margin-right", (n) => ({ path: "margin.right", value: n })), o.setNormalizer("margin-bottom", (n) => ({ path: "margin.bottom", value: n })), o.setNormalizer("margin-left", (n) => ({ path: "margin.left", value: n })), o.setReducer("margin", Ox("margin")), o.setStyleRelation("margin", ["margin-top", "margin-right", "margin-bottom", "margin-left"]);
}
class lw {
  constructor(n) {
    m(this, "crashes", []);
    m(this, "state", "initializing");
    m(this, "_crashNumberLimit");
    m(this, "_now", Date.now);
    m(this, "_minimumNonErrorTimePeriod");
    m(this, "_boundErrorHandler");
    m(this, "_listeners");
    if (this.crashes = [], this._crashNumberLimit = typeof n.crashNumberLimit == "number" ? n.crashNumberLimit : 3, this._minimumNonErrorTimePeriod = typeof n.minimumNonErrorTimePeriod == "number" ? n.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = (t) => {
      const e = "error" in t ? t.error : t.reason;
      e instanceof Error && this._handleError(e, t);
    }, this._listeners = {}, !this._restart) throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
  }
  destroy() {
    this._stopErrorHandling(), this._listeners = {};
  }
  on(n, t) {
    this._listeners[n] || (this._listeners[n] = []), this._listeners[n].push(t);
  }
  off(n, t) {
    this._listeners[n] = this._listeners[n].filter((e) => e !== t);
  }
  _fire(n, ...t) {
    const e = this._listeners[n] || [];
    for (const i of e) i.apply(this, [null, ...t]);
  }
  _startErrorHandling() {
    window.addEventListener("error", this._boundErrorHandler), window.addEventListener("unhandledrejection", this._boundErrorHandler);
  }
  _stopErrorHandling() {
    window.removeEventListener("error", this._boundErrorHandler), window.removeEventListener("unhandledrejection", this._boundErrorHandler);
  }
  _handleError(n, t) {
    if (this._shouldReactToError(n)) {
      this.crashes.push({ message: n.message, stack: n.stack, filename: t instanceof ErrorEvent ? t.filename : void 0, lineno: t instanceof ErrorEvent ? t.lineno : void 0, colno: t instanceof ErrorEvent ? t.colno : void 0, date: this._now() });
      const e = this._shouldRestart();
      this.state = "crashed", this._fire("stateChange"), this._fire("error", { error: n, causesRestart: e }), e ? this._restart() : (this.state = "crashedPermanently", this._fire("stateChange"));
    }
  }
  _shouldReactToError(n) {
    return n.is && n.is("CKEditorError") && n.context !== void 0 && n.context !== null && this.state === "ready" && this._isErrorComingFromThisItem(n);
  }
  _shouldRestart() {
    return this.crashes.length <= this._crashNumberLimit ? !0 : (this.crashes[this.crashes.length - 1].date - this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date) / this._crashNumberLimit > this._minimumNonErrorTimePeriod;
  }
}
function id(o, n = /* @__PURE__ */ new Set()) {
  const t = [o], e = /* @__PURE__ */ new Set();
  let i = 0;
  for (; t.length > i; ) {
    const r = t[i++];
    if (!e.has(r) && Hx(r) && !n.has(r)) if (e.add(r), Symbol.iterator in r) try {
      for (const s of r) t.push(s);
    } catch {
    }
    else for (const s in r) s !== "defaultValue" && t.push(r[s]);
  }
  return e;
}
function Hx(o) {
  const n = Object.prototype.toString.call(o), t = typeof o;
  return !(t === "number" || t === "boolean" || t === "string" || t === "symbol" || t === "function" || n === "[object Date]" || n === "[object RegExp]" || n === "[object Module]" || o == null || o._watchdogExcluded || o instanceof EventTarget || o instanceof Event);
}
function cw(o, n, t = /* @__PURE__ */ new Set()) {
  if (o === n && typeof (e = o) == "object" && e !== null) return !0;
  var e;
  const i = id(o, t), r = id(n, t);
  for (const s of i) if (r.has(s)) return !0;
  return !1;
}
class dw extends lw {
  constructor(t, e = {}) {
    super(e);
    m(this, "_editor", null);
    m(this, "_lifecyclePromise", null);
    m(this, "_throttledSave");
    m(this, "_data");
    m(this, "_lastDocumentVersion");
    m(this, "_elementOrData");
    m(this, "_initUsingData", !0);
    m(this, "_editables", {});
    m(this, "_config");
    m(this, "_excludedProps");
    this._throttledSave = Qo(this._save.bind(this), typeof e.saveInterval == "number" ? e.saveInterval : 5e3), t && (this._creator = (i, r) => t.create(i, r)), this._destructor = (i) => i.destroy();
  }
  get editor() {
    return this._editor;
  }
  get _item() {
    return this._editor;
  }
  setCreator(t) {
    this._creator = t;
  }
  setDestructor(t) {
    this._destructor = t;
  }
  _restart() {
    return Promise.resolve().then(() => (this.state = "initializing", this._fire("stateChange"), this._destroy())).catch((t) => {
      console.error("An error happened during the editor destroying.", t);
    }).then(() => {
      const t = {}, e = [], i = this._config.rootsAttributes || {}, r = {};
      for (const [a, l] of Object.entries(this._data.roots)) l.isLoaded ? (t[a] = "", r[a] = i[a] || {}) : e.push(a);
      const s = { ...this._config, extraPlugins: this._config.extraPlugins || [], lazyRoots: e, rootsAttributes: r, _watchdogInitialData: this._data };
      return delete s.initialData, s.extraPlugins.push(Ux), this._initUsingData ? this.create(t, s, s.context) : Si(this._elementOrData) ? this.create(this._elementOrData, s, s.context) : this.create(this._editables, s, s.context);
    }).then(() => {
      this._fire("restart");
    });
  }
  create(t = this._elementOrData, e = this._config, i) {
    return this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => (super._startErrorHandling(), this._elementOrData = t, this._initUsingData = typeof t == "string" || Object.keys(t).length > 0 && typeof Object.values(t)[0] == "string", this._config = this._cloneEditorConfiguration(e) || {}, this._config.context = i, this._creator(t, this._config))).then((r) => {
      this._editor = r, r.model.document.on("change:data", this._throttledSave), this._lastDocumentVersion = r.model.document.version, this._data = this._getData(), this._initUsingData || (this._editables = this._getEditables()), this.state = "ready", this._fire("stateChange");
    }).finally(() => {
      this._lifecyclePromise = null;
    }), this._lifecyclePromise;
  }
  destroy() {
    return this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy())).finally(() => {
      this._lifecyclePromise = null;
    }), this._lifecyclePromise;
  }
  _destroy() {
    return Promise.resolve().then(() => {
      this._stopErrorHandling(), this._throttledSave.cancel();
      const t = this._editor;
      return this._editor = null, t.model.document.off("change:data", this._throttledSave), this._destructor(t);
    });
  }
  _save() {
    const t = this._editor.model.document.version;
    try {
      this._data = this._getData(), this._initUsingData || (this._editables = this._getEditables()), this._lastDocumentVersion = t;
    } catch (e) {
      console.error(e, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
    }
  }
  _setExcludedProperties(t) {
    this._excludedProps = t;
  }
  _getData() {
    const t = this._editor, e = t.model.document.roots.filter((l) => l.isAttached() && l.rootName != "$graveyard"), { plugins: i } = t, r = i.has("CommentsRepository") && i.get("CommentsRepository"), s = i.has("TrackChanges") && i.get("TrackChanges"), a = { roots: {}, markers: {}, commentThreads: JSON.stringify([]), suggestions: JSON.stringify([]) };
    e.forEach((l) => {
      a.roots[l.rootName] = { content: JSON.stringify(Array.from(l.getChildren())), attributes: JSON.stringify(Array.from(l.getAttributes())), isLoaded: l._isLoaded };
    });
    for (const l of t.model.markers) l._affectsData && (a.markers[l.name] = { rangeJSON: l.getRange().toJSON(), usingOperation: l._managedUsingOperations, affectsData: l._affectsData });
    return r && (a.commentThreads = JSON.stringify(r.getCommentThreads({ toJSON: !0, skipNotAttached: !0 }))), s && (a.suggestions = JSON.stringify(s.getSuggestions({ toJSON: !0, skipNotAttached: !0 }))), a;
  }
  _getEditables() {
    const t = {};
    for (const e of this.editor.model.document.getRootNames()) {
      const i = this.editor.ui.getEditableElement(e);
      i && (t[e] = i);
    }
    return t;
  }
  _isErrorComingFromThisItem(t) {
    return cw(this._editor, t.context, this._excludedProps);
  }
  _cloneEditorConfiguration(t) {
    return il(t, (e, i) => Si(e) || i === "context" ? e : void 0);
  }
}
class Ux {
  constructor(n) {
    m(this, "editor");
    m(this, "_data");
    this.editor = n, this._data = n.config.get("_watchdogInitialData");
  }
  init() {
    this.editor.data.on("init", (n) => {
      n.stop(), this.editor.model.enqueueChange({ isUndoable: !1 }, (t) => {
        this._restoreCollaborationData(), this._restoreEditorData(t);
      }), this.editor.data.fire("ready");
    }, { priority: 999 });
  }
  _createNode(n, t) {
    if ("name" in t) {
      const e = n.createElement(t.name, t.attributes);
      if (t.children) for (const i of t.children) e._appendChild(this._createNode(n, i));
      return e;
    }
    return n.createText(t.data, t.attributes);
  }
  _restoreEditorData(n) {
    const t = this.editor;
    Object.entries(this._data.roots).forEach(([e, { content: i, attributes: r }]) => {
      const s = JSON.parse(i), a = JSON.parse(r), l = t.model.document.getRoot(e);
      for (const [c, d] of a) n.setAttribute(c, d, l);
      for (const c of s) {
        const d = this._createNode(n, c);
        n.insert(d, l, "end");
      }
    }), Object.entries(this._data.markers).forEach(([e, i]) => {
      const { document: r } = t.model, { rangeJSON: { start: s, end: a }, ...l } = i, c = r.getRoot(s.root), d = n.createPositionFromPath(c, s.path, s.stickiness), u = n.createPositionFromPath(c, a.path, a.stickiness), h = n.createRange(d, u);
      n.addMarker(e, { range: h, ...l });
    });
  }
  _restoreCollaborationData() {
    const n = JSON.parse(this._data.commentThreads), t = JSON.parse(this._data.suggestions);
    n.forEach((e) => {
      const i = this.editor.config.get("collaboration.channelId"), r = this.editor.plugins.get("CommentsRepository");
      r.hasCommentThread(e.threadId) && r.getCommentThread(e.threadId).remove(), r.addCommentThread({ channelId: i, ...e });
    }), t.forEach((e) => {
      const i = this.editor.plugins.get("TrackChangesEditing");
      i.hasSuggestion(e.id) ? i.getSuggestion(e.id).attributes = e.attributes : i.addSuggestionData(e);
    });
  }
}
const Ur = Symbol("MainQueueId");
class $x extends lw {
  constructor(t, e = {}) {
    super(e);
    m(this, "_watchdogs", /* @__PURE__ */ new Map());
    m(this, "_watchdogConfig");
    m(this, "_context", null);
    m(this, "_contextProps", /* @__PURE__ */ new Set());
    m(this, "_actionQueues", new qx());
    m(this, "_contextConfig");
    m(this, "_item");
    this._watchdogConfig = e, this._creator = (i) => t.create(i), this._destructor = (i) => i.destroy(), this._actionQueues.onEmpty(() => {
      this.state === "initializing" && (this.state = "ready", this._fire("stateChange"));
    });
  }
  setCreator(t) {
    this._creator = t;
  }
  setDestructor(t) {
    this._destructor = t;
  }
  get context() {
    return this._context;
  }
  create(t = {}) {
    return this._actionQueues.enqueue(Ur, () => (this._contextConfig = t, this._create()));
  }
  getItem(t) {
    return this._getWatchdog(t)._item;
  }
  getItemState(t) {
    return this._getWatchdog(t).state;
  }
  add(t) {
    const e = Tm(t);
    return Promise.all(e.map((i) => this._actionQueues.enqueue(i.id, () => {
      if (this.state === "destroyed") throw new Error("Cannot add items to destroyed watchdog.");
      if (!this._context) throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
      let r;
      if (this._watchdogs.has(i.id)) throw new Error(`Item with the given id is already added: '${i.id}'.`);
      if (i.type === "editor") return r = new dw(null, this._watchdogConfig), r.setCreator(i.creator), r._setExcludedProperties(this._contextProps), i.destructor && r.setDestructor(i.destructor), this._watchdogs.set(i.id, r), r.on("error", (s, { error: a, causesRestart: l }) => {
        this._fire("itemError", { itemId: i.id, error: a }), l && this._actionQueues.enqueue(i.id, () => new Promise((c) => {
          const d = () => {
            r.off("restart", d), this._fire("itemRestart", { itemId: i.id }), c();
          };
          r.on("restart", d);
        }));
      }), r.create(i.sourceElementOrData, i.config, this._context);
      throw new Error(`Not supported item type: '${i.type}'.`);
    })));
  }
  remove(t) {
    const e = Tm(t);
    return Promise.all(e.map((i) => this._actionQueues.enqueue(i, () => {
      const r = this._getWatchdog(i);
      return this._watchdogs.delete(i), r.destroy();
    })));
  }
  destroy() {
    return this._actionQueues.enqueue(Ur, () => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
  }
  _restart() {
    return this._actionQueues.enqueue(Ur, () => (this.state = "initializing", this._fire("stateChange"), this._destroy().catch((t) => {
      console.error("An error happened during destroying the context or items.", t);
    }).then(() => this._create()).then(() => this._fire("restart"))));
  }
  _create() {
    return Promise.resolve().then(() => (this._startErrorHandling(), this._creator(this._contextConfig))).then((t) => (this._context = t, this._contextProps = id(this._context), Promise.all(Array.from(this._watchdogs.values()).map((e) => (e._setExcludedProperties(this._contextProps), e.create(void 0, void 0, this._context))))));
  }
  _destroy() {
    return Promise.resolve().then(() => {
      this._stopErrorHandling();
      const t = this._context;
      return this._context = null, this._contextProps = /* @__PURE__ */ new Set(), Promise.all(Array.from(this._watchdogs.values()).map((e) => e.destroy())).then(() => this._destructor(t));
    });
  }
  _getWatchdog(t) {
    const e = this._watchdogs.get(t);
    if (!e) throw new Error(`Item with the given id was not registered: ${t}.`);
    return e;
  }
  _isErrorComingFromThisItem(t) {
    for (const e of this._watchdogs.values()) if (e._isErrorComingFromThisItem(t)) return !1;
    return cw(this._context, t.context);
  }
}
class qx {
  constructor() {
    m(this, "_onEmptyCallbacks", []);
    m(this, "_queues", /* @__PURE__ */ new Map());
    m(this, "_activeActions", 0);
  }
  onEmpty(n) {
    this._onEmptyCallbacks.push(n);
  }
  enqueue(n, t) {
    const e = n === Ur;
    this._activeActions++, this._queues.get(n) || this._queues.set(n, Promise.resolve());
    const i = (e ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(Ur), this._queues.get(n)])).then(t), r = i.catch(() => {
    });
    return this._queues.set(n, r), i.finally(() => {
      this._activeActions--, this._queues.get(n) === r && this._activeActions === 0 && this._onEmptyCallbacks.forEach((s) => s());
    });
  }
}
function Tm(o) {
  return Array.isArray(o) ? o : [o];
}
class Wx {
  constructor() {
    m(this, "_commands");
    this._commands = /* @__PURE__ */ new Map();
  }
  add(n, t) {
    this._commands.set(n, t);
  }
  get(n) {
    return this._commands.get(n);
  }
  execute(n, ...t) {
    const e = this.get(n);
    if (!e) throw new v("commandcollection-command-not-found", this, { commandName: n });
    return e.execute(...t);
  }
  *names() {
    yield* this._commands.keys();
  }
  *commands() {
    yield* this._commands.values();
  }
  [Symbol.iterator]() {
    return this._commands[Symbol.iterator]();
  }
  destroy() {
    for (const n of this.commands()) n.destroy();
  }
}
class Gx extends Mt {
  constructor(t) {
    super();
    m(this, "editor");
    this.editor = t;
  }
  set(t, e, i = {}) {
    if (typeof e == "string") {
      const r = e;
      e = (s, a) => {
        this.editor.execute(r), a();
      };
    }
    super.set(t, e, i);
  }
}
const Fl = "contentEditing", Sm = "common";
class Kx {
  constructor(n) {
    m(this, "keystrokeInfos", /* @__PURE__ */ new Map());
    m(this, "_editor");
    this._editor = n;
    const t = n.config.get("menuBar.isVisible"), e = n.locale.t;
    this.addKeystrokeInfoCategory({ id: Fl, label: e("Content editing keystrokes"), description: e("These keyboard shortcuts allow for quick access to content editing features.") });
    const i = [{ label: e("Close contextual balloons, dropdowns, and dialogs"), keystroke: "Esc" }, { label: e("Open the accessibility help dialog"), keystroke: "Alt+0" }, { label: e("Move focus between form fields (inputs, buttons, etc.)"), keystroke: [["Tab"], ["Shift+Tab"]] }, { label: e("Move focus to the toolbar, navigate between toolbars"), keystroke: "Alt+F10", mayRequireFn: !0 }, { label: e("Navigate through the toolbar or menu bar"), keystroke: [["arrowup"], ["arrowright"], ["arrowdown"], ["arrowleft"]] }, { label: e("Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content."), keystroke: [["Enter"], ["Space"]] }];
    t && i.push({ label: e("Move focus to the menu bar, navigate between menu bars"), keystroke: "Alt+F9", mayRequireFn: !0 }), this.addKeystrokeInfoCategory({ id: "navigation", label: e("User interface and content navigation keystrokes"), description: e("Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface."), groups: [{ id: "common", keystrokes: i }] });
  }
  addKeystrokeInfoCategory({ id: n, label: t, description: e, groups: i }) {
    this.keystrokeInfos.set(n, { id: n, label: t, description: e, groups: /* @__PURE__ */ new Map() }), this.addKeystrokeInfoGroup({ categoryId: n, id: Sm }), i && i.forEach((r) => {
      this.addKeystrokeInfoGroup({ categoryId: n, ...r });
    });
  }
  addKeystrokeInfoGroup({ categoryId: n = Fl, id: t, label: e, keystrokes: i }) {
    const r = this.keystrokeInfos.get(n);
    if (!r) throw new v("accessibility-unknown-keystroke-info-category", this._editor, { groupId: t, categoryId: n });
    r.groups.set(t, { id: t, label: e, keystrokes: i || [] });
  }
  addKeystrokeInfos({ categoryId: n = Fl, groupId: t = Sm, keystrokes: e }) {
    if (!this.keystrokeInfos.has(n)) throw new v("accessibility-unknown-keystroke-info-category", this._editor, { categoryId: n, keystrokes: e });
    const i = this.keystrokeInfos.get(n);
    if (!i.groups.has(t)) throw new v("accessibility-unknown-keystroke-info-group", this._editor, { groupId: t, categoryId: n, keystrokes: e });
    i.groups.get(t).keystrokes.push(...e);
  }
}
function Yx(o) {
  return Object.getPrototypeOf(o).constructor.editorName;
}
function jl(o) {
  if (!o) return;
  const n = Array.isArray(o) ? { items: o } : o, t = function i(r) {
    return r.flatMap((s) => typeof s == "string" ? [s] : i(s.items));
  }(n.items || []);
  return { isMultiline: t.includes("-"), shouldNotGroupWhenFull: !!n.shouldNotGroupWhenFull, items: (e = t, e.filter((i) => i !== "|" && i !== "-")) };
  var e;
}
function Zx() {
  let o = "unknown", n = "unknown";
  return H.isMac ? o = "mac" : H.isWindows ? o = "windows" : H.isiOS ? o = "ios" : H.isAndroid && (o = "android"), H.isGecko ? n = "gecko" : H.isBlink ? n = "blink" : H.isSafari && (n = "safari"), { os: o, browser: n };
}
function Qx() {
  return localStorage.getItem("__ckeditor-session-id") || localStorage.setItem("__ckeditor-session-id", Ee()), localStorage.getItem("__ckeditor-session-id");
}
function Jx() {
  return N.window.CKEDITOR_PAGE_SESSION_ID = N.window.CKEDITOR_PAGE_SESSION_ID || Ee(), N.window.CKEDITOR_PAGE_SESSION_ID;
}
class Po extends _t() {
  constructor(t = {}) {
    super();
    m(this, "accessibility");
    m(this, "commands");
    m(this, "config");
    m(this, "conversion");
    m(this, "data");
    m(this, "editing");
    m(this, "locale");
    m(this, "model");
    m(this, "plugins");
    m(this, "keystrokes");
    m(this, "t");
    m(this, "_context");
    m(this, "_readOnlyLocks");
    if ("sanitizeHtml" in t) throw new v("editor-config-sanitizehtml-not-supported");
    const e = this.constructor, { translations: i, ...r } = e.defaultConfig || {}, { translations: s = i, ...a } = t, l = t.language || r.language;
    this._context = t.context || new va({ language: l, translations: s }), this._context._addEditor(this, !t.context);
    const c = Array.from(e.builtinPlugins || []);
    this.config = new fk(a, r), this.config.define("plugins", c), this.config.define(this._context._getEditorConfig()), function(u) {
      let h = u.get("licenseKey");
      if (!h && window.CKEDITOR_GLOBAL_LICENSE_KEY && (h = window.CKEDITOR_GLOBAL_LICENSE_KEY, u.set("licenseKey", h)), !h) throw new v("license-key-missing");
    }(this.config), this.plugins = new Sk(this, c, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this._readOnlyLocks = /* @__PURE__ */ new Set(), this.commands = new Wx(), this.set("state", "initializing"), this.once("ready", () => this.state = "ready", { priority: "high" }), this.once("destroy", () => this.state = "destroyed", { priority: "high" }), this.model = new mx(), this.on("change:isReadOnly", () => {
      this.model.document.isReadOnly = this.isReadOnly;
    });
    const d = new RC();
    this.data = new $A(this.model, d), this.editing = new IA(this.model, d), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new qA([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new Gx(this), this.keystrokes.listenTo(this.editing.view.document), this.accessibility = new Kx(this), function(u) {
      const h = u.config.get("licenseKey"), g = window[Symbol.for("cke distribution")] || "sh";
      function f(w) {
        u.enableReadOnlyMode(Symbol("invalidLicense")), u._showLicenseError(w);
      }
      if (h == "GPL") return void (g == "cloud" && f("distributionChannel"));
      const p = function(w) {
        const _ = w.split(".");
        return _.length != 3 ? null : _[1];
      }(h);
      if (!p) return void f("invalid");
      const b = lu(p);
      if (!b || !function(w) {
        return ["exp", "jti", "vc"].every((_) => _ in w);
      }(b)) return void f("invalid");
      if (b.distributionChannel && !Bt(b.distributionChannel).includes(g)) return void f("distributionChannel");
      if (MC(function(w) {
        return Object.getOwnPropertyNames(w).sort().filter((_) => _ != "vc" && w[_] != null).map((_) => w[_]);
      }(b)) != b.vc.toLowerCase()) return void f("invalid");
      if (new Date(1e3 * b.exp) < Jy) return void f("expired");
      const k = b.licensedHosts;
      if (k && k.length > 0 && !function(w) {
        const { hostname: _ } = new URL(window.location.href);
        if (w.includes(_)) return !0;
        const y = _.split(".");
        return w.filter((C) => C.includes("*")).map((C) => C.split(".")).filter((C) => C.length <= y.length).map((C) => Array(y.length - C.length).fill(C[0] === "*" ? "*" : "").concat(C)).some((C) => y.every((x, I) => C[I] === x || C[I] === "*"));
      }(k)) return void f("domainLimit");
      if (["evaluation", "trial"].includes(b.licenseType) && 1e3 * b.exp < Date.now()) return void f("expired");
      if (["development", "evaluation", "trial"].includes(b.licenseType)) {
        const { licenseType: w } = b, _ = w[0].toUpperCase() + w.slice(1), y = w === "evaluation" ? "an" : "a";
        console.info(`%cCKEditor 5 ${_} License`, "color: #ffffff; background: #743CCD; font-size: 14px; padding: 4px 8px; border-radius: 4px;"), console.warn(` You are using ${y} ${w} license of CKEditor 5` + (w === "trial" ? " which is for evaluation purposes only" : "") + ". For production usage, please obtain a production license at https://portal.ckeditor.com/");
      }
      if (["evaluation", "trial"].includes(b.licenseType)) {
        const w = b.licenseType, _ = setTimeout(() => {
          f(`${w}Limit`);
        }, 6e5);
        u.on("destroy", () => {
          clearTimeout(_);
        });
      }
      b.usageEndpoint && u.once("ready", () => {
        const w = { requestId: Ee(), requestTime: Math.round(Date.now() / 1e3), license: h, editor: Xx(u) };
        u._sendUsageRequest(b.usageEndpoint, w).then((_) => {
          const { status: y, message: C } = _;
          C && console.warn(C), y != "ok" && f("usageLimit");
        }, () => {
          Qy("license-key-validation-endpoint-not-reachable", { url: b.usageEndpoint });
        });
      }, { priority: "high" });
    }(this);
  }
  static get editorName() {
    return "Editor";
  }
  get isReadOnly() {
    return this._readOnlyLocks.size > 0;
  }
  set isReadOnly(t) {
    throw new v("editor-isreadonly-has-no-setter");
  }
  enableReadOnlyMode(t) {
    if (typeof t != "string" && typeof t != "symbol") throw new v("editor-read-only-lock-id-invalid", null, { lockId: t });
    this._readOnlyLocks.has(t) || (this._readOnlyLocks.add(t), this._readOnlyLocks.size === 1 && this.fire("change:isReadOnly", "isReadOnly", !0, !1));
  }
  disableReadOnlyMode(t) {
    if (typeof t != "string" && typeof t != "symbol") throw new v("editor-read-only-lock-id-invalid", null, { lockId: t });
    this._readOnlyLocks.has(t) && (this._readOnlyLocks.delete(t), this._readOnlyLocks.size === 0 && this.fire("change:isReadOnly", "isReadOnly", !1, !0));
  }
  setData(t) {
    this.data.set(t);
  }
  getData(t) {
    return this.data.get(t);
  }
  initPlugins() {
    const t = this.config, e = t.get("plugins"), i = t.get("removePlugins") || [], r = t.get("extraPlugins") || [], s = t.get("substitutePlugins") || [];
    return this.plugins.init(e.concat(r), i, s);
  }
  destroy() {
    let t = Promise.resolve();
    return this.state == "initializing" && (t = new Promise((e) => this.once("ready", e))), t.then(() => {
      this.fire("destroy"), this.stopListening(), this.commands.destroy();
    }).then(() => this.plugins.destroy()).then(() => {
      this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy();
    }).then(() => this._context._removeEditor(this));
  }
  execute(t, ...e) {
    try {
      return this.commands.execute(t, ...e);
    } catch (i) {
      v.rethrowUnexpectedError(i, this);
    }
  }
  focus() {
    this.editing.view.focus();
  }
  static create(...t) {
    throw new Error("This is an abstract method.");
  }
  _showLicenseError(t, e) {
    setTimeout(() => {
      if (t == "invalid") throw new v("invalid-license-key");
      if (t == "expired") throw new v("license-key-expired");
      if (t == "domainLimit") throw new v("license-key-domain-limit");
      if (t == "featureNotAllowed") throw new v("license-key-plugin-not-allowed", null, { pluginName: e });
      if (t == "evaluationLimit") throw new v("license-key-evaluation-limit");
      if (t == "trialLimit") throw new v("license-key-trial-limit");
      if (t == "developmentLimit") throw new v("license-key-development-limit");
      if (t == "usageLimit") throw new v("license-key-usage-limit");
      if (t == "distributionChannel") throw new v("license-key-invalid-distribution-channel");
    }, 0), this._showLicenseError = () => {
    };
  }
  async _sendUsageRequest(t, e) {
    const i = new Headers({ "Content-Type": "application/json" }), r = await fetch(new URL(t), { method: "POST", headers: i, body: JSON.stringify(e) });
    if (!r.ok) throw new Error(`HTTP Response: ${r.status}`);
    return r.json();
  }
}
m(Po, "defaultConfig"), m(Po, "builtinPlugins"), m(Po, "Context", va), m(Po, "EditorWatchdog", dw), m(Po, "ContextWatchdog", $x);
function Xx(o) {
  const n = function(t) {
    return { sessionId: Qx(), pageSessionId: Jx(), hostname: window.location.hostname, version: globalThis.CKEDITOR_VERSION, type: Yx(t), plugins: (e = t.plugins, Array.from(e).filter(([i]) => !!i.pluginName).map(([i]) => {
      const { pluginName: r, isContextPlugin: s, isOfficialPlugin: a, isPremiumPlugin: l } = i;
      return { isContext: !!s, isOfficial: !!a, isPremium: !!l, name: r };
    })), distribution: { channel: window[Symbol.for("cke distribution")] || "sh" }, env: Zx(), integration: /* @__PURE__ */ Object.create(null), menuBar: { isVisible: !!t.config.get("menuBar.isVisible") }, language: { ui: t.locale.uiLanguage, content: t.locale.contentLanguage }, toolbar: { main: jl(t.config.get("toolbar")), block: jl(t.config.get("blockToolbar")), balloon: jl(t.config.get("balloonToolbar")) } };
    var e;
  }(o);
  return o.fire("collectUsageData", { setUsageData: function(t, e) {
    if (Ti(n, t) !== void 0) throw new v("editor-usage-data-path-already-set", { path: t });
    ck(n, t, e);
  } }), n;
}
function t2(o) {
  if (!ka(o.updateSourceElement)) throw new v("attachtoform-missing-elementapi-interface", o);
  const n = o.sourceElement;
  if (function(t) {
    return !!t && t.tagName.toLowerCase() === "textarea";
  }(n) && n.form) {
    let t;
    const e = n.form, i = () => o.updateSourceElement();
    ka(e.submit) && (t = e.submit, e.submit = () => {
      i(), t.apply(e);
    }), e.addEventListener("submit", i), o.on("destroy", () => {
      e.removeEventListener("submit", i), t && (e.submit = t);
    });
  }
}
function od(o) {
  return class extends o {
    constructor() {
      super(...arguments);
      m(this, "sourceElement");
    }
    updateSourceElement(t) {
      if (!this.sourceElement) throw new v("editor-missing-sourceelement", this);
      const e = this.config.get("updateSourceElementOnDestroy"), i = this.sourceElement instanceof HTMLTextAreaElement;
      if (!e && !i) return void Ch(this.sourceElement, "");
      const r = typeof t == "string" ? t : this.data.get();
      Ch(this.sourceElement, r);
    }
  };
}
function e2(o, n) {
  if (n.ckeditorInstance) throw new v("editor-source-element-already-used", o);
  n.ckeditorInstance = o, o.once("destroy", () => {
    delete n.ckeditorInstance;
  });
}
od.updateSourceElement = od(Object).prototype.updateSourceElement;
class Ta extends Ik {
  constructor() {
    super(...arguments);
    m(this, "_actions");
  }
  static get pluginName() {
    return "PendingActions";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    this.set("hasAny", !1), this._actions = new ne({ idProperty: "_id" }), this._actions.delegate("add", "remove").to(this);
  }
  add(t) {
    if (typeof t != "string") throw new v("pendingactions-add-invalid-message", this);
    const e = new (_t())();
    return e.set("message", t), this._actions.add(e), this.hasAny = !0, e;
  }
  remove(t) {
    this._actions.remove(t), this.hasAny = !!this._actions.length;
  }
  get first() {
    return this._actions.get(0);
  }
  [Symbol.iterator]() {
    return this._actions[Symbol.iterator]();
  }
}
class n2 extends _t() {
  constructor() {
    super();
    m(this, "total");
    m(this, "_reader");
    m(this, "_data");
    const t = new window.FileReader();
    this._reader = t, this._data = void 0, this.set("loaded", 0), t.onprogress = (e) => {
      this.loaded = e.loaded;
    };
  }
  get error() {
    return this._reader.error;
  }
  get data() {
    return this._data;
  }
  read(t) {
    const e = this._reader;
    return this.total = t.size, new Promise((i, r) => {
      e.onload = () => {
        const s = e.result;
        this._data = s, i(s);
      }, e.onerror = () => {
        r("error");
      }, e.onabort = () => {
        r("aborted");
      }, this._reader.readAsDataURL(t);
    });
  }
  abort() {
    this._reader.abort();
  }
}
class vi extends A {
  constructor() {
    super(...arguments);
    m(this, "loaders", new ne());
    m(this, "_loadersMap", /* @__PURE__ */ new Map());
    m(this, "_pendingAction", null);
  }
  static get pluginName() {
    return "FileRepository";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [Ta];
  }
  init() {
    this.loaders.on("change", () => this._updatePendingAction()), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (t, e) => e ? t / e * 100 : 0);
  }
  getLoader(t) {
    return this._loadersMap.get(t) || null;
  }
  createLoader(t) {
    if (!this.createUploadAdapter) return at("filerepository-no-upload-adapter"), null;
    const e = new Im(Promise.resolve(t), this.createUploadAdapter);
    return this.loaders.add(e), this._loadersMap.set(t, e), t instanceof Promise && e.file.then((i) => {
      this._loadersMap.set(i, e);
    }).catch(() => {
    }), e.on("change:uploaded", () => {
      let i = 0;
      for (const r of this.loaders) i += r.uploaded;
      this.uploaded = i;
    }), e.on("change:uploadTotal", () => {
      let i = 0;
      for (const r of this.loaders) r.uploadTotal && (i += r.uploadTotal);
      this.uploadTotal = i;
    }), e;
  }
  destroyLoader(t) {
    const e = t instanceof Im ? t : this.getLoader(t);
    e._destroy(), this.loaders.remove(e), this._loadersMap.forEach((i, r) => {
      i === e && this._loadersMap.delete(r);
    });
  }
  _updatePendingAction() {
    const t = this.editor.plugins.get(Ta);
    if (this.loaders.length) {
      if (!this._pendingAction) {
        const e = this.editor.t, i = (r) => `${e("Upload in progress")} ${parseInt(r)}%.`;
        this._pendingAction = t.add(i(this.uploadedPercent)), this._pendingAction.bind("message").to(this, "uploadedPercent", i);
      }
    } else t.remove(this._pendingAction), this._pendingAction = null;
  }
}
class Im extends _t() {
  constructor(t, e) {
    super();
    m(this, "id");
    m(this, "_filePromiseWrapper");
    m(this, "_adapter");
    m(this, "_reader");
    this.id = Ee(), this._filePromiseWrapper = this._createFilePromiseWrapper(t), this._adapter = e(this), this._reader = new n2(), this.set("status", "idle"), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (i, r) => r ? i / r * 100 : 0), this.set("uploadResponse", null);
  }
  get file() {
    return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then((t) => this._filePromiseWrapper ? t : null) : Promise.resolve(null);
  }
  get data() {
    return this._reader.data;
  }
  read() {
    if (this.status != "idle") throw new v("filerepository-read-wrong-status", this);
    return this.status = "reading", this.file.then((t) => this._reader.read(t)).then((t) => {
      if (this.status !== "reading") throw this.status;
      return this.status = "idle", t;
    }).catch((t) => {
      throw t === "aborted" ? (this.status = "aborted", "aborted") : (this.status = "error", this._reader.error ? this._reader.error : t);
    });
  }
  upload() {
    if (this.status != "idle") throw new v("filerepository-upload-wrong-status", this);
    return this.status = "uploading", this.file.then(() => this._adapter.upload()).then((t) => (this.uploadResponse = t, this.status = "idle", t)).catch((t) => {
      throw this.status === "aborted" ? "aborted" : (this.status = "error", t);
    });
  }
  abort() {
    const t = this.status;
    this.status = "aborted", this._filePromiseWrapper.isFulfilled ? t == "reading" ? this._reader.abort() : t == "uploading" && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch(() => {
    }), this._filePromiseWrapper.rejecter("aborted")), this._destroy();
  }
  _destroy() {
    this._filePromiseWrapper = void 0, this._reader = void 0, this._adapter = void 0, this.uploadResponse = void 0;
  }
  _createFilePromiseWrapper(t) {
    const e = {};
    return e.promise = new Promise((i, r) => {
      e.rejecter = r, e.isFulfilled = !1, t.then((s) => {
        e.isFulfilled = !0, i(s);
      }).catch((s) => {
        e.isFulfilled = !0, r(s);
      });
    }), e;
  }
}
class i2 extends A {
  static get requires() {
    return [vi];
  }
  static get pluginName() {
    return "Base64UploadAdapter";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    this.editor.plugins.get(vi).createUploadAdapter = (n) => new o2(n);
  }
}
let o2 = class {
  constructor(o) {
    m(this, "loader");
    m(this, "reader");
    this.loader = o;
  }
  upload() {
    return new Promise((o, n) => {
      const t = this.reader = new window.FileReader();
      t.addEventListener("load", () => {
        o({ default: t.result });
      }), t.addEventListener("error", (e) => {
        n(e);
      }), t.addEventListener("abort", () => {
        n();
      }), this.loader.file.then((e) => {
        t.readAsDataURL(e);
      });
    });
  }
  abort() {
    this.reader.abort();
  }
};
const _u = ["left", "right", "center", "justify"];
function uw(o) {
  return _u.includes(o);
}
function hw(o, n) {
  return n.contentLanguageDirection == "rtl" ? o === "right" : o === "left";
}
function mw(o) {
  const n = o.map((e) => {
    let i;
    return i = typeof e == "string" ? { name: e } : e, i;
  }).filter((e) => {
    const i = _u.includes(e.name);
    return i || at("alignment-config-name-not-recognized", { option: e }), i;
  }), t = n.filter((e) => !!e.className).length;
  if (t && t < n.length) throw new v("alignment-config-classnames-are-missing", { configuredOptions: o });
  return n.forEach((e, i, r) => {
    const s = r.slice(i + 1);
    if (s.some((a) => a.name == e.name)) throw new v("alignment-config-name-already-defined", { option: e, configuredOptions: o });
    if (e.className && s.some((a) => a.className == e.className))
      throw new v("alignment-config-classname-already-defined", { option: e, configuredOptions: o });
  }), n;
}
const Hl = "alignment";
class r2 extends q {
  refresh() {
    const n = this.editor.locale, t = yt(this.editor.model.document.selection.getSelectedBlocks());
    this.isEnabled = !!t && this._canBeAligned(t), this.isEnabled && t.hasAttribute("alignment") ? this.value = t.getAttribute("alignment") : this.value = n.contentLanguageDirection === "rtl" ? "right" : "left";
  }
  execute(n = {}) {
    const t = this.editor, e = t.locale, i = t.model, r = i.document, s = n.value;
    i.change((a) => {
      const l = Array.from(r.selection.getSelectedBlocks()).filter((d) => this._canBeAligned(d)), c = l[0].getAttribute("alignment");
      hw(s, e) || c === s || !s ? function(d, u) {
        for (const h of d) u.removeAttribute(Hl, h);
      }(l, a) : function(d, u, h) {
        for (const g of d) u.setAttribute(Hl, h, g);
      }(l, a, s);
    });
  }
  _canBeAligned(n) {
    return this.editor.model.schema.checkAttribute(n, Hl);
  }
}
class s2 extends A {
  static get pluginName() {
    return "AlignmentEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  constructor(n) {
    super(n), n.config.define("alignment", { options: _u.map((t) => ({ name: t })) });
  }
  init() {
    const n = this.editor, t = n.locale, e = n.model.schema, i = mw(n.config.get("alignment.options")).filter((l) => uw(l.name) && !hw(l.name, t)), r = i.some((l) => !!l.className);
    e.extend("$block", { allowAttributes: "alignment" }), n.model.schema.setAttributeProperties("alignment", { isFormatting: !0 }), r ? n.conversion.attributeToAttribute(function(l) {
      const c = {};
      for (const u of l) c[u.name] = { key: "class", value: u.className };
      return { model: { key: "alignment", values: l.map((u) => u.name) }, view: c };
    }(i)) : n.conversion.for("downcast").attributeToAttribute(function(l) {
      const c = {};
      for (const { name: u } of l) c[u] = { key: "style", value: { "text-align": u } };
      return { model: { key: "alignment", values: l.map((u) => u.name) }, view: c };
    }(i));
    const s = function(l) {
      const c = [];
      for (const { name: d } of l) c.push({ view: { key: "style", value: { "text-align": d } }, model: { key: "alignment", value: d } });
      return c;
    }(i);
    for (const l of s) n.conversion.for("upcast").attributeToAttribute(l);
    const a = function(l) {
      const c = [];
      for (const { name: d } of l) c.push({ view: { key: "align", value: d }, model: { key: "alignment", value: d } });
      return c;
    }(i);
    for (const l of a) n.conversion.for("upcast").attributeToAttribute(l);
    n.commands.add("alignment", new r2(n));
  }
}
class Te extends ne {
  constructor(t = []) {
    super(t, { idProperty: "viewUid" });
    m(this, "_parentElement");
    this.on("add", (e, i, r) => {
      this._renderViewIntoCollectionParent(i, r);
    }), this.on("remove", (e, i) => {
      i.element && this._parentElement && i.element.remove();
    }), this._parentElement = null;
  }
  destroy() {
    this.map((t) => t.destroy());
  }
  setParent(t) {
    this._parentElement = t;
    for (const e of this) this._renderViewIntoCollectionParent(e);
  }
  delegate(...t) {
    if (!t.length || !t.every((e) => typeof e == "string")) throw new v("ui-viewcollection-delegate-wrong-events", this);
    return { to: (e) => {
      for (const i of this) for (const r of t) i.delegate(r).to(e);
      this.on("add", (i, r) => {
        for (const s of t) r.delegate(s).to(e);
      }), this.on("remove", (i, r) => {
        for (const s of t) r.stopDelegating(s, e);
      });
    } };
  }
  _renderViewIntoCollectionParent(t, e) {
    t.isRendered || t.render(), t.element && this._parentElement && this._parentElement.insertBefore(t.element, this._parentElement.children[e]);
  }
  remove(t) {
    return super.remove(t);
  }
}
class sn extends vt() {
  constructor(t) {
    super();
    m(this, "ns");
    m(this, "tag");
    m(this, "text");
    m(this, "attributes");
    m(this, "children");
    m(this, "eventListeners");
    m(this, "_isRendered");
    m(this, "_revertData");
    Object.assign(this, Dm(Mm(t))), this._isRendered = !1, this._revertData = null;
  }
  render() {
    const t = this._renderNode({ intoFragment: !0 });
    return this._isRendered = !0, t;
  }
  apply(t) {
    return this._revertData = { children: [], bindings: [], attributes: {} }, this._renderNode({ node: t, intoFragment: !1, isApplying: !0, revertData: this._revertData }), t;
  }
  revert(t) {
    if (!this._revertData) throw new v("ui-template-revert-not-applied", [this, t]);
    this._revertTemplateFromNode(t, this._revertData);
  }
  *getViews() {
    yield* function* t(e) {
      if (e.children) for (const i of e.children) Sa(i) ? yield i : vu(i) && (yield* t(i));
    }(this);
  }
  static bind(t, e) {
    return { to: (i, r) => new a2({ eventNameOrFunction: i, attribute: i, observable: t, emitter: e, callback: r }), if: (i, r, s) => new gw({ observable: t, emitter: e, attribute: i, valueIfTrue: r, callback: s }) };
  }
  static extend(t, e) {
    if (t._isRendered) throw new v("template-extend-render", [this, t]);
    bw(t, Dm(Mm(e)));
  }
  _renderNode(t) {
    let e;
    if (e = t.node ? this.tag && this.text : this.tag ? this.text : !this.text, e) throw new v("ui-template-wrong-syntax", this);
    return this.text ? this._renderText(t) : this._renderElement(t);
  }
  _renderElement(t) {
    let e = t.node;
    return e || (e = t.node = document.createElementNS(this.ns || "http://www.w3.org/1999/xhtml", this.tag)), this._renderAttributes(t), this._renderElementChildren(t), this._setUpListeners(t), e;
  }
  _renderText(t) {
    let e = t.node;
    return e ? t.revertData.text = e.textContent : e = t.node = document.createTextNode(""), ia(this.text) ? this._bindToObservable({ schema: this.text, updater: l2(e), data: t }) : e.textContent = this.text.join(""), e;
  }
  _renderAttributes(t) {
    if (!this.attributes) return;
    const e = t.node, i = t.revertData;
    for (const r in this.attributes) {
      const s = e.getAttribute(r), a = this.attributes[r];
      i && (i.attributes[r] = s);
      const l = Bm(a) ? a[0].ns : null;
      if (ia(a)) {
        const c = Bm(a) ? a[0].value : a;
        i && Nm(r) && c.unshift(s), this._bindToObservable({ schema: c, updater: c2(e, r, l), data: t });
      } else if (r == "style" && typeof a[0] != "string") this._renderStyleAttribute(a[0], t);
      else {
        i && s && Nm(r) && a.unshift(s);
        const c = a.map((d) => d && d.value || d).reduce((d, u) => d.concat(u), []).reduce(pw, "");
        tr(c) || e.setAttributeNS(l, r, c);
      }
    }
  }
  _renderStyleAttribute(t, e) {
    const i = e.node;
    for (const r in t) {
      const s = t[r];
      ia(s) ? this._bindToObservable({ schema: [s], updater: d2(i, r), data: e }) : i.style[r] = s;
    }
  }
  _renderElementChildren(t) {
    const e = t.node, i = t.intoFragment ? document.createDocumentFragment() : e, r = t.isApplying;
    let s = 0;
    for (const a of this.children) if (yu(a)) {
      if (!r) {
        a.setParent(e);
        for (const l of a) i.appendChild(l.element);
      }
    } else if (Sa(a)) r || (a.isRendered || a.render(), i.appendChild(a.element));
    else if (Ii(a)) i.appendChild(a);
    else if (r) {
      const l = { children: [], bindings: [], attributes: {} };
      t.revertData.children.push(l), a._renderNode({ intoFragment: !1, node: i.childNodes[s++], isApplying: !0, revertData: l });
    } else i.appendChild(a.render());
    t.intoFragment && e.appendChild(i);
  }
  _setUpListeners(t) {
    if (this.eventListeners) for (const e in this.eventListeners) {
      const i = this.eventListeners[e].map((r) => {
        const [s, a] = e.split("@");
        return r.activateDomEventListener(s, a, t);
      });
      t.revertData && t.revertData.bindings.push(i);
    }
  }
  _bindToObservable({ schema: t, updater: e, data: i }) {
    const r = i.revertData;
    fw(t, e, i);
    const s = t.filter((a) => !tr(a)).filter((a) => a.observable).map((a) => a.activateAttributeListener(t, e, i));
    r && r.bindings.push(s);
  }
  _revertTemplateFromNode(t, e) {
    for (const r of e.bindings) for (const s of r) s();
    if (e.text) return void (t.textContent = e.text);
    const i = t;
    for (const r in e.attributes) {
      const s = e.attributes[r];
      s === null ? i.removeAttribute(r) : i.setAttribute(r, s);
    }
    for (let r = 0; r < e.children.length; ++r) this._revertTemplateFromNode(i.childNodes[r], e.children[r]);
  }
}
class _s {
  constructor(n) {
    m(this, "attribute");
    m(this, "observable");
    m(this, "emitter");
    m(this, "callback");
    this.attribute = n.attribute, this.observable = n.observable, this.emitter = n.emitter, this.callback = n.callback;
  }
  getValue(n) {
    const t = this.observable[this.attribute];
    return this.callback ? this.callback(t, n) : t;
  }
  activateAttributeListener(n, t, e) {
    const i = () => fw(n, t, e);
    return this.emitter.listenTo(this.observable, `change:${this.attribute}`, i), () => {
      this.emitter.stopListening(this.observable, `change:${this.attribute}`, i);
    };
  }
}
class a2 extends _s {
  constructor(t) {
    super(t);
    m(this, "eventNameOrFunction");
    this.eventNameOrFunction = t.eventNameOrFunction;
  }
  activateDomEventListener(t, e, i) {
    const r = (s, a) => {
      e && !a.target.matches(e) || (typeof this.eventNameOrFunction == "function" ? this.eventNameOrFunction(a) : this.observable.fire(this.eventNameOrFunction, a));
    };
    return this.emitter.listenTo(i.node, t, r), () => {
      this.emitter.stopListening(i.node, t, r);
    };
  }
}
class gw extends _s {
  constructor(t) {
    super(t);
    m(this, "valueIfTrue");
    this.valueIfTrue = t.valueIfTrue;
  }
  getValue(t) {
    return !tr(super.getValue(t)) && (this.valueIfTrue || !0);
  }
}
function ia(o) {
  return !!o && (o.value && (o = o.value), Array.isArray(o) ? o.some(ia) : o instanceof _s);
}
function fw(o, n, { node: t }) {
  const e = function(r, s) {
    return r.map((a) => a instanceof _s ? a.getValue(s) : a);
  }(o, t);
  let i;
  i = o.length == 1 && o[0] instanceof gw ? e[0] : e.reduce(pw, ""), tr(i) ? n.remove() : n.set(i);
}
function l2(o) {
  return { set(n) {
    o.textContent = n;
  }, remove() {
    o.textContent = "";
  } };
}
function c2(o, n, t) {
  return { set(e) {
    o.setAttributeNS(t, n, e);
  }, remove() {
    o.removeAttributeNS(t, n);
  } };
}
function d2(o, n) {
  return { set(t) {
    o.style[n] = t;
  }, remove() {
    o.style[n] = null;
  } };
}
function Mm(o) {
  return il(o, (n) => {
    if (n && (n instanceof _s || vu(n) || Sa(n) || yu(n))) return n;
  });
}
function Dm(o) {
  if (typeof o == "string" ? o = /* @__PURE__ */ function(n) {
    return { text: [n] };
  }(o) : o.text && function(n) {
    n.text = Bt(n.text);
  }(o), o.on && (o.eventListeners = function(n) {
    for (const t in n) Pm(n, t);
    return n;
  }(o.on), delete o.on), !o.text) {
    o.attributes && function(t) {
      for (const e in t) t[e].value && (t[e].value = Bt(t[e].value)), Pm(t, e);
    }(o.attributes);
    const n = [];
    if (o.children) if (yu(o.children)) n.push(o.children);
    else for (const t of o.children) vu(t) || Sa(t) || Ii(t) ? n.push(t) : n.push(new sn(t));
    o.children = n;
  }
  return o;
}
function Pm(o, n) {
  o[n] = Bt(o[n]);
}
function pw(o, n) {
  return tr(n) ? o : tr(o) ? n : `${o} ${n}`;
}
function Lm(o, n) {
  for (const t in n) o[t] ? o[t].push(...n[t]) : o[t] = n[t];
}
function bw(o, n) {
  if (n.attributes && (o.attributes || (o.attributes = {}), Lm(o.attributes, n.attributes)), n.eventListeners && (o.eventListeners || (o.eventListeners = {}), Lm(o.eventListeners, n.eventListeners)), n.text && o.text.push(...n.text), n.children && n.children.length) {
    if (o.children.length != n.children.length) throw new v("ui-template-extend-children-mismatch", o);
    let t = 0;
    for (const e of n.children) bw(o.children[t++], e);
  }
}
function tr(o) {
  return !o && o !== 0;
}
function Sa(o) {
  return o instanceof L;
}
function vu(o) {
  return o instanceof sn;
}
function yu(o) {
  return o instanceof Te;
}
function Bm(o) {
  return bn(o[0]) && o[0].ns;
}
function Nm(o) {
  return o == "class" || o == "style";
}
class L extends Pe(_t()) {
  constructor(t) {
    super();
    m(this, "element");
    m(this, "isRendered");
    m(this, "locale");
    m(this, "t");
    m(this, "template");
    m(this, "_viewCollections");
    m(this, "_unboundChildren");
    m(this, "_bindTemplate");
    this.element = null, this.isRendered = !1, this.locale = t, this.t = t && t.t, this._viewCollections = new ne(), this._unboundChildren = this.createCollection(), this._viewCollections.on("add", (e, i) => {
      i.locale = t, i.t = t && t.t;
    }), this.decorate("render");
  }
  get bindTemplate() {
    return this._bindTemplate ? this._bindTemplate : this._bindTemplate = sn.bind(this, this);
  }
  createCollection(t) {
    const e = new Te(t);
    return this._viewCollections.add(e), e;
  }
  registerChild(t) {
    Ye(t) || (t = [t]);
    for (const e of t) this._unboundChildren.add(e);
  }
  deregisterChild(t) {
    Ye(t) || (t = [t]);
    for (const e of t) this._unboundChildren.remove(e);
  }
  setTemplate(t) {
    this.template = new sn(t);
  }
  extendTemplate(t) {
    sn.extend(this.template, t);
  }
  render() {
    if (this.isRendered) throw new v("ui-view-render-already-rendered", this);
    this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = !0;
  }
  destroy() {
    this.stopListening(), this._viewCollections.map((t) => t.destroy()), this.template && this.template._revertData && this.template.revert(this.element);
  }
}
function Ni({ emitter: o, activator: n, callback: t, contextElements: e, listenerOptions: i }) {
  o.listenTo(document, "mousedown", (r, s) => {
    if (!n()) return;
    const a = typeof s.composedPath == "function" ? s.composedPath() : [], l = typeof e == "function" ? e() : e;
    for (const c of l) if (c.contains(s.target) || a.includes(c)) return;
    t();
  }, i);
}
function rs(o) {
  return class extends o {
    disableCssTransitions() {
      this._isCssTransitionsDisabled = !0;
    }
    enableCssTransitions() {
      this._isCssTransitionsDisabled = !1;
    }
    constructor(...n) {
      super(...n), this.set("_isCssTransitionsDisabled", !1), this.initializeCssTransitionDisablerMixin();
    }
    initializeCssTransitionDisablerMixin() {
      this.extendTemplate({ attributes: { class: [this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")] } });
    }
  };
}
function ar({ view: o }) {
  o.listenTo(o.element, "submit", (n, t) => {
    t.preventDefault(), o.fire("submit");
  }, { useCapture: !0 });
}
function vs({ keystrokeHandler: o, focusTracker: n, gridItems: t, numberOfColumns: e, uiLanguageDirection: i }) {
  const r = typeof e == "number" ? () => e : e;
  function s(c) {
    return (d) => {
      const u = t.find((f) => f.element === n.focusedElement), h = t.getIndex(u), g = c(h, t);
      t.get(g).focus(), d.stopPropagation(), d.preventDefault();
    };
  }
  function a(c, d) {
    return c === d - 1 ? 0 : c + 1;
  }
  function l(c, d) {
    return c === 0 ? d - 1 : c - 1;
  }
  o.set("arrowright", s((c, d) => i === "rtl" ? l(c, d.length) : a(c, d.length))), o.set("arrowleft", s((c, d) => i === "rtl" ? a(c, d.length) : l(c, d.length))), o.set("arrowup", s((c, d) => {
    let u = c - r();
    return u < 0 && (u = c + r() * Math.floor(d.length / r()), u > d.length - 1 && (u -= r())), u;
  })), o.set("arrowdown", s((c, d) => {
    let u = c + r();
    return u > d.length - 1 && (u = c % r()), u;
  }));
}
var zm = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 6.628a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z"/><path d="M8.5 9.125a.3.3 0 0 0-.253-.296L5.11 8.327a.75.75 0 1 1 .388-1.449l4.04.716c.267.072.624.08.893.009l4.066-.724a.75.75 0 1 1 .388 1.45l-3.132.5a.3.3 0 0 0-.253.296v1.357a.3.3 0 0 0 .018.102l1.615 4.438a.75.75 0 0 1-1.41.513l-1.35-3.71a.3.3 0 0 0-.281-.197h-.209a.3.3 0 0 0-.282.198l-1.35 3.711a.75.75 0 0 1-1.41-.513l1.64-4.509a.3.3 0 0 0 .019-.103V9.125Z"/><path clip-rule="evenodd" d="M10 18.5a8.5 8.5 0 1 1 0-17 8.5 8.5 0 0 1 0 17Zm0 1.5c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10Z"/></svg>', u2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>', h2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', kw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', m2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>', ww = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>', Cu = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>', Au = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>', g2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>', _w = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>', Om = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.87 12.61a.75.75 0 0 1-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 0 1 .237.95l-.057.095a.75.75 0 0 1-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 0 1 1.047.174zm2.795-.231.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 0 1-.88-.151l-.07-.086-.058-.095a.75.75 0 0 1 .15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 0 1 .862-1.207zM16 0a2 2 0 0 1 2 2v9.354l-.663-.492-.837-.001V2a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3.118L7.156 19H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h14zM5.009 15l.003 1H3v-1h2.009zm2.188-2-1.471 1H5v-1h2.197zM10 11v.095L8.668 12H7v-1h3zm4-2v1H7V9h7zm0-2v1H7V7h7zm-4-2v1H5V5h5zM6 3v1H3V3h3z"/></svg>', f2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 5.7 5.2 3.9v1.3l-5.6 4c-.1.2-.3.2-.5.2-.3-.1-.6-.7-.6-1l.3-.4 4.7-3.5L11.5 7l-.2-.2c-.1-.3-.1-.6 0-.8.2-.2.5-.4.8-.4a.8.8 0 0 1 .4.1zm-5.2 0L2 9.6v1.3l5.6 4c.1.2.3.2.5.2.3-.1.7-.7.6-1 0-.1 0-.3-.2-.4l-5-3.5L8.2 7l.2-.2c.1-.3.1-.6 0-.8-.2-.2-.5-.4-.8-.4a.8.8 0 0 0-.3.1z"/></svg>', p2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.209 18.717A8.5 8.5 0 1 1 18.686 9.6h-.008l.002.12a3 3 0 0 1-2.866 2.997h-.268l-.046-.002v.002h-4.791a2 2 0 1 0 0 4 1 1 0 1 1-.128 1.992 8.665 8.665 0 0 1-.372.008Zm-3.918-7.01a1.25 1.25 0 1 0-2.415-.648 1.25 1.25 0 0 0 2.415.647ZM5.723 8.18a1.25 1.25 0 1 0 .647-2.414 1.25 1.25 0 0 0-.647 2.414ZM9.76 6.155a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Zm4.028 1.759a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Z"/></svg>', b2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>', k2 = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>', w2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/></svg>', ul = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>', _2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path clip-rule="evenodd" d="M8.5 8.25a1.25 1.25 0 1 1-2.499.001A1.25 1.25 0 0 1 8.5 8.25Z"/><path clip-rule="evenodd" d="M14 8.25a1.25 1.25 0 1 1-2.499.001A1.25 1.25 0 0 1 14 8.25Z"/><path clip-rule="evenodd" d="M7.127 12.088a.75.75 0 1 0-1.254.824C6.88 14.444 8.423 15.25 10 15.25c1.578 0 3.12-.805 4.127-2.338a.75.75 0 0 0-1.254-.824C12.13 13.221 11.048 13.75 10 13.75c-1.047 0-2.13-.529-2.873-1.662Z"/><path d="M10 19a9 9 0 1 0 0-18 9 9 0 0 0 0 18Zm0-1.5a7.5 7.5 0 1 1 0-15 7.5 7.5 0 0 1 0 15Z"/></svg>', rd = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>', v2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>', y2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3 10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>', Rm = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.03 3h6.149a.75.75 0 1 1 0 1.5h-5.514L11.03 3zm1.27 3h4.879a.75.75 0 1 1 0 1.5h-4.244L12.3 6zm1.27 3h3.609a.75.75 0 1 1 0 1.5h-2.973L13.57 9zm-2.754 2.5L8.038 4.785 5.261 11.5h5.555zm.62 1.5H4.641l-1.666 4.028H1.312l5.789-14h1.875l5.789 14h-1.663L11.436 13z"/></svg>', Vm = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>', C2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 9h16v2H2z"/></svg>', A2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.66 9.118a.693.693 0 0 1 .956.032l3.65 3.411 2.422-2.238a.695.695 0 0 1 .945 0L17.5 13.6V2.5h-15v11.1l4.16-4.482ZM17.8 1c.652 0 1.2.47 1.2 1.1v14.362c0 .64-.532 1.038-1.184 1.038H2.184C1.532 17.5 1 17.103 1 16.462V2.1C1 1.47 1.537 1 2.2 1h15.6Zm-5.655 6a2.128 2.128 0 0 1 .157-2.364A2.133 2.133 0 1 1 12.145 7Z"/></svg>', x2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037h9.494a2.97 2.97 0 0 1-.414-.287 2.998 2.998 0 0 1-1.055-2.03 3.003 3.003 0 0 1 .693-2.185l.383-.455-.02.018-3.65-3.41a.695.695 0 0 0-.957-.034L1.5 13.6V2.5h15v5.535a2.97 2.97 0 0 1 1.412.932l.088.105V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.713 2.803a2.146 2.146 0 0 0-2.049 1.992 2.14 2.14 0 0 0 1.28 2.096 2.13 2.13 0 0 0 2.644-3.11 2.134 2.134 0 0 0-1.875-.978Z"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.784.784 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79Z"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.784.784 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79Z"/></svg>', E2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037h7.029a5.401 5.401 0 0 1 .615-4.338l.762-1.232-2.975-2.78a.696.696 0 0 0-.957-.033L1.5 13.6V2.5h15v6.023c.449.131.887.32 1.307.573l.058.033c.046.028.09.057.135.086V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.713 2.803a2.15 2.15 0 0 0-1.611.834 2.118 2.118 0 0 0-.438 1.158 2.14 2.14 0 0 0 1.277 2.096 2.132 2.132 0 0 0 2.645-3.11 2.13 2.13 0 0 0-1.873-.978Z"/><path d="M16.63 10.294a3.003 3.003 0 0 0-4.142.887l-.117.177a.647.647 0 0 0-.096.492.664.664 0 0 0 .278.418.7.7 0 0 0 .944-.234 1.741 1.741 0 0 1 2.478-.463 1.869 1.869 0 0 1 .476 2.55.637.637 0 0 0-.071.5.646.646 0 0 0 .309.396.627.627 0 0 0 .869-.19l.027-.041a3.226 3.226 0 0 0-.956-4.492Zm-6.061 3.78-.044.066a3.228 3.228 0 0 0 .82 4.403 3.005 3.005 0 0 0 4.275-.798l.13-.197a.626.626 0 0 0 .092-.475.638.638 0 0 0-.268-.402.713.713 0 0 0-.99.26l-.018.029a1.741 1.741 0 0 1-2.477.461 1.87 1.87 0 0 1-.475-2.55l.029-.047a.647.647 0 0 0 .086-.485.66.66 0 0 0-.275-.408l-.04-.027a.609.609 0 0 0-.845.17Z"/><path d="M15.312 13.925c.24-.36.154-.838-.19-1.067-.346-.23-.82-.124-1.059.236l-1.268 1.907c-.239.36-.153.838.192 1.067.345.23.818.123 1.057-.236l1.268-1.907Z"/></svg>', T2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>', Fm = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>', S2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>', vw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>', I2 = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4z"/></svg>', M2 = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M5.714 15.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm6.078.914V8.531H10.79c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.344 0v-1.235h-1.235V15h1.235zm-9.422 9.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm7.088.914v-1.147H10.35c.065-.111.149-.226.253-.343.104-.117.35-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.493-.824.104-.263.156-.539.156-.829 0-.51-.181-.936-.544-1.279-.364-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.152-.155.357-.233.615-.233.261 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.467.536-1.024 1.055-.691.641-1.154 1.156-1.388 1.544-.235.389-.375.8-.422 1.233h4.328zm2.334 0v-1.235h-1.235V24h1.235zM5.714 34.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm4.992 1.024c.616 0 1.13-.2 1.543-.598.413-.398.62-.88.62-1.446 0-.39-.111-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.618-.337.927-.788.927-1.353 0-.399-.15-.756-.452-1.073-.366-.386-.853-.58-1.46-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.667.55c-.16.232-.28.544-.359.933l1.139.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.214 0 .386.065.515.194s.193.302.193.518c0 .255-.088.46-.264.613-.175.154-.43.227-.764.218l-.136 1.006c.22-.061.408-.092.566-.092.24 0 .444.09.611.272.167.182.25.428.25.739 0 .328-.086.589-.26.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.308-.698l-1.195.145c.062.542.284.98.668 1.316.384.335.867.503 1.45.503zm4.43-.11v-1.235h-1.235V34h1.235z"/></svg>', D2 = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M10.29 15V8.531H9.286c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.343 0v-1.235h-1.235V15h1.235zM11.3 24v-1.147H8.848c.064-.111.148-.226.252-.343.104-.117.351-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.494-.824.104-.263.156-.539.156-.829 0-.51-.182-.936-.545-1.279-.363-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.153-.155.358-.233.616-.233.26 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.468.536-1.024 1.055-.692.641-1.155 1.156-1.389 1.544-.234.389-.375.8-.422 1.233H11.3zm2.333 0v-1.235h-1.235V24h1.235zM9.204 34.11c.615 0 1.129-.2 1.542-.598.413-.398.62-.88.62-1.446 0-.39-.11-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.619-.337.928-.788.928-1.353 0-.399-.151-.756-.453-1.073-.366-.386-.852-.58-1.459-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.668.55c-.16.232-.28.544-.358.933l1.138.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.215 0 .386.065.515.194s.193.302.193.518c0 .255-.087.46-.263.613-.176.154-.43.227-.765.218l-.136 1.006c.22-.061.409-.092.567-.092.24 0 .444.09.61.272.168.182.251.428.251.739 0 .328-.087.589-.261.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.307-.698l-1.196.145c.062.542.285.98.668 1.316.384.335.868.503 1.45.503zm4.43-.11v-1.235h-1.236V34h1.235z"/></svg>', P2 = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6z"/></svg>', L2 = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M9.62 14.105c.272 0 .528-.05.768-.153s.466-.257.677-.462c.009.024.023.072.044.145.047.161.086.283.119.365h1.221a2.649 2.649 0 0 1-.222-.626c-.04-.195-.059-.498-.059-.908l.013-1.441c0-.536-.055-.905-.165-1.105-.11-.201-.3-.367-.569-.497-.27-.13-.68-.195-1.23-.195-.607 0-1.064.108-1.371.325-.308.217-.525.55-.65 1.002l1.12.202c.076-.217.176-.369.299-.455.123-.086.294-.13.514-.13.325 0 .546.05.663.152.118.101.176.27.176.508v.123c-.222.093-.622.194-1.2.303-.427.082-.755.178-.982.288-.227.11-.403.268-.53.474a1.327 1.327 0 0 0-.188.706c0 .398.138.728.415.988.277.261.656.391 1.136.391zm.368-.87a.675.675 0 0 1-.492-.189.606.606 0 0 1-.193-.448c0-.176.08-.32.241-.435.106-.07.33-.142.673-.215a7.19 7.19 0 0 0 .751-.19v.247c0 .296-.016.496-.048.602a.773.773 0 0 1-.295.409 1.07 1.07 0 0 1-.637.22zm4.645.765v-1.235h-1.235V14h1.235zM10.2 25.105c.542 0 1.003-.215 1.382-.646.38-.43.57-1.044.57-1.84 0-.771-.187-1.362-.559-1.774a1.82 1.82 0 0 0-1.41-.617c-.522 0-.973.216-1.354.65v-2.32H7.594V25h1.147v-.686a1.9 1.9 0 0 0 .67.592c.26.133.523.2.79.2zm-.299-.975c-.354 0-.638-.164-.852-.492-.153-.232-.229-.59-.229-1.073 0-.468.098-.818.295-1.048a.93.93 0 0 1 .738-.345c.302 0 .55.118.743.354.193.236.29.62.29 1.154 0 .5-.096.868-.288 1.1-.192.233-.424.35-.697.35zm4.478.87v-1.235h-1.234V25h1.234zm-4.017 9.105c.6 0 1.08-.142 1.437-.426.357-.284.599-.704.725-1.261l-1.213-.207c-.061.326-.167.555-.316.688a.832.832 0 0 1-.576.2.916.916 0 0 1-.75-.343c-.185-.228-.278-.62-.278-1.173 0-.498.091-.853.274-1.066.183-.212.429-.318.736-.318.232 0 .42.061.565.184.145.123.238.306.28.55l1.216-.22c-.146-.501-.387-.874-.722-1.119-.336-.244-.788-.366-1.356-.366-.695 0-1.245.214-1.653.643-.407.43-.61 1.03-.61 1.8 0 .762.202 1.358.608 1.788.406.431.95.646 1.633.646zM14.633 34v-1.235h-1.235V34h1.235z"/></svg>', B2 = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.88 8.7V7.558h-1.234V8.7h1.234zm0 5.3V9.333h-1.234V14h1.234zm2.5 0v-1.235h-1.234V14h1.235zm-4.75 4.7v-1.142H8.395V18.7H9.63zm0 5.3v-4.667H8.395V24H9.63zm2.5-5.3v-1.142h-1.234V18.7h1.235zm0 5.3v-4.667h-1.234V24h1.235zm2.501 0v-1.235h-1.235V24h1.235zM7.38 28.7v-1.142H6.145V28.7H7.38zm0 5.3v-4.667H6.145V34H7.38zm2.5-5.3v-1.142H8.646V28.7H9.88zm0 5.3v-4.667H8.646V34H9.88zm2.5-5.3v-1.142h-1.234V28.7h1.235zm0 5.3v-4.667h-1.234V34h1.235zm2.501 0v-1.235h-1.235V34h1.235z"/></svg>', N2 = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M14 27v6H8v-6h6zm0-9v6H8v-6h6zm0-9v6H8V9h6z"/></svg>', z2 = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="m7.88 15 .532-1.463h2.575L11.549 15h1.415l-2.58-6.442H9.01L6.5 15h1.38zm2.69-2.549H8.811l.87-2.39.887 2.39zM14.88 15v-1.235h-1.234V15h1.234zM9.352 25c.83-.006 1.352-.02 1.569-.044.346-.038.636-.14.872-.305.236-.166.422-.387.558-.664.137-.277.205-.562.205-.855 0-.372-.106-.695-.317-.97-.21-.276-.512-.471-.905-.585a1.51 1.51 0 0 0 .661-.567 1.5 1.5 0 0 0 .244-.83c0-.28-.066-.53-.197-.754a1.654 1.654 0 0 0-.495-.539 1.676 1.676 0 0 0-.672-.266c-.25-.042-.63-.063-1.14-.063H7.158V25h2.193zm.142-3.88H8.46v-1.49h.747c.612 0 .983.007 1.112.022.217.026.38.102.49.226.11.125.165.287.165.486a.68.68 0 0 1-.192.503.86.86 0 0 1-.525.23 11.47 11.47 0 0 1-.944.023h.18zm.17 2.795H8.46v-1.723h1.05c.592 0 .977.03 1.154.092.177.062.313.16.406.295a.84.84 0 0 1 .14.492c0 .228-.06.41-.181.547a.806.806 0 0 1-.473.257c-.126.026-.423.04-.892.04zM14.88 25v-1.235h-1.234V25h1.234zm-5.018 9.11c.691 0 1.262-.17 1.711-.512.45-.341.772-.864.965-1.567l-1.261-.4c-.109.472-.287.818-.536 1.037-.25.22-.547.33-.892.33-.47 0-.85-.173-1.143-.519-.293-.345-.44-.925-.44-1.74 0-.767.15-1.322.447-1.665.297-.343.684-.514 1.162-.514.346 0 .64.096.881.29.242.193.4.457.477.79l1.288-.307c-.147-.516-.367-.911-.66-1.187-.492-.465-1.132-.698-1.92-.698-.902 0-1.63.296-2.184.89-.554.593-.83 1.426-.83 2.498 0 1.014.275 1.813.825 2.397.551.585 1.254.877 2.11.877zM14.88 34v-1.235h-1.234V34h1.234z"/></svg>', O2 = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.916 15V8.558h-1.301V15h1.3zm2.465 0v-1.235h-1.235V15h1.235zM9.665 25v-6.442h-1.3V25h1.3zm2.5 0v-6.442h-1.3V25h1.3zm2.466 0v-1.235h-1.235V25h1.235zm-7.216 9v-6.442h-1.3V34h1.3zm2.5 0v-6.442h-1.3V34h1.3zm2.501 0v-6.442h-1.3V34h1.3zm2.465 0v-1.235h-1.235V34h1.235z"/></svg>', R2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.68 13.74h-.001l4.209 4.208a1 1 0 1 0 1.414-1.414l-4.267-4.268a6 6 0 1 0-1.355 1.474ZM13 9a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"/></svg>', V2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.798 1.59 3.002 12.875l1.895 1.852 2.521 1.402 6.997-12.194z"/><path d="m2.556 16.727.234-.348c-.297-.151-.462-.293-.498-.426-.036-.137.002-.416.115-.837.094-.25.15-.449.169-.595a4.495 4.495 0 0 0 0-.725c-.209-.621-.303-1.041-.284-1.26.02-.218.178-.506.475-.862l6.77-9.414c.539-.91 1.605-.85 3.199.18 1.594 1.032 2.188 1.928 1.784 2.686l-5.877 10.36c-.158.412-.333.673-.526.782-.193.108-.604.179-1.232.21-.362.131-.608.237-.738.318-.13.081-.305.238-.526.47-.293.265-.504.397-.632.397-.096 0-.27-.075-.524-.226l-.31.41-1.6-1.12zm-.279.415 1.575 1.103-.392.515H1.19l1.087-1.618zm8.1-13.656-4.953 6.9L8.75 12.57l4.247-7.574c.175-.25-.188-.647-1.092-1.192-.903-.546-1.412-.652-1.528-.32zM8.244 18.5 9.59 17h9.406v1.5H8.245z"/></svg>', F2 = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>', j2 = '<svg viewBox="0 0 22 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.587 1.5c-.612 0-.601-.029-.601.551v14.84c0 .59-.01.559.591.559h18.846c.602 0 .591.03.591-.56V2.052c0-.58.01-.55-.591-.55H1.587Zm.701.971h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-14.24 1h13.008v12H4.467l.029-12Zm-2.208 1h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003l-.029 1h-.974v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h.974v1h-.974v-1Zm16.448 0h1.003v1h-1.003v-1Z"/><path d="M8.374 6.648a.399.399 0 0 1 .395-.4.402.402 0 0 1 .2.049l5.148 2.824a.4.4 0 0 1 0 .7l-5.148 2.824a.403.403 0 0 1-.595-.35V6.648Z"/></svg>', yw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>', xu = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>', sd = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>', H2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>', Cw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', ad = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', Aw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', xw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', Ew = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', U2 = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:v="https://vecta.io/nano" viewBox="0 0 20 20"><path d="M.95 1.43a.95.95 0 0 0-.95.95v3.1a.95.95 0 0 0 .95.95h.75v6.3H.95a.95.95 0 0 0-.95.95v3.1a.95.95 0 0 0 .95.95h3.1a.95.95 0 0 0 .95-.95v-.65h1.932l1.539-1.5H5v-.95a.95.95 0 0 0-.95-.95H3.2v-6.3h.85A.95.95 0 0 0 5 5.48v-.55h10v.55a.95.95 0 0 0 .95.95h3.1a.95.95 0 0 0 .95-.95v-3.1a.95.95 0 0 0-.95-.95h-3.1a.95.95 0 0 0-.95.95v1.05H5V2.38a.95.95 0 0 0-.95-.95H.95zm.55 3.5v-2h2v2h-2zm0 9.3v2h2v-2h-2zm15-11.3v2h2v-2h-2z"/><path d="M8.139 20.004v-2.388l7.045-7.048 2.391 2.391-7.046 7.046h-2.39zm11.421-9.101a.64.64 0 0 1-.138.206l-1.165 1.168-2.391-2.391 1.167-1.163a.63.63 0 0 1 .206-.138.635.635 0 0 1 .243-.049.63.63 0 0 1 .449.187l1.491 1.488c.059.059.108.129.138.206s.049.16.049.243a.6.6 0 0 1-.049.243z"/></svg>', $2 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>', q2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M13 5.5H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2ZM13 7a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-8A.5.5 0 0 1 2 7h11Z"/></svg>', W2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M10 7.5H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2ZM10 9a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6A.5.5 0 0 1 2 9h8Z"/></svg>', G2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M7 9.5H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2ZM7 11a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4A.5.5 0 0 1 2 11h5Z"/></svg>', jm = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>', K2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>', Y2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>', Z2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.126 2.268 2.002 13.874l1.895 1.852 2.521 1.402L14.47 5.481l-1.543-2.568-2.801-.645z"/><path d="m4.5 18.088-2.645-1.852-.04-2.95-.006-.005.006-.008v-.025l.011.008L8.73 2.97c.165-.233.356-.417.567-.557l-1.212.308L4.604 7.9l-.83-.558 3.694-5.495 2.708-.69 1.65 1.145.046.018.85-1.216 2.16 1.512-.856 1.222c.828.967 1.144 2.141.432 3.158L7.55 17.286l.006.005-3.055.797H4.5zm-.634.166-1.976.516-.026-1.918 2.002 1.402zM9.968 3.817l-.006-.004-6.123 9.184 3.277 2.294 6.108-9.162.005.003c.317-.452-.16-1.332-1.064-1.966-.891-.624-1.865-.776-2.197-.349zM8.245 18.5 9.59 17h9.406v1.5H8.245z"/></svg>', Q2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>', J2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>', co = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>', X2 = `<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>
`, tE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>', Hm = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>', eE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>', nE = '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>', iE = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>', oE = `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.734 6.375H1.75a.75.75 0 0 1 0-1.5h1.984a2.626 2.626 0 0 1 5.032 0h9.48a.75.75 0 0 1 0 1.5h-9.48a2.626 2.626 0 0 1-5.032 0Zm1.141-.75a1.375 1.375 0 1 1 2.75 0 1.375 1.375 0 0 1-2.75 0ZM16.263 14.625h1.983a.75.75 0 0 1 0 1.5h-1.983a2.626 2.626 0 0 1-5.033 0H1.75a.75.75 0 0 1 0-1.5h9.48a2.626 2.626 0 0 1 5.033 0Zm-1.142.75a1.375 1.375 0 1 1-2.75 0 1.375 1.375 0 0 1 2.75 0Z"/></svg>
`, rE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2.5a7.47 7.47 0 0 1 4.231 1.31 7.268 7.268 0 0 1 2.703 3.454 7.128 7.128 0 0 1 .199 4.353c-.39 1.436-1.475 2.72-2.633 3.677h2.013c0-.226.092-.443.254-.603a.876.876 0 0 1 1.229 0c.163.16.254.377.254.603v.853c0 .209-.078.41-.22.567a.873.873 0 0 1-.547.28l-.101.006h-4.695a.517.517 0 0 1-.516-.518v-1.265c0-.21.128-.398.317-.489a5.601 5.601 0 0 0 2.492-2.371 5.459 5.459 0 0 0 .552-3.693 5.53 5.53 0 0 0-1.955-3.2A5.71 5.71 0 0 0 10 4.206 5.708 5.708 0 0 0 6.419 5.46 5.527 5.527 0 0 0 4.46 8.663a5.457 5.457 0 0 0 .554 3.695 5.6 5.6 0 0 0 2.497 2.37.55.55 0 0 1 .317.49v1.264c0 .286-.23.518-.516.518H2.618a.877.877 0 0 1-.614-.25.845.845 0 0 1-.254-.603v-.853c0-.226.091-.443.254-.603a.876.876 0 0 1 1.228 0c.163.16.255.377.255.603h1.925c-1.158-.958-2.155-2.241-2.545-3.678a7.128 7.128 0 0 1 .199-4.352 7.268 7.268 0 0 1 2.703-3.455A7.475 7.475 0 0 1 10 2.5z"/></svg>', sE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>', aE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.03 10.349 3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82zm8.147 7.829h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309z"/></svg>', lE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.677 8.678h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82z"/></svg>', cE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>', dE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>', uE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>', Um = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 5.5v3h4v-3H3Zm0 4v3h4v-3H3Zm0 4v3h4v-3H3Zm5 3h4v-3H8v3Zm5 0h4v-3h-4v3Zm4-4v-3h-4v3h4Zm0-4v-3h-4v3h4Zm1.5 8A1.5 1.5 0 0 1 17 18H3a1.5 1.5 0 0 1-1.5-1.5V3c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13.5Zm-6.5-4v-3H8v3h4Zm0-4v-3H8v3h4Z"/></svg>', hE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.035 1C2.446 1 2 1.54 2 2.098V10.5h1.5v-8h13v8H18V2.098C18 1.539 17.48 1 16.9 1H3.035Zm10.453 2.61a1.885 1.885 0 0 0-1.442.736 1.89 1.89 0 0 0 1.011 2.976 1.903 1.903 0 0 0 2.253-1.114 1.887 1.887 0 0 0-1.822-2.598ZM7.463 8.163a.611.611 0 0 0-.432.154L5.071 10.5h5.119L7.88 8.348a.628.628 0 0 0-.417-.185Zm6.236 1.059a.62.62 0 0 0-.42.164L12.07 10.5h2.969l-.92-1.113a.618.618 0 0 0-.42-.165ZM.91 11.5a.91.91 0 0 0-.91.912v6.877c0 .505.405.91.91.91h18.178a.91.91 0 0 0 .912-.91v-6.877a.908.908 0 0 0-.912-.912H.91ZM3.668 13h1.947l2.135 5.7H5.898l-.28-.946H3.601l-.278.945H1.516L3.668 13Zm4.947 0h1.801v4.3h2.7v1.4h-4.5V13h-.001Zm4.5 0h5.4v1.4h-1.798v4.3h-1.701v-4.3h-1.9V13h-.001Zm-8.517 1.457-.614 2.059h1.262l-.648-2.059Z"/></svg>', mE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>', Eu = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>', gE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m2.315 14.705 2.224-2.24a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .949L2.865 16.07a.682.682 0 0 1-.112.089.647.647 0 0 1-.852-.051L.688 14.886a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.717.722zm5.185.045a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75zM2.329 5.745l2.21-2.226a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .95L2.865 7.125a.685.685 0 0 1-.496.196.644.644 0 0 1-.468-.187L.688 5.912a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.73.736zM7.5 5.75A.75.75 0 0 1 8.25 5h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>', fE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>', $m = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>', pE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';
const qa = class qa extends L {
  constructor() {
    super();
    const n = this.bindTemplate;
    this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.set("isColorInherited", !0), this.set("isVisible", !0), this.setTemplate({ tag: "svg", ns: "http://www.w3.org/2000/svg", attributes: { class: ["ck", "ck-icon", n.if("isVisible", "ck-hidden", (t) => !t), "ck-reset_all-excluded", n.if("isColorInherited", "ck-icon_inherit-color")], viewBox: n.to("viewBox"), "aria-hidden": !0 } });
  }
  render() {
    super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", () => {
      this._updateXMLContent(), this._colorFillPaths();
    }), this.on("change:fillColor", () => {
      this._colorFillPaths();
    });
  }
  _updateXMLContent() {
    if (this.content) {
      const n = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg");
      if (!n) throw new v("ui-iconview-invalid-svg", this);
      const t = n.getAttribute("viewBox");
      t && (this.viewBox = t);
      for (const { name: e, value: i } of Array.from(n.attributes)) qa.presentationalAttributeNames.includes(e) && this.element.setAttribute(e, i);
      for (; this.element.firstChild; ) this.element.removeChild(this.element.firstChild);
      for (; n.childNodes.length > 0; ) this.element.appendChild(n.childNodes[0]);
    }
  }
  _colorFillPaths() {
    this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach((n) => {
      n.style.fill = this.fillColor;
    });
  }
};
m(qa, "presentationalAttributeNames", ["alignment-baseline", "baseline-shift", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-rendering", "cursor", "direction", "display", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "overflow", "paint-order", "pointer-events", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-overflow", "text-rendering", "transform", "unicode-bidi", "vector-effect", "visibility", "white-space", "word-spacing", "writing-mode"]);
let cn = qa;
class Tw extends L {
  constructor() {
    super(), this.set({ style: void 0, text: void 0, id: void 0 });
    const n = this.bindTemplate;
    this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__label"], style: n.to("style"), id: n.to("id") }, children: [{ text: n.to("text") }] });
  }
}
class V extends L {
  constructor(t, e = new Tw()) {
    super(t);
    m(this, "children");
    m(this, "labelView");
    m(this, "iconView");
    m(this, "keystrokeView");
    m(this, "_focusDelayed", null);
    const i = this.bindTemplate, r = Ee();
    this.set("_ariaPressed", !1), this.set("_ariaChecked", !1), this.set("ariaLabel", void 0), this.set("ariaLabelledBy", `ck-editor__aria-label_${r}`), this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isVisible", !0), this.set("isToggleable", !1), this.set("keystroke", void 0), this.set("label", void 0), this.set("role", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.set("withKeystroke", !1), this.children = this.createCollection(), this.labelView = this._setupLabelView(e), this.iconView = new cn(), this.iconView.extendTemplate({ attributes: { class: "ck-button__icon" } }), this.iconView.bind("content").to(this, "icon"), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
    const s = { tag: "button", attributes: { class: ["ck", "ck-button", i.to("class"), i.if("isEnabled", "ck-disabled", (a) => !a), i.if("isVisible", "ck-hidden", (a) => !a), i.to("isOn", (a) => a ? "ck-on" : "ck-off"), i.if("withText", "ck-button_with-text"), i.if("withKeystroke", "ck-button_with-keystroke")], role: i.to("role"), type: i.to("type", (a) => a || "button"), tabindex: i.to("tabindex"), "aria-checked": i.to("_ariaChecked"), "aria-pressed": i.to("_ariaPressed"), "aria-label": i.to("ariaLabel"), "aria-labelledby": i.to("ariaLabelledBy"), "aria-disabled": i.if("isEnabled", !0, (a) => !a), "data-cke-tooltip-text": i.to("_tooltipString"), "data-cke-tooltip-position": i.to("tooltipPosition") }, children: this.children, on: { click: i.to((a) => {
      this.isEnabled ? this.fire("execute") : a.preventDefault();
    }) } };
    this.bind("_ariaPressed").to(this, "isOn", this, "isToggleable", this, "role", (a, l, c) => !(!l || qm(c)) && String(!!a)), this.bind("_ariaChecked").to(this, "isOn", this, "isToggleable", this, "role", (a, l, c) => !(!l || !qm(c)) && String(!!a)), H.isSafari && (this._focusDelayed || (this._focusDelayed = au(() => this.focus(), 0)), s.on.mousedown = i.to(() => {
      this._focusDelayed();
    }), s.on.mouseup = i.to(() => {
      this._focusDelayed.cancel();
    })), this.setTemplate(s);
  }
  render() {
    super.render(), this.icon && this.children.add(this.iconView), this.on("change:icon", (t, e, i, r) => {
      i && !r ? this.children.add(this.iconView, 0) : !i && r && this.children.remove(this.iconView);
    }), this.children.add(this.labelView), this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView);
  }
  focus() {
    this.element.focus();
  }
  destroy() {
    this._focusDelayed && this._focusDelayed.cancel(), super.destroy();
  }
  _setupLabelView(t) {
    return t.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy"), t;
  }
  _createKeystrokeView() {
    const t = new L();
    return t.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__keystroke"] }, children: [{ text: this.bindTemplate.to("keystroke", (e) => _a(e)) }] }), t;
  }
  _getTooltipString(t, e, i) {
    return t ? typeof t == "string" ? t : (i && (i = _a(i)), t instanceof Function ? t(e, i) : `${e}${i ? ` (${i})` : ""}`) : "";
  }
}
function qm(o) {
  switch (o) {
    case "radio":
    case "checkbox":
    case "option":
    case "switch":
    case "menuitemcheckbox":
    case "menuitemradio":
      return !0;
    default:
      return !1;
  }
}
class uo extends L {
  constructor(t, e = {}) {
    super(t);
    m(this, "children");
    m(this, "iconView");
    const i = this.bindTemplate;
    this.set("label", e.label || ""), this.set("class", e.class || null), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-form__header", i.to("class")] }, children: this.children }), e.icon && (this.iconView = new cn(), this.iconView.content = e.icon, this.children.add(this.iconView));
    const r = new L(t);
    r.setTemplate({ tag: "h2", attributes: { class: ["ck", "ck-form__header__label"], role: "presentation" }, children: [{ text: i.to("label") }] }), this.children.add(r);
  }
}
class le extends vt() {
  constructor(t) {
    super();
    m(this, "focusables");
    m(this, "focusTracker");
    m(this, "keystrokeHandler");
    m(this, "actions");
    if (this.focusables = t.focusables, this.focusTracker = t.focusTracker, this.keystrokeHandler = t.keystrokeHandler, this.actions = t.actions, t.actions && t.keystrokeHandler) for (const e in t.actions) {
      let i = t.actions[e];
      typeof i == "string" && (i = [i]);
      for (const r of i) t.keystrokeHandler.set(r, (s, a) => {
        this[e](), a();
      }, t.keystrokeHandlerOptions);
    }
    this.on("forwardCycle", () => this.focusFirst(), { priority: "low" }), this.on("backwardCycle", () => this.focusLast(), { priority: "low" });
  }
  get first() {
    return this.focusables.find(Ul) || null;
  }
  get last() {
    return this.focusables.filter(Ul).slice(-1)[0] || null;
  }
  get next() {
    return this._getDomFocusableItem(1);
  }
  get previous() {
    return this._getDomFocusableItem(-1);
  }
  get current() {
    let t = null;
    return this.focusTracker.focusedElement === null ? null : (this.focusables.find((e, i) => {
      const r = e.element === this.focusTracker.focusedElement;
      return r && (t = i), r;
    }), t);
  }
  focusFirst() {
    this._focus(this.first, 1);
  }
  focusLast() {
    this._focus(this.last, -1);
  }
  focusNext() {
    const t = this.next;
    t && this.focusables.getIndex(t) === this.current || t === this.first ? this.fire("forwardCycle") : this._focus(t, 1);
  }
  focusPrevious() {
    const t = this.previous;
    t && this.focusables.getIndex(t) === this.current || t === this.last ? this.fire("backwardCycle") : this._focus(t, -1);
  }
  chain(t) {
    const e = () => this.current === null ? null : this.focusables.get(this.current);
    this.listenTo(t, "forwardCycle", (i) => {
      const r = e();
      this.focusNext(), r !== e() && i.stop();
    }, { priority: "low" }), this.listenTo(t, "backwardCycle", (i) => {
      const r = e();
      this.focusPrevious(), r !== e() && i.stop();
    }, { priority: "low" });
  }
  unchain(t) {
    this.stopListening(t);
  }
  _focus(t, e) {
    t && this.focusTracker.focusedElement !== t.element && t.focus(e);
  }
  _getDomFocusableItem(t) {
    const e = this.focusables.length;
    if (!e) return null;
    const i = this.current;
    if (i === null) return this[t === 1 ? "first" : "last"];
    let r = this.focusables.get(i), s = (i + e + t) % e;
    do {
      const a = this.focusables.get(s);
      if (Ul(a)) {
        r = a;
        break;
      }
      s = (s + e + t) % e;
    } while (s !== i);
    return r;
  }
}
function Ul(o) {
  return lr(o) && ri(o.element);
}
function lr(o) {
  return !(!("focus" in o) || typeof o.focus != "function");
}
function Sw(o) {
  return lr(o) && "focusCycler" in o && o.focusCycler instanceof le;
}
function bE(o) {
  return class extends o {
    constructor(...t) {
      super(...t);
      m(this, "_onDragBound", this._onDrag.bind(this));
      m(this, "_onDragEndBound", this._onDragEnd.bind(this));
      m(this, "_lastDraggingCoordinates", { x: 0, y: 0 });
      this.on("render", () => {
        this._attachListeners();
      }), this.set("isDragging", !1);
    }
    _attachListeners() {
      this.listenTo(this.element, "mousedown", this._onDragStart.bind(this)), this.listenTo(this.element, "touchstart", this._onDragStart.bind(this));
    }
    _attachDragListeners() {
      this.listenTo(N.document, "mouseup", this._onDragEndBound), this.listenTo(N.document, "touchend", this._onDragEndBound), this.listenTo(N.document, "mousemove", this._onDragBound), this.listenTo(N.document, "touchmove", this._onDragBound);
    }
    _detachDragListeners() {
      this.stopListening(N.document, "mouseup", this._onDragEndBound), this.stopListening(N.document, "touchend", this._onDragEndBound), this.stopListening(N.document, "mousemove", this._onDragBound), this.stopListening(N.document, "touchmove", this._onDragBound);
    }
    _onDragStart(t, e) {
      if (!this._isHandleElementPressed(e)) return;
      this._attachDragListeners();
      let i = 0, r = 0;
      e instanceof MouseEvent ? (i = e.clientX, r = e.clientY) : (i = e.touches[0].clientX, r = e.touches[0].clientY), this._lastDraggingCoordinates = { x: i, y: r }, this.isDragging = !0;
    }
    _onDrag(t, e) {
      if (!this.isDragging) return void this._detachDragListeners();
      let i = 0, r = 0;
      e instanceof MouseEvent ? (i = e.clientX, r = e.clientY) : (i = e.touches[0].clientX, r = e.touches[0].clientY), e.preventDefault(), this.fire("drag", { deltaX: Math.round(i - this._lastDraggingCoordinates.x), deltaY: Math.round(r - this._lastDraggingCoordinates.y) }), this._lastDraggingCoordinates = { x: i, y: r };
    }
    _onDragEnd() {
      this._detachDragListeners(), this.isDragging = !1;
    }
    _isHandleElementPressed(t) {
      return !!this.dragHandleElement && (this.dragHandleElement === t.target || t.target instanceof HTMLElement && this.dragHandleElement.contains(t.target));
    }
  };
}
class kE extends L {
  constructor(t) {
    super(t);
    m(this, "children");
    m(this, "keystrokes");
    m(this, "focusCycler");
    m(this, "_focusTracker");
    m(this, "_focusables");
    this.children = this.createCollection(), this.keystrokes = new Mt(), this._focusTracker = new gt(), this._focusables = new Te(), this.focusCycler = new le({ focusables: this._focusables, focusTracker: this._focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-dialog__actions"] }, children: this.children });
  }
  render() {
    super.render(), this.keystrokes.listenTo(this.element);
  }
  setButtons(t) {
    for (const e of t) {
      const i = new V(this.locale);
      let r;
      for (r in i.on("execute", () => e.onExecute()), e.onCreate && e.onCreate(i), e) r != "onExecute" && r != "onCreate" && i.set(r, e[r]);
      this.children.add(i);
    }
    this._updateFocusCyclableItems();
  }
  focus(t) {
    t === -1 ? this.focusCycler.focusLast() : this.focusCycler.focusFirst();
  }
  _updateFocusCyclableItems() {
    Array.from(this.children).forEach((t) => {
      this._focusables.add(t), this._focusTracker.add(t.element);
    });
  }
}
class wE extends L {
  constructor(t) {
    super(t);
    m(this, "children");
    this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-dialog__content"] }, children: this.children });
  }
  reset() {
    for (; this.children.length; ) this.children.remove(0);
  }
}
const en = { SCREEN_CENTER: "screen-center", EDITOR_CENTER: "editor-center", EDITOR_TOP_SIDE: "editor-top-side", EDITOR_TOP_CENTER: "editor-top-center", EDITOR_BOTTOM_CENTER: "editor-bottom-center", EDITOR_ABOVE_CENTER: "editor-above-center", EDITOR_BELOW_CENTER: "editor-below-center" }, Wm = Li("px"), Wa = class Wa extends bE(L) {
  constructor(t, { getCurrentDomRoot: e, getViewportOffset: i, keystrokeHandlerOptions: r }) {
    super(t);
    m(this, "parts");
    m(this, "headerView");
    m(this, "closeButtonView");
    m(this, "actionsView");
    m(this, "contentView");
    m(this, "keystrokes");
    m(this, "focusTracker");
    m(this, "wasMoved", !1);
    m(this, "_getCurrentDomRoot");
    m(this, "_getViewportOffset");
    m(this, "_focusables");
    m(this, "_focusCycler");
    const s = this.bindTemplate, a = t.t;
    this.set("className", ""), this.set("ariaLabel", a("Editor dialog")), this.set("isModal", !1), this.set("position", en.SCREEN_CENTER), this.set("_isVisible", !1), this.set("_isTransparent", !1), this.set("_top", 0), this.set("_left", 0), this._getCurrentDomRoot = e, this._getViewportOffset = i, this.decorate("moveTo"), this.parts = this.createCollection(), this.keystrokes = new Mt(), this.focusTracker = new gt(), this._focusables = new Te(), this._focusCycler = new le({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" }, keystrokeHandlerOptions: r }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-dialog-overlay", s.if("isModal", "ck-dialog-overlay__transparent", (l) => !l), s.if("_isVisible", "ck-hidden", (l) => !l)], tabindex: "-1" }, children: [{ tag: "div", attributes: { tabindex: "-1", class: ["ck", "ck-dialog", s.if("isModal", "ck-dialog_modal"), s.to("className")], role: "dialog", "aria-label": s.to("ariaLabel"), style: { top: s.to("_top", (l) => Wm(l)), left: s.to("_left", (l) => Wm(l)), visibility: s.if("_isTransparent", "hidden") } }, children: this.parts }] });
  }
  render() {
    super.render(), this.keystrokes.set("Esc", (t, e) => {
      t.defaultPrevented || (this.fire("close", { source: "escKeyPress" }), e());
    }), this.on("drag", (t, { deltaX: e, deltaY: i }) => {
      this.wasMoved = !0, this.moveBy(e, i);
    }), this.listenTo(N.window, "resize", () => {
      this._isVisible && !this.wasMoved && this.updatePosition();
    }), this.listenTo(N.document, "scroll", () => {
      this._isVisible && !this.wasMoved && this.updatePosition();
    }), this.on("change:_isVisible", (t, e, i) => {
      i && (this._isTransparent = !0, setTimeout(() => {
        this.updatePosition(), this._isTransparent = !1, this.focus();
      }, 10));
    }), this.keystrokes.listenTo(this.element);
  }
  get dragHandleElement() {
    return this.headerView && !this.isModal ? this.headerView.element : null;
  }
  setupParts({ icon: t, title: e, hasCloseButton: i = !0, content: r, actionButtons: s }) {
    e && (this.headerView = new uo(this.locale, { icon: t }), i && (this.closeButtonView = this._createCloseButton(), this.headerView.children.add(this.closeButtonView)), this.headerView.label = e, this.ariaLabel = e, this.parts.add(this.headerView, 0)), r && (r instanceof L && (r = [r]), this.contentView = new wE(this.locale), this.contentView.children.addMany(r), this.parts.add(this.contentView)), s && (this.actionsView = new kE(this.locale), this.actionsView.setButtons(s), this.parts.add(this.actionsView)), this._updateFocusCyclableItems();
  }
  focus() {
    this._focusCycler.focusFirst();
  }
  moveTo(t, e) {
    const i = this._getViewportRect(), r = this._getDialogRect();
    t + r.width > i.right && (t = i.right - r.width), t < i.left && (t = i.left), e < i.top && (e = i.top), this._moveTo(t, e);
  }
  _moveTo(t, e) {
    this._left = t, this._top = e;
  }
  moveBy(t, e) {
    this.moveTo(this._left + t, this._top + e);
  }
  _moveOffScreen() {
    this._moveTo(-9999, -9999);
  }
  updatePosition() {
    if (!this.element || !this.element.parentNode) return;
    const t = this._getViewportRect();
    let e, i = this.position;
    this._getCurrentDomRoot() ? e = this._getVisibleDomRootRect(t) : i = en.SCREEN_CENTER;
    const r = Wa.defaultOffset, s = this._getDialogRect();
    switch (i) {
      case en.EDITOR_TOP_SIDE:
        if (e) {
          const a = this.locale.contentLanguageDirection === "ltr" ? e.right - s.width - r : e.left + r;
          this.moveTo(a, e.top + r);
        } else this._moveOffScreen();
        break;
      case en.EDITOR_CENTER:
        e ? this.moveTo(Math.round(e.left + e.width / 2 - s.width / 2), Math.round(e.top + e.height / 2 - s.height / 2)) : this._moveOffScreen();
        break;
      case en.SCREEN_CENTER:
        this.moveTo(Math.round((t.width - s.width) / 2), Math.round((t.height - s.height) / 2));
        break;
      case en.EDITOR_TOP_CENTER:
        e ? this.moveTo(Math.round(e.left + e.width / 2 - s.width / 2), e.top + r) : this._moveOffScreen();
        break;
      case en.EDITOR_BOTTOM_CENTER:
        e ? this.moveTo(Math.round(e.left + e.width / 2 - s.width / 2), e.bottom - s.height - r) : this._moveOffScreen();
        break;
      case en.EDITOR_ABOVE_CENTER:
        e ? this.moveTo(Math.round(e.left + e.width / 2 - s.width / 2), e.top - s.height - r) : this._moveOffScreen();
        break;
      case en.EDITOR_BELOW_CENTER:
        e ? this.moveTo(Math.round(e.left + e.width / 2 - s.width / 2), e.bottom + r) : this._moveOffScreen();
    }
  }
  _getVisibleDomRootRect(t) {
    let e = new K(this._getCurrentDomRoot()).getVisible();
    return e ? (e = t.getIntersection(e), e || null) : null;
  }
  _getDialogRect() {
    return new K(this.element.firstElementChild);
  }
  _getViewportRect() {
    const t = new K(N.window);
    if (this.isModal) return t;
    const e = { top: 0, bottom: 0, left: 0, right: 0, ...this._getViewportOffset() };
    return t.top += e.top, t.height -= e.top, t.bottom -= e.bottom, t.height -= e.bottom, t.left += e.left, t.right -= e.right, t.width -= e.left + e.right, t;
  }
  _updateFocusCyclableItems() {
    const t = [];
    if (this.contentView) for (const e of this.contentView.children) lr(e) && t.push(e);
    this.actionsView && t.push(this.actionsView), this.closeButtonView && t.push(this.closeButtonView), t.forEach((e) => {
      this._focusables.add(e), this.focusTracker.add(e.element), Sw(e) && this._focusCycler.chain(e.focusCycler);
    });
  }
  _createCloseButton() {
    const t = new V(this.locale), e = this.locale.t;
    return t.set({ label: e("Close"), tooltip: !0, icon: Au }), t.on("execute", () => this.fire("close", { source: "closeButton" })), t;
  }
};
m(Wa, "defaultOffset", 15);
let ld = Wa;
const hn = class hn extends A {
  constructor(t) {
    super(t);
    m(this, "view");
    m(this, "_onHide");
    const e = t.t;
    this._initShowHideListeners(), this._initFocusToggler(), this._initMultiRootIntegration(), this.set({ id: null, isOpen: !1 }), t.accessibility.addKeystrokeInfos({ categoryId: "navigation", keystrokes: [{ label: e("Move focus in and out of an active dialog window"), keystroke: "Ctrl+F6", mayRequireFn: !0 }] });
  }
  static get pluginName() {
    return "Dialog";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  destroy() {
    super.destroy(), hn._visibleDialogPlugin === this && this._unlockBodyScroll();
  }
  _initShowHideListeners() {
    this.on("show", (t, e) => {
      this._show(e);
    }), this.on("show", (t, e) => {
      e.onShow && e.onShow(this);
    }, { priority: "low" }), this.on("hide", () => {
      hn._visibleDialogPlugin && hn._visibleDialogPlugin._hide();
    }), this.on("hide", () => {
      this._onHide && (this._onHide(this), this._onHide = void 0);
    }, { priority: "low" });
  }
  _initFocusToggler() {
    const t = this.editor;
    t.keystrokes.set("Ctrl+F6", (e, i) => {
      this.isOpen && !this.view.isModal && (this.view.focusTracker.isFocused ? t.editing.view.focus() : this.view.focus(), i());
    });
  }
  _initMultiRootIntegration() {
    const t = this.editor.model;
    t.document.on("change:data", () => {
      if (!this.view) return;
      const e = t.document.differ.getChangedRoots();
      for (const i of e) i.state && this.view.updatePosition();
    });
  }
  show(t) {
    this.hide(), this.fire(`show:${t.id}`, t);
  }
  _show({ id: t, icon: e, title: i, hasCloseButton: r = !0, content: s, actionButtons: a, className: l, isModal: c, position: d, onHide: u, keystrokeHandlerOptions: h }) {
    const g = this.editor;
    this.view = new ld(g.locale, { getCurrentDomRoot: () => g.editing.view.getDomRoot(g.model.document.selection.anchor.root.rootName), getViewportOffset: () => g.ui.viewportOffset, keystrokeHandlerOptions: h });
    const f = this.view;
    f.on("close", () => {
      this.hide();
    }), g.ui.view.body.add(f), g.keystrokes.listenTo(f.element), d || (d = c ? en.SCREEN_CENTER : en.EDITOR_CENTER), c && this._lockBodyScroll(), f.set({ position: d, _isVisible: !0, className: l, isModal: c }), f.setupParts({ icon: e, title: i, hasCloseButton: r, content: s, actionButtons: a }), this.id = t, u && (this._onHide = u), this.isOpen = !0, hn._visibleDialogPlugin = this;
  }
  hide() {
    hn._visibleDialogPlugin && hn._visibleDialogPlugin.fire(`hide:${hn._visibleDialogPlugin.id}`);
  }
  _hide() {
    if (!this.view) return;
    const t = this.editor, e = this.view;
    e.isModal && this._unlockBodyScroll(), e.contentView && e.contentView.reset(), t.ui.view.body.remove(e), t.ui.focusTracker.remove(e.element), t.keystrokes.stopListening(e.element), e.destroy(), t.editing.view.focus(), this.id = null, this.isOpen = !1, hn._visibleDialogPlugin = null;
  }
  _lockBodyScroll() {
    document.documentElement.classList.add("ck-dialog-scroll-locked");
  }
  _unlockBodyScroll() {
    document.documentElement.classList.remove("ck-dialog-scroll-locked");
  }
};
m(hn, "_visibleDialogPlugin");
let no = hn;
class er extends V {
  constructor(t, e = new Tw()) {
    super(t, e);
    m(this, "_checkIconHolderView", new _E());
    this.set({ hasCheckSpace: !1, _hasCheck: this.isToggleable });
    const i = this.bindTemplate;
    this.extendTemplate({ attributes: { class: ["ck-list-item-button", i.if("isToggleable", "ck-list-item-button_toggleable")] } }), this.bind("_hasCheck").to(this, "hasCheckSpace", this, "isToggleable", (r, s) => r || s);
  }
  render() {
    super.render(), this._hasCheck && this.children.add(this._checkIconHolderView, 0), this._watchCheckIconHolderMount();
  }
  _watchCheckIconHolderMount() {
    this._checkIconHolderView.bind("isOn").to(this, "isOn", (t) => this.isToggleable && t), this.on("change:_hasCheck", (t, e, i) => {
      const { children: r, _checkIconHolderView: s } = this;
      i ? r.add(s, 0) : r.remove(s);
    });
  }
}
class _E extends L {
  constructor() {
    super();
    m(this, "children");
    m(this, "_checkIconView", this._createCheckIconView());
    const t = this.bindTemplate;
    this.children = this.createCollection(), this.set("isOn", !1), this.setTemplate({ tag: "span", children: this.children, attributes: { class: ["ck", "ck-list-item-button__check-holder", t.to("isOn", (e) => e ? "ck-on" : "ck-off")] } });
  }
  render() {
    super.render(), this.isOn && this.children.add(this._checkIconView, 0), this._watchCheckIconMount();
  }
  _watchCheckIconMount() {
    this.on("change:isOn", (t, e, i) => {
      const { children: r, _checkIconView: s } = this;
      i && !r.has(s) ? r.add(s) : !i && r.has(s) && r.remove(s);
    });
  }
  _createCheckIconView() {
    const t = new cn();
    return t.content = _w, t.extendTemplate({ attributes: { class: "ck-list-item-button__check-icon" } }), t;
  }
}
class Et extends er {
  constructor(n) {
    super(n), this.set({ withText: !0, withKeystroke: !0, tooltip: !1, role: "menuitem" }), this.extendTemplate({ attributes: { class: ["ck-menu-bar__menu__item__button"] } });
  }
}
class Tu extends L {
  constructor(t) {
    super(t);
    m(this, "id");
    this.set("text", void 0), this.set("for", void 0), this.id = `ck-editor__label_${Ee()}`;
    const e = this.bindTemplate;
    this.setTemplate({ tag: "label", attributes: { class: ["ck", "ck-label"], id: this.id, for: e.to("for") }, children: [{ text: e.to("text") }] });
  }
}
class vE extends L {
  constructor(n, t) {
    super(n);
    const e = n.t, i = new Tu();
    i.text = e("Help Contents. To close this dialog press ESC."), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-accessibility-help-dialog__content"], "aria-labelledby": i.id, role: "document", tabindex: -1 }, children: [mn(document, "p", {}, e("Below, you can find a list of keyboard shortcuts that can be used in the editor.")), ...this._createCategories(Array.from(t.values())), i] });
  }
  focus() {
    this.element.focus();
  }
  _createCategories(n) {
    return n.map((t) => {
      const e = [mn(document, "h3", {}, t.label), ...Array.from(t.groups.values()).map((i) => this._createGroup(i)).flat()];
      return t.description && e.splice(1, 0, mn(document, "p", {}, t.description)), mn(document, "section", {}, e);
    });
  }
  _createGroup(n) {
    const t = n.keystrokes.sort((i, r) => i.label.localeCompare(r.label)).map((i) => this._createGroupRow(i)).flat(), e = [mn(document, "dl", {}, t)];
    return n.label && e.unshift(mn(document, "h4", {}, n.label)), e;
  }
  _createGroupRow(n) {
    const t = this.locale.t, e = mn(document, "dt"), i = mn(document, "dd"), r = function(a) {
      return typeof a == "string" ? [[a]] : typeof a[0] == "string" ? [a] : a;
    }(n.keystroke), s = [];
    for (const a of r) s.push(a.map(yE).join(""));
    return e.innerHTML = n.label, i.innerHTML = s.join(", ") + (n.mayRequireFn && H.isMac ? ` ${t("(may require <kbd>Fn</kbd>)")}` : ""), [e, i];
  }
}
function yE(o) {
  return _a(o).split("+").map((n) => `<kbd>${n}</kbd>`).join("+");
}
class CE extends A {
  constructor() {
    super(...arguments);
    m(this, "contentView", null);
  }
  static get requires() {
    return [no];
  }
  static get pluginName() {
    return "AccessibilityHelp";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor, e = t.locale.t;
    t.ui.componentFactory.add("accessibilityHelp", () => {
      const i = this._createButton(V);
      return i.set({ tooltip: !0, withText: !1, label: e("Accessibility help") }), i;
    }), t.ui.componentFactory.add("menuBar:accessibilityHelp", () => {
      const i = this._createButton(Et);
      return i.label = e("Accessibility"), i;
    }), t.keystrokes.set("Alt+0", (i, r) => {
      this._toggleDialog(), r();
    }), this._setupRootLabels();
  }
  _createButton(t) {
    const e = this.editor, i = e.plugins.get("Dialog"), r = new t(e.locale);
    return r.set({ keystroke: "Alt+0", icon: zm, isToggleable: !0 }), r.on("execute", () => this._toggleDialog()), r.bind("isOn").to(i, "id", (s) => s === "accessibilityHelp"), r;
  }
  _setupRootLabels() {
    const t = this.editor, e = t.editing.view, i = t.t;
    function r(s, a) {
      const l = [a.getAttribute("aria-label"), i("Press %0 for help.", [_a("Alt+0")])].filter((c) => c).join(". ");
      s.setAttribute("aria-label", l, a);
    }
    t.ui.on("ready", () => {
      e.change((s) => {
        for (const a of e.document.roots) r(s, a);
      }), t.on("addRoot", (s, a) => {
        const l = t.editing.view.document.getRoot(a.rootName);
        e.change((c) => r(c, l));
      }, { priority: "low" });
    });
  }
  _toggleDialog() {
    const t = this.editor, e = t.plugins.get("Dialog"), i = t.locale.t;
    this.contentView || (this.contentView = new vE(t.locale, t.accessibility.keystrokeInfos)), e.id === "accessibilityHelp" ? e.hide() : e.show({ id: "accessibilityHelp", className: "ck-accessibility-help-dialog", title: i("Accessibility help"), icon: zm, hasCloseButton: !0, content: this.contentView });
  }
}
const tn = class tn extends Te {
  constructor(t, e = []) {
    super(e);
    m(this, "locale");
    m(this, "_bodyCollectionContainer");
    this.locale = t;
  }
  get bodyCollectionContainer() {
    return this._bodyCollectionContainer;
  }
  attachToDom() {
    this._bodyCollectionContainer = new sn({ tag: "div", attributes: { class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"], dir: this.locale.uiLanguageDirection, role: "application" }, children: this }).render(), tn._bodyWrapper && tn._bodyWrapper.isConnected || (tn._bodyWrapper = mn(document, "div", { class: "ck-body-wrapper" }), document.body.appendChild(tn._bodyWrapper)), tn._bodyWrapper.appendChild(this._bodyCollectionContainer);
  }
  detachFromDom() {
    super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove(), tn._bodyWrapper && !tn._bodyWrapper.childElementCount && (tn._bodyWrapper.remove(), delete tn._bodyWrapper);
  }
};
m(tn, "_bodyWrapper");
let cd = tn;
class ys extends V {
  constructor(t) {
    super(t);
    m(this, "toggleSwitchView");
    this.isToggleable = !0, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({ attributes: { class: "ck-switchbutton" } });
  }
  render() {
    super.render(), this.children.add(this.toggleSwitchView);
  }
  _createToggleView() {
    const t = new L();
    return t.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__toggle"] }, children: [{ tag: "span", attributes: { class: ["ck", "ck-button__toggle__inner"] } }] }), t;
  }
}
class Gm extends Iw(V) {
}
class AE extends Iw(er) {
}
function Iw(o) {
  return class extends o {
    constructor(...t) {
      super(...t);
      m(this, "buttonView");
      m(this, "_fileInputView");
      this.buttonView = this, this._fileInputView = new xE(this.locale), this._fileInputView.bind("acceptedType").to(this), this._fileInputView.bind("allowMultipleFiles").to(this), this._fileInputView.delegate("done").to(this), this.on("execute", () => {
        this._fileInputView.open();
      }), this.extendTemplate({ attributes: { class: "ck-file-dialog-button" } });
    }
    render() {
      super.render(), this.children.add(this._fileInputView);
    }
  };
}
class xE extends L {
  constructor(n) {
    super(n), this.set("acceptedType", void 0), this.set("allowMultipleFiles", !1);
    const t = this.bindTemplate;
    this.setTemplate({ tag: "input", attributes: { class: ["ck-hidden"], type: "file", tabindex: "-1", accept: t.to("acceptedType"), multiple: t.to("allowMultipleFiles") }, on: { change: t.to(() => {
      var e, i;
      (i = (e = this.element) == null ? void 0 : e.files) != null && i.length && this.fire("done", this.element.files), this.element.value = "";
    }) } });
  }
  open() {
    this.element.click();
  }
}
class Mw extends L {
  constructor(t, e) {
    super(t);
    m(this, "buttonView");
    m(this, "children");
    const i = this.bindTemplate;
    this.set("isCollapsed", !1), this.set("label", ""), this.buttonView = this._createButtonView(), this.children = this.createCollection(), this.set("_collapsibleAriaLabelUid", void 0), e && this.children.addMany(e), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-collapsible", i.if("isCollapsed", "ck-collapsible_collapsed")] }, children: [this.buttonView, { tag: "div", attributes: { class: ["ck", "ck-collapsible__children"], role: "region", hidden: i.if("isCollapsed", "hidden"), "aria-labelledby": i.to("_collapsibleAriaLabelUid") }, children: this.children }] });
  }
  render() {
    super.render(), this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id;
  }
  focus() {
    this.buttonView.focus();
  }
  _createButtonView() {
    const t = new V(this.locale), e = t.bindTemplate;
    return t.set({ withText: !0, icon: ul }), t.extendTemplate({ attributes: { "aria-expanded": e.to("isOn", (i) => String(i)) } }), t.bind("label").to(this), t.bind("isOn").to(this, "isCollapsed", (i) => !i), t.on("execute", () => {
      this.isCollapsed = !this.isCollapsed;
    }), t;
  }
}
function EE(o, n) {
  const t = o.t, e = { Black: t("Black"), "Dim grey": t("Dim grey"), Grey: t("Grey"), "Light grey": t("Light grey"), White: t("White"), Red: t("Red"), Orange: t("Orange"), Yellow: t("Yellow"), "Light green": t("Light green"), Green: t("Green"), Aquamarine: t("Aquamarine"), Turquoise: t("Turquoise"), "Light blue": t("Light blue"), Blue: t("Blue"), Purple: t("Purple") };
  return n.map((i) => {
    const r = e[i.label];
    return r && r != i.label && (i.label = r), i;
  });
}
function TE(o) {
  return o.map(SE).filter((n) => !!n);
}
function SE(o) {
  return typeof o == "string" ? { model: o, label: o, hasBorder: !1, view: { name: "span", styles: { color: o } } } : { model: o.color, label: o.label || o.color, hasBorder: o.hasBorder !== void 0 && o.hasBorder, view: { name: "span", styles: { color: `${o.color}` } } };
}
class Dw extends V {
  constructor(n) {
    super(n);
    const t = this.bindTemplate;
    this.set("color", void 0), this.set("hasBorder", !1), this.icon = b2, this.extendTemplate({ attributes: { style: { backgroundColor: t.to("color", (e) => H.isMediaForcedColors ? null : e) }, class: ["ck", "ck-color-grid__tile", t.if("hasBorder", "ck-color-selector__color-tile_bordered")] } });
  }
  render() {
    super.render(), this.iconView.fillColor = "hsl(0, 0%, 100%)";
  }
}
class Km extends L {
  constructor(t, e) {
    super(t);
    m(this, "columns");
    m(this, "items");
    m(this, "focusTracker");
    m(this, "keystrokes");
    const i = e && e.colorDefinitions ? e.colorDefinitions : [];
    this.columns = (e == null ? void 0 : e.columns) || 5;
    const r = { gridTemplateColumns: `repeat( ${this.columns}, 1fr)` };
    this.set("selectedColor", void 0), this.items = this.createCollection(), this.focusTracker = new gt(), this.keystrokes = new Mt(), this.items.on("add", (s, a) => {
      a.isOn = a.color === this.selectedColor;
    }), i.forEach((s) => {
      const a = new Dw();
      a.set({ color: s.color, label: s.label, tooltip: !0, hasBorder: s.options.hasBorder }), a.on("execute", () => {
        this.fire("execute", { value: s.color, hasBorder: s.options.hasBorder, label: s.label });
      }), this.items.add(a);
    }), this.setTemplate({ tag: "div", children: this.items, attributes: { class: ["ck", "ck-color-grid"], style: r } }), this.on("change:selectedColor", (s, a, l) => {
      for (const c of this.items) c.isOn = c.color === l;
    });
  }
  focus() {
    this.items.length && this.items.first.focus();
  }
  focusLast() {
    this.items.length && this.items.last.focus();
  }
  render() {
    var t;
    super.render();
    for (const e of this.items) this.focusTracker.add(e.element);
    this.items.on("add", (e, i) => {
      this.focusTracker.add(i.element);
    }), this.items.on("remove", (e, i) => {
      this.focusTracker.remove(i.element);
    }), this.keystrokes.listenTo(this.element), vs({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.items, numberOfColumns: this.columns, uiLanguageDirection: (t = this.locale) == null ? void 0 : t.uiLanguageDirection });
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
}
var dd = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, Ym = { red: 0, orange: 60, yellow: 120, green: 180, blue: 240, purple: 300 };
function Zm(o) {
  var n, t, e = [], i = 1;
  if (typeof o == "string") if (dd[o]) e = dd[o].slice(), t = "rgb";
  else if (o === "transparent") i = 0, t = "rgb", e = [0, 0, 0];
  else if (/^#[A-Fa-f0-9]+$/.test(o)) {
    var r = o.slice(1);
    i = 1, (l = r.length) <= 4 ? (e = [parseInt(r[0] + r[0], 16), parseInt(r[1] + r[1], 16), parseInt(r[2] + r[2], 16)], l === 4 && (i = parseInt(r[3] + r[3], 16) / 255)) : (e = [parseInt(r[0] + r[1], 16), parseInt(r[2] + r[3], 16), parseInt(r[4] + r[5], 16)], l === 8 && (i = parseInt(r[6] + r[7], 16) / 255)), e[0] || (e[0] = 0), e[1] || (e[1] = 0), e[2] || (e[2] = 0), t = "rgb";
  } else if (n = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(o)) {
    var s = n[1], a = s === "rgb";
    t = r = s.replace(/a$/, "");
    var l = r === "cmyk" ? 4 : r === "gray" ? 1 : 3;
    e = n[2].trim().split(/\s*[,\/]\s*|\s+/).map(function(c, d) {
      if (/%$/.test(c)) return d === l ? parseFloat(c) / 100 : r === "rgb" ? 255 * parseFloat(c) / 100 : parseFloat(c);
      if (r[d] === "h") {
        if (/deg$/.test(c)) return parseFloat(c);
        if (Ym[c] !== void 0) return Ym[c];
      }
      return parseFloat(c);
    }), s === r && e.push(1), i = a || e[l] === void 0 ? 1 : e[l], e = e.slice(0, l);
  } else o.length > 10 && /[0-9](?:\s|\/)/.test(o) && (e = o.match(/([0-9]+)/g).map(function(c) {
    return parseFloat(c);
  }), t = o.match(/([a-z])/gi).join("").toLowerCase());
  else isNaN(o) ? Array.isArray(o) || o.length ? (e = [o[0], o[1], o[2]], t = "rgb", i = o.length === 4 ? o[3] : 1) : o instanceof Object && (o.r != null || o.red != null || o.R != null ? (t = "rgb", e = [o.r || o.red || o.R || 0, o.g || o.green || o.G || 0, o.b || o.blue || o.B || 0]) : (t = "hsl", e = [o.h || o.hue || o.H || 0, o.s || o.saturation || o.S || 0, o.l || o.lightness || o.L || o.b || o.brightness]), i = o.a || o.alpha || o.opacity || 1, o.opacity != null && (i /= 100)) : (t = "rgb", e = [o >>> 16, (65280 & o) >>> 8, 255 & o]);
  return { space: t, values: e, alpha: i };
}
const $r = dd, Pw = {};
for (const o of Object.keys($r)) Pw[$r[o]] = o;
const j = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
var Lw = j;
for (const o of Object.keys(j)) {
  if (!("channels" in j[o])) throw new Error("missing channels property: " + o);
  if (!("labels" in j[o])) throw new Error("missing channel labels property: " + o);
  if (j[o].labels.length !== j[o].channels) throw new Error("channel and label counts mismatch: " + o);
  const { channels: n, labels: t } = j[o];
  delete j[o].channels, delete j[o].labels, Object.defineProperty(j[o], "channels", { value: n }), Object.defineProperty(j[o], "labels", { value: t });
}
function IE(o, n) {
  return (o[0] - n[0]) ** 2 + (o[1] - n[1]) ** 2 + (o[2] - n[2]) ** 2;
}
j.rgb.hsl = function(o) {
  const n = o[0] / 255, t = o[1] / 255, e = o[2] / 255, i = Math.min(n, t, e), r = Math.max(n, t, e), s = r - i;
  let a, l;
  r === i ? a = 0 : n === r ? a = (t - e) / s : t === r ? a = 2 + (e - n) / s : e === r && (a = 4 + (n - t) / s), a = Math.min(60 * a, 360), a < 0 && (a += 360);
  const c = (i + r) / 2;
  return l = r === i ? 0 : c <= 0.5 ? s / (r + i) : s / (2 - r - i), [a, 100 * l, 100 * c];
}, j.rgb.hsv = function(o) {
  let n, t, e, i, r;
  const s = o[0] / 255, a = o[1] / 255, l = o[2] / 255, c = Math.max(s, a, l), d = c - Math.min(s, a, l), u = function(h) {
    return (c - h) / 6 / d + 0.5;
  };
  return d === 0 ? (i = 0, r = 0) : (r = d / c, n = u(s), t = u(a), e = u(l), s === c ? i = e - t : a === c ? i = 1 / 3 + n - e : l === c && (i = 2 / 3 + t - n), i < 0 ? i += 1 : i > 1 && (i -= 1)), [360 * i, 100 * r, 100 * c];
}, j.rgb.hwb = function(o) {
  const n = o[0], t = o[1];
  let e = o[2];
  const i = j.rgb.hsl(o)[0], r = 1 / 255 * Math.min(n, Math.min(t, e));
  return e = 1 - 1 / 255 * Math.max(n, Math.max(t, e)), [i, 100 * r, 100 * e];
}, j.rgb.cmyk = function(o) {
  const n = o[0] / 255, t = o[1] / 255, e = o[2] / 255, i = Math.min(1 - n, 1 - t, 1 - e);
  return [100 * ((1 - n - i) / (1 - i) || 0), 100 * ((1 - t - i) / (1 - i) || 0), 100 * ((1 - e - i) / (1 - i) || 0), 100 * i];
}, j.rgb.keyword = function(o) {
  const n = Pw[o];
  if (n) return n;
  let t, e = 1 / 0;
  for (const i of Object.keys($r)) {
    const r = IE(o, $r[i]);
    r < e && (e = r, t = i);
  }
  return t;
}, j.keyword.rgb = function(o) {
  return $r[o];
}, j.rgb.xyz = function(o) {
  let n = o[0] / 255, t = o[1] / 255, e = o[2] / 255;
  return n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92, t = t > 0.04045 ? ((t + 0.055) / 1.055) ** 2.4 : t / 12.92, e = e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92, [100 * (0.4124 * n + 0.3576 * t + 0.1805 * e), 100 * (0.2126 * n + 0.7152 * t + 0.0722 * e), 100 * (0.0193 * n + 0.1192 * t + 0.9505 * e)];
}, j.rgb.lab = function(o) {
  const n = j.rgb.xyz(o);
  let t = n[0], e = n[1], i = n[2];
  return t /= 95.047, e /= 100, i /= 108.883, t = t > 8856e-6 ? t ** (1 / 3) : 7.787 * t + 16 / 116, e = e > 8856e-6 ? e ** (1 / 3) : 7.787 * e + 16 / 116, i = i > 8856e-6 ? i ** (1 / 3) : 7.787 * i + 16 / 116, [116 * e - 16, 500 * (t - e), 200 * (e - i)];
}, j.hsl.rgb = function(o) {
  const n = o[0] / 360, t = o[1] / 100, e = o[2] / 100;
  let i, r, s;
  if (t === 0) return s = 255 * e, [s, s, s];
  i = e < 0.5 ? e * (1 + t) : e + t - e * t;
  const a = 2 * e - i, l = [0, 0, 0];
  for (let c = 0; c < 3; c++) r = n + 1 / 3 * -(c - 1), r < 0 && r++, r > 1 && r--, s = 6 * r < 1 ? a + 6 * (i - a) * r : 2 * r < 1 ? i : 3 * r < 2 ? a + (i - a) * (2 / 3 - r) * 6 : a, l[c] = 255 * s;
  return l;
}, j.hsl.hsv = function(o) {
  const n = o[0];
  let t = o[1] / 100, e = o[2] / 100, i = t;
  const r = Math.max(e, 0.01);
  return e *= 2, t *= e <= 1 ? e : 2 - e, i *= r <= 1 ? r : 2 - r, [n, 100 * (e === 0 ? 2 * i / (r + i) : 2 * t / (e + t)), 100 * ((e + t) / 2)];
}, j.hsv.rgb = function(o) {
  const n = o[0] / 60, t = o[1] / 100;
  let e = o[2] / 100;
  const i = Math.floor(n) % 6, r = n - Math.floor(n), s = 255 * e * (1 - t), a = 255 * e * (1 - t * r), l = 255 * e * (1 - t * (1 - r));
  switch (e *= 255, i) {
    case 0:
      return [e, l, s];
    case 1:
      return [a, e, s];
    case 2:
      return [s, e, l];
    case 3:
      return [s, a, e];
    case 4:
      return [l, s, e];
    case 5:
      return [e, s, a];
  }
}, j.hsv.hsl = function(o) {
  const n = o[0], t = o[1] / 100, e = o[2] / 100, i = Math.max(e, 0.01);
  let r, s;
  s = (2 - t) * e;
  const a = (2 - t) * i;
  return r = t * i, r /= a <= 1 ? a : 2 - a, r = r || 0, s /= 2, [n, 100 * r, 100 * s];
}, j.hwb.rgb = function(o) {
  const n = o[0] / 360;
  let t = o[1] / 100, e = o[2] / 100;
  const i = t + e;
  let r;
  i > 1 && (t /= i, e /= i);
  const s = Math.floor(6 * n), a = 1 - e;
  r = 6 * n - s, 1 & s && (r = 1 - r);
  const l = t + r * (a - t);
  let c, d, u;
  switch (s) {
    default:
    case 6:
    case 0:
      c = a, d = l, u = t;
      break;
    case 1:
      c = l, d = a, u = t;
      break;
    case 2:
      c = t, d = a, u = l;
      break;
    case 3:
      c = t, d = l, u = a;
      break;
    case 4:
      c = l, d = t, u = a;
      break;
    case 5:
      c = a, d = t, u = l;
  }
  return [255 * c, 255 * d, 255 * u];
}, j.cmyk.rgb = function(o) {
  const n = o[0] / 100, t = o[1] / 100, e = o[2] / 100, i = o[3] / 100;
  return [255 * (1 - Math.min(1, n * (1 - i) + i)), 255 * (1 - Math.min(1, t * (1 - i) + i)), 255 * (1 - Math.min(1, e * (1 - i) + i))];
}, j.xyz.rgb = function(o) {
  const n = o[0] / 100, t = o[1] / 100, e = o[2] / 100;
  let i, r, s;
  return i = 3.2406 * n + -1.5372 * t + -0.4986 * e, r = -0.9689 * n + 1.8758 * t + 0.0415 * e, s = 0.0557 * n + -0.204 * t + 1.057 * e, i = i > 31308e-7 ? 1.055 * i ** (1 / 2.4) - 0.055 : 12.92 * i, r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : 12.92 * r, s = s > 31308e-7 ? 1.055 * s ** (1 / 2.4) - 0.055 : 12.92 * s, i = Math.min(Math.max(0, i), 1), r = Math.min(Math.max(0, r), 1), s = Math.min(Math.max(0, s), 1), [255 * i, 255 * r, 255 * s];
}, j.xyz.lab = function(o) {
  let n = o[0], t = o[1], e = o[2];
  return n /= 95.047, t /= 100, e /= 108.883, n = n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116, t = t > 8856e-6 ? t ** (1 / 3) : 7.787 * t + 16 / 116, e = e > 8856e-6 ? e ** (1 / 3) : 7.787 * e + 16 / 116, [116 * t - 16, 500 * (n - t), 200 * (t - e)];
}, j.lab.xyz = function(o) {
  let n, t, e;
  t = (o[0] + 16) / 116, n = o[1] / 500 + t, e = t - o[2] / 200;
  const i = t ** 3, r = n ** 3, s = e ** 3;
  return t = i > 8856e-6 ? i : (t - 16 / 116) / 7.787, n = r > 8856e-6 ? r : (n - 16 / 116) / 7.787, e = s > 8856e-6 ? s : (e - 16 / 116) / 7.787, n *= 95.047, t *= 100, e *= 108.883, [n, t, e];
}, j.lab.lch = function(o) {
  const n = o[0], t = o[1], e = o[2];
  let i;
  return i = 360 * Math.atan2(e, t) / 2 / Math.PI, i < 0 && (i += 360), [n, Math.sqrt(t * t + e * e), i];
}, j.lch.lab = function(o) {
  const n = o[0], t = o[1], e = o[2] / 360 * 2 * Math.PI;
  return [n, t * Math.cos(e), t * Math.sin(e)];
}, j.rgb.ansi16 = function(o, n = null) {
  const [t, e, i] = o;
  let r = n === null ? j.rgb.hsv(o)[2] : n;
  if (r = Math.round(r / 50), r === 0) return 30;
  let s = 30 + (Math.round(i / 255) << 2 | Math.round(e / 255) << 1 | Math.round(t / 255));
  return r === 2 && (s += 60), s;
}, j.hsv.ansi16 = function(o) {
  return j.rgb.ansi16(j.hsv.rgb(o), o[2]);
}, j.rgb.ansi256 = function(o) {
  const n = o[0], t = o[1], e = o[2];
  return n === t && t === e ? n < 8 ? 16 : n > 248 ? 231 : Math.round((n - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(n / 255 * 5) + 6 * Math.round(t / 255 * 5) + Math.round(e / 255 * 5);
}, j.ansi16.rgb = function(o) {
  let n = o % 10;
  if (n === 0 || n === 7) return o > 50 && (n += 3.5), n = n / 10.5 * 255, [n, n, n];
  const t = 0.5 * (1 + ~~(o > 50));
  return [(1 & n) * t * 255, (n >> 1 & 1) * t * 255, (n >> 2 & 1) * t * 255];
}, j.ansi256.rgb = function(o) {
  if (o >= 232) {
    const t = 10 * (o - 232) + 8;
    return [t, t, t];
  }
  let n;
  return o -= 16, [Math.floor(o / 36) / 5 * 255, Math.floor((n = o % 36) / 6) / 5 * 255, n % 6 / 5 * 255];
}, j.rgb.hex = function(o) {
  const n = (((255 & Math.round(o[0])) << 16) + ((255 & Math.round(o[1])) << 8) + (255 & Math.round(o[2]))).toString(16).toUpperCase();
  return "000000".substring(n.length) + n;
}, j.hex.rgb = function(o) {
  const n = o.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!n) return [0, 0, 0];
  let t = n[0];
  n[0].length === 3 && (t = t.split("").map((i) => i + i).join(""));
  const e = parseInt(t, 16);
  return [e >> 16 & 255, e >> 8 & 255, 255 & e];
}, j.rgb.hcg = function(o) {
  const n = o[0] / 255, t = o[1] / 255, e = o[2] / 255, i = Math.max(Math.max(n, t), e), r = Math.min(Math.min(n, t), e), s = i - r;
  let a, l;
  return a = s < 1 ? r / (1 - s) : 0, l = s <= 0 ? 0 : i === n ? (t - e) / s % 6 : i === t ? 2 + (e - n) / s : 4 + (n - t) / s, l /= 6, l %= 1, [360 * l, 100 * s, 100 * a];
}, j.hsl.hcg = function(o) {
  const n = o[1] / 100, t = o[2] / 100, e = t < 0.5 ? 2 * n * t : 2 * n * (1 - t);
  let i = 0;
  return e < 1 && (i = (t - 0.5 * e) / (1 - e)), [o[0], 100 * e, 100 * i];
}, j.hsv.hcg = function(o) {
  const n = o[1] / 100, t = o[2] / 100, e = n * t;
  let i = 0;
  return e < 1 && (i = (t - e) / (1 - e)), [o[0], 100 * e, 100 * i];
}, j.hcg.rgb = function(o) {
  const n = o[0] / 360, t = o[1] / 100, e = o[2] / 100;
  if (t === 0) return [255 * e, 255 * e, 255 * e];
  const i = [0, 0, 0], r = n % 1 * 6, s = r % 1, a = 1 - s;
  let l = 0;
  switch (Math.floor(r)) {
    case 0:
      i[0] = 1, i[1] = s, i[2] = 0;
      break;
    case 1:
      i[0] = a, i[1] = 1, i[2] = 0;
      break;
    case 2:
      i[0] = 0, i[1] = 1, i[2] = s;
      break;
    case 3:
      i[0] = 0, i[1] = a, i[2] = 1;
      break;
    case 4:
      i[0] = s, i[1] = 0, i[2] = 1;
      break;
    default:
      i[0] = 1, i[1] = 0, i[2] = a;
  }
  return l = (1 - t) * e, [255 * (t * i[0] + l), 255 * (t * i[1] + l), 255 * (t * i[2] + l)];
}, j.hcg.hsv = function(o) {
  const n = o[1] / 100, t = n + o[2] / 100 * (1 - n);
  let e = 0;
  return t > 0 && (e = n / t), [o[0], 100 * e, 100 * t];
}, j.hcg.hsl = function(o) {
  const n = o[1] / 100, t = o[2] / 100 * (1 - n) + 0.5 * n;
  let e = 0;
  return t > 0 && t < 0.5 ? e = n / (2 * t) : t >= 0.5 && t < 1 && (e = n / (2 * (1 - t))), [o[0], 100 * e, 100 * t];
}, j.hcg.hwb = function(o) {
  const n = o[1] / 100, t = n + o[2] / 100 * (1 - n);
  return [o[0], 100 * (t - n), 100 * (1 - t)];
}, j.hwb.hcg = function(o) {
  const n = o[1] / 100, t = 1 - o[2] / 100, e = t - n;
  let i = 0;
  return e < 1 && (i = (t - e) / (1 - e)), [o[0], 100 * e, 100 * i];
}, j.apple.rgb = function(o) {
  return [o[0] / 65535 * 255, o[1] / 65535 * 255, o[2] / 65535 * 255];
}, j.rgb.apple = function(o) {
  return [o[0] / 255 * 65535, o[1] / 255 * 65535, o[2] / 255 * 65535];
}, j.gray.rgb = function(o) {
  return [o[0] / 100 * 255, o[0] / 100 * 255, o[0] / 100 * 255];
}, j.gray.hsl = function(o) {
  return [0, 0, o[0]];
}, j.gray.hsv = j.gray.hsl, j.gray.hwb = function(o) {
  return [0, 100, o[0]];
}, j.gray.cmyk = function(o) {
  return [0, 0, 0, o[0]];
}, j.gray.lab = function(o) {
  return [o[0], 0, 0];
}, j.gray.hex = function(o) {
  const n = 255 & Math.round(o[0] / 100 * 255), t = ((n << 16) + (n << 8) + n).toString(16).toUpperCase();
  return "000000".substring(t.length) + t;
}, j.rgb.gray = function(o) {
  return [(o[0] + o[1] + o[2]) / 3 / 255 * 100];
};
const Ia = Lw;
function ME(o) {
  const n = function() {
    const e = {}, i = Object.keys(Ia);
    for (let r = i.length, s = 0; s < r; s++) e[i[s]] = { distance: -1, parent: null };
    return e;
  }(), t = [o];
  for (n[o].distance = 0; t.length; ) {
    const e = t.pop(), i = Object.keys(Ia[e]);
    for (let r = i.length, s = 0; s < r; s++) {
      const a = i[s], l = n[a];
      l.distance === -1 && (l.distance = n[e].distance + 1, l.parent = e, t.unshift(a));
    }
  }
  return n;
}
function DE(o, n) {
  return function(t) {
    return n(o(t));
  };
}
function PE(o, n) {
  const t = [n[o].parent, o];
  let e = Ia[n[o].parent][o], i = n[o].parent;
  for (; n[i].parent; ) t.unshift(n[i].parent), e = DE(Ia[n[i].parent][i], e), i = n[i].parent;
  return e.conversion = t, e;
}
const $l = Lw, LE = function(o) {
  const n = ME(o), t = {}, e = Object.keys(n);
  for (let i = e.length, r = 0; r < i; r++) {
    const s = e[r];
    n[s].parent !== null && (t[s] = PE(s, n));
  }
  return t;
}, Wi = {};
Object.keys($l).forEach((o) => {
  Wi[o] = {}, Object.defineProperty(Wi[o], "channels", { value: $l[o].channels }), Object.defineProperty(Wi[o], "labels", { value: $l[o].labels });
  const n = LE(o);
  Object.keys(n).forEach((t) => {
    const e = n[t];
    Wi[o][t] = function(i) {
      const r = function(...s) {
        const a = s[0];
        if (a == null) return a;
        a.length > 1 && (s = a);
        const l = i(s);
        if (typeof l == "object") for (let c = l.length, d = 0; d < c; d++) l[d] = Math.round(l[d]);
        return l;
      };
      return "conversion" in i && (r.conversion = i.conversion), r;
    }(e), Wi[o][t].raw = function(i) {
      const r = function(...s) {
        const a = s[0];
        return a == null ? a : (a.length > 1 && (s = a), i(s));
      };
      return "conversion" in i && (r.conversion = i.conversion), r;
    }(e);
  });
});
var Qm = Hy({ __proto__: null, default: Wi }, [Wi]);
function Bw(o, n) {
  if (!o) return "";
  const t = Nw(o);
  if (!t) return "";
  if (t.space === n) return o;
  if (e = t, !Object.keys(Qm).includes(e.space)) return "";
  var e;
  const i = Qm[t.space][n];
  return i ? function(r, s) {
    switch (s) {
      case "hex":
        return `#${r}`;
      case "rgb":
        return `rgb(${r[0]}, ${r[1]}, ${r[2]})`;
      case "hsl":
        return `hsl(${r[0]}, ${r[1]}%, ${r[2]}%)`;
      case "hwb":
        return `hwb(${r[0]}, ${r[1]}, ${r[2]})`;
      case "lab":
        return `lab(${r[0]}% ${r[1]} ${r[2]})`;
      case "lch":
        return `lch(${r[0]}% ${r[1]} ${r[2]})`;
      default:
        return "";
    }
  }(i(t.space === "hex" ? t.hexValue : t.values), n) : "";
}
function Nw(o) {
  if (o.startsWith("#")) {
    const t = Zm(o);
    return { space: "hex", values: t.values, hexValue: o, alpha: t.alpha };
  }
  const n = Zm(o);
  return n.space ? n : null;
}
class Nn extends L {
  constructor(t, e) {
    super(t);
    m(this, "fieldView");
    m(this, "labelView");
    m(this, "statusView");
    m(this, "fieldWrapperChildren");
    const i = `ck-labeled-field-view-${Ee()}`, r = `ck-labeled-field-view-status-${Ee()}`;
    this.fieldView = e(this, i, r), this.set("label", void 0), this.set("isEnabled", !0), this.set("isEmpty", !0), this.set("isFocused", !1), this.set("errorText", null), this.set("infoText", null), this.set("class", void 0), this.set("placeholder", void 0), this.labelView = this._createLabelView(i), this.statusView = this._createStatusView(r), this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]), this.bind("_statusText").to(this, "errorText", this, "infoText", (a, l) => a || l);
    const s = this.bindTemplate;
    this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view", s.to("class"), s.if("isEnabled", "ck-disabled", (a) => !a), s.if("isEmpty", "ck-labeled-field-view_empty"), s.if("isFocused", "ck-labeled-field-view_focused"), s.if("placeholder", "ck-labeled-field-view_placeholder"), s.if("errorText", "ck-error")] }, children: [{ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__input-wrapper"] }, children: this.fieldWrapperChildren }, this.statusView] });
  }
  _createLabelView(t) {
    const e = new Tu(this.locale);
    return e.for = t, e.bind("text").to(this, "label"), e;
  }
  _createStatusView(t) {
    const e = new L(this.locale), i = this.bindTemplate;
    return e.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__status", i.if("errorText", "ck-labeled-field-view__status_error"), i.if("_statusText", "ck-hidden", (r) => !r)], id: t, role: i.if("errorText", "alert") }, children: [{ text: i.to("_statusText") }] }), e;
  }
  focus(t) {
    this.fieldView.focus(t);
  }
}
class BE extends L {
  constructor(t) {
    super(t);
    m(this, "focusTracker");
    this.set("value", void 0), this.set("id", void 0), this.set("placeholder", void 0), this.set("tabIndex", void 0), this.set("isReadOnly", !1), this.set("hasError", !1), this.set("ariaDescribedById", void 0), this.set("ariaLabel", void 0), this.focusTracker = new gt(), this.bind("isFocused").to(this.focusTracker), this.set("isEmpty", !0);
    const e = this.bindTemplate;
    this.setTemplate({ tag: "input", attributes: { class: ["ck", "ck-input", e.if("isFocused", "ck-input_focused"), e.if("isEmpty", "ck-input-text_empty"), e.if("hasError", "ck-error")], id: e.to("id"), placeholder: e.to("placeholder"), tabindex: e.to("tabIndex"), readonly: e.to("isReadOnly"), "aria-invalid": e.if("hasError", !0), "aria-describedby": e.to("ariaDescribedById"), "aria-label": e.to("ariaLabel") }, on: { input: e.to((...i) => {
      this.fire("input", ...i), this._updateIsEmpty();
    }), change: e.to(this._updateIsEmpty.bind(this)) } });
  }
  render() {
    super.render(), this.focusTracker.add(this.element), this._setDomElementValue(this.value), this._updateIsEmpty(), this.on("change:value", (t, e, i) => {
      this._setDomElementValue(i), this._updateIsEmpty();
    });
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy();
  }
  select() {
    this.element.select();
  }
  focus() {
    this.element.focus();
  }
  reset() {
    this.value = this.element.value = "", this._updateIsEmpty();
  }
  _updateIsEmpty() {
    this.isEmpty = !this.element.value;
  }
  _setDomElementValue(t) {
    this.element.value = t || t === 0 ? t : "";
  }
}
class zw extends BE {
  constructor(n) {
    super(n), this.set("inputMode", "text");
    const t = this.bindTemplate;
    this.extendTemplate({ attributes: { inputmode: t.to("inputMode") } });
  }
}
class NE extends zw {
  constructor(n) {
    super(n), this.extendTemplate({ attributes: { type: "text", class: ["ck-input-text"] } });
  }
}
class zE extends zw {
  constructor(n, { min: t, max: e, step: i } = {}) {
    super(n);
    const r = this.bindTemplate;
    this.set("min", t), this.set("max", e), this.set("step", i), this.extendTemplate({ attributes: { type: "number", class: ["ck-input-number"], min: r.to("min"), max: r.to("max"), step: r.to("step") } });
  }
}
class OE extends L {
  constructor(t) {
    super(t);
    m(this, "children");
    const e = this.bindTemplate;
    this.set("isVisible", !1), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-dropdown__panel", e.to("position", (i) => `ck-dropdown__panel_${i}`), e.if("isVisible", "ck-dropdown__panel-visible")], tabindex: "-1" }, children: this.children, on: { selectstart: e.to((i) => {
      i.target.tagName.toLocaleLowerCase() !== "input" && i.preventDefault();
    }) } });
  }
  focus() {
    if (this.children.length) {
      const t = this.children.first;
      typeof t.focus == "function" ? t.focus() : at("ui-dropdown-panel-focus-child-missing-focus", { childView: this.children.first, dropdownPanel: this });
    }
  }
  focusLast() {
    if (this.children.length) {
      const t = this.children.last;
      typeof t.focusLast == "function" ? t.focusLast() : t.focus();
    }
  }
}
const Fo = class Fo extends L {
  constructor(t, e, i) {
    super(t);
    m(this, "buttonView");
    m(this, "panelView");
    m(this, "focusTracker");
    m(this, "keystrokes");
    m(this, "listView");
    m(this, "toolbarView");
    m(this, "menuView");
    const r = this.bindTemplate;
    this.buttonView = e, this.panelView = i, this.set("isOpen", !1), this.set("isEnabled", !0), this.set("class", void 0), this.set("id", void 0), this.set("panelPosition", "auto"), this.panelView.bind("isVisible").to(this, "isOpen"), this.keystrokes = new Mt(), this.focusTracker = new gt(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-dropdown", r.to("class"), r.if("isEnabled", "ck-disabled", (s) => !s)], id: r.to("id"), "aria-describedby": r.to("ariaDescribedById") }, children: [e, i] }), e.extendTemplate({ attributes: { class: ["ck-dropdown__button"], "data-cke-tooltip-disabled": r.to("isOpen") } });
  }
  render() {
    super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.listenTo(this.buttonView, "open", () => {
      this.isOpen = !this.isOpen;
    }), this.on("change:isOpen", (e, i, r) => {
      if (r) if (this.panelPosition === "auto") {
        const s = Fo._getOptimalPosition({ element: this.panelView.element, target: this.buttonView.element, fitInViewport: !0, positions: this._panelPositions });
        this.panelView.position = s ? s.name : this._defaultPanelPositionName;
      } else this.panelView.position = this.panelPosition;
    }), this.keystrokes.listenTo(this.element);
    const t = (e, i) => {
      this.isOpen && (this.isOpen = !1, i());
    };
    this.keystrokes.set("arrowdown", (e, i) => {
      this.buttonView.isEnabled && !this.isOpen && (this.isOpen = !0, i());
    }), this.keystrokes.set("arrowright", (e, i) => {
      this.isOpen && i();
    }), this.keystrokes.set("arrowleft", t), this.keystrokes.set("esc", t);
  }
  focus() {
    this.buttonView.focus();
  }
  get _panelPositions() {
    const { south: t, north: e, southEast: i, southWest: r, northEast: s, northWest: a, southMiddleEast: l, southMiddleWest: c, northMiddleEast: d, northMiddleWest: u } = Fo.defaultPanelPositions;
    return this.locale.uiLanguageDirection !== "rtl" ? [i, r, l, c, t, s, a, d, u, e] : [r, i, c, l, t, a, s, u, d, e];
  }
  get _defaultPanelPositionName() {
    return this.locale.uiLanguageDirection === "rtl" ? "sw" : "se";
  }
};
m(Fo, "defaultPanelPositions", { south: (t, e) => ({ top: t.bottom, left: t.left - (e.width - t.width) / 2, name: "s" }), southEast: (t) => ({ top: t.bottom, left: t.left, name: "se" }), southWest: (t, e) => ({ top: t.bottom, left: t.left - e.width + t.width, name: "sw" }), southMiddleEast: (t, e) => ({ top: t.bottom, left: t.left - (e.width - t.width) / 4, name: "sme" }), southMiddleWest: (t, e) => ({ top: t.bottom, left: t.left - 3 * (e.width - t.width) / 4, name: "smw" }), north: (t, e) => ({ top: t.top - e.height, left: t.left - (e.width - t.width) / 2, name: "n" }), northEast: (t, e) => ({ top: t.top - e.height, left: t.left, name: "ne" }), northWest: (t, e) => ({ top: t.top - e.height, left: t.left - e.width + t.width, name: "nw" }), northMiddleEast: (t, e) => ({ top: t.top - e.height, left: t.left - (e.width - t.width) / 4, name: "nme" }), northMiddleWest: (t, e) => ({ top: t.top - e.height, left: t.left - 3 * (e.width - t.width) / 4, name: "nmw" }) }), m(Fo, "_getOptimalPosition", ru);
let ud = Fo;
class Ow extends V {
  constructor(t) {
    super(t);
    m(this, "arrowView");
    this.arrowView = this._createArrowView(), this.extendTemplate({ attributes: { "aria-haspopup": !0, "aria-expanded": this.bindTemplate.to("isOn", (e) => String(e)) } }), this.delegate("execute").to(this, "open");
  }
  render() {
    super.render(), this.children.add(this.arrowView);
  }
  _createArrowView() {
    const t = new cn();
    return t.content = ul, t.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } }), t;
  }
}
class dn extends L {
  constructor(t) {
    super(t);
    m(this, "children");
    const e = this.bindTemplate;
    this.set("isVisible", !0), this.children = this.createCollection(), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__item", e.if("isVisible", "ck-hidden", (i) => !i)], role: "presentation" }, children: this.children });
  }
  focus() {
    this.children.first && this.children.first.focus();
  }
}
class hl extends L {
  constructor(n) {
    super(n), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__separator"] } });
  }
}
class oa extends L {
  constructor(t, e = new Tu()) {
    super(t);
    m(this, "labelView");
    m(this, "items");
    m(this, "children");
    const i = this.bindTemplate, r = new ho(t);
    this.set({ label: "", isVisible: !0 }), this.labelView = e, this.labelView.bind("text").to(this, "label"), this.children = this.createCollection(), this.children.addMany([this.labelView, r]), r.set({ role: "group", ariaLabelledBy: e.id }), r.focusTracker.destroy(), r.keystrokes.destroy(), this.items = r.items, this.setTemplate({ tag: "li", attributes: { role: "presentation", class: ["ck", "ck-list__group", i.if("isVisible", "ck-hidden", (s) => !s)] }, children: this.children });
  }
  focus() {
    if (this.items) {
      const t = this.items.find((e) => !(e instanceof hl));
      t && t.focus();
    }
  }
}
class ho extends L {
  constructor(t) {
    super(t);
    m(this, "focusables");
    m(this, "items");
    m(this, "focusTracker");
    m(this, "keystrokes");
    m(this, "_focusCycler");
    m(this, "_listItemGroupToChangeListeners", /* @__PURE__ */ new WeakMap());
    const e = this.bindTemplate;
    this.focusables = new Te(), this.items = this.createCollection(), this.focusTracker = new gt(), this.keystrokes = new Mt(), this._focusCycler = new le({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "arrowup", focusNext: "arrowdown" } }), this.set("ariaLabel", void 0), this.set("ariaLabelledBy", void 0), this.set("role", void 0), this.setTemplate({ tag: "ul", attributes: { class: ["ck", "ck-reset", "ck-list"], role: e.to("role"), "aria-label": e.to("ariaLabel"), "aria-labelledby": e.to("ariaLabelledBy") }, children: this.items });
  }
  render() {
    super.render();
    for (const t of this.items) t instanceof oa ? this._registerFocusableItemsGroup(t) : t instanceof dn && this._registerFocusableListItem(t);
    this.items.on("change", (t, e) => {
      for (const i of e.removed) i instanceof oa ? this._deregisterFocusableItemsGroup(i) : i instanceof dn && this._deregisterFocusableListItem(i);
      for (const i of Array.from(e.added).reverse()) i instanceof oa ? this._registerFocusableItemsGroup(i, e.index) : this._registerFocusableListItem(i, e.index);
    }), this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  focus() {
    this._focusCycler.focusFirst();
  }
  focusFirst() {
    this._focusCycler.focusFirst();
  }
  focusLast() {
    this._focusCycler.focusLast();
  }
  _registerFocusableListItem(t, e) {
    this.focusTracker.add(t.element), this.focusables.add(t, e);
  }
  _deregisterFocusableListItem(t) {
    this.focusTracker.remove(t.element), this.focusables.remove(t);
  }
  _getOnGroupItemsChangeCallback(t) {
    return (e, i) => {
      for (const r of i.removed) this._deregisterFocusableListItem(r);
      for (const r of Array.from(i.added).reverse()) this._registerFocusableListItem(r, this.items.getIndex(t) + i.index);
    };
  }
  _registerFocusableItemsGroup(t, e) {
    Array.from(t.items).forEach((r, s) => {
      const a = e !== void 0 ? e + s : void 0;
      this._registerFocusableListItem(r, a);
    });
    const i = this._getOnGroupItemsChangeCallback(t);
    this._listItemGroupToChangeListeners.set(t, i), t.items.on("change", i);
  }
  _deregisterFocusableItemsGroup(t) {
    for (const e of t.items) this._deregisterFocusableListItem(e);
    t.items.off("change", this._listItemGroupToChangeListeners.get(t)), this._listItemGroupToChangeListeners.delete(t);
  }
}
const Jm = Li("px"), RE = { top: -99999, left: -99999, name: "arrowless", config: { withArrow: !1 } }, Ue = class Ue extends L {
  constructor(t) {
    super(t);
    m(this, "content");
    m(this, "_pinWhenIsVisibleCallback");
    m(this, "_resizeObserver");
    const e = this.bindTemplate;
    this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", !1), this.set("withArrow", !0), this.set("class", void 0), this._pinWhenIsVisibleCallback = null, this._resizeObserver = null, this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-panel", e.to("position", (i) => `ck-balloon-panel_${i}`), e.if("isVisible", "ck-balloon-panel_visible"), e.if("withArrow", "ck-balloon-panel_with-arrow"), e.to("class")], style: { top: e.to("top", Jm), left: e.to("left", Jm) } }, children: this.content });
  }
  destroy() {
    this.hide(), super.destroy();
  }
  show() {
    this.isVisible = !0;
  }
  hide() {
    this.isVisible = !1;
  }
  attachTo(t) {
    const e = ra(t.target);
    if (e && !ri(e)) return !1;
    this.show();
    const i = Ue.defaultPositions, r = Object.assign({}, { element: this.element, positions: [i.southArrowNorth, i.southArrowNorthMiddleWest, i.southArrowNorthMiddleEast, i.southArrowNorthWest, i.southArrowNorthEast, i.northArrowSouth, i.northArrowSouthMiddleWest, i.northArrowSouthMiddleEast, i.northArrowSouthWest, i.northArrowSouthEast, i.viewportStickyNorth], limiter: N.document.body, fitInViewport: !0 }, t), s = Ue._getOptimalPosition(r) || RE, a = parseInt(s.left), l = parseInt(s.top), c = s.name, d = s.config || {}, { withArrow: u = !0 } = d;
    return this.top = l, this.left = a, this.position = c, this.withArrow = u, !0;
  }
  pin(t) {
    this.unpin(), this._startPinning(t) && (this._pinWhenIsVisibleCallback = () => {
      this.isVisible ? this._startPinning(t) : this._stopPinning();
    }, this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback));
  }
  unpin() {
    this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide());
  }
  _startPinning(t) {
    if (!this.attachTo(t)) return !1;
    let e = ra(t.target);
    const i = t.limiter ? ra(t.limiter) : N.document.body;
    if (this.listenTo(N.document, "scroll", (r, s) => {
      const a = s.target, l = e && a.contains(e), c = i && a.contains(i);
      !l && !c && e && i || this.attachTo(t);
    }, { useCapture: !0 }), this.listenTo(N.window, "resize", () => {
      this.attachTo(t);
    }), !this._resizeObserver && (e && qt(e) && (e = e.parentElement), e)) {
      const r = () => {
        ri(e) || this.unpin();
      };
      this._resizeObserver = new to(e, r);
    }
    return !0;
  }
  _stopPinning() {
    this.stopListening(N.document, "scroll"), this.stopListening(N.window, "resize"), this._resizeObserver && (this._resizeObserver.destroy(), this._resizeObserver = null);
  }
  static generatePositions(t = {}) {
    const { sideOffset: e = Ue.arrowSideOffset, heightOffset: i = Ue.arrowHeightOffset, stickyVerticalOffset: r = Ue.stickyVerticalOffset, config: s } = t;
    return { northWestArrowSouthWest: (c, d) => ({ top: a(c, d), left: c.left - e, name: "arrow_sw", ...s && { config: s } }), northWestArrowSouthMiddleWest: (c, d) => ({ top: a(c, d), left: c.left - 0.25 * d.width - e, name: "arrow_smw", ...s && { config: s } }), northWestArrowSouth: (c, d) => ({ top: a(c, d), left: c.left - d.width / 2, name: "arrow_s", ...s && { config: s } }), northWestArrowSouthMiddleEast: (c, d) => ({ top: a(c, d), left: c.left - 0.75 * d.width + e, name: "arrow_sme", ...s && { config: s } }), northWestArrowSouthEast: (c, d) => ({ top: a(c, d), left: c.left - d.width + e, name: "arrow_se", ...s && { config: s } }), northArrowSouthWest: (c, d) => ({ top: a(c, d), left: c.left + c.width / 2 - e, name: "arrow_sw", ...s && { config: s } }), northArrowSouthMiddleWest: (c, d) => ({ top: a(c, d), left: c.left + c.width / 2 - 0.25 * d.width - e, name: "arrow_smw", ...s && { config: s } }), northArrowSouth: (c, d) => ({ top: a(c, d), left: c.left + c.width / 2 - d.width / 2, name: "arrow_s", ...s && { config: s } }), northArrowSouthMiddleEast: (c, d) => ({ top: a(c, d), left: c.left + c.width / 2 - 0.75 * d.width + e, name: "arrow_sme", ...s && { config: s } }), northArrowSouthEast: (c, d) => ({ top: a(c, d), left: c.left + c.width / 2 - d.width + e, name: "arrow_se", ...s && { config: s } }), northEastArrowSouthWest: (c, d) => ({ top: a(c, d), left: c.right - e, name: "arrow_sw", ...s && { config: s } }), northEastArrowSouthMiddleWest: (c, d) => ({ top: a(c, d), left: c.right - 0.25 * d.width - e, name: "arrow_smw", ...s && { config: s } }), northEastArrowSouth: (c, d) => ({ top: a(c, d), left: c.right - d.width / 2, name: "arrow_s", ...s && { config: s } }), northEastArrowSouthMiddleEast: (c, d) => ({ top: a(c, d), left: c.right - 0.75 * d.width + e, name: "arrow_sme", ...s && { config: s } }), northEastArrowSouthEast: (c, d) => ({ top: a(c, d), left: c.right - d.width + e, name: "arrow_se", ...s && { config: s } }), southWestArrowNorthWest: (c) => ({ top: l(c), left: c.left - e, name: "arrow_nw", ...s && { config: s } }), southWestArrowNorthMiddleWest: (c, d) => ({ top: l(c), left: c.left - 0.25 * d.width - e, name: "arrow_nmw", ...s && { config: s } }), southWestArrowNorth: (c, d) => ({ top: l(c), left: c.left - d.width / 2, name: "arrow_n", ...s && { config: s } }), southWestArrowNorthMiddleEast: (c, d) => ({ top: l(c), left: c.left - 0.75 * d.width + e, name: "arrow_nme", ...s && { config: s } }), southWestArrowNorthEast: (c, d) => ({ top: l(c), left: c.left - d.width + e, name: "arrow_ne", ...s && { config: s } }), southArrowNorthWest: (c) => ({ top: l(c), left: c.left + c.width / 2 - e, name: "arrow_nw", ...s && { config: s } }), southArrowNorthMiddleWest: (c, d) => ({ top: l(c), left: c.left + c.width / 2 - 0.25 * d.width - e, name: "arrow_nmw", ...s && { config: s } }), southArrowNorth: (c, d) => ({ top: l(c), left: c.left + c.width / 2 - d.width / 2, name: "arrow_n", ...s && { config: s } }), southArrowNorthMiddleEast: (c, d) => ({ top: l(c), left: c.left + c.width / 2 - 0.75 * d.width + e, name: "arrow_nme", ...s && { config: s } }), southArrowNorthEast: (c, d) => ({ top: l(c), left: c.left + c.width / 2 - d.width + e, name: "arrow_ne", ...s && { config: s } }), southEastArrowNorthWest: (c) => ({ top: l(c), left: c.right - e, name: "arrow_nw", ...s && { config: s } }), southEastArrowNorthMiddleWest: (c, d) => ({ top: l(c), left: c.right - 0.25 * d.width - e, name: "arrow_nmw", ...s && { config: s } }), southEastArrowNorth: (c, d) => ({ top: l(c), left: c.right - d.width / 2, name: "arrow_n", ...s && { config: s } }), southEastArrowNorthMiddleEast: (c, d) => ({ top: l(c), left: c.right - 0.75 * d.width + e, name: "arrow_nme", ...s && { config: s } }), southEastArrowNorthEast: (c, d) => ({ top: l(c), left: c.right - d.width + e, name: "arrow_ne", ...s && { config: s } }), westArrowEast: (c, d) => ({ top: c.top + c.height / 2 - d.height / 2, left: c.left - d.width - i, name: "arrow_e", ...s && { config: s } }), eastArrowWest: (c, d) => ({ top: c.top + c.height / 2 - d.height / 2, left: c.right + i, name: "arrow_w", ...s && { config: s } }), viewportStickyNorth: (c, d, u, h) => {
      const g = h || u;
      return c.getIntersection(g) ? g.height - c.height > r ? null : { top: g.top + r, left: c.left + c.width / 2 - d.width / 2, name: "arrowless", config: { withArrow: !1, ...s } } : null;
    } };
    function a(c, d) {
      return c.top - d.height - i;
    }
    function l(c) {
      return c.bottom + i;
    }
  }
};
m(Ue, "arrowSideOffset", 25), m(Ue, "arrowHeightOffset", 10), m(Ue, "stickyVerticalOffset", 20), m(Ue, "_getOptimalPosition", ru), m(Ue, "defaultPositions", Ue.generatePositions());
let se = Ue;
function ra(o) {
  return Si(o) ? o : ol(o) ? o.commonAncestorContainer : typeof o == "function" ? ra(o()) : null;
}
class Su extends L {
  constructor(n) {
    super(n), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__separator"] } });
  }
}
class VE extends L {
  constructor(n) {
    super(n), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__line-break"] } });
  }
}
function Iu(o) {
  if (Array.isArray(o)) return { items: o, removeItems: [] };
  const n = { items: [], removeItems: [] };
  return o ? { ...n, ...o } : n;
}
const hd = { alignLeft: kw, bold: ww, importExport: T2, paragraph: K2, plus: J2, text: mE, threeVerticalDots: Eu, pilcrow: Q2, dragIndicator: w2 };
class Cs extends L {
  constructor(t, e) {
    super(t);
    m(this, "options");
    m(this, "items");
    m(this, "focusTracker");
    m(this, "keystrokes");
    m(this, "itemsView");
    m(this, "children");
    m(this, "focusables");
    m(this, "_focusCycler");
    m(this, "_behavior");
    const i = this.bindTemplate, r = this.t;
    this.options = e || {}, this.set("ariaLabel", r("Editor toolbar")), this.set("maxWidth", "auto"), this.set("role", "toolbar"), this.set("isGrouping", !!this.options.shouldGroupWhenFull), this.items = this.createCollection(), this.focusTracker = new gt(), this.keystrokes = new Mt(), this.set("class", void 0), this.set("isCompact", !1), this.set("isVertical", !1), this.itemsView = new FE(t), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection();
    const s = t.uiLanguageDirection === "rtl";
    this._focusCycler = new le({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: [s ? "arrowright" : "arrowleft", "arrowup"], focusNext: [s ? "arrowleft" : "arrowright", "arrowdown"] } });
    const a = ["ck", "ck-toolbar", i.to("class"), i.if("isCompact", "ck-toolbar_compact"), i.if("isGrouping", "ck-toolbar_grouping"), i.if("isVertical", "ck-toolbar_vertical")];
    var l;
    this.options.shouldGroupWhenFull && this.options.isFloating && a.push("ck-toolbar_floating"), this.setTemplate({ tag: "div", attributes: { class: a, role: i.to("role"), "aria-label": i.to("ariaLabel"), style: { maxWidth: i.to("maxWidth") }, tabindex: -1 }, children: this.children, on: { mousedown: (l = this, l.bindTemplate.to((c) => {
      c.target === l.element && c.preventDefault();
    })) } }), this._behavior = this.options.shouldGroupWhenFull ? new tg(this) : new Xm(this);
  }
  render() {
    super.render(), this.focusTracker.add(this.element);
    for (const t of this.items) this.focusTracker.add(t);
    this.items.on("add", (t, e) => {
      this.focusTracker.add(e);
    }), this.items.on("remove", (t, e) => {
      this.focusTracker.remove(e);
    }), this.keystrokes.listenTo(this.element), this._behavior.render(this);
  }
  destroy() {
    return this._behavior.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy(), super.destroy();
  }
  focus() {
    this._focusCycler.focusFirst();
  }
  focusLast() {
    this._focusCycler.focusLast();
  }
  fillFromConfig(t, e, i) {
    this.items.addMany(this._buildItemsFromConfig(t, e, i));
  }
  switchBehavior(t) {
    this._behavior.type !== t && (this._behavior.destroy(), this.itemsView.children.clear(), this.focusables.clear(), t === "dynamic" ? (this._behavior = new tg(this), this._behavior.render(this), this._behavior.refreshItems()) : (this._behavior = new Xm(this), this._behavior.render(this)));
  }
  _buildItemsFromConfig(t, e, i) {
    const r = Iu(t), s = i || r.removeItems;
    return this._cleanItemsConfiguration(r.items, e, s).map((a) => bn(a) ? this._createNestedToolbarDropdown(a, e, s) : a === "|" ? new Su() : a === "-" ? new VE() : e.create(a)).filter((a) => !!a);
  }
  _cleanItemsConfiguration(t, e, i) {
    const r = t.filter((s, a, l) => s === "|" || i.indexOf(s) === -1 && (s === "-" ? !this.options.shouldGroupWhenFull || (at("toolbarview-line-break-ignored-when-grouping-items", l), !1) : !(!bn(s) && !e.has(s)) || (at("toolbarview-item-unavailable", { item: s }), !1)));
    return this._cleanSeparatorsAndLineBreaks(r);
  }
  _cleanSeparatorsAndLineBreaks(t) {
    const e = (a) => a !== "-" && a !== "|", i = t.length, r = t.findIndex(e);
    if (r === -1) return [];
    const s = i - t.slice().reverse().findIndex(e);
    return t.slice(r, s).filter((a, l, c) => e(a) ? !0 : !(l > 0 && c[l - 1] === a));
  }
  _createNestedToolbarDropdown(t, e, i) {
    let { label: r, icon: s, items: a, tooltip: l = !0, withText: c = !1 } = t;
    if (a = this._cleanItemsConfiguration(a, e, i), !a.length) return null;
    const d = ge(this.locale);
    return r || at("toolbarview-nested-toolbar-dropdown-missing-label", t), d.class = "ck-toolbar__nested-toolbar-dropdown", d.buttonView.set({ label: r, tooltip: l, withText: !!c }), s !== !1 ? d.buttonView.icon = hd[s] || s || Eu : d.buttonView.withText = !0, As(d, () => d.toolbarView._buildItemsFromConfig(a, e, i)), d;
  }
}
class FE extends L {
  constructor(t) {
    super(t);
    m(this, "children");
    this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-toolbar__items"] }, children: this.children });
  }
}
class Xm {
  constructor(n) {
    m(this, "type", "static");
    n.isGrouping = !1, n.itemsView.children.bindTo(n.items).using((t) => t), n.focusables.bindTo(n.items).using((t) => lr(t) ? t : null);
  }
  render() {
  }
  destroy() {
  }
}
class tg {
  constructor(n) {
    m(this, "type", "dynamic");
    m(this, "view");
    m(this, "viewChildren");
    m(this, "viewFocusables");
    m(this, "viewItemsView");
    m(this, "viewFocusTracker");
    m(this, "viewLocale");
    m(this, "ungroupedItems");
    m(this, "groupedItems");
    m(this, "groupedItemsDropdown");
    m(this, "resizeObserver", null);
    m(this, "cachedPadding", null);
    m(this, "shouldUpdateGroupingOnNextResize", !1);
    m(this, "viewElement");
    this.view = n, this.viewChildren = n.children, this.viewFocusables = n.focusables, this.viewItemsView = n.itemsView, this.viewFocusTracker = n.focusTracker, this.viewLocale = n.locale, this.view.isGrouping = !0, this.ungroupedItems = n.createCollection(), this.groupedItems = n.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), n.itemsView.children.bindTo(this.ungroupedItems).using((t) => t), this.ungroupedItems.on("change", this._updateFocusCyclableItems.bind(this)), n.children.on("change", this._updateFocusCyclableItems.bind(this)), n.items.on("change", (t, e) => {
      const i = e.index, r = Array.from(e.added);
      for (const s of e.removed) i >= this.ungroupedItems.length ? this.groupedItems.remove(s) : this.ungroupedItems.remove(s);
      for (let s = i; s < i + r.length; s++) {
        const a = r[s - i];
        s > this.ungroupedItems.length ? this.groupedItems.add(a, s - this.ungroupedItems.length) : this.ungroupedItems.add(a, s);
      }
      this._updateGrouping();
    });
  }
  render(n) {
    this.viewElement = n.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(n);
  }
  destroy() {
    this.groupedItemsDropdown.destroy(), this.viewChildren.length > 1 && (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last)), this.resizeObserver.destroy();
  }
  refreshItems() {
    const n = this.view;
    if (n.items.length) {
      for (let t = 0; t < n.items.length; t++) {
        const e = [...n.items][t];
        this.ungroupedItems.add(e, t);
      }
      this._updateGrouping();
    }
  }
  _updateGrouping() {
    if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) return;
    if (!ri(this.viewElement)) return void (this.shouldUpdateGroupingOnNextResize = !0);
    const n = this.groupedItems.length;
    let t;
    for (; this._areItemsOverflowing; ) this._groupLastItem(), t = !0;
    if (!t && this.groupedItems.length) {
      for (; this.groupedItems.length && !this._areItemsOverflowing; ) this._ungroupFirstItem();
      this._areItemsOverflowing && this._groupLastItem();
    }
    this.groupedItems.length !== n && this.view.fire("groupedItemsUpdate");
  }
  get _areItemsOverflowing() {
    if (!this.ungroupedItems.length) return !1;
    const n = this.viewElement, t = this.viewLocale.uiLanguageDirection, e = new K(n.lastChild), i = new K(n);
    if (!this.cachedPadding) {
      const r = N.window.getComputedStyle(n), s = t === "ltr" ? "paddingRight" : "paddingLeft";
      this.cachedPadding = Number.parseInt(r[s]);
    }
    return t === "ltr" ? e.right > i.right - this.cachedPadding : e.left < i.left + this.cachedPadding;
  }
  _enableGroupingOnResize() {
    let n;
    this.resizeObserver = new to(this.viewElement, (t) => {
      n && n === t.contentRect.width && !this.shouldUpdateGroupingOnNextResize || (this.shouldUpdateGroupingOnNextResize = !1, this._updateGrouping(), n = t.contentRect.width);
    }), this._updateGrouping();
  }
  _enableGroupingOnMaxWidthChange(n) {
    n.on("change:maxWidth", () => {
      this._updateGrouping();
    });
  }
  _groupLastItem() {
    this.groupedItems.length || (this.viewChildren.add(new Su()), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
  }
  _ungroupFirstItem() {
    this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element));
  }
  _createGroupedItemsDropdown() {
    const n = this.viewLocale, t = n.t, e = ge(n);
    return e.class = "ck-toolbar__grouped-dropdown", e.panelPosition = n.uiLanguageDirection === "ltr" ? "sw" : "se", As(e, this.groupedItems), e.buttonView.set({ label: t("Show more items"), tooltip: !0, tooltipPosition: n.uiLanguageDirection === "rtl" ? "se" : "sw", icon: Eu }), e;
  }
  _updateFocusCyclableItems() {
    this.viewFocusables.clear(), this.ungroupedItems.map((n) => {
      lr(n) && this.viewFocusables.add(n);
    }), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown);
  }
}
class mo extends L {
  constructor(t, e) {
    super(t);
    m(this, "children");
    m(this, "actionView");
    m(this, "arrowView");
    m(this, "keystrokes");
    m(this, "focusTracker");
    const i = this.bindTemplate;
    this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isToggleable", !1), this.set("isVisible", !0), this.set("keystroke", void 0), this.set("withKeystroke", !1), this.set("label", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.children = this.createCollection(), this.actionView = this._createActionView(e), this.arrowView = this._createArrowView(), this.keystrokes = new Mt(), this.focusTracker = new gt(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-splitbutton", i.to("class"), i.if("isVisible", "ck-hidden", (r) => !r), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")] }, children: this.children });
  }
  render() {
    super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", (t, e) => {
      this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), e());
    }), this.keystrokes.set("arrowleft", (t, e) => {
      this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), e());
    });
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  focus() {
    this.actionView.focus();
  }
  _createActionView(t) {
    const e = t || new V();
    return t || e.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), e.extendTemplate({ attributes: { class: "ck-splitbutton__action" } }), e.delegate("execute").to(this), e;
  }
  _createArrowView() {
    const t = new V(), e = t.bindTemplate;
    return t.icon = ul, t.extendTemplate({ attributes: { class: ["ck-splitbutton__arrow"], "data-cke-tooltip-disabled": e.to("isOn"), "aria-haspopup": !0, "aria-expanded": e.to("isOn", (i) => String(i)) } }), t.bind("isEnabled").to(this), t.bind("label").to(this), t.bind("tooltip").to(this), t.delegate("execute").to(this, "open"), t;
  }
}
function ge(o, n = Ow) {
  const t = typeof n == "function" ? new n(o) : n, e = new OE(o), i = new ud(o, t, e);
  return t.bind("isEnabled").to(i), t instanceof mo ? t.arrowView.bind("isOn").to(i, "isOpen") : t.bind("isOn").to(i, "isOpen"), function(r) {
    (function(s) {
      Ni({ emitter: s, activator: () => s.isRendered && s.isOpen, callback: () => {
        s.isOpen = !1;
      }, contextElements: () => [s.element, ...Rw(s.focusTracker).filter((a) => !s.element.contains(a))] });
    })(r), function(s) {
      s.on("execute", (a) => {
        a.source instanceof ys || (s.isOpen = !1);
      });
    }(r), function(s) {
      s.focusTracker.on("change:isFocused", (a, l, c) => {
        !c && s.isOpen && (s.isOpen = !1);
      });
    }(r), function(s) {
      s.keystrokes.set("arrowdown", (a, l) => {
        s.isOpen && (s.panelView.focus(), l());
      }), s.keystrokes.set("arrowup", (a, l) => {
        s.isOpen && (s.panelView.focusLast(), l());
      });
    }(r), function(s) {
      s.on("change:isOpen", (a, l, c) => {
        c || s.focusTracker.elements.some((d) => d.contains(N.document.activeElement)) && s.buttonView.focus();
      });
    }(r), function(s) {
      s.on("change:isOpen", (a, l, c) => {
        c && s.panelView.focus();
      }, { priority: "low" });
    }(r);
  }(i), i;
}
function As(o, n, t = {}) {
  o.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } }), o.isOpen ? eg(o, n, t) : o.once("change:isOpen", () => eg(o, n, t), { priority: "highest" }), t.enableActiveItemFocusOnDropdownOpen && ml(o, () => o.toolbarView.items.find((e) => e.isOn));
}
function eg(o, n, t) {
  const e = o.locale, i = e.t, r = o.toolbarView = new Cs(e), s = typeof n == "function" ? n() : n;
  r.ariaLabel = t.ariaLabel || i("Dropdown toolbar"), t.maxWidth && (r.maxWidth = t.maxWidth), t.class && (r.class = t.class), t.isCompact && (r.isCompact = t.isCompact), t.isVertical && (r.isVertical = !0), s instanceof Te ? r.items.bindTo(s).using((a) => a) : r.items.addMany(s), o.panelView.children.add(r), o.focusTracker.add(r), r.items.delegate("execute").to(o);
}
function zi(o, n, t = {}) {
  o.isOpen ? ng(o, n, t) : o.once("change:isOpen", () => ng(o, n, t), { priority: "highest" }), ml(o, () => o.listView.items.find((e) => e instanceof dn && e.children.first.isOn));
}
function ng(o, n, t) {
  const e = o.locale, i = o.listView = new ho(e), r = typeof n == "function" ? n() : n;
  i.ariaLabel = t.ariaLabel, i.role = t.role, Vw(o, i.items, r, e), o.panelView.children.add(i), i.items.delegate("execute").to(o);
}
function ml(o, n) {
  o.on("change:isOpen", () => {
    if (!o.isOpen) return;
    const t = n();
    t && (typeof t.focus == "function" ? t.focus() : at("ui-dropdown-focus-child-on-open-child-missing-focus", { view: t }));
  }, { priority: Ci.low - 10 });
}
function Rw(o) {
  return [...o.elements, ...o.externalViews.flatMap((n) => Rw(n.focusTracker))];
}
function Vw(o, n, t, e) {
  n.on("change", () => {
    const i = [...n].reduce((s, a) => (a instanceof dn && a.children.first instanceof er && s.push(a.children.first), s), []), r = i.some((s) => s.isToggleable);
    i.forEach((s) => {
      s.hasCheckSpace = r;
    });
  }), n.bindTo(t).using((i) => {
    if (i.type === "separator") return new hl(e);
    if (i.type === "group") {
      const r = new oa(e);
      return r.set({ label: i.label }), Vw(o, r.items, i.items, e), r.items.delegate("execute").to(o), r;
    }
    if (i.type === "button" || i.type === "switchbutton") {
      const r = i.model.role === "menuitemcheckbox" || i.model.role === "menuitemradio", s = new dn(e);
      let a;
      return i.type === "button" ? (a = new er(e), a.set({ isToggleable: r })) : a = new ys(e), a.bind(...Object.keys(i.model)).to(i.model), a.delegate("execute").to(s), s.children.add(a), s;
    }
    return null;
  });
}
const Mi = (o, n, t) => {
  const e = new NE(o.locale);
  return e.set({ id: n, ariaDescribedById: t }), e.bind("isReadOnly").to(o, "isEnabled", (i) => !i), e.bind("hasError").to(o, "errorText", (i) => !!i), e.on("input", () => {
    o.errorText = null;
  }), o.bind("isEmpty", "isFocused", "placeholder").to(e), e;
}, Fw = (o, n, t) => {
  const e = new zE(o.locale);
  return e.set({ id: n, ariaDescribedById: t, inputMode: "numeric" }), e.bind("isReadOnly").to(o, "isEnabled", (i) => !i), e.bind("hasError").to(o, "errorText", (i) => !!i), e.on("input", () => {
    o.errorText = null;
  }), o.bind("isEmpty", "isFocused", "placeholder").to(e), e;
}, jE = (o, n, t) => {
  const e = ge(o.locale);
  return e.set({ id: n, ariaDescribedById: t }), e.bind("isEnabled").to(o), e;
}, ss = (o, n = 0, t = 1) => o > t ? t : o < n ? n : o, pe = (o, n = 0, t = Math.pow(10, n)) => Math.round(t * o) / t, ql = (o) => (o[0] === "#" && (o = o.substring(1)), o.length < 6 ? { r: parseInt(o[0] + o[0], 16), g: parseInt(o[1] + o[1], 16), b: parseInt(o[2] + o[2], 16), a: o.length === 4 ? pe(parseInt(o[3] + o[3], 16) / 255, 2) : 1 } : { r: parseInt(o.substring(0, 2), 16), g: parseInt(o.substring(2, 4), 16), b: parseInt(o.substring(4, 6), 16), a: o.length === 8 ? pe(parseInt(o.substring(6, 8), 16) / 255, 2) : 1 }), md = (o) => {
  const { h: n, s: t, l: e } = (({ h: i, s: r, v: s, a }) => {
    const l = (200 - r) * s / 100;
    return { h: pe(i), s: pe(l > 0 && l < 200 ? r * s / 100 / (l <= 100 ? l : 200 - l) * 100 : 0), l: pe(l / 2), a: pe(a, 2) };
  })(o);
  return `hsl(${n}, ${t}%, ${e}%)`;
}, HE = ({ h: o, s: n, v: t, a: e }) => {
  o = o / 360 * 6, n /= 100, t /= 100;
  const i = Math.floor(o), r = t * (1 - n), s = t * (1 - (o - i) * n), a = t * (1 - (1 - o + i) * n), l = i % 6;
  return { r: pe(255 * [t, s, r, r, a, t][l]), g: pe(255 * [a, t, t, s, r, r][l]), b: pe(255 * [r, r, a, t, t, s][l]), a: pe(e, 2) };
}, Ns = (o) => {
  const n = o.toString(16);
  return n.length < 2 ? "0" + n : n;
}, UE = ({ r: o, g: n, b: t, a: e }) => {
  const i = e < 1 ? Ns(pe(255 * e)) : "";
  return "#" + Ns(o) + Ns(n) + Ns(t) + i;
}, $E = ({ r: o, g: n, b: t, a: e }) => {
  const i = Math.max(o, n, t), r = i - Math.min(o, n, t), s = r ? i === o ? (n - t) / r : i === n ? 2 + (t - o) / r : 4 + (o - n) / r : 0;
  return { h: pe(60 * (s < 0 ? s + 6 : s)), s: pe(i ? r / i * 100 : 0), v: pe(i / 255 * 100), a: e };
}, jw = (o, n) => {
  if (o === n) return !0;
  for (const t in o) if (o[t] !== n[t]) return !1;
  return !0;
}, ig = {}, Hw = (o) => {
  let n = ig[o];
  return n || (n = document.createElement("template"), n.innerHTML = o, ig[o] = n), n;
}, Mu = (o, n, t) => {
  o.dispatchEvent(new CustomEvent(n, { bubbles: !0, detail: t }));
};
let Co = !1;
const gd = (o) => "touches" in o, og = (o, n) => {
  const t = gd(n) ? n.touches[0] : n, e = o.el.getBoundingClientRect();
  Mu(o.el, "move", o.getMove({ x: ss((t.pageX - (e.left + window.pageXOffset)) / e.width), y: ss((t.pageY - (e.top + window.pageYOffset)) / e.height) }));
};
class Uw {
  constructor(n, t, e, i) {
    const r = Hw(`<div role="slider" tabindex="0" part="${t}" ${e}><div part="${t}-pointer"></div></div>`);
    n.appendChild(r.content.cloneNode(!0));
    const s = n.querySelector(`[part=${t}]`);
    s.addEventListener("mousedown", this), s.addEventListener("touchstart", this), s.addEventListener("keydown", this), this.el = s, this.xy = i, this.nodes = [s.firstChild, s];
  }
  set dragging(n) {
    const t = n ? document.addEventListener : document.removeEventListener;
    t(Co ? "touchmove" : "mousemove", this), t(Co ? "touchend" : "mouseup", this);
  }
  handleEvent(n) {
    switch (n.type) {
      case "mousedown":
      case "touchstart":
        if (n.preventDefault(), !((t) => !(Co && !gd(t) || (Co || (Co = gd(t)), 0)))(n) || !Co && n.button != 0) return;
        this.el.focus(), og(this, n), this.dragging = !0;
        break;
      case "mousemove":
      case "touchmove":
        n.preventDefault(), og(this, n);
        break;
      case "mouseup":
      case "touchend":
        this.dragging = !1;
        break;
      case "keydown":
        ((t, e) => {
          const i = e.keyCode;
          i > 40 || t.xy && i < 37 || i < 33 || (e.preventDefault(), Mu(t.el, "move", t.getMove({ x: i === 39 ? 0.01 : i === 37 ? -0.01 : i === 34 ? 0.05 : i === 33 ? -0.05 : i === 35 ? 1 : i === 36 ? -1 : 0, y: i === 40 ? 0.01 : i === 38 ? -0.01 : 0 }, !0)));
        })(this, n);
    }
  }
  style(n) {
    n.forEach((t, e) => {
      for (const i in t) this.nodes[e].style.setProperty(i, t[i]);
    });
  }
}
class qE extends Uw {
  constructor(n) {
    super(n, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', !1);
  }
  update({ h: n }) {
    this.h = n, this.style([{ left: n / 360 * 100 + "%", color: md({ h: n, s: 100, v: 100, a: 1 }) }]), this.el.setAttribute("aria-valuenow", `${pe(n)}`);
  }
  getMove(n, t) {
    return { h: t ? ss(this.h + 360 * n.x, 0, 360) : 360 * n.x };
  }
}
class WE extends Uw {
  constructor(n) {
    super(n, "saturation", 'aria-label="Color"', !0);
  }
  update(n) {
    this.hsva = n, this.style([{ top: 100 - n.v + "%", left: `${n.s}%`, color: md(n) }, { "background-color": md({ h: n.h, s: 100, v: 100, a: 1 }) }]), this.el.setAttribute("aria-valuetext", `Saturation ${pe(n.s)}%, Brightness ${pe(n.v)}%`);
  }
  getMove(n, t) {
    return { s: t ? ss(this.hsva.s + 100 * n.x, 0, 100) : 100 * n.x, v: t ? ss(this.hsva.v - 100 * n.y, 0, 100) : Math.round(100 - 100 * n.y) };
  }
}
const zs = Symbol("same"), Wl = Symbol("color"), rg = Symbol("hsva"), Gl = Symbol("update"), sg = Symbol("parts"), ag = Symbol("css"), lg = Symbol("sliders");
class GE extends HTMLElement {
  static get observedAttributes() {
    return ["color"];
  }
  get [ag]() {
    return [':host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}', "[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}", "[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}"];
  }
  get [lg]() {
    return [WE, qE];
  }
  get color() {
    return this[Wl];
  }
  set color(n) {
    if (!this[zs](n)) {
      const t = this.colorModel.toHsva(n);
      this[Gl](t), this[Wl] = n;
    }
  }
  constructor() {
    super();
    const n = Hw(`<style>${this[ag].join("")}</style>`), t = this.attachShadow({ mode: "open" });
    t.appendChild(n.content.cloneNode(!0)), t.addEventListener("move", this), this[sg] = this[lg].map((e) => new e(t));
  }
  connectedCallback() {
    if (this.hasOwnProperty("color")) {
      const n = this.color;
      delete this.color, this.color = n;
    } else this.color || (this.color = this.colorModel.defaultColor);
  }
  attributeChangedCallback(n, t, e) {
    const i = this.colorModel.fromAttr(e);
    this[zs](i) || (this.color = i);
  }
  handleEvent(n) {
    const t = this[rg], e = { ...t, ...n.detail };
    let i;
    this[Gl](e), jw(e, t) || this[zs](i = this.colorModel.fromHsva(e)) || (this[Wl] = i, Mu(this, "color-changed", { value: i }));
  }
  [zs](n) {
    return this.color && this.colorModel.equal(n, this.color);
  }
  [Gl](n) {
    this[rg] = n, this[sg].forEach((t) => t.update(n));
  }
}
const KE = { defaultColor: "#000", toHsva: (o) => $E(ql(o)), fromHsva: ({ h: o, s: n, v: t }) => UE(HE({ h: o, s: n, v: t, a: 1 })), equal: (o, n) => o.toLowerCase() === n.toLowerCase() || jw(ql(o), ql(n)), fromAttr: (o) => o };
class YE extends GE {
  get colorModel() {
    return KE;
  }
}
class ZE extends L {
  constructor(t, e = {}) {
    super(t);
    m(this, "hexInputRow");
    m(this, "_debounceColorPickerEvent");
    m(this, "_config");
    this.set({ color: "", _hexColor: "" }), this.hexInputRow = this._createInputRow();
    const i = this.createCollection();
    e.hideInput || i.add(this.hexInputRow), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-color-picker"], tabindex: -1 }, children: i }), this._config = e, this._debounceColorPickerEvent = kn((r) => {
      this.set("color", r), this.fire("colorSelected", { color: this.color });
    }, 150, { leading: !0 }), this.on("set:color", (r, s, a) => {
      r.return = Bw(a, this._config.format || "hsl");
    }), this.on("change:color", () => {
      this._hexColor = Kl(this.color);
    }), this.on("change:_hexColor", () => {
      document.activeElement !== this.picker && this.picker.setAttribute("color", this._hexColor), Kl(this.color) != Kl(this._hexColor) && (this.color = this._hexColor);
    });
  }
  render() {
    var t, e;
    if (super.render(), t = "hex-color-picker", e = YE, customElements.get(t) === void 0 && customElements.define(t, e), this.picker = N.document.createElement("hex-color-picker"), this.picker.setAttribute("class", "hex-color-picker"), this.picker.setAttribute("tabindex", "-1"), this._createSlidersView(), this.element) {
      this.hexInputRow.element ? this.element.insertBefore(this.picker, this.hexInputRow.element) : this.element.appendChild(this.picker);
      const i = document.createElement("style");
      i.textContent = '[role="slider"]:focus [part$="pointer"] {border: 1px solid #fff;outline: 1px solid var(--ck-color-focus-border);box-shadow: 0 0 0 2px #fff;}', this.picker.shadowRoot.appendChild(i);
    }
    this.picker.addEventListener("color-changed", (i) => {
      const r = i.detail.value;
      this._debounceColorPickerEvent(r);
    });
  }
  focus() {
    !this._config.hideInput && (H.isGecko || H.isiOS || H.isSafari || H.isBlink) && this.hexInputRow.children.get(1).focus(), this.slidersView.first.focus();
  }
  _createSlidersView() {
    const t = [...this.picker.shadowRoot.children].filter((e) => e.getAttribute("role") === "slider").map((e) => new QE(e));
    this.slidersView = this.createCollection(), t.forEach((e) => {
      this.slidersView.add(e);
    });
  }
  _createInputRow() {
    const t = this._createColorInput();
    return new XE(this.locale, t);
  }
  _createColorInput() {
    const t = new Nn(this.locale, Mi), { t: e } = this.locale;
    return t.set({ label: e("HEX"), class: "color-picker-hex-input" }), t.fieldView.bind("value").to(this, "_hexColor", (i) => t.isFocused ? t.fieldView.value : i.startsWith("#") ? i.substring(1) : i), t.fieldView.on("input", () => {
      const i = t.fieldView.element.value;
      if (i) {
        const r = $w(i);
        r && this._debounceColorPickerEvent(r);
      }
    }), t;
  }
  isValid() {
    const { t } = this.locale;
    return !!this._config.hideInput || (this.resetValidationStatus(), !!this.hexInputRow.getParsedColor() || (this.hexInputRow.inputView.errorText = t('Please enter a valid color (e.g. "ff0000").'), !1));
  }
  resetValidationStatus() {
    this.hexInputRow.inputView.errorText = null;
  }
}
function Kl(o) {
  let n = function(t) {
    if (!t) return "";
    const e = Nw(t);
    return e ? e.space === "hex" ? e.hexValue : Bw(t, "hex") : "#000";
  }(o);
  return n || (n = "#000"), n.length === 4 && (n = "#" + [n[1], n[1], n[2], n[2], n[3], n[3]].join("")), n.toLowerCase();
}
class QE extends L {
  constructor(n) {
    super(), this.element = n;
  }
  focus() {
    this.element.focus();
  }
}
class JE extends L {
  constructor(n) {
    super(n), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-color-picker__hash-view"] }, children: "#" });
  }
}
class XE extends L {
  constructor(t, e) {
    super(t);
    m(this, "children");
    m(this, "inputView");
    this.inputView = e, this.children = this.createCollection([new JE(), this.inputView]), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-color-picker__row"] }, children: this.children });
  }
  getParsedColor() {
    return $w(this.inputView.fieldView.element.value);
  }
}
function $w(o) {
  if (!o) return null;
  const n = o.trim().replace(/^#/, "");
  return [3, 4, 6, 8].includes(n.length) && /^(([0-9a-fA-F]{2}){3,4}|([0-9a-fA-F]){3,4})$/.test(n) ? `#${n}` : null;
}
class t5 extends _t(ne) {
  constructor(n) {
    super(n), this.set("isEmpty", !0), this.on("change", () => {
      this.set("isEmpty", this.length === 0);
    });
  }
  add(n, t) {
    return this.find((e) => e.color === n.color) ? this : super.add(n, t);
  }
  hasColor(n) {
    return !!this.find((t) => t.color === n);
  }
}
class e5 extends L {
  constructor(t, { colors: e, columns: i, removeButtonLabel: r, documentColorsLabel: s, documentColorsCount: a, colorPickerLabel: l, focusTracker: c, focusables: d }) {
    super(t);
    m(this, "items");
    m(this, "colorDefinitions");
    m(this, "focusTracker");
    m(this, "columns");
    m(this, "documentColors");
    m(this, "documentColorsCount");
    m(this, "staticColorsGrid");
    m(this, "documentColorsGrid");
    m(this, "colorPickerButtonView");
    m(this, "removeColorButtonView");
    m(this, "_focusables");
    m(this, "_documentColorsLabel");
    m(this, "_removeButtonLabel");
    m(this, "_colorPickerLabel");
    const u = this.bindTemplate;
    this.set("isVisible", !0), this.focusTracker = c, this.items = this.createCollection(), this.colorDefinitions = e, this.columns = i, this.documentColors = new t5(), this.documentColorsCount = a, this._focusables = d, this._removeButtonLabel = r, this._colorPickerLabel = l, this._documentColorsLabel = s, this.setTemplate({ tag: "div", attributes: { class: ["ck-color-grids-fragment", u.if("isVisible", "ck-hidden", (h) => !h)] }, children: this.items }), this.removeColorButtonView = this._createRemoveColorButton(), this.items.add(this.removeColorButtonView);
  }
  updateDocumentColors(t, e) {
    const i = t.document, r = this.documentColorsCount;
    this.documentColors.clear();
    for (const s of i.getRoots()) {
      const a = t.createRangeIn(s);
      for (const l of a.getItems()) if (l.is("$textProxy") && l.hasAttribute(e) && (this._addColorToDocumentColors(l.getAttribute(e)), this.documentColors.length >= r)) return;
    }
  }
  updateSelectedColors() {
    const t = this.documentColorsGrid, e = this.staticColorsGrid, i = this.selectedColor;
    e.selectedColor = i, t && (t.selectedColor = i);
  }
  render() {
    if (super.render(), this.staticColorsGrid = this._createStaticColorsGrid(), this.items.add(this.staticColorsGrid), this.documentColorsCount) {
      const t = sn.bind(this.documentColors, this.documentColors), e = new L(this.locale);
      e.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-color-grid__label", t.if("isEmpty", "ck-hidden")] }, children: [{ text: this._documentColorsLabel }] }), this.items.add(e), this.documentColorsGrid = this._createDocumentColorsGrid(), this.items.add(this.documentColorsGrid);
    }
    this._createColorPickerButton(), this._addColorSelectorElementsToFocusTracker();
  }
  focus() {
    this.removeColorButtonView.focus();
  }
  destroy() {
    super.destroy();
  }
  addColorPickerButton() {
    this.colorPickerButtonView && (this.items.add(this.colorPickerButtonView), this.focusTracker.add(this.colorPickerButtonView.element), this._focusables.add(this.colorPickerButtonView));
  }
  _addColorSelectorElementsToFocusTracker() {
    this.focusTracker.add(this.removeColorButtonView.element), this._focusables.add(this.removeColorButtonView), this.staticColorsGrid && (this.focusTracker.add(this.staticColorsGrid.element), this._focusables.add(this.staticColorsGrid)), this.documentColorsGrid && (this.focusTracker.add(this.documentColorsGrid.element), this._focusables.add(this.documentColorsGrid));
  }
  _createColorPickerButton() {
    this.colorPickerButtonView = new V(), this.colorPickerButtonView.set({ label: this._colorPickerLabel, withText: !0, icon: p2, class: "ck-color-selector__color-picker" }), this.colorPickerButtonView.on("execute", () => {
      this.fire("colorPicker:show");
    });
  }
  _createRemoveColorButton() {
    const t = new V();
    return t.set({ withText: !0, icon: rd, label: this._removeButtonLabel }), t.class = "ck-color-selector__remove-color", t.on("execute", () => {
      this.fire("execute", { value: null, source: "removeColorButton" });
    }), t.render(), t;
  }
  _createStaticColorsGrid() {
    const t = new Km(this.locale, { colorDefinitions: this.colorDefinitions, columns: this.columns });
    return t.on("execute", (e, i) => {
      this.fire("execute", { value: i.value, source: "staticColorsGrid" });
    }), t;
  }
  _createDocumentColorsGrid() {
    const t = sn.bind(this.documentColors, this.documentColors), e = new Km(this.locale, { columns: this.columns });
    return e.extendTemplate({ attributes: { class: t.if("isEmpty", "ck-hidden") } }), e.items.bindTo(this.documentColors).using((i) => {
      var s;
      const r = new Dw();
      return r.set({ color: i.color, hasBorder: (s = i.options) == null ? void 0 : s.hasBorder }), i.label && r.set({ label: i.label, tooltip: !0 }), r.on("execute", () => {
        this.fire("execute", { value: i.color, source: "documentColorsGrid" });
      }), r;
    }), this.documentColors.on("change:isEmpty", (i, r, s) => {
      s && (e.selectedColor = null);
    }), e;
  }
  _addColorToDocumentColors(t) {
    const e = this.colorDefinitions.find((i) => i.color === t);
    e ? this.documentColors.add(Object.assign({}, e)) : this.documentColors.add({ color: t, label: t, options: { hasBorder: !1 } });
  }
}
class n5 extends L {
  constructor(t, { focusTracker: e, focusables: i, keystrokes: r, colorPickerViewConfig: s }) {
    super(t);
    m(this, "items");
    m(this, "colorPickerView");
    m(this, "saveButtonView");
    m(this, "cancelButtonView");
    m(this, "actionBarView");
    m(this, "focusTracker");
    m(this, "keystrokes");
    m(this, "_focusables");
    m(this, "_colorPickerViewConfig");
    this.items = this.createCollection(), this.focusTracker = e, this.keystrokes = r, this.set("isVisible", !1), this.set("selectedColor", void 0), this._focusables = i, this._colorPickerViewConfig = s;
    const a = this.bindTemplate, { saveButtonView: l, cancelButtonView: c } = this._createActionButtons();
    this.saveButtonView = l, this.cancelButtonView = c, this.actionBarView = this._createActionBarView({ saveButtonView: l, cancelButtonView: c }), this.setTemplate({ tag: "div", attributes: { class: ["ck-color-picker-fragment", a.if("isVisible", "ck-hidden", (d) => !d)] }, children: this.items });
  }
  render() {
    super.render();
    const t = new ZE(this.locale, { ...this._colorPickerViewConfig });
    this.colorPickerView = t, this.colorPickerView.render(), this.selectedColor && (t.color = this.selectedColor), this.listenTo(this, "change:selectedColor", (e, i, r) => {
      t.color = r;
    }), this.items.add(this.colorPickerView), this.items.add(this.actionBarView), this._addColorPickersElementsToFocusTracker(), this._stopPropagationOnArrowsKeys(), this._executeOnEnterPress(), this._executeUponColorChange();
  }
  destroy() {
    super.destroy();
  }
  focus() {
    this.colorPickerView.focus();
  }
  resetValidationStatus() {
    this.colorPickerView.resetValidationStatus();
  }
  _executeOnEnterPress() {
    this.keystrokes.set("enter", (t) => {
      this.isVisible && this.focusTracker.focusedElement !== this.cancelButtonView.element && this.colorPickerView.isValid() && (this.fire("execute", { value: this.selectedColor }), t.stopPropagation(), t.preventDefault());
    });
  }
  _stopPropagationOnArrowsKeys() {
    const t = (e) => e.stopPropagation();
    this.keystrokes.set("arrowright", t), this.keystrokes.set("arrowleft", t), this.keystrokes.set("arrowup", t), this.keystrokes.set("arrowdown", t);
  }
  _addColorPickersElementsToFocusTracker() {
    for (const e of this.colorPickerView.slidersView) this.focusTracker.add(e.element), this._focusables.add(e);
    const t = this.colorPickerView.hexInputRow.children.get(1);
    t.element && (this.focusTracker.add(t.element), this._focusables.add(t)), this.focusTracker.add(this.saveButtonView.element), this._focusables.add(this.saveButtonView), this.focusTracker.add(this.cancelButtonView.element), this._focusables.add(this.cancelButtonView);
  }
  _createActionBarView({ saveButtonView: t, cancelButtonView: e }) {
    const i = new L(), r = this.createCollection();
    return r.add(t), r.add(e), i.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-color-selector_action-bar"] }, children: r }), i;
  }
  _createActionButtons() {
    const t = this.locale, e = t.t, i = new V(t), r = new V(t);
    return i.set({ icon: _w, class: "ck-button-save", type: "button", withText: !1, label: e("Accept") }), r.set({ icon: Au, class: "ck-button-cancel", type: "button", withText: !1, label: e("Cancel") }), i.on("execute", () => {
      this.colorPickerView.isValid() && this.fire("execute", { source: "colorPickerSaveButton", value: this.selectedColor });
    }), r.on("execute", () => {
      this.fire("colorPicker:cancel");
    }), { saveButtonView: i, cancelButtonView: r };
  }
  _executeUponColorChange() {
    this.colorPickerView.on("colorSelected", (t, e) => {
      this.fire("execute", { value: e.color, source: "colorPicker" }), this.set("selectedColor", e.color);
    });
  }
}
class cg extends L {
  constructor(t, { colors: e, columns: i, removeButtonLabel: r, documentColorsLabel: s, documentColorsCount: a, colorPickerLabel: l, colorPickerViewConfig: c }) {
    super(t);
    m(this, "focusTracker");
    m(this, "keystrokes");
    m(this, "items");
    m(this, "colorGridsFragmentView");
    m(this, "colorPickerFragmentView");
    m(this, "_focusCycler");
    m(this, "_focusables");
    m(this, "_colorPickerViewConfig");
    this.items = this.createCollection(), this.focusTracker = new gt(), this.keystrokes = new Mt(), this._focusables = new Te(), this._colorPickerViewConfig = c, this._focusCycler = new le({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.colorGridsFragmentView = new e5(t, { colors: e, columns: i, removeButtonLabel: r, documentColorsLabel: s, documentColorsCount: a, colorPickerLabel: l, focusTracker: this.focusTracker, focusables: this._focusables }), this.colorPickerFragmentView = new n5(t, { focusables: this._focusables, focusTracker: this.focusTracker, keystrokes: this.keystrokes, colorPickerViewConfig: c }), this.set("_isColorGridsFragmentVisible", !0), this.set("_isColorPickerFragmentVisible", !1), this.set("selectedColor", void 0), this.colorGridsFragmentView.bind("isVisible").to(this, "_isColorGridsFragmentVisible"), this.colorPickerFragmentView.bind("isVisible").to(this, "_isColorPickerFragmentVisible"), this.on("change:selectedColor", (d, u, h) => {
      this.colorGridsFragmentView.set("selectedColor", h), this.colorPickerFragmentView.set("selectedColor", h);
    }), this.colorGridsFragmentView.on("change:selectedColor", (d, u, h) => {
      this.set("selectedColor", h);
    }), this.colorPickerFragmentView.on("change:selectedColor", (d, u, h) => {
      this.set("selectedColor", h);
    }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-color-selector"] }, children: this.items });
  }
  render() {
    super.render(), this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  appendUI() {
    this._appendColorGridsFragment(), this._colorPickerViewConfig && this._appendColorPickerFragment();
  }
  showColorPickerFragment() {
    this.colorPickerFragmentView.colorPickerView && !this._isColorPickerFragmentVisible && (this._isColorPickerFragmentVisible = !0, this.colorPickerFragmentView.focus(), this.colorPickerFragmentView.resetValidationStatus(), this._isColorGridsFragmentVisible = !1);
  }
  showColorGridsFragment() {
    this._isColorGridsFragmentVisible || (this._isColorGridsFragmentVisible = !0, this.colorGridsFragmentView.focus(), this._isColorPickerFragmentVisible = !1);
  }
  focus() {
    this._focusCycler.focusFirst();
  }
  focusLast() {
    this._focusCycler.focusLast();
  }
  updateDocumentColors(t, e) {
    this.colorGridsFragmentView.updateDocumentColors(t, e);
  }
  updateSelectedColors() {
    this.colorGridsFragmentView.updateSelectedColors();
  }
  _appendColorGridsFragment() {
    this.items.length || (this.items.add(this.colorGridsFragmentView), this.colorGridsFragmentView.delegate("execute").to(this), this.colorGridsFragmentView.delegate("colorPicker:show").to(this));
  }
  _appendColorPickerFragment() {
    this.items.length !== 2 && (this.items.add(this.colorPickerFragmentView), this.colorGridsFragmentView.colorPickerButtonView && this.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
      this.showColorPickerFragment();
    }), this.colorGridsFragmentView.addColorPickerButton(), this.colorPickerFragmentView.delegate("execute").to(this), this.colorPickerFragmentView.delegate("colorPicker:cancel").to(this));
  }
}
class i5 {
  constructor(n) {
    m(this, "editor");
    m(this, "_components", /* @__PURE__ */ new Map());
    this.editor = n;
  }
  *names() {
    for (const n of this._components.values()) yield n.originalName;
  }
  add(n, t) {
    this._components.set(Yl(n), { callback: t, originalName: n });
  }
  create(n) {
    if (!this.has(n)) throw new v("componentfactory-item-missing", this, { name: n });
    return this._components.get(Yl(n)).callback(this.editor.locale);
  }
  has(n) {
    return this._components.has(Yl(n));
  }
}
function Yl(o) {
  return String(o).toLowerCase();
}
const dg = "ck-tooltip", ce = class ce extends Pe() {
  constructor(t) {
    super();
    m(this, "tooltipTextView");
    m(this, "balloonPanelView");
    m(this, "_currentElementWithTooltip", null);
    m(this, "_currentTooltipPosition", null);
    m(this, "_mutationObserver", null);
    m(this, "_pinTooltipDebounced");
    m(this, "_unpinTooltipDebounced");
    m(this, "_watchdogExcluded");
    if (ce._editors.add(t), ce._instance) return ce._instance;
    ce._instance = this, this.tooltipTextView = new L(t.locale), this.tooltipTextView.set("text", ""), this.tooltipTextView.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-tooltip__text"] }, children: [{ text: this.tooltipTextView.bindTemplate.to("text") }] }), this.balloonPanelView = new se(t.locale), this.balloonPanelView.class = dg, this.balloonPanelView.content.add(this.tooltipTextView), this._mutationObserver = function(e) {
      const i = new MutationObserver(() => {
        e();
      });
      return { attach(r) {
        i.observe(r, { attributes: !0, attributeFilter: ["data-cke-tooltip-text", "data-cke-tooltip-position"] });
      }, detach() {
        i.disconnect();
      } };
    }(() => {
      this._updateTooltipPosition();
    }), this._pinTooltipDebounced = kn(this._pinTooltip, 600), this._unpinTooltipDebounced = kn(this._unpinTooltip, 400), this.listenTo(N.document, "keydown", this._onKeyDown.bind(this), { useCapture: !0 }), this.listenTo(N.document, "mouseenter", this._onEnterOrFocus.bind(this), { useCapture: !0 }), this.listenTo(N.document, "mouseleave", this._onLeaveOrBlur.bind(this), { useCapture: !0 }), this.listenTo(N.document, "focus", this._onEnterOrFocus.bind(this), { useCapture: !0 }), this.listenTo(N.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: !0 }), this.listenTo(N.document, "scroll", this._onScroll.bind(this), { useCapture: !0 }), this._watchdogExcluded = !0;
  }
  destroy(t) {
    const e = t.ui.view && t.ui.view.body;
    ce._editors.delete(t), this.stopListening(t.ui), e && e.has(this.balloonPanelView) && e.remove(this.balloonPanelView), ce._editors.size || (this._unpinTooltip(), this.balloonPanelView.destroy(), this.stopListening(), ce._instance = null);
  }
  static getPositioningFunctions(t) {
    const e = ce.defaultBalloonPositions;
    return { s: [e.southArrowNorth, e.southArrowNorthEast, e.southArrowNorthWest], n: [e.northArrowSouth], e: [e.eastArrowWest], w: [e.westArrowEast], sw: [e.southArrowNorthEast], se: [e.southArrowNorthWest] }[t];
  }
  _onKeyDown(t, e) {
    e.key === "Escape" && this._currentElementWithTooltip && (this._unpinTooltip(), e.stopPropagation());
  }
  _onEnterOrFocus(t, { target: e }) {
    const i = Zl(e);
    i ? i !== this._currentElementWithTooltip ? (this._unpinTooltip(), t.name === "focus" && !i.matches(":hover") || i.matches("[data-cke-tooltip-instant]") ? this._pinTooltip(i, Ql(i)) : this._pinTooltipDebounced(i, Ql(i))) : this._unpinTooltipDebounced.cancel() : t.name === "focus" && this._unpinTooltip();
  }
  _onLeaveOrBlur(t, { target: e, relatedTarget: i }) {
    if (t.name === "mouseleave") {
      if (!Si(e)) return;
      const r = this.balloonPanelView.element, s = r && (r === i || r.contains(i)), a = !s && e === r;
      if (s) return void this._unpinTooltipDebounced.cancel();
      if (!a && this._currentElementWithTooltip && e !== this._currentElementWithTooltip) return;
      const l = Zl(e), c = Zl(i);
      (a || l && l !== c) && (this._pinTooltipDebounced.cancel(), this._currentElementWithTooltip && this._currentElementWithTooltip.matches("[data-cke-tooltip-instant]") || l && l.matches("[data-cke-tooltip-instant]") ? this._unpinTooltip() : this._unpinTooltipDebounced());
    } else {
      if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) return;
      this._pinTooltipDebounced.cancel(), this._unpinTooltipDebounced();
    }
  }
  _onScroll(t, { target: e }) {
    this._currentElementWithTooltip && (e.contains(this.balloonPanelView.element) && e.contains(this._currentElementWithTooltip) || this._unpinTooltip());
  }
  _pinTooltip(t, { text: e, position: i, cssClass: r }) {
    this._unpinTooltip();
    const s = yt(ce._editors.values()).ui.view.body;
    s.has(this.balloonPanelView) || s.add(this.balloonPanelView), this.tooltipTextView.text = e, this.balloonPanelView.class = [dg, r].filter((a) => a).join(" "), this.balloonPanelView.pin({ target: t, positions: ce.getPositioningFunctions(i) }), this._mutationObserver.attach(t);
    for (const a of ce._editors) this.listenTo(a.ui, "update", this._updateTooltipPosition.bind(this), { priority: "low" });
    this._currentElementWithTooltip = t, this._currentTooltipPosition = i;
  }
  _unpinTooltip() {
    this._unpinTooltipDebounced.cancel(), this._pinTooltipDebounced.cancel(), this.balloonPanelView.unpin();
    for (const t of ce._editors) this.stopListening(t.ui, "update");
    this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this.tooltipTextView.text = "", this._mutationObserver.detach();
  }
  _updateTooltipPosition() {
    if (!this._currentElementWithTooltip) return;
    const t = Ql(this._currentElementWithTooltip);
    ri(this._currentElementWithTooltip) && t.text ? this.balloonPanelView.pin({ target: this._currentElementWithTooltip, positions: ce.getPositioningFunctions(t.position) }) : this._unpinTooltip();
  }
};
m(ce, "defaultBalloonPositions", se.generatePositions({ heightOffset: 5, sideOffset: 13 })), m(ce, "_editors", /* @__PURE__ */ new Set()), m(ce, "_instance", null);
let fd = ce;
function Zl(o) {
  return Si(o) ? o.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") : null;
}
function Ql(o) {
  return { text: o.dataset.ckeTooltipText, position: o.dataset.ckeTooltipPosition || "s", cssClass: o.dataset.ckeTooltipClass || "" };
}
class qw extends Pe() {
  constructor(t, e = {}) {
    super();
    m(this, "editor");
    m(this, "_balloonView", null);
    m(this, "_showBalloonThrottled", Qo(() => this._showBalloon(), 50, { leading: !0 }));
    m(this, "_lastFocusedEditableElement", null);
    m(this, "_balloonClass");
    this.editor = t, this._balloonClass = e.balloonClass, t.on("ready", () => this._handleEditorReady());
  }
  destroy() {
    const t = this._balloonView;
    t && (t.unpin(), this._balloonView = null), this._showBalloonThrottled.cancel(), this.stopListening();
  }
  _handleEditorReady() {
    const t = this.editor;
    this._isEnabled() && t.ui.view && (t.ui.focusTracker.on("change:isFocused", (e, i, r) => {
      this._updateLastFocusedEditableElement(), r ? this._showBalloon() : this._hideBalloon();
    }), t.ui.focusTracker.on("change:focusedElement", (e, i, r) => {
      this._updateLastFocusedEditableElement(), r && this._showBalloon();
    }), t.ui.on("update", () => {
      this._showBalloonThrottled();
    }));
  }
  _getNormalizedConfig() {
    return { side: this.editor.locale.contentLanguageDirection === "ltr" ? "right" : "left", position: "border", verticalOffset: 0, horizontalOffset: 5 };
  }
  _showBalloon() {
    const t = this._getBalloonAttachOptions();
    t && (this._balloonView || (this._balloonView = this._createBalloonView()), this._balloonView.pin(t));
  }
  _hideBalloon() {
    this._balloonView && this._balloonView.unpin();
  }
  _createBalloonView() {
    const t = this.editor, e = new se(), i = this._createBadgeContent();
    return e.content.add(i), this._balloonClass && (e.class = this._balloonClass), t.ui.view.body.add(e), e;
  }
  _getBalloonAttachOptions() {
    if (!this._lastFocusedEditableElement) return null;
    const t = this._getNormalizedConfig(), e = t.side === "right" ? ug(this._lastFocusedEditableElement, i = t, (r, s) => r.left + r.width - s.width - i.horizontalOffset) : function(r, s) {
      return ug(r, s, (a) => a.left + s.horizontalOffset);
    }(this._lastFocusedEditableElement, t);
    var i;
    return { target: this._lastFocusedEditableElement, positions: [e] };
  }
  _updateLastFocusedEditableElement() {
    const t = this.editor, e = t.ui.focusTracker.isFocused, i = t.ui.focusTracker.focusedElement;
    if (!e || !i) return void (this._lastFocusedEditableElement = null);
    const r = Array.from(t.ui.getEditableElementsNames()).map((s) => t.ui.getEditableElement(s));
    r.includes(i) ? this._lastFocusedEditableElement = i : this._lastFocusedEditableElement = r[0];
  }
}
function ug(o, n, t) {
  return (e, i) => {
    const r = new K(o);
    if (r.width < 350 || r.height < 50) return null;
    let s;
    s = n.position === "inside" ? r.bottom - i.height : r.bottom - i.height / 2, s -= n.verticalOffset;
    const a = t(r, i), l = e.clone().moveTo(a, s).getIntersection(i.clone().moveTo(a, s)).getVisible();
    return !l || l.getArea() < i.getArea() ? null : { top: s, left: a, name: `position_${n.position}-side_${n.side}`, config: { withArrow: !1 } };
  };
}
class o5 extends qw {
  constructor(n) {
    super(n, { balloonClass: "ck-powered-by-balloon" });
  }
  _isEnabled() {
    const n = this.editor;
    if (n.config.get("ui.poweredBy.forceVisible")) return !0;
    const t = n.config.get("licenseKey");
    if (t == "GPL") return !0;
    const e = lu(t.split(".")[1]);
    return !e || !e.whiteLabel;
  }
  _createBadgeContent() {
    return new r5(this.editor.locale, this._getNormalizedConfig().label);
  }
  _getNormalizedConfig() {
    const n = super._getNormalizedConfig(), t = this.editor.config.get("ui.poweredBy") || {}, e = t.position || n.position, i = e === "inside" ? 5 : n.verticalOffset;
    return { position: e, side: t.side || n.side, label: t.label === void 0 ? "Powered by" : t.label, verticalOffset: t.verticalOffset !== void 0 ? t.verticalOffset : i, horizontalOffset: t.horizontalOffset !== void 0 ? t.horizontalOffset : n.horizontalOffset, forceVisible: !!t.forceVisible };
  }
}
class r5 extends L {
  constructor(n, t) {
    super(n);
    const e = new cn(), i = this.bindTemplate;
    e.set({ content: X2, isColorInherited: !1 }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-powered-by"], "aria-hidden": !0 }, children: [{ tag: "a", attributes: { href: "https://ckeditor.com/powered-by-ckeditor/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo", target: "_blank", tabindex: "-1" }, children: [...t ? [{ tag: "span", attributes: { class: ["ck", "ck-powered-by__label"] }, children: [t] }] : [], e], on: { dragstart: i.to((r) => r.preventDefault()) } }] });
  }
}
class s5 extends qw {
  constructor(t) {
    super(t, { balloonClass: "ck-evaluation-badge-balloon" });
    m(this, "licenseTypeMessage", { evaluation: "For evaluation purposes only", trial: "For evaluation purposes only", development: "For development purposes only" });
  }
  _isEnabled() {
    const t = hg(this.editor.config.get("licenseKey"));
    return !!(t && this.licenseTypeMessage[t]);
  }
  _createBadgeContent() {
    const t = hg(this.editor.config.get("licenseKey"));
    return new a5(this.editor.locale, this.licenseTypeMessage[t]);
  }
  _getNormalizedConfig() {
    const t = super._getNormalizedConfig(), e = this.editor.config.get("ui.poweredBy") || {};
    return { position: e.position || t.position, side: (e.side || t.side) === "left" ? "right" : "left", verticalOffset: t.verticalOffset, horizontalOffset: t.horizontalOffset };
  }
}
class a5 extends L {
  constructor(n, t) {
    super(n), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-evaluation-badge"], "aria-hidden": !0 }, children: [{ tag: "span", attributes: { class: ["ck", "ck-evaluation-badge__label"] }, children: [t] }] });
  }
}
function hg(o) {
  if (o == "GPL") return "GPL";
  const n = lu(o.split(".")[1]);
  return n ? n.licenseType || "production" : null;
}
const mg = { POLITE: "polite", ASSERTIVE: "assertive" };
class l5 {
  constructor(n) {
    m(this, "editor");
    m(this, "view");
    this.editor = n, n.once("ready", () => {
      for (const t of Object.values(mg)) this.announce("", t);
    });
  }
  announce(n, t = mg.POLITE) {
    const e = this.editor;
    if (!e.ui.view) return;
    this.view || (this.view = new c5(e.locale), e.ui.view.body.add(this.view));
    const { politeness: i, isUnsafeHTML: r } = typeof t == "string" ? { politeness: t } : t;
    let s = this.view.regionViews.find((a) => a.politeness === i);
    s || (s = new d5(e, i), this.view.regionViews.add(s)), s.announce({ announcement: n, isUnsafeHTML: r });
  }
}
class c5 extends L {
  constructor(t) {
    super(t);
    m(this, "regionViews");
    this.regionViews = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-aria-live-announcer"] }, children: this.regionViews });
  }
}
class d5 extends L {
  constructor(t, e) {
    super(t.locale);
    m(this, "politeness");
    m(this, "_domConverter");
    m(this, "_pruneAnnouncementsInterval");
    this.setTemplate({ tag: "div", attributes: { "aria-live": e, "aria-relevant": "additions" }, children: [{ tag: "ul", attributes: { class: ["ck", "ck-aria-live-region-list"] } }] }), t.on("destroy", () => {
      this._pruneAnnouncementsInterval !== null && (clearInterval(this._pruneAnnouncementsInterval), this._pruneAnnouncementsInterval = null);
    }), this.politeness = e, this._domConverter = t.data.htmlProcessor.domConverter, this._pruneAnnouncementsInterval = setInterval(() => {
      this.element && this._listElement.firstChild && this._listElement.firstChild.remove();
    }, 5e3);
  }
  announce({ announcement: t, isUnsafeHTML: e }) {
    if (!t.trim().length) return;
    const i = document.createElement("li");
    e ? this._domConverter.setContentOf(i, t) : i.innerText = t, this._listElement.appendChild(i);
  }
  get _listElement() {
    return this.element.querySelector("ul");
  }
}
class zn extends dn {
  constructor(n, t) {
    super(n);
    const e = this.bindTemplate;
    this.extendTemplate({ attributes: { class: ["ck-menu-bar__menu__item"] }, on: { mouseenter: e.to("mouseenter") } }), this.delegate("mouseenter").to(t);
  }
}
const Ao = { toggleMenusAndFocusItemsOnHover(o) {
  o.on("menu:mouseenter", (n) => {
    if (o.isFocusBorderEnabled || o.isOpen) {
      if (o.isOpen) for (const t of o.menus) {
        const e = n.path[0], i = e instanceof zn && e.children.first === t;
        t.isOpen = (n.path.includes(t) || i) && t.isEnabled;
      }
      n.source.focus();
    }
  });
}, focusCycleMenusOnArrows(o) {
  const n = o.locale.uiLanguageDirection === "rtl";
  function t(e, i) {
    const r = o.children.getIndex(e), s = e.isOpen, a = o.children.length, l = o.children.get((r + a + i) % a);
    e.isOpen = !1, s && (l.isOpen = !0), l.buttonView.focus();
  }
  o.on("menu:arrowright", (e) => {
    t(e.source, n ? -1 : 1);
  }), o.on("menu:arrowleft", (e) => {
    t(e.source, n ? 1 : -1);
  });
}, closeMenusWhenTheBarCloses(o) {
  o.on("change:isOpen", () => {
    o.isOpen || o.menus.forEach((n) => {
      n.isOpen = !1;
    });
  });
}, closeMenuWhenAnotherOnTheSameLevelOpens(o) {
  o.on("menu:change:isOpen", (n, t, e) => {
    e && o.menus.filter((i) => n.source.parentMenuView === i.parentMenuView && n.source !== i && i.isOpen).forEach((i) => {
      i.isOpen = !1;
    });
  });
}, closeOnClickOutside(o) {
  Ni({ emitter: o, activator: () => o.isOpen, callback: () => o.close(), contextElements: () => o.children.map((n) => n.element) });
}, enableFocusHighlightOnInteraction(o) {
  let n = !1;
  o.on("change:isOpen", (t, e, i) => {
    i || (n || (o.isFocusBorderEnabled = !1), n = !1);
  }), o.listenTo(o.element, "keydown", () => {
    n = !0;
  }, { useCapture: !0 }), o.listenTo(o.element, "keyup", () => {
    n = !1;
  }, { useCapture: !0 }), o.listenTo(o.element, "focus", () => {
    n && (o.isFocusBorderEnabled = !0);
  }, { useCapture: !0 });
} }, mi = { openAndFocusPanelOnArrowDownKey(o) {
  o.keystrokes.set("arrowdown", (n, t) => {
    o.isEnabled && o.focusTracker.focusedElement === o.buttonView.element && (o.isOpen || (o.isOpen = !0), o.panelView.focus(), t());
  });
}, openOnArrowRightKey(o) {
  const n = o.locale.uiLanguageDirection === "rtl" ? "arrowleft" : "arrowright";
  o.keystrokes.set(n, (t, e) => {
    o.focusTracker.focusedElement === o.buttonView.element && o.isEnabled && (o.isOpen || (o.isOpen = !0), o.panelView.focus(), e());
  });
}, openOnButtonClick(o) {
  o.buttonView.on("execute", () => {
    o.isOpen = !0;
  });
}, toggleOnButtonClick(o) {
  o.buttonView.on("execute", () => {
    o.isOpen = !o.isOpen;
  });
}, openAndFocusOnEnterKeyPress(o) {
  o.keystrokes.set("enter", (n, t) => {
    o.focusTracker.focusedElement === o.buttonView.element && (o.isOpen = !0, o.panelView.focus(), t());
  });
}, closeOnArrowLeftKey(o) {
  const n = o.locale.uiLanguageDirection === "rtl" ? "arrowright" : "arrowleft";
  o.keystrokes.set(n, (t, e) => {
    o.isOpen && (o.isOpen = !1, o.focus(), e());
  });
}, closeOnEscKey(o) {
  o.keystrokes.set("esc", (n, t) => {
    o.isOpen && (o.isOpen = !1, o.focus(), t());
  });
}, closeOnParentClose(o) {
  o.parentMenuView.on("change:isOpen", (n, t, e) => {
    e || n.source !== o.parentMenuView || (o.isOpen = !1);
  });
} }, u5 = { southEast: (o) => ({ top: o.bottom, left: o.left, name: "se" }), southWest: (o, n) => ({ top: o.bottom, left: o.left - n.width + o.width, name: "sw" }), northEast: (o, n) => ({ top: o.top - n.height, left: o.left, name: "ne" }), northWest: (o, n) => ({ top: o.top - n.height, left: o.left - n.width + o.width, name: "nw" }), eastSouth: (o) => ({ top: o.top, left: o.right - 5, name: "es" }), eastNorth: (o, n) => ({ top: o.top - n.height, left: o.right - 5, name: "en" }), westSouth: (o, n) => ({ top: o.top, left: o.left - n.width + 5, name: "ws" }), westNorth: (o, n) => ({ top: o.top - n.height, left: o.left - n.width + 5, name: "wn" }) }, h5 = [{ menuId: "file", label: "File", groups: [{ groupId: "export", items: ["menuBar:exportPdf", "menuBar:exportWord"] }, { groupId: "import", items: ["menuBar:importWord"] }, { groupId: "revisionHistory", items: ["menuBar:revisionHistory"] }] }, { menuId: "edit", label: "Edit", groups: [{ groupId: "undo", items: ["menuBar:undo", "menuBar:redo"] }, { groupId: "selectAll", items: ["menuBar:selectAll"] }, { groupId: "findAndReplace", items: ["menuBar:findAndReplace"] }] }, { menuId: "view", label: "View", groups: [{ groupId: "sourceEditingEnhanced", items: ["menuBar:sourceEditingEnhanced"] }, { groupId: "sourceEditing", items: ["menuBar:sourceEditing"] }, { groupId: "showBlocks", items: ["menuBar:showBlocks"] }, { groupId: "previewMergeFields", items: ["menuBar:previewMergeFields"] }, { groupId: "fullscreen", items: ["menuBar:fullscreen"] }, { groupId: "restrictedEditing", items: ["menuBar:restrictedEditing"] }] }, { menuId: "insert", label: "Insert", groups: [{ groupId: "insertMainWidgets", items: ["menuBar:insertImage", "menuBar:ckbox", "menuBar:ckfinder", "menuBar:insertTable", "menuBar:insertTableLayout"] }, { groupId: "insertInline", items: ["menuBar:link", "menuBar:bookmark", "menuBar:comment", "menuBar:insertMergeField", "menuBar:emoji"] }, { groupId: "insertMinorWidgets", items: ["menuBar:mediaEmbed", "menuBar:insertTemplate", "menuBar:specialCharacters", "menuBar:blockQuote", "menuBar:codeBlock", "menuBar:htmlEmbed"] }, { groupId: "insertStructureWidgets", items: ["menuBar:horizontalLine", "menuBar:pageBreak", "menuBar:tableOfContents"] }, { groupId: "restrictedEditingException", items: ["menuBar:restrictedEditingException"] }] }, { menuId: "format", label: "Format", groups: [{ groupId: "textAndFont", items: [{ menuId: "text", label: "Text", groups: [{ groupId: "basicStyles", items: ["menuBar:bold", "menuBar:italic", "menuBar:underline", "menuBar:strikethrough", "menuBar:superscript", "menuBar:subscript", "menuBar:code"] }, { groupId: "textPartLanguage", items: ["menuBar:textPartLanguage"] }] }, { menuId: "font", label: "Font", groups: [{ groupId: "fontProperties", items: ["menuBar:fontSize", "menuBar:fontFamily"] }, { groupId: "fontColors", items: ["menuBar:fontColor", "menuBar:fontBackgroundColor"] }, { groupId: "highlight", items: ["menuBar:highlight"] }] }, "menuBar:heading"] }, { groupId: "list", items: ["menuBar:bulletedList", "menuBar:numberedList", "menuBar:multiLevelList", "menuBar:todoList"] }, { groupId: "indent", items: ["menuBar:alignment", "menuBar:indent", "menuBar:outdent"] }, { groupId: "caseChange", items: ["menuBar:caseChange"] }, { groupId: "removeFormat", items: ["menuBar:removeFormat"] }] }, { menuId: "tools", label: "Tools", groups: [{ groupId: "aiTools", items: ["menuBar:aiAssistant", "menuBar:aiCommands"] }, { groupId: "tools", items: ["menuBar:trackChanges", "menuBar:commentsArchive"] }] }, { menuId: "help", label: "Help", groups: [{ groupId: "help", items: ["menuBar:accessibilityHelp"] }] }];
function m5(o) {
  let n;
  return n = "items" in o && o.items ? { items: o.items, removeItems: [], addItems: [], isVisible: !0, isUsingDefaultConfig: !1, ...o } : { items: Ge(h5), addItems: [], removeItems: [], isVisible: !0, isUsingDefaultConfig: !0, ...o }, n;
}
function g5({ normalizedConfig: o, locale: n, componentFactory: t, extraItems: e }) {
  const i = Ge(o);
  return gg(o, i, e), function(r, s) {
    const a = s.removeItems, l = [];
    s.items = s.items.filter(({ menuId: c }) => !a.includes(c) || (l.push(c), !1)), Ko(s.items, (c) => {
      c.groups = c.groups.filter(({ groupId: d }) => !a.includes(d) || (l.push(d), !1));
      for (const d of c.groups) d.items = d.items.filter((u) => {
        const h = Gw(u);
        return !a.includes(h) || (l.push(h), !1);
      });
    });
    for (const c of a) l.includes(c) || at("menu-bar-item-could-not-be-removed", { menuBarConfig: r, itemName: c });
  }(o, i), gg(o, i, i.addItems), function(r, s, a) {
    Ko(s.items, (l) => {
      for (const c of l.groups) c.items = c.items.filter((d) => {
        const u = typeof d == "string" && !a.has(d);
        return u && !s.isUsingDefaultConfig && at("menu-bar-item-unavailable", { menuBarConfig: r, parentMenuConfig: Ge(l), componentName: d }), !u;
      });
    });
  }(o, i, t), Ww(o, i), function(r, s) {
    const a = s.t, l = { File: a({ string: "File", id: "MENU_BAR_MENU_FILE" }), Edit: a({ string: "Edit", id: "MENU_BAR_MENU_EDIT" }), View: a({ string: "View", id: "MENU_BAR_MENU_VIEW" }), Insert: a({ string: "Insert", id: "MENU_BAR_MENU_INSERT" }), Format: a({ string: "Format", id: "MENU_BAR_MENU_FORMAT" }), Tools: a({ string: "Tools", id: "MENU_BAR_MENU_TOOLS" }), Help: a({ string: "Help", id: "MENU_BAR_MENU_HELP" }), Text: a({ string: "Text", id: "MENU_BAR_MENU_TEXT" }), Font: a({ string: "Font", id: "MENU_BAR_MENU_FONT" }) };
    Ko(r.items, (c) => {
      c.label in l && (c.label = l[c.label]);
    });
  }(i, n), i;
}
function gg(o, n, t) {
  const e = [];
  if (t.length != 0) {
    for (const r of t) {
      const s = p5(r.position), a = b5(r.position);
      if (typeof (i = r) == "object" && "menu" in i) if (a) {
        const l = n.items.findIndex((c) => c.menuId === a);
        l != -1 ? s === "before" ? (n.items.splice(l, 0, r.menu), e.push(r)) : s === "after" && (n.items.splice(l + 1, 0, r.menu), e.push(r)) : fg(n, r.menu, a, s) && e.push(r);
      } else s === "start" ? (n.items.unshift(r.menu), e.push(r)) : s === "end" && (n.items.push(r.menu), e.push(r));
      else f5(r) ? Ko(n.items, (l) => {
        if (l.menuId === a) s === "start" ? (l.groups.unshift(r.group), e.push(r)) : s === "end" && (l.groups.push(r.group), e.push(r));
        else {
          const c = l.groups.findIndex((d) => d.groupId === a);
          c !== -1 && (s === "before" ? (l.groups.splice(c, 0, r.group), e.push(r)) : s === "after" && (l.groups.splice(c + 1, 0, r.group), e.push(r)));
        }
      }) : fg(n, r.item, a, s) && e.push(r);
    }
    var i;
    for (const r of t) e.includes(r) || at("menu-bar-item-could-not-be-added", { menuBarConfig: o, addedItemConfig: r });
  }
}
function fg(o, n, t, e) {
  let i = !1;
  return Ko(o.items, (r) => {
    for (const { groupId: s, items: a } of r.groups) {
      if (i) return;
      if (s === t) e === "start" ? (a.unshift(n), i = !0) : e === "end" && (a.push(n), i = !0);
      else {
        const l = a.findIndex((c) => Gw(c) === t);
        l !== -1 && (e === "before" ? (a.splice(l, 0, n), i = !0) : e === "after" && (a.splice(l + 1, 0, n), i = !0));
      }
    }
  }), i;
}
function Ww(o, n) {
  const t = n.isUsingDefaultConfig;
  let e = !1;
  n.items = n.items.filter((i) => !!i.groups.length || (Jl(o, i, t), !1)), n.items.length ? (Ko(n.items, (i) => {
    i.groups = i.groups.filter((r) => !!r.items.length || (e = !0, !1));
    for (const r of i.groups) r.items = r.items.filter((s) => !(Kw(s) && !s.groups.length) || (Jl(o, s, t), e = !0, !1));
  }), e && Ww(o, n)) : Jl(o, o, t);
}
function Jl(o, n, t) {
  t || at("menu-bar-menu-empty", { menuBarConfig: o, emptyMenuConfig: n });
}
function Ko(o, n) {
  if (Array.isArray(o)) for (const e of o) t(e);
  function t(e) {
    n(e);
    for (const i of e.groups) for (const r of i.items) Kw(r) && t(r);
  }
}
function f5(o) {
  return typeof o == "object" && "group" in o;
}
function p5(o) {
  return o.startsWith("start") ? "start" : o.startsWith("end") ? "end" : o.startsWith("after") ? "after" : "before";
}
function b5(o) {
  const n = o.match(/^[^:]+:(.+)/);
  return n ? n[1] : null;
}
function Gw(o) {
  return typeof o == "string" ? o : o.menuId;
}
function Kw(o) {
  return typeof o == "object" && "menuId" in o;
}
class k5 extends _t() {
  constructor(t) {
    super();
    m(this, "editor");
    m(this, "componentFactory");
    m(this, "focusTracker");
    m(this, "tooltipManager");
    m(this, "poweredBy");
    m(this, "evaluationBadge");
    m(this, "ariaLiveAnnouncer");
    m(this, "isReady", !1);
    m(this, "_editableElementsMap", /* @__PURE__ */ new Map());
    m(this, "_focusableToolbarDefinitions", []);
    m(this, "_extraMenuBarElements", []);
    m(this, "_lastFocusedForeignElement", null);
    const e = t.editing.view;
    this.editor = t, this.componentFactory = new i5(t), this.focusTracker = new gt(), this.tooltipManager = new fd(t), this.poweredBy = new o5(t), this.evaluationBadge = new s5(t), this.ariaLiveAnnouncer = new l5(t), this.set("viewportOffset", this._readViewportOffsetFromConfig()), this.once("ready", () => {
      this._bindBodyCollectionWithFocusTracker(), this.isReady = !0;
    }), this.listenTo(e.document, "layoutChanged", this.update.bind(this)), this.listenTo(e, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this)), this._initFocusTracking();
  }
  get element() {
    return null;
  }
  update() {
    this.fire("update");
  }
  destroy() {
    this.stopListening(), this.focusTracker.destroy(), this.tooltipManager.destroy(this.editor), this.poweredBy.destroy(), this.evaluationBadge.destroy();
    for (const t of this._editableElementsMap.values()) t.ckeditorInstance = null, this.editor.keystrokes.stopListening(t);
    this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [];
  }
  setEditableElement(t, e) {
    this._editableElementsMap.set(t, e), e.ckeditorInstance || (e.ckeditorInstance = this.editor), this.focusTracker.add(e);
    const i = () => {
      this.editor.editing.view.getDomRoot(t) || this.editor.keystrokes.listenTo(e);
    };
    this.isReady ? i() : this.once("ready", i);
  }
  removeEditableElement(t) {
    const e = this._editableElementsMap.get(t);
    e && (this._editableElementsMap.delete(t), this.editor.keystrokes.stopListening(e), this.focusTracker.remove(e), e.ckeditorInstance = null);
  }
  getEditableElement(t = "main") {
    return this._editableElementsMap.get(t);
  }
  getEditableElementsNames() {
    return this._editableElementsMap.keys();
  }
  addToolbar(t, e = {}) {
    t.isRendered ? (this.focusTracker.add(t), this.editor.keystrokes.listenTo(t.element)) : t.once("render", () => {
      this.focusTracker.add(t), this.editor.keystrokes.listenTo(t.element);
    }), this._focusableToolbarDefinitions.push({ toolbarView: t, options: e });
  }
  extendMenuBar(t) {
    this._extraMenuBarElements.push(t);
  }
  get _editableElements() {
    return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this }), this._editableElementsMap;
  }
  initMenuBar(t) {
    const e = t.element;
    this.focusTracker.add(e), this.editor.keystrokes.listenTo(e);
    const i = m5(this.editor.config.get("menuBar") || {});
    t.fillFromConfig(i, this.componentFactory, this._extraMenuBarElements), this.editor.keystrokes.set("Esc", (r, s) => {
      e.contains(this.editor.ui.focusTracker.focusedElement) && (this._lastFocusedForeignElement ? (this._lastFocusedForeignElement.focus(), this._lastFocusedForeignElement = null) : this.editor.editing.view.focus(), s());
    }), this.editor.keystrokes.set("Alt+F9", (r, s) => {
      e.contains(this.editor.ui.focusTracker.focusedElement) || (this._saveLastFocusedForeignElement(), t.isFocusBorderEnabled = !0, t.focus(), s());
    });
  }
  _readViewportOffsetFromConfig() {
    const t = this.editor, e = t.config.get("ui.viewportOffset");
    if (e) return e;
    const i = t.config.get("toolbar.viewportTopOffset");
    return i ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."), { top: i }) : { top: 0 };
  }
  _initFocusTracking() {
    const t = this.editor;
    let e;
    t.keystrokes.set("Alt+F10", (i, r) => {
      this._saveLastFocusedForeignElement();
      const s = this._getCurrentFocusedToolbarDefinition();
      s && e || (e = this._getFocusableCandidateToolbarDefinitions());
      for (let a = 0; a < e.length; a++) {
        const l = e.shift();
        if (e.push(l), l !== s && this._focusFocusableCandidateToolbar(l)) {
          s && s.options.afterBlur && s.options.afterBlur();
          break;
        }
      }
      r();
    }), t.keystrokes.set("Esc", (i, r) => {
      const s = this._getCurrentFocusedToolbarDefinition();
      s && (this._lastFocusedForeignElement ? (this._lastFocusedForeignElement.focus(), this._lastFocusedForeignElement = null) : t.editing.view.focus(), s.options.afterBlur && s.options.afterBlur(), r());
    });
  }
  _saveLastFocusedForeignElement() {
    const t = this.focusTracker.focusedElement;
    Array.from(this._editableElementsMap.values()).includes(t) && !Array.from(this.editor.editing.view.domRoots.values()).includes(t) && (this._lastFocusedForeignElement = t);
  }
  _getFocusableCandidateToolbarDefinitions() {
    const t = [];
    for (const e of this._focusableToolbarDefinitions) {
      const { toolbarView: i, options: r } = e;
      (ri(i.element) || r.beforeFocus) && t.push(e);
    }
    return t.sort((e, i) => pg(e) - pg(i)), t;
  }
  _getCurrentFocusedToolbarDefinition() {
    for (const t of this._focusableToolbarDefinitions) if (t.toolbarView.element && t.toolbarView.element.contains(this.focusTracker.focusedElement)) return t;
    return null;
  }
  _focusFocusableCandidateToolbar(t) {
    const { toolbarView: e, options: { beforeFocus: i } } = t;
    return i && i(), !!ri(e.element) && (e.focus(), !0);
  }
  _handleScrollToTheSelection(t, e) {
    const i = { top: 0, bottom: 0, left: 0, right: 0, ...this.viewportOffset };
    e.viewportOffset.top += i.top, e.viewportOffset.bottom += i.bottom, e.viewportOffset.left += i.left, e.viewportOffset.right += i.right;
  }
  _bindBodyCollectionWithFocusTracker() {
    const t = this.view.body;
    for (const e of t) this.focusTracker.add(e.element);
    t.on("add", (e, i) => {
      this.focusTracker.add(i.element);
    }), t.on("remove", (e, i) => {
      this.focusTracker.remove(i.element);
    });
  }
}
function pg(o) {
  const { toolbarView: n, options: t } = o;
  let e = 10;
  return ri(n.element) && e--, t.isContextual && (e -= 2), e;
}
class w5 extends L {
  constructor(t) {
    super(t);
    m(this, "body");
    m(this, "menuBarView");
    m(this, "toolbar");
    this.body = new cd(t);
  }
  render() {
    super.render(), this.body.attachToDom();
  }
  destroy() {
    return this.body.detachFromDom(), super.destroy();
  }
}
class _5 extends L {
  constructor(t, e, i) {
    super(t);
    m(this, "name", null);
    m(this, "_editingView");
    m(this, "_editableElement");
    m(this, "_hasExternalElement");
    this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"], lang: t.contentLanguage, dir: t.contentLanguageDirection } }), this.set("isFocused", !1), this._editableElement = i, this._hasExternalElement = !!this._editableElement, this._editingView = e;
  }
  render() {
    super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", () => this._updateIsFocusedClasses()), this._updateIsFocusedClasses();
  }
  destroy() {
    this._hasExternalElement && this.template.revert(this._editableElement), super.destroy();
  }
  get hasExternalElement() {
    return this._hasExternalElement;
  }
  _updateIsFocusedClasses() {
    const t = this._editingView;
    function e(i) {
      t.change((r) => {
        const s = t.document.getRoot(i.name);
        r.addClass(i.isFocused ? "ck-focused" : "ck-blurred", s), r.removeClass(i.isFocused ? "ck-blurred" : "ck-focused", s);
      });
    }
    t.isRenderingInProgress ? function i(r) {
      t.once("change:isRenderingInProgress", (s, a, l) => {
        l ? i(r) : e(r);
      });
    }(this) : e(this);
  }
}
class v5 extends _5 {
  constructor(t, e, i, r = {}) {
    super(t, e, i);
    m(this, "_options");
    this._options = r, this.extendTemplate({ attributes: { role: "textbox", class: "ck-editor__editable_inline" } });
  }
  render() {
    super.render();
    const t = this._editingView;
    t.change((e) => {
      const i = t.document.getRoot(this.name);
      e.setAttribute("aria-label", this.getEditableAriaLabel(), i);
    });
  }
  getEditableAriaLabel() {
    const t = this.locale.t, e = this._options.label, i = this._editableElement, r = this.name;
    if (typeof e == "string") return e;
    if (typeof e == "object") return e[r];
    if (typeof e == "function") return e(this);
    if (i) {
      const s = i.getAttribute("aria-label");
      if (s) return s;
    }
    return t("Rich Text Editor. Editing area: %0", r);
  }
}
class Ma extends L {
  constructor(t, e = {}) {
    super(t);
    m(this, "children");
    const i = this.bindTemplate;
    this.set("class", ["ck", "ck-form__row", ...Bt(e.class || [])]), this.children = this.createCollection(), e.children && e.children.forEach((r) => this.children.add(r)), this.set("_role", null), this.set("_ariaLabelledBy", null), e.labelView && this.set({ _role: "group", _ariaLabelledBy: e.labelView.id }), this.setTemplate({ tag: "div", attributes: { class: i.to("class", (r) => r.join(" ")), role: i.to("_role"), "aria-labelledby": i.to("_ariaLabelledBy") }, children: this.children });
  }
}
class bg extends Ik {
  static get pluginName() {
    return "Notification";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    this.on("show:warning", (n, t) => {
      window.alert(t.message);
    }, { priority: "lowest" });
  }
  showSuccess(n, t = {}) {
    this._showNotification({ message: n, type: "success", namespace: t.namespace, title: t.title });
  }
  showInfo(n, t = {}) {
    this._showNotification({ message: n, type: "info", namespace: t.namespace, title: t.title });
  }
  showWarning(n, t = {}) {
    this._showNotification({ message: n, type: "warning", namespace: t.namespace, title: t.title });
  }
  _showNotification(n) {
    const t = n.namespace ? `show:${n.type}:${n.namespace}` : `show:${n.type}`;
    this.fire(t, { message: n.message, type: n.type, title: n.title || "" });
  }
}
class ai extends _t() {
  constructor(n, t) {
    super(), t && uk(this, t), n && this.set(n);
  }
}
const Os = Li("px");
class On extends A {
  constructor(t) {
    super(t);
    m(this, "positionLimiter");
    m(this, "visibleStack");
    m(this, "_viewToStack", /* @__PURE__ */ new Map());
    m(this, "_idToStack", /* @__PURE__ */ new Map());
    m(this, "_view", null);
    m(this, "_rotatorView", null);
    m(this, "_fakePanelsView", null);
    this.positionLimiter = () => {
      const e = this.editor.editing.view, i = e.document.selection.editableElement;
      return i ? e.domConverter.mapViewToDom(i.root) : null;
    }, this.decorate("getPositionOptions"), this.set("visibleView", null), this.set("_numberOfStacks", 0), this.set("_singleViewMode", !1);
  }
  static get pluginName() {
    return "ContextualBalloon";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  destroy() {
    super.destroy(), this._view && this._view.destroy(), this._rotatorView && this._rotatorView.destroy(), this._fakePanelsView && this._fakePanelsView.destroy();
  }
  get view() {
    return this._view || this._createPanelView(), this._view;
  }
  hasView(t) {
    return Array.from(this._viewToStack.keys()).includes(t);
  }
  add(t) {
    if (this._view || this._createPanelView(), this.hasView(t.view)) throw new v("contextualballoon-add-view-exist", [this, t]);
    const e = t.stackId || "main";
    if (!this._idToStack.has(e)) return this._idToStack.set(e, /* @__PURE__ */ new Map([[t.view, t]])), this._viewToStack.set(t.view, this._idToStack.get(e)), this._numberOfStacks = this._idToStack.size, void (this._visibleStack && !t.singleViewMode || this.showStack(e));
    const i = this._idToStack.get(e);
    t.singleViewMode && this.showStack(e), i.set(t.view, t), this._viewToStack.set(t.view, i), i === this._visibleStack && this._showView(t);
  }
  remove(t) {
    if (!this.hasView(t)) throw new v("contextualballoon-remove-view-not-exist", [this, t]);
    const e = this._viewToStack.get(t);
    this._singleViewMode && this.visibleView === t && (this._singleViewMode = !1), this.visibleView === t && (e.size === 1 ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(e.values())[e.size - 2])), e.size === 1 ? (this._idToStack.delete(this._getStackId(e)), this._numberOfStacks = this._idToStack.size) : e.delete(t), this._viewToStack.delete(t);
  }
  updatePosition(t) {
    t && (this._visibleStack.get(this.visibleView).position = t), this.view.pin(this.getPositionOptions()), this._fakePanelsView.updatePosition();
  }
  getPositionOptions() {
    let t = Array.from(this._visibleStack.values()).pop().position;
    return t && (t.limiter || (t = Object.assign({}, t, { limiter: this.positionLimiter })), t = Object.assign({}, t, { viewportOffsetConfig: this.editor.ui.viewportOffset })), t;
  }
  showStack(t) {
    this.visibleStack = t;
    const e = this._idToStack.get(t);
    if (!e) throw new v("contextualballoon-showstack-stack-not-exist", this);
    this._visibleStack !== e && this._showView(Array.from(e.values()).pop());
  }
  _createPanelView() {
    this._view = new se(this.editor.locale), this.editor.ui.view.body.add(this._view), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView();
  }
  get _visibleStack() {
    return this._viewToStack.get(this.visibleView);
  }
  _getStackId(t) {
    return Array.from(this._idToStack.entries()).find((e) => e[1] === t)[0];
  }
  _showNextStack() {
    const t = Array.from(this._idToStack.values());
    let e = t.indexOf(this._visibleStack) + 1;
    t[e] || (e = 0), this.showStack(this._getStackId(t[e]));
  }
  _showPrevStack() {
    const t = Array.from(this._idToStack.values());
    let e = t.indexOf(this._visibleStack) - 1;
    t[e] || (e = t.length - 1), this.showStack(this._getStackId(t[e]));
  }
  _createRotatorView() {
    const t = new y5(this.editor.locale), e = this.editor.locale.t;
    return this.view.content.add(t), t.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (i, r) => !r && i > 1), t.on("change:isNavigationVisible", () => this.updatePosition(), { priority: "low" }), t.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (i, r) => {
      if (r < 2) return "";
      const s = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
      return e("%0 of %1", [s, r]);
    }), t.buttonNextView.on("execute", () => {
      t.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack();
    }), t.buttonPrevView.on("execute", () => {
      t.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack();
    }), t;
  }
  _createFakePanelsView() {
    const t = new C5(this.editor.locale, this.view);
    return t.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (e, i) => !i && e >= 2 ? Math.min(e - 1, 2) : 0), t.listenTo(this.view, "change:top", () => t.updatePosition()), t.listenTo(this.view, "change:left", () => t.updatePosition()), this.editor.ui.view.body.add(t), t;
  }
  _showView({ view: t, balloonClassName: e = "", withArrow: i = !0, singleViewMode: r = !1 }) {
    this.view.class = e, this.view.withArrow = i, this._rotatorView.showView(t), this.visibleView = t, this.view.pin(this.getPositionOptions()), this._fakePanelsView.updatePosition(), r && (this._singleViewMode = !0);
  }
}
class y5 extends L {
  constructor(t) {
    super(t);
    m(this, "focusTracker");
    m(this, "buttonPrevView");
    m(this, "buttonNextView");
    m(this, "content");
    const e = t.t, i = this.bindTemplate;
    this.set("isNavigationVisible", !0), this.focusTracker = new gt(), this.buttonPrevView = this._createButtonView(e("Previous"), co), this.buttonNextView = this._createButtonView(e("Next"), yw), this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-rotator"], "z-index": "-1" }, children: [{ tag: "div", attributes: { class: ["ck-balloon-rotator__navigation", i.to("isNavigationVisible", (r) => r ? "" : "ck-hidden")] }, children: [this.buttonPrevView, { tag: "span", attributes: { class: ["ck-balloon-rotator__counter"] }, children: [{ text: i.to("counter") }] }, this.buttonNextView] }, { tag: "div", attributes: { class: "ck-balloon-rotator__content" }, children: this.content }] });
  }
  render() {
    super.render(), this.focusTracker.add(this.element);
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy();
  }
  showView(t) {
    this.hideView(), this.content.add(t);
  }
  hideView() {
    this.content.clear();
  }
  _createButtonView(t, e) {
    const i = new V(this.locale);
    return i.set({ label: t, icon: e, tooltip: !0 }), i;
  }
}
class C5 extends L {
  constructor(t, e) {
    super(t);
    m(this, "content");
    m(this, "_balloonPanelView");
    const i = this.bindTemplate;
    this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = e, this.setTemplate({ tag: "div", attributes: { class: ["ck-fake-panel", i.to("numberOfPanels", (r) => r ? "" : "ck-hidden")], style: { top: i.to("top", Os), left: i.to("left", Os), width: i.to("width", Os), height: i.to("height", Os) } }, children: this.content }), this.on("change:numberOfPanels", (r, s, a, l) => {
      a > l ? this._addPanels(a - l) : this._removePanels(l - a), this.updatePosition();
    });
  }
  _addPanels(t) {
    for (; t--; ) {
      const e = new L();
      e.setTemplate({ tag: "div" }), this.content.add(e), this.registerChild(e);
    }
  }
  _removePanels(t) {
    for (; t--; ) {
      const e = this.content.last;
      this.content.remove(e), this.deregisterChild(e), e.destroy();
    }
  }
  updatePosition() {
    if (this.numberOfPanels) {
      const { top: t, left: e } = this._balloonPanelView, { width: i, height: r } = new K(this._balloonPanelView.element);
      Object.assign(this, { top: t, left: e, width: i, height: r });
    }
  }
}
class A5 extends Nn {
  constructor(t, e) {
    const i = t.t, r = Object.assign({}, { showResetButton: !0, showIcon: !0, creator: Mi }, e);
    super(t, r.creator);
    m(this, "iconView");
    m(this, "resetButtonView");
    m(this, "_viewConfig");
    this.label = e.label, this._viewConfig = r, this._viewConfig.showIcon && (this.iconView = new cn(), this.iconView.content = R2, this.fieldWrapperChildren.add(this.iconView, 0), this.extendTemplate({ attributes: { class: "ck-search__query_with-icon" } })), this._viewConfig.showResetButton && (this.resetButtonView = new V(t), this.resetButtonView.set({ label: i("Clear"), icon: Au, class: "ck-search__reset", isVisible: !1, tooltip: !0 }), this.resetButtonView.on("execute", () => {
      this.reset(), this.focus(), this.fire("reset");
    }), this.resetButtonView.bind("isVisible").to(this.fieldView, "isEmpty", (s) => !s), this.fieldWrapperChildren.add(this.resetButtonView), this.extendTemplate({ attributes: { class: "ck-search__query_with-reset" } }));
  }
  reset() {
    this.fieldView.reset(), this._viewConfig.showResetButton && (this.resetButtonView.isVisible = !1);
  }
}
class Yw extends L {
  constructor() {
    super();
    const n = this.bindTemplate;
    this.set({ isVisible: !1, primaryText: "", secondaryText: "" }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-search__info", n.if("isVisible", "ck-hidden", (t) => !t)], tabindex: -1 }, children: [{ tag: "span", children: [{ text: [n.to("primaryText")] }] }, { tag: "span", children: [{ text: [n.to("secondaryText")] }] }] });
  }
  focus() {
    this.element.focus();
  }
}
class x5 extends L {
  constructor(t) {
    super(t);
    m(this, "focusTracker");
    m(this, "children");
    m(this, "_focusCycler");
    this.children = this.createCollection(), this.focusTracker = new gt(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-search__results"], tabindex: -1 }, children: this.children }), this._focusCycler = new le({ focusables: this.children, focusTracker: this.focusTracker });
  }
  render() {
    super.render();
    for (const t of this.children) this.focusTracker.add(t.element);
  }
  focus() {
    this._focusCycler.focusFirst();
  }
  focusFirst() {
    this._focusCycler.focusFirst();
  }
  focusLast() {
    this._focusCycler.focusLast();
  }
}
class E5 extends L {
  constructor(t, e) {
    super(t);
    m(this, "focusTracker");
    m(this, "keystrokes");
    m(this, "resultsView");
    m(this, "filteredView");
    m(this, "infoView");
    m(this, "queryView");
    m(this, "focusCycler");
    m(this, "_config");
    this._config = e, this.filteredView = e.filteredView, this.queryView = this._createSearchTextQueryView(), this.focusTracker = new gt(), this.keystrokes = new Mt(), this.resultsView = new x5(t), this.children = this.createCollection(), this.focusableChildren = this.createCollection([this.queryView, this.resultsView]), this.set("isEnabled", !0), this.set("resultsCount", 0), this.set("totalItemsCount", 0), e.infoView && e.infoView.instance ? this.infoView = e.infoView.instance : (this.infoView = new Yw(), this._enableDefaultInfoViewBehavior(), this.on("render", () => {
      this.search("");
    })), this.resultsView.children.addMany([this.infoView, this.filteredView]), this.focusCycler = new le({ focusables: this.focusableChildren, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.on("search", (i, { resultsCount: r, totalItemsCount: s }) => {
      this.resultsCount = r, this.totalItemsCount = s;
    }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-search", e.class || null], tabindex: "-1" }, children: this.children });
  }
  render() {
    super.render(), this.children.addMany([this.queryView, this.resultsView]);
    const t = (e) => e.stopPropagation();
    for (const e of this.focusableChildren) this.focusTracker.add(e.element);
    this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", t), this.keystrokes.set("arrowleft", t), this.keystrokes.set("arrowup", t), this.keystrokes.set("arrowdown", t);
  }
  focus() {
    this.queryView.focus();
  }
  reset() {
    this.queryView.reset(), this.search(""), this.filteredView.element.scrollTo(0, 0);
  }
  search(t) {
    const e = t ? new RegExp(mk(t), "ig") : null, i = this.filteredView.filter(e);
    this.fire("search", { query: t, ...i });
  }
  _createSearchTextQueryView() {
    const t = new A5(this.locale, this._config.queryView);
    return this.listenTo(t.fieldView, "input", () => {
      this.search(t.fieldView.element.value);
    }), t.on("reset", () => this.reset()), t.bind("isEnabled").to(this), t;
  }
  _enableDefaultInfoViewBehavior() {
    const t = this.locale.t, e = this.infoView;
    function i(r, { query: s, resultsCount: a, totalItemsCount: l }) {
      return typeof r == "function" ? r(s, a, l) : r;
    }
    this.on("search", (r, s) => {
      if (s.resultsCount) e.set({ isVisible: !1 });
      else {
        const a = this._config.infoView && this._config.infoView.text;
        let l, c;
        s.totalItemsCount ? a != null && a.notFound ? (l = a.notFound.primary, c = a.notFound.secondary) : (l = t("No results found"), c = "") : a != null && a.noSearchableItems ? (l = a.noSearchableItems.primary, c = a.noSearchableItems.secondary) : (l = t("No searchable items"), c = ""), e.set({ primaryText: i(l, s), secondaryText: i(c, s), isVisible: !0 });
      }
    });
  }
}
const T5 = Li("px");
class S5 extends A {
  constructor(t) {
    super(t);
    m(this, "toolbarView");
    m(this, "focusTracker");
    m(this, "_balloonConfig");
    m(this, "_resizeObserver", null);
    m(this, "_balloon");
    m(this, "_fireSelectionChangeDebounced");
    this._balloonConfig = Iu(t.config.get("balloonToolbar")), this.toolbarView = this._createToolbarView(), this.focusTracker = new gt(), this._trackFocusableEditableElements(), this.focusTracker.add(this.toolbarView), t.ui.addToolbar(this.toolbarView, { beforeFocus: () => this.show(!0), afterBlur: () => this.hide(), isContextual: !0 }), this._balloon = t.plugins.get(On), this._fireSelectionChangeDebounced = kn(() => this.fire("_selectionChangeDebounced"), 200), this.decorate("show");
  }
  static get pluginName() {
    return "BalloonToolbar";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [On];
  }
  init() {
    const t = this.editor, e = t.model.document.selection;
    this.listenTo(this.focusTracker, "change:isFocused", (i, r, s) => {
      const a = this._balloon.visibleView === this.toolbarView;
      !s && a ? this.hide() : s && this.show();
    }), this.listenTo(e, "change:range", (i, r) => {
      (r.directChange || e.isCollapsed) && this.hide(), this._fireSelectionChangeDebounced();
    }), this.listenTo(this, "_selectionChangeDebounced", () => {
      this.editor.editing.view.document.isFocused && this.show();
    }), this._balloonConfig.shouldNotGroupWhenFull || this.listenTo(t, "ready", () => {
      const i = t.ui.view.editable.element;
      this._resizeObserver = new to(i, (r) => {
        this.toolbarView.maxWidth = T5(0.9 * r.contentRect.width);
      });
    }), this.listenTo(this.toolbarView, "groupedItemsUpdate", () => {
      this._updatePosition();
    }), t.ui.once("ready", () => {
      this.toolbarView.fillFromConfig(this._balloonConfig, this.editor.ui.componentFactory);
    });
  }
  _createToolbarView() {
    const t = this.editor.locale.t, e = !this._balloonConfig.shouldNotGroupWhenFull, i = new Cs(this.editor.locale, { shouldGroupWhenFull: e, isFloating: !0 });
    return i.ariaLabel = t("Editor contextual toolbar"), i.render(), i;
  }
  show(t = !1) {
    const e = this.editor, i = e.model.document.selection, r = e.model.schema;
    this._balloon.hasView(this.toolbarView) || i.isCollapsed && !t || function(s, a) {
      return s.rangeCount === 1 ? !1 : [...s.getRanges()].every((l) => {
        const c = l.getContainedElement();
        return c && a.isSelectable(c);
      });
    }(i, r) || Array.from(this.toolbarView.items).every((s) => s.isEnabled !== void 0 && !s.isEnabled) || (this.listenTo(this.editor.ui, "update", () => {
      this._updatePosition();
    }), this._balloon.add({ view: this.toolbarView, position: this._getBalloonPositionData(), balloonClassName: "ck-toolbar-container" }));
  }
  hide() {
    this._balloon.hasView(this.toolbarView) && (this.stopListening(this.editor.ui, "update"), this._balloon.remove(this.toolbarView));
  }
  _trackFocusableEditableElements() {
    const { editor: t, focusTracker: e } = this, { editing: i } = t;
    i.view.addObserver(class extends yn {
      observe(r) {
        e.add(r);
      }
      stopObserving(r) {
        e.remove(r);
      }
    });
  }
  _getBalloonPositionData() {
    const t = this.editor.editing.view, e = t.document, i = e.selection, r = e.selection.isBackward;
    return { target: () => {
      const s = r ? i.getFirstRange() : i.getLastRange(), a = K.getDomRangeRects(t.domConverter.viewRangeToDom(s));
      return r ? a[0] : (a.length > 1 && a[a.length - 1].width === 0 && a.pop(), a[a.length - 1]);
    }, positions: this._getBalloonPositions(r) };
  }
  _updatePosition() {
    this._balloon.updatePosition(this._getBalloonPositionData());
  }
  destroy() {
    super.destroy(), this.stopListening(), this._fireSelectionChangeDebounced.cancel(), this.toolbarView.destroy(), this.focusTracker.destroy(), this._resizeObserver && this._resizeObserver.destroy();
  }
  _getBalloonPositions(t) {
    const e = H.isSafari && H.isiOS ? se.generatePositions({ heightOffset: Math.max(se.arrowHeightOffset, Math.round(20 / N.window.visualViewport.scale)) }) : se.defaultPositions;
    return t ? [e.northWestArrowSouth, e.northWestArrowSouthWest, e.northWestArrowSouthEast, e.northWestArrowSouthMiddleEast, e.northWestArrowSouthMiddleWest, e.southWestArrowNorth, e.southWestArrowNorthWest, e.southWestArrowNorthEast, e.southWestArrowNorthMiddleWest, e.southWestArrowNorthMiddleEast] : [e.southEastArrowNorth, e.southEastArrowNorthEast, e.southEastArrowNorthWest, e.southEastArrowNorthMiddleEast, e.southEastArrowNorthMiddleWest, e.northEastArrowSouth, e.northEastArrowSouthEast, e.northEastArrowSouthWest, e.northEastArrowSouthMiddleEast, e.northEastArrowSouthMiddleWest];
  }
}
const kg = Li("px");
class I5 extends V {
  constructor(n) {
    super(n);
    const t = this.bindTemplate;
    this.isVisible = !1, this.isToggleable = !0, this.set("top", 0), this.set("left", 0), this.extendTemplate({ attributes: { class: "ck-block-toolbar-button", style: { top: t.to("top", (e) => kg(e)), left: t.to("left", (e) => kg(e)) } } });
  }
}
const kr = Li("px");
class M5 extends A {
  constructor(t) {
    super(t);
    m(this, "toolbarView");
    m(this, "panelView");
    m(this, "buttonView");
    m(this, "_resizeObserver", null);
    m(this, "_blockToolbarConfig");
    this._blockToolbarConfig = Iu(this.editor.config.get("blockToolbar")), this.toolbarView = this._createToolbarView(), this.panelView = this._createPanelView(), this.buttonView = this._createButtonView(), Ni({ emitter: this.panelView, contextElements: [this.panelView.element, this.buttonView.element], activator: () => this.panelView.isVisible, callback: () => this._hidePanel() });
  }
  static get pluginName() {
    return "BlockToolbar";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor, e = t.t, i = e("Click to edit block"), r = e("Drag to move"), s = e("Edit block"), a = t.plugins.has("DragDropBlockToolbar"), l = a ? `${i}
${r}` : s;
    this.buttonView.label = l, a && (this.buttonView.element.dataset.ckeTooltipClass = "ck-tooltip_multi-line"), this.listenTo(t.model.document.selection, "change:range", (c, d) => {
      d.directChange && this._hidePanel();
    }), this.listenTo(t.ui, "update", () => this._updateButton()), this.listenTo(t, "change:isReadOnly", () => this._updateButton(), { priority: "low" }), this.listenTo(t.ui.focusTracker, "change:isFocused", () => this._updateButton()), this.listenTo(this.buttonView, "change:isVisible", (c, d, u) => {
      u ? this.buttonView.listenTo(window, "resize", () => this._updateButton()) : (this.buttonView.stopListening(window, "resize"), this._hidePanel());
    }), this._repositionButtonOnScroll(), t.ui.addToolbar(this.toolbarView, { beforeFocus: () => this._showPanel(), afterBlur: () => this._hidePanel() }), t.ui.once("ready", () => {
      this.toolbarView.fillFromConfig(this._blockToolbarConfig, this.editor.ui.componentFactory);
      for (const c of this.toolbarView.items) c.on("execute", () => this._hidePanel(!0), { priority: "high" });
    });
  }
  destroy() {
    super.destroy(), this.panelView.destroy(), this.buttonView.destroy(), this.toolbarView.destroy(), this._resizeObserver && this._resizeObserver.destroy();
  }
  _createToolbarView() {
    const t = this.editor.locale.t, e = !this._blockToolbarConfig.shouldNotGroupWhenFull, i = new Cs(this.editor.locale, { shouldGroupWhenFull: e, isFloating: !0 });
    return i.ariaLabel = t("Editor block content toolbar"), i;
  }
  _createPanelView() {
    const t = this.editor, e = new se(t.locale);
    return e.content.add(this.toolbarView), e.class = "ck-toolbar-container", t.ui.view.body.add(e), this.toolbarView.keystrokes.set("Esc", (i, r) => {
      this._hidePanel(!0), r();
    }), e;
  }
  _createButtonView() {
    const t = this.editor, e = t.t, i = new I5(t.locale), r = this._blockToolbarConfig.icon, s = hd[r] || r || hd.dragIndicator;
    return i.set({ label: e("Edit block"), icon: s, withText: !1 }), i.bind("isOn").to(this.panelView, "isVisible"), i.bind("tooltip").to(this.panelView, "isVisible", (a) => !a), this.listenTo(i, "execute", () => {
      this.panelView.isVisible ? this._hidePanel(!0) : this._showPanel();
    }), this.listenTo(i, "change:isEnabled", (a, l, c) => {
      !c && this.panelView.isVisible && this._hidePanel(!1);
    }), t.ui.view.body.add(i), i;
  }
  _updateButton() {
    const t = this.editor, e = t.model, i = t.editing.view;
    if (!t.ui.focusTracker.isFocused) return void this._hideButton();
    if (!t.model.canEditAt(t.model.document.selection)) return void this._hideButton();
    const r = Array.from(e.document.selection.getSelectedBlocks())[0];
    if (!r || Array.from(this.toolbarView.items).every((a) => !a.isEnabled)) return void this._hideButton();
    const s = i.domConverter.mapViewToDom(t.editing.mapper.toViewElement(r));
    this.buttonView.isVisible = !0, this._setupToolbarResize(), this._attachButtonToElement(s), this.panelView.isVisible && this._showPanel();
  }
  _hideButton() {
    this.buttonView.isVisible = !1;
  }
  _showPanel() {
    if (!this.buttonView.isVisible) return;
    const t = this.panelView.isVisible;
    this.panelView.show();
    const e = this._getSelectedEditableElement();
    this.toolbarView.maxWidth = this._getToolbarMaxWidth(e), this.panelView.pin({ target: this.buttonView.element, limiter: e }), t || this.toolbarView.items.get(0).focus();
  }
  _getSelectedEditableElement() {
    const t = this.editor.model.document.selection.getFirstRange().root.rootName;
    return this.editor.ui.getEditableElement(t);
  }
  _hidePanel(t) {
    this.panelView.isVisible = !1, t && this.editor.editing.view.focus();
  }
  _repositionButtonOnScroll() {
    const { buttonView: t } = this;
    let e = !1;
    const i = (r, s) => {
      if (e) return;
      const a = this._getSelectedEditableElement();
      (s.target === N.document || kk(a).includes(s.target)) && (e = !0, N.window.requestAnimationFrame(() => {
        this._updateButton(), e = !1;
      }));
    };
    t.on("change:isVisible", (r, s, a) => {
      a ? t.listenTo(N.document, "scroll", i, { useCapture: !0, usePassive: !0 }) : t.stopListening(N.document, "scroll", i);
    });
  }
  _attachButtonToElement(t) {
    const e = this.buttonView.element, i = this._getSelectedEditableElement(), r = window.getComputedStyle(t), s = new K(i), a = parseInt(r.paddingTop, 10), l = parseInt(r.lineHeight, 10) || 1.2 * parseInt(r.fontSize, 10), c = new K(e), d = new K(t);
    let u;
    u = this.editor.locale.uiLanguageDirection === "ltr" ? s.left - c.width : s.right;
    const h = d.top + a + (l - c.height) / 2;
    c.moveTo(u, h);
    const g = c.toAbsoluteRect();
    this.buttonView.top = g.top, this.buttonView.left = g.left, this._clipButtonToViewport(this.buttonView, i);
  }
  _clipButtonToViewport(t, e) {
    const i = new K(t.element), r = new K(e).getVisible(), s = (...l) => {
      t.element.style.clipPath = l.length ? `polygon(${l.join(",")})` : "";
    }, a = (l) => {
      t.isEnabled = !l, t.element.style.pointerEvents = l ? "none" : "";
    };
    if (r && r.bottom < i.bottom) {
      const l = Math.min(i.height, i.bottom - r.bottom);
      a(l >= i.height), s("0 0", "100% 0", `100% calc(100% - ${kr(l)})`, `0 calc(100% - ${kr(l)}`);
    } else if (r && r.top > i.top) {
      const l = Math.min(i.height, r.top - i.top);
      a(l >= i.height), s(`0 ${kr(l)}`, `100% ${kr(l)}`, "100% 100%", "0 100%");
    } else a(!1), s();
  }
  _setupToolbarResize() {
    const t = this._getSelectedEditableElement();
    this._blockToolbarConfig.shouldNotGroupWhenFull || (this._resizeObserver && this._resizeObserver.element !== t && (this._resizeObserver.destroy(), this._resizeObserver = null), this._resizeObserver || (this._resizeObserver = new to(t, () => {
      this.toolbarView.maxWidth = this._getToolbarMaxWidth(t);
    })));
  }
  _getToolbarMaxWidth(t) {
    const e = new K(t), i = new K(this.buttonView.element), r = this.editor.locale.uiLanguageDirection === "rtl" ? i.left - e.right + i.width : e.left - i.left;
    return kr(e.width + r);
  }
}
class D5 extends er {
  constructor(t) {
    super(t);
    m(this, "arrowView");
    const e = this.bindTemplate;
    this.set({ withText: !0, role: "menuitem" }), this.arrowView = this._createArrowView(), this.extendTemplate({ attributes: { class: ["ck-menu-bar__menu__button"], "aria-haspopup": !0, "aria-expanded": this.bindTemplate.to("isOn", (i) => String(i)), "data-cke-tooltip-disabled": e.to("isOn") }, on: { mouseenter: e.to("mouseenter") } });
  }
  render() {
    super.render(), this.children.add(this.arrowView);
  }
  _createArrowView() {
    const t = new cn();
    return t.content = ul, t.extendTemplate({ attributes: { class: "ck-menu-bar__menu__button__arrow" } }), t;
  }
}
class P5 extends L {
  constructor(t) {
    super(t);
    m(this, "children");
    const e = this.bindTemplate;
    this.set("isVisible", !1), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-menu-bar__menu__panel", e.to("position", (i) => `ck-menu-bar__menu__panel_position_${i}`), e.if("isVisible", "ck-hidden", (i) => !i)], tabindex: "-1" }, children: this.children, on: { selectstart: e.to((i) => {
      i.target.tagName.toLocaleLowerCase() !== "input" && i.preventDefault();
    }) } });
  }
  focus(t = 1) {
    this.children.length && (t === 1 ? this.children.first.focus() : this.children.last.focus());
  }
}
const Ga = class Ga extends L {
  constructor(t) {
    super(t);
    m(this, "buttonView");
    m(this, "panelView");
    m(this, "focusTracker");
    m(this, "keystrokes");
    const e = this.bindTemplate;
    this.buttonView = new D5(t), this.buttonView.delegate("mouseenter").to(this), this.buttonView.bind("isOn", "isEnabled").to(this, "isOpen", "isEnabled"), this.panelView = new P5(t), this.panelView.bind("isVisible").to(this, "isOpen"), this.keystrokes = new Mt(), this.focusTracker = new gt(), this.set("isOpen", !1), this.set("isEnabled", !0), this.set("panelPosition", "w"), this.set("class", void 0), this.set("parentMenuView", null), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-menu-bar__menu", e.to("class"), e.if("isEnabled", "ck-disabled", (i) => !i), e.if("parentMenuView", "ck-menu-bar__menu_top-level", (i) => !i)] }, children: [this.buttonView, this.panelView] });
  }
  render() {
    super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.keystrokes.listenTo(this.element), mi.closeOnEscKey(this), this._repositionPanelOnOpen();
  }
  _attachBehaviors() {
    this.parentMenuView ? (mi.openOnButtonClick(this), mi.openOnArrowRightKey(this), mi.closeOnArrowLeftKey(this), mi.openAndFocusOnEnterKeyPress(this), mi.closeOnParentClose(this)) : (this._propagateArrowKeystrokeEvents(), mi.openAndFocusPanelOnArrowDownKey(this), mi.toggleOnButtonClick(this));
  }
  _propagateArrowKeystrokeEvents() {
    this.keystrokes.set("arrowright", (t, e) => {
      this.fire("arrowright"), e();
    }), this.keystrokes.set("arrowleft", (t, e) => {
      this.fire("arrowleft"), e();
    });
  }
  _repositionPanelOnOpen() {
    this.on("change:isOpen", (t, e, i) => {
      if (!i) return;
      const r = Ga._getOptimalPosition({ element: this.panelView.element, target: this.buttonView.element, fitInViewport: !0, positions: this._panelPositions });
      this.panelView.position = r ? r.name : this._defaultMenuPositionName;
    });
  }
  focus() {
    this.buttonView.focus();
  }
  get _panelPositions() {
    const { southEast: t, southWest: e, northEast: i, northWest: r, westSouth: s, eastSouth: a, westNorth: l, eastNorth: c } = u5;
    return this.locale.uiLanguageDirection === "ltr" ? this.parentMenuView ? [a, c, s, l] : [t, e, i, r] : this.parentMenuView ? [s, l, a, c] : [e, t, r, i];
  }
  get _defaultMenuPositionName() {
    return this.locale.uiLanguageDirection === "ltr" ? this.parentMenuView ? "es" : "se" : this.parentMenuView ? "ws" : "sw";
  }
};
m(Ga, "_getOptimalPosition", ru);
let Me = Ga;
class li extends ho {
  constructor(n) {
    super(n), this.role = "menu", this.items.on("change", this._setItemsCheckSpace.bind(this));
  }
  _setItemsCheckSpace() {
    const n = Array.from(this.items).some((t) => {
      const e = wg(t);
      return e && e.isToggleable;
    });
    this.items.forEach((t) => {
      const e = wg(t);
      e && (e.hasCheckSpace = n);
    });
  }
}
function wg(o) {
  return o instanceof dn ? o.children.map((n) => function(t) {
    return typeof t == "object" && "buttonView" in t && t.buttonView instanceof V;
  }(n) ? n.buttonView : n).find((n) => n instanceof er) : null;
}
class Zw extends AE {
  constructor(n) {
    super(n), this.set({ withText: !0, withKeystroke: !0, tooltip: !1, role: "menuitem" }), this.extendTemplate({ attributes: { class: ["ck-menu-bar__menu__item__button"] } });
  }
}
const _g = ["mouseenter", "arrowleft", "arrowright", "change:isOpen"];
class L5 extends L {
  constructor(t) {
    super(t);
    m(this, "children");
    m(this, "menus", []);
    const e = t.t, i = this.bindTemplate;
    this.set({ isOpen: !1, isFocusBorderEnabled: !1 }), this._setupIsOpenUpdater(), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-menu-bar", i.if("isFocusBorderEnabled", "ck-menu-bar_focus-border-enabled")], "aria-label": e("Editor menu bar"), role: "menubar" }, children: this.children });
  }
  fillFromConfig(t, e, i = []) {
    const r = g5({ normalizedConfig: t, locale: this.locale, componentFactory: e, extraItems: i }).items.map((s) => this._createMenu({ componentFactory: e, menuDefinition: s }));
    this.children.addMany(r);
  }
  render() {
    super.render(), Ao.toggleMenusAndFocusItemsOnHover(this), Ao.closeMenusWhenTheBarCloses(this), Ao.closeMenuWhenAnotherOnTheSameLevelOpens(this), Ao.focusCycleMenusOnArrows(this), Ao.closeOnClickOutside(this), Ao.enableFocusHighlightOnInteraction(this);
  }
  focus() {
    this.children.first && this.children.first.focus();
  }
  close() {
    for (const t of this.children) t.isOpen = !1;
  }
  disable() {
    for (const t of this.children) t.isEnabled = !1;
  }
  enable() {
    for (const t of this.children) t.isEnabled = !0;
  }
  registerMenu(t, e = null) {
    e ? (t.delegate(..._g).to(e), t.parentMenuView = e) : t.delegate(..._g).to(this, (i) => "menu:" + i), t._attachBehaviors(), this.menus.push(t);
  }
  _createMenu({ componentFactory: t, menuDefinition: e, parentMenuView: i }) {
    const r = this.locale, s = new Me(r);
    return this.registerMenu(s, i), s.buttonView.set({ label: e.label }), s.once("change:isOpen", () => {
      const a = new li(r);
      a.ariaLabel = e.label, s.panelView.children.add(a), a.items.addMany(this._createMenuItems({ menuDefinition: e, parentMenuView: s, componentFactory: t }));
    }), s;
  }
  _createMenuItems({ menuDefinition: t, parentMenuView: e, componentFactory: i }) {
    const r = this.locale, s = [];
    for (const a of t.groups) {
      for (const l of a.items) {
        const c = new zn(r, e);
        if (bn(l)) c.children.add(this._createMenu({ componentFactory: i, menuDefinition: l, parentMenuView: e }));
        else {
          const d = this._createMenuItemContentFromFactory({ componentName: l, componentFactory: i, parentMenuView: e });
          if (!d) continue;
          c.children.add(d);
        }
        s.push(c);
      }
      a !== t.groups[t.groups.length - 1] && s.push(new hl(r));
    }
    return s;
  }
  _createMenuItemContentFromFactory({ componentName: t, parentMenuView: e, componentFactory: i }) {
    const r = i.create(t);
    return r instanceof Me || r instanceof Et || r instanceof Zw ? (this._registerMenuTree(r, e), r.on("execute", () => {
      this.close();
    }), r) : (at("menu-bar-component-unsupported", { componentName: t, componentView: r }), null);
  }
  _registerMenuTree(t, e) {
    if (!(t instanceof Me)) return void t.delegate("mouseenter").to(e);
    this.registerMenu(t, e);
    const i = t.panelView.children.filter((s) => s instanceof li)[0];
    if (!i) return void t.delegate("mouseenter").to(e);
    const r = i.items.filter((s) => s instanceof dn);
    for (const s of r) this._registerMenuTree(s.children.get(0), t);
  }
  _setupIsOpenUpdater() {
    let t;
    this.on("menu:change:isOpen", (e, i, r) => {
      clearTimeout(t), r ? this.isOpen = !0 : t = setTimeout(() => {
        this.isOpen = Array.from(this.children).some((s) => s.isOpen);
      }, 0);
    });
  }
}
const wr = /* @__PURE__ */ new Map([["left", kw], ["right", m2], ["center", u2], ["justify", h2]]);
class B5 extends A {
  get localizedOptionTitles() {
    const n = this.editor.t;
    return { left: n("Align left"), right: n("Align right"), center: n("Align center"), justify: n("Justify") };
  }
  static get pluginName() {
    return "AlignmentUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = mw(this.editor.config.get("alignment.options"));
    n.map((t) => t.name).filter(uw).forEach((t) => this._addButton(t)), this._addToolbarDropdown(n), this._addMenuBarMenu(n);
  }
  _addButton(n) {
    this.editor.ui.componentFactory.add(`alignment:${n}`, (t) => this._createButton(t, n));
  }
  _createButton(n, t, e = {}) {
    const i = this.editor, r = i.commands.get("alignment"), s = new V(n);
    return s.set({ label: this.localizedOptionTitles[t], icon: wr.get(t), tooltip: !0, isToggleable: !0, ...e }), s.bind("isEnabled").to(r), s.bind("isOn").to(r, "value", (a) => a === t), this.listenTo(s, "execute", () => {
      i.execute("alignment", { value: t }), i.editing.view.focus();
    }), s;
  }
  _addToolbarDropdown(n) {
    const t = this.editor;
    t.ui.componentFactory.add("alignment", (e) => {
      const i = ge(e), r = e.uiLanguageDirection === "rtl" ? "w" : "e", s = e.t;
      As(i, () => n.map((c) => this._createButton(e, c.name, { tooltipPosition: r })), { enableActiveItemFocusOnDropdownOpen: !0, isVertical: !0, ariaLabel: s("Text alignment toolbar") }), i.buttonView.set({ label: s("Text alignment"), tooltip: !0 }), i.extendTemplate({ attributes: { class: "ck-alignment-dropdown" } });
      const a = e.contentLanguageDirection === "rtl" ? wr.get("right") : wr.get("left"), l = t.commands.get("alignment");
      return i.buttonView.bind("icon").to(l, "value", (c) => wr.get(c) || a), i.bind("isEnabled").to(l, "isEnabled"), this.listenTo(i, "execute", () => {
        t.editing.view.focus();
      }), i;
    });
  }
  _addMenuBarMenu(n) {
    const t = this.editor;
    t.ui.componentFactory.add("menuBar:alignment", (e) => {
      const i = t.commands.get("alignment"), r = e.t, s = new Me(e), a = new li(e);
      s.bind("isEnabled").to(i), a.set({ ariaLabel: r("Text alignment"), role: "menu" }), s.buttonView.set({ label: r("Text alignment") });
      for (const l of n) {
        const c = new zn(e, s), d = new Et(e);
        d.delegate("execute").to(s), d.set({ label: this.localizedOptionTitles[l.name], icon: wr.get(l.name), role: "menuitemcheckbox", isToggleable: !0 }), d.on("execute", () => {
          t.execute("alignment", { value: l.name }), t.editing.view.focus();
        }), d.bind("isOn").to(i, "value", (u) => u === l.name), d.bind("isEnabled").to(i, "isEnabled"), c.children.add(d), a.items.add(c);
      }
      return s.panelView.children.add(a), s;
    });
  }
}
class N5 extends A {
  static get requires() {
    return [s2, B5];
  }
  static get pluginName() {
    return "Alignment";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class Qw {
  constructor(n, t = 20) {
    m(this, "model");
    m(this, "limit");
    m(this, "_isLocked");
    m(this, "_size");
    m(this, "_batch", null);
    m(this, "_changeCallback");
    m(this, "_selectionChangeCallback");
    this.model = n, this._size = 0, this.limit = t, this._isLocked = !1, this._changeCallback = (e, i) => {
      i.isLocal && i.isUndoable && i !== this._batch && this._reset(!0);
    }, this._selectionChangeCallback = () => {
      this._reset();
    }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
  }
  get batch() {
    return this._batch || (this._batch = this.model.createBatch({ isTyping: !0 })), this._batch;
  }
  get size() {
    return this._size;
  }
  input(n) {
    this._size += n, this._size >= this.limit && this._reset(!0);
  }
  get isLocked() {
    return this._isLocked;
  }
  lock() {
    this._isLocked = !0;
  }
  unlock() {
    this._isLocked = !1;
  }
  destroy() {
    this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
  }
  _reset(n = !1) {
    this.isLocked && !n || (this._batch = null, this._size = 0);
  }
}
class z5 extends q {
  constructor(t, e) {
    super(t);
    m(this, "_buffer");
    this._buffer = new Qw(t.model, e), this._isEnabledBasedOnSelection = !1;
  }
  get buffer() {
    return this._buffer;
  }
  destroy() {
    super.destroy(), this._buffer.destroy();
  }
  execute(t = {}) {
    const e = this.editor.model, i = e.document, r = t.text || "", s = r.length;
    let a = i.selection;
    if (t.selection ? a = t.selection : t.range && (a = e.createSelection(t.range)), !e.canEditAt(a)) return;
    const l = t.resultRange;
    e.enqueueChange(this._buffer.batch, (c) => {
      this._buffer.lock();
      const d = Array.from(i.selection.getAttributes());
      e.deleteContent(a), r && e.insertContent(c.createText(r, d), a), l ? c.setSelection(l) : a.is("documentSelection") || c.setSelection(a), this._buffer.unlock(), this._buffer.input(s);
    });
  }
}
const Jw = ["insertText", "insertReplacementText"], O5 = [...Jw, "insertCompositionText"];
class R5 extends yn {
  constructor(t) {
    super(t);
    m(this, "focusObserver");
    this.focusObserver = t.getObserver(Aa);
    const e = H.isAndroid ? O5 : Jw, i = t.document;
    i.on("beforeinput", (r, s) => {
      if (!this.isEnabled) return;
      const { data: a, targetRanges: l, inputType: c, domEvent: d } = s;
      if (!e.includes(c)) return;
      this.focusObserver.flush();
      const u = new oi(i, "insertText");
      i.fire(u, new Xo(t, d, { text: a, selection: t.createSelection(l) })), u.stop.called && r.stop();
    }), H.isAndroid || i.on("compositionend", (r, { data: s, domEvent: a }) => {
      this.isEnabled && s && i.fire("insertText", new Xo(t, a, { text: s }));
    }, { priority: "lowest" });
  }
  observe() {
  }
  stopObserving() {
  }
}
class Xw extends A {
  constructor() {
    super(...arguments);
    m(this, "_compositionQueue");
  }
  static get pluginName() {
    return "Input";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor, e = t.model, i = t.editing.view, r = t.editing.mapper, s = e.document.selection;
    this._compositionQueue = new V5(t), i.addObserver(R5);
    const a = new z5(t, t.config.get("typing.undoStep") || 20);
    t.commands.add("insertText", a), t.commands.add("input", a), this.listenTo(i.document, "insertText", (l, c) => {
      i.document.isComposing || c.preventDefault(), H.isAndroid && i.document.isComposing && this._compositionQueue.flush("next beforeinput");
      const { text: d, selection: u } = c;
      let h;
      h = u ? Array.from(u.getRanges()).map((p) => r.toModelRange(p)) : Array.from(s.getRanges());
      let g = d;
      if (H.isAndroid) {
        const p = Array.from(h[0].getItems()).reduce((b, k) => b + (k.is("$textProxy") ? k.data : ""), "");
        if (p && (p.length <= g.length ? g.startsWith(p) && (g = g.substring(p.length), h[0].start = h[0].start.getShiftedBy(p.length)) : p.startsWith(g) && (h[0].start = h[0].start.getShiftedBy(g.length), g = "")), g.length == 0 && h[0].isCollapsed) return;
      }
      const f = { text: g, selection: e.createSelection(h) };
      H.isAndroid && i.document.isComposing ? this._compositionQueue.push(f) : (t.execute("insertText", f), i.scrollToTheSelection());
    }), H.isAndroid ? this.listenTo(i.document, "keydown", (l, c) => {
      !s.isCollapsed && c.keyCode == 229 && i.document.isComposing && vg(e, a);
    }) : this.listenTo(i.document, "compositionstart", () => {
      s.isCollapsed || vg(e, a);
    }), H.isAndroid ? (this.listenTo(i.document, "mutations", (l, { mutations: c }) => {
      if (i.document.isComposing) for (const { node: d } of c) {
        const u = F5(d, r), h = r.toModelElement(u);
        if (this._compositionQueue.isComposedElement(h)) return void this._compositionQueue.flush("mutations");
      }
    }), this.listenTo(i.document, "compositionend", () => {
      this._compositionQueue.flush("composition end");
    }), this.listenTo(i.document, "compositionend", () => {
      const l = [];
      for (const c of this._compositionQueue.flushComposedElements()) {
        const d = r.toViewElement(c);
        d && l.push({ type: "children", node: d });
      }
      l.length && i.document.fire("mutations", { mutations: l });
    }, { priority: "lowest" })) : this.listenTo(i.document, "compositionend", () => {
      i.document.fire("mutations", { mutations: [] });
    }, { priority: "lowest" });
  }
  destroy() {
    super.destroy(), this._compositionQueue.destroy();
  }
}
class V5 {
  constructor(n) {
    m(this, "editor");
    m(this, "flushDebounced", kn(() => this.flush("timeout"), 50));
    m(this, "_queue", []);
    m(this, "_compositionElements", /* @__PURE__ */ new Set());
    this.editor = n;
  }
  destroy() {
    for (this.flushDebounced.cancel(), this._compositionElements.clear(); this._queue.length; ) this.shift();
  }
  get length() {
    return this._queue.length;
  }
  push(n) {
    const t = { text: n.text };
    if (n.selection) {
      t.selectionRanges = [];
      for (const e of n.selection.getRanges()) t.selectionRanges.push(Ie.fromRange(e)), this._compositionElements.add(e.start.parent);
    }
    this._queue.push(t), this.flushDebounced();
  }
  shift() {
    const n = this._queue.shift(), t = { text: n.text };
    if (n.selectionRanges) {
      const e = n.selectionRanges.map((i) => function(r) {
        const s = r.toRange();
        return r.detach(), s.root.rootName == "$graveyard" ? null : s;
      }(i)).filter((i) => !!i);
      e.length && (t.selection = this.editor.model.createSelection(e));
    }
    return t;
  }
  flush(n) {
    const t = this.editor, e = t.model, i = t.editing.view;
    if (this.flushDebounced.cancel(), !this._queue.length) return;
    const r = t.commands.get("insertText").buffer;
    e.enqueueChange(r.batch, () => {
      for (r.lock(); this._queue.length; ) {
        const s = this.shift();
        t.execute("insertText", s);
      }
      r.unlock();
    }), i.scrollToTheSelection();
  }
  isComposedElement(n) {
    return this._compositionElements.has(n);
  }
  flushComposedElements() {
    const n = Array.from(this._compositionElements);
    return this._compositionElements.clear(), n;
  }
}
function vg(o, n) {
  if (!n.isEnabled) return;
  const t = n.buffer;
  t.lock(), o.enqueueChange(t.batch, () => {
    o.deleteContent(o.document.selection);
  }), t.unlock();
}
function F5(o, n) {
  let t = o.is("$text") ? o.parent : o;
  for (; !n.toModelElement(t); ) t = t.parent;
  return t;
}
class yg extends q {
  constructor(t, e) {
    super(t);
    m(this, "direction");
    m(this, "_buffer");
    this.direction = e, this._buffer = new Qw(t.model, t.config.get("typing.undoStep")), this._isEnabledBasedOnSelection = !1;
  }
  get buffer() {
    return this._buffer;
  }
  execute(t = {}) {
    const e = this.editor.model, i = e.document;
    e.enqueueChange(this._buffer.batch, (r) => {
      this._buffer.lock();
      const s = r.createSelection(t.selection || i.selection);
      if (!e.canEditAt(s)) return;
      const a = t.sequence || 1, l = s.isCollapsed;
      if (s.isCollapsed && e.modifySelection(s, { direction: this.direction, unit: t.unit, treatEmojiAsSingleUnit: !0 }), this._shouldEntireContentBeReplacedWithParagraph(a)) return void this._replaceEntireContentWithParagraph(r);
      if (this._shouldReplaceFirstBlockWithParagraph(s, a)) return void this.editor.execute("paragraph", { selection: s });
      if (s.isCollapsed) return;
      let c = 0;
      s.getFirstRange().getMinimalFlatRanges().forEach((d) => {
        c += qc(d.getWalker({ singleCharacters: !0, ignoreElementEnd: !0, shallow: !0 }));
      }), e.deleteContent(s, { doNotResetEntireContent: l, direction: this.direction }), this._buffer.input(c), r.setSelection(s), this._buffer.unlock();
    });
  }
  _shouldEntireContentBeReplacedWithParagraph(t) {
    if (t > 1) return !1;
    const e = this.editor.model, i = e.document.selection, r = e.schema.getLimitElement(i);
    if (!(i.isCollapsed && i.containsEntireContent(r)) || !e.schema.checkChild(r, "paragraph")) return !1;
    const s = r.getChild(0);
    return !s || !s.is("element", "paragraph");
  }
  _replaceEntireContentWithParagraph(t) {
    const e = this.editor.model, i = e.document.selection, r = e.schema.getLimitElement(i), s = t.createElement("paragraph");
    t.remove(t.createRangeIn(r)), t.insert(s, r), t.setSelection(s, 0);
  }
  _shouldReplaceFirstBlockWithParagraph(t, e) {
    const i = this.editor.model;
    if (e > 1 || this.direction != "backward" || !t.isCollapsed) return !1;
    const r = t.getFirstPosition(), s = i.schema.getLimitElement(r), a = s.getChild(0);
    return r.parent == a && !!t.containsEntireContent(a) && !!i.schema.checkChild(s, "paragraph") && a.name != "paragraph";
  }
}
const Cg = "word", wi = "selection", Lo = "backward", Dr = "forward", Ag = { deleteContent: { unit: wi, direction: Lo }, deleteContentBackward: { unit: "codePoint", direction: Lo }, deleteWordBackward: { unit: Cg, direction: Lo }, deleteHardLineBackward: { unit: wi, direction: Lo }, deleteSoftLineBackward: { unit: wi, direction: Lo }, deleteContentForward: { unit: "character", direction: Dr }, deleteWordForward: { unit: Cg, direction: Dr }, deleteHardLineForward: { unit: wi, direction: Dr }, deleteSoftLineForward: { unit: wi, direction: Dr } };
class j5 extends yn {
  constructor(n) {
    super(n);
    const t = n.document;
    let e = 0;
    t.on("keydown", () => {
      e++;
    }), t.on("keyup", () => {
      e = 0;
    }), t.on("beforeinput", (i, r) => {
      if (!this.isEnabled) return;
      const { targetRanges: s, domEvent: a, inputType: l } = r, c = Ag[l];
      if (!c) return;
      const d = { direction: c.direction, unit: c.unit, sequence: e };
      d.unit == wi && (d.selectionToRemove = n.createSelection(s[0])), l === "deleteContentBackward" && (H.isAndroid && (d.sequence = 1), function(h) {
        if (h.length != 1 || h[0].isCollapsed) return !1;
        const g = h[0].getWalker({ direction: "backward", singleCharacters: !0, ignoreElementEnd: !0 });
        let f = 0;
        for (const { nextPosition: p, item: b } of g) {
          if (p.parent.is("$text")) {
            const k = p.parent.data, w = p.offset;
            if (cu(k, w) || du(k, w) || Tk(k, w)) continue;
            f++;
          } else (b.is("containerElement") || b.is("emptyElement")) && f++;
          if (f > 1) return !0;
        }
        return !1;
      }(s) && (d.unit = wi, d.selectionToRemove = n.createSelection(s)));
      const u = new Jo(t, "delete", s[0]);
      t.fire(u, new Xo(n, a, d)), u.stop.called && i.stop();
    }), H.isBlink && function(i) {
      const r = i.view, s = r.document;
      let a = null, l = !1;
      function c(u) {
        return u == nt.backspace || u == nt.delete;
      }
      function d(u) {
        return u == nt.backspace ? Lo : Dr;
      }
      s.on("keydown", (u, { keyCode: h }) => {
        a = h, l = !1;
      }), s.on("keyup", (u, { keyCode: h, domEvent: g }) => {
        const f = s.selection, p = i.isEnabled && h == a && c(h) && !f.isCollapsed && !l;
        if (a = null, p) {
          const b = f.getFirstRange(), k = new Jo(s, "delete", b), w = { unit: wi, direction: d(h), selectionToRemove: f };
          s.fire(k, new Xo(r, g, w));
        }
      }), s.on("beforeinput", (u, { inputType: h }) => {
        const g = Ag[h];
        c(a) && g && g.direction == d(a) && (l = !0);
      }, { priority: "high" }), s.on("beforeinput", (u, { inputType: h, data: g }) => {
        a == nt.delete && h == "insertText" && g == "" && u.stop();
      }, { priority: "high" });
    }(this);
  }
  observe() {
  }
  stopObserving() {
  }
}
class Rn extends A {
  constructor() {
    super(...arguments);
    m(this, "_undoOnBackspace");
  }
  static get pluginName() {
    return "Delete";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor, e = t.editing.view, i = e.document, r = t.model.document;
    e.addObserver(j5), this._undoOnBackspace = !1;
    const s = new yg(t, "forward");
    t.commands.add("deleteForward", s), t.commands.add("forwardDelete", s), t.commands.add("delete", new yg(t, "backward")), this.listenTo(i, "delete", (a, l) => {
      i.isComposing || l.preventDefault();
      const { direction: c, sequence: d, selectionToRemove: u, unit: h } = l, g = c === "forward" ? "deleteForward" : "delete", f = { sequence: d };
      if (h == "selection") {
        const p = Array.from(u.getRanges()).map((b) => t.editing.mapper.toModelRange(b));
        f.selection = t.model.createSelection(p);
      } else f.unit = h;
      t.execute(g, f), e.scrollToTheSelection();
    }, { priority: "low" }), this.listenTo(i, "keydown", (a, l) => {
      if (i.isComposing || l.keyCode != nt.backspace || !r.selection.isCollapsed) return;
      const c = t.model.schema.getLimitElement(r.selection);
      t.model.createPositionAt(c, 0).isTouching(r.selection.getFirstPosition()) && l.preventDefault();
    }), this.editor.plugins.has("UndoEditing") && (this.listenTo(i, "delete", (a, l) => {
      this._undoOnBackspace && l.direction == "backward" && l.sequence == 1 && l.unit == "codePoint" && (this._undoOnBackspace = !1, t.execute("undo"), l.preventDefault(), a.stop());
    }, { context: "$capture" }), this.listenTo(r, "change", () => {
      this._undoOnBackspace = !1;
    }));
  }
  requestUndoOnBackspace() {
    this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = !0);
  }
}
class gl extends A {
  static get requires() {
    return [Xw, Rn];
  }
  static get pluginName() {
    return "Typing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
function t_(o, n) {
  let t = o.start;
  return { text: Array.from(o.getWalker({ ignoreElementEnd: !1 })).reduce((e, { item: i }) => i.is("$text") || i.is("$textProxy") ? e + i.data : (t = n.createPositionAfter(i), ""), ""), range: n.createRange(t, o.end) };
}
class e_ extends _t() {
  constructor(t, e) {
    super();
    m(this, "model");
    m(this, "testCallback");
    m(this, "_hasMatch");
    this.model = t, this.testCallback = e, this._hasMatch = !1, this.set("isEnabled", !0), this.on("change:isEnabled", () => {
      this.isEnabled ? this._startListening() : (this.stopListening(t.document.selection), this.stopListening(t.document));
    }), this._startListening();
  }
  get hasMatch() {
    return this._hasMatch;
  }
  _startListening() {
    const t = this.model.document;
    this.listenTo(t.selection, "change:range", (e, { directChange: i }) => {
      i && (t.selection.isCollapsed ? this._evaluateTextBeforeSelection("selection") : this.hasMatch && (this.fire("unmatched"), this._hasMatch = !1));
    }), this.listenTo(t, "change:data", (e, i) => {
      !i.isUndo && i.isLocal && this._evaluateTextBeforeSelection("data", { batch: i });
    });
  }
  _evaluateTextBeforeSelection(t, e = {}) {
    const i = this.model, r = i.document.selection, s = i.createRange(i.createPositionAt(r.focus.parent, 0), r.focus), { text: a, range: l } = t_(s, i), c = this.testCallback(a);
    if (!c && this.hasMatch && this.fire("unmatched"), this._hasMatch = !!c, c) {
      const d = Object.assign(e, { text: a, range: l });
      typeof c == "object" && Object.assign(d, c), this.fire(`matched:${t}`, d);
    }
  }
}
class Da extends A {
  constructor(t) {
    super(t);
    m(this, "attributes");
    m(this, "_overrideUid");
    m(this, "_isNextGravityRestorationSkipped", !1);
    this.attributes = /* @__PURE__ */ new Set(), this._overrideUid = null;
  }
  static get pluginName() {
    return "TwoStepCaretMovement";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor, e = t.model, i = t.editing.view, r = t.locale, s = e.document.selection;
    this.listenTo(i.document, "arrowKey", (a, l) => {
      if (!s.isCollapsed || l.shiftKey || l.altKey || l.ctrlKey) return;
      const c = l.keyCode == nt.arrowright, d = l.keyCode == nt.arrowleft;
      if (!c && !d) return;
      const u = r.contentLanguageDirection;
      let h = !1;
      h = u === "ltr" && c || u === "rtl" && d ? this._handleForwardMovement(l) : this._handleBackwardMovement(l), h === !0 && a.stop();
    }, { context: "$text", priority: "highest" }), this.listenTo(s, "change:range", (a, l) => {
      this._isNextGravityRestorationSkipped ? this._isNextGravityRestorationSkipped = !1 : this._isGravityOverridden && (!l.directChange && Xe(s.getFirstPosition(), this.attributes) || this._restoreGravity());
    }), this._enableClickingAfterNode(), this._enableInsertContentSelectionAttributesFixer(), this._handleDeleteContentAfterNode();
  }
  registerAttribute(t) {
    this.attributes.add(t);
  }
  _handleForwardMovement(t) {
    const e = this.attributes, i = this.editor.model, r = i.document.selection, s = r.getFirstPosition();
    return !this._isGravityOverridden && (!s.isAtStart || !qn(r, e)) && !!Xe(s, e) && (t && vr(t), qn(r, e) && Xe(s, e, !0) ? _r(i, e) : this._overrideGravity(), !0);
  }
  _handleBackwardMovement(t) {
    const e = this.attributes, i = this.editor.model, r = i.document.selection, s = r.getFirstPosition();
    return this._isGravityOverridden ? (t && vr(t), this._restoreGravity(), Xe(s, e, !0) ? _r(i, e) : Rs(i, e, s), !0) : s.isAtStart ? !!qn(r, e) && (t && vr(t), Rs(i, e, s), !0) : !qn(r, e) && Xe(s, e, !0) ? (t && vr(t), Rs(i, e, s), !0) : !!xg(s, e) && (s.isAtEnd && !qn(r, e) && Xe(s, e) ? (t && vr(t), Rs(i, e, s), !0) : (this._isNextGravityRestorationSkipped = !0, this._overrideGravity(), !1));
  }
  _enableClickingAfterNode() {
    const t = this.editor, e = t.model, i = e.document.selection, r = t.editing.view.document;
    t.editing.view.addObserver(dl), t.editing.view.addObserver(fx);
    let s = !1, a = !1;
    this.listenTo(r, "touchstart", () => {
      a = !1, s = !0;
    }), this.listenTo(r, "mousedown", () => {
      a = !0;
    }), this.listenTo(r, "selectionChange", () => {
      const l = this.attributes;
      if (!a && !s || (a = !1, s = !1, !i.isCollapsed) || !qn(i, l)) return;
      const c = i.getFirstPosition();
      Xe(c, l) && (c.isAtStart || Xe(c, l, !0) ? _r(e, l) : this._isGravityOverridden || this._overrideGravity());
    });
  }
  _enableInsertContentSelectionAttributesFixer() {
    const t = this.editor.model, e = t.document.selection, i = this.attributes;
    this.listenTo(t, "insertContent", () => {
      const r = e.getFirstPosition();
      qn(e, i) && Xe(r, i) && _r(t, i);
    }, { priority: "low" });
  }
  _handleDeleteContentAfterNode() {
    const t = this.editor, e = t.model, i = e.document.selection, r = t.editing.view;
    let s = !1, a = !1;
    this.listenTo(r.document, "delete", (l, c) => {
      s = c.direction === "backward";
    }, { priority: "high" }), this.listenTo(e, "deleteContent", () => {
      if (!s) return;
      const l = i.getFirstPosition();
      a = qn(i, this.attributes) && !xg(l, this.attributes);
    }, { priority: "high" }), this.listenTo(e, "deleteContent", () => {
      s && (s = !1, a || t.model.enqueueChange(() => {
        const l = i.getFirstPosition();
        qn(i, this.attributes) && Xe(l, this.attributes) && (l.isAtStart || Xe(l, this.attributes, !0) ? _r(e, this.attributes) : this._isGravityOverridden || this._overrideGravity());
      }));
    }, { priority: "low" });
  }
  get _isGravityOverridden() {
    return !!this._overrideUid;
  }
  _overrideGravity() {
    this._overrideUid = this.editor.model.change((t) => t.overrideSelectionGravity());
  }
  _restoreGravity() {
    this.editor.model.change((t) => {
      t.restoreSelectionGravity(this._overrideUid), this._overrideUid = null;
    });
  }
}
function qn(o, n) {
  for (const t of n) if (o.hasAttribute(t)) return !0;
  return !1;
}
function Rs(o, n, t) {
  const e = t.nodeBefore;
  o.change((i) => {
    if (e) {
      const r = [], s = o.schema.isObject(e) && o.schema.isInline(e);
      for (const [a, l] of e.getAttributes()) !o.schema.checkAttribute("$text", a) || s && o.schema.getAttributeProperties(a).copyFromObject === !1 || r.push([a, l]);
      i.setSelectionAttribute(r);
    } else i.removeSelectionAttribute(n);
  });
}
function _r(o, n) {
  o.change((t) => {
    t.removeSelectionAttribute(n);
  });
}
function vr(o) {
  o.preventDefault();
}
function xg(o, n) {
  return Xe(o.getShiftedBy(-1), n);
}
function Xe(o, n, t = !1) {
  const { nodeBefore: e, nodeAfter: i } = o;
  for (const r of n) {
    const s = e ? e.getAttribute(r) : void 0, a = i ? i.getAttribute(r) : void 0;
    if ((!t || s !== void 0 && a !== void 0) && a !== s) return !0;
  }
  return !1;
}
function fl(o, n, t, e) {
  return e.createRange(Eg(o, n, t, !0, e), Eg(o, n, t, !1, e));
}
function Eg(o, n, t, e, i) {
  let r = o.textNode || (e ? o.nodeBefore : o.nodeAfter), s = null;
  for (; r && r.getAttribute(n) == t; ) s = r, r = e ? r.previousSibling : r.nextSibling;
  return s ? i.createPositionAt(s, e ? "before" : "after") : o;
}
function n_(o, n, t, e) {
  const i = o.editing.view, r = /* @__PURE__ */ new Set();
  i.document.registerPostFixer((s) => {
    const a = o.model.document.selection;
    let l = !1;
    if (a.hasAttribute(n)) {
      const c = fl(a.getFirstPosition(), n, a.getAttribute(n), o.model), d = o.editing.mapper.toViewRange(c);
      for (const u of d.getItems()) u.is("element", t) && !u.hasClass(e) && (s.addClass(e, u), r.add(u), l = !0);
    }
    return l;
  }), o.conversion.for("editingDowncast").add((s) => {
    function a() {
      i.change((l) => {
        for (const c of r.values()) l.removeClass(e, c), r.delete(c);
      });
    }
    s.on("insert", a, { priority: "highest" }), s.on("remove", a, { priority: "highest" }), s.on("attribute", a, { priority: "highest" }), s.on("selection", a, { priority: "highest" });
  });
}
function gi(o, n, t, e) {
  let i, r = null;
  typeof e == "function" ? i = e : (r = o.commands.get(e), i = () => {
    o.execute(e);
  }), o.model.document.on("change:data", (s, a) => {
    if (r && !r.isEnabled || !n.isEnabled) return;
    const l = yt(o.model.document.selection.getRanges());
    if (!l.isCollapsed || a.isUndo || !a.isLocal) return;
    const c = Array.from(o.model.document.differ.getChanges()), d = c[0];
    if (c.length != 1 || d.type !== "insert" || d.name != "$text" || d.length != 1) return;
    const u = d.position.parent;
    if (u.is("element", "codeBlock") || u.is("element", "listItem") && typeof e != "function" && !["numberedList", "bulletedList", "todoList"].includes(e) || r && r.value === !0) return;
    const h = u.getChild(0), g = o.model.createRangeOn(h);
    if (!g.containsRange(l) && !l.end.isEqual(g.end)) return;
    const f = t.exec(h.data.substr(0, l.end.offset));
    f && o.model.enqueueChange((p) => {
      const b = p.createPositionAt(u, 0), k = p.createPositionAt(u, f[0].length), w = new Ie(b, k);
      if (i({ match: f }) !== !1) {
        p.remove(w);
        const _ = o.model.document.selection.getFirstRange(), y = p.createRangeIn(u);
        !u.isEmpty || y.isEqual(_) || y.containsRange(_, !0) || p.remove(u);
      }
      w.detach(), o.model.enqueueChange(() => {
        o.plugins.get("Delete").requestUndoOnBackspace();
      });
    });
  });
}
function xo(o, n, t, e) {
  let i, r;
  t instanceof RegExp ? i = t : r = t, r = r || ((s) => {
    let a;
    const l = [], c = [];
    for (; (a = i.exec(s)) !== null && !(a && a.length < 4); ) {
      let { index: d, 1: u, 2: h, 3: g } = a;
      const f = u + h + g;
      d += a[0].length - f.length;
      const p = [d, d + u.length], b = [d + u.length + h.length, d + u.length + h.length + g.length];
      l.push(p), l.push(b), c.push([d + u.length, d + u.length + h.length]);
    }
    return { remove: l, format: c };
  }), o.model.document.on("change:data", (s, a) => {
    if (a.isUndo || !a.isLocal || !n.isEnabled) return;
    const l = o.model, c = l.document.selection;
    if (!c.isCollapsed) return;
    const d = Array.from(l.document.differ.getChanges()), u = d[0];
    if (d.length != 1 || u.type !== "insert" || u.name != "$text" || u.length != 1) return;
    const h = c.focus, g = h.parent, { text: f, range: p } = function(_, y) {
      let C = _.start;
      return { text: Array.from(_.getItems()).reduce((I, P) => !P.is("$text") && !P.is("$textProxy") || P.getAttribute("code") ? (C = y.createPositionAfter(P), "") : I + P.data, ""), range: y.createRange(C, _.end) };
    }(l.createRange(l.createPositionAt(g, 0), h), l), b = r(f), k = Tg(p.start, b.format, l), w = Tg(p.start, b.remove, l);
    k.length && w.length && l.enqueueChange((_) => {
      if (e(_, k) !== !1) {
        for (const y of w.reverse()) _.remove(y);
        l.enqueueChange(() => {
          o.plugins.get("Delete").requestUndoOnBackspace();
        });
      }
    });
  });
}
function Tg(o, n, t) {
  return n.filter((e) => e[0] !== void 0 && e[1] !== void 0).map((e) => t.createRange(o.getShiftedBy(e[0]), o.getShiftedBy(e[1])));
}
class H5 extends A {
  static get requires() {
    return [Rn];
  }
  static get pluginName() {
    return "Autoformat";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  afterInit() {
    const n = this.editor, t = this.editor.t;
    this._addListAutoformats(), this._addBasicStylesAutoformats(), this._addHeadingAutoformats(), this._addBlockQuoteAutoformats(), this._addCodeBlockAutoformats(), this._addHorizontalLineAutoformats(), n.accessibility.addKeystrokeInfos({ keystrokes: [{ label: t("Revert autoformatting action"), keystroke: "Backspace" }] });
  }
  _addListAutoformats() {
    const n = this.editor.commands;
    n.get("bulletedList") && gi(this.editor, this, /^[*-]\s$/, "bulletedList"), n.get("numberedList") && gi(this.editor, this, /^1[.|)]\s$/, "numberedList"), n.get("todoList") && gi(this.editor, this, /^\[\s?\]\s$/, "todoList"), n.get("checkTodoList") && gi(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
      this.editor.execute("todoList"), this.editor.execute("checkTodoList");
    });
  }
  _addBasicStylesAutoformats() {
    const n = this.editor.commands;
    if (n.get("bold")) {
      const t = Vs(this.editor, "bold");
      xo(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t), xo(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t);
    }
    if (n.get("italic")) {
      const t = Vs(this.editor, "italic");
      xo(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t), xo(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t);
    }
    if (n.get("code")) {
      const t = Vs(this.editor, "code");
      xo(this.editor, this, /(`)([^`]+)(`)$/g, t);
    }
    if (n.get("strikethrough")) {
      const t = Vs(this.editor, "strikethrough");
      xo(this.editor, this, /(~~)([^~]+)(~~)$/g, t);
    }
  }
  _addHeadingAutoformats() {
    const n = this.editor.commands.get("heading");
    n && n.modelElements.filter((t) => t.match(/^heading[1-6]$/)).forEach((t) => {
      const e = t[7], i = new RegExp(`^(#{${e}})\\s$`);
      gi(this.editor, this, i, () => {
        if (!n.isEnabled || n.value === t) return !1;
        this.editor.execute("heading", { value: t });
      });
    });
  }
  _addBlockQuoteAutoformats() {
    this.editor.commands.get("blockQuote") && gi(this.editor, this, /^>\s$/, "blockQuote");
  }
  _addCodeBlockAutoformats() {
    const n = this.editor, t = n.model.document.selection;
    n.commands.get("codeBlock") && gi(n, this, /^```$/, () => {
      if (t.getFirstPosition().parent.is("element", "listItem")) return !1;
      this.editor.execute("codeBlock", { usePreviousLanguageChoice: !0 });
    });
  }
  _addHorizontalLineAutoformats() {
    this.editor.commands.get("horizontalLine") && gi(this.editor, this, /^---$/, "horizontalLine");
  }
}
function Vs(o, n) {
  return (t, e) => {
    if (!o.commands.get(n).isEnabled) return !1;
    const i = o.model.schema.getValidRanges(e, n);
    for (const r of i) t.setAttribute(n, !0, r);
    t.removeSelectionAttribute(n);
  };
}
class U5 extends A {
  constructor(t) {
    super(t);
    m(this, "adapter");
    m(this, "_debouncedSave");
    m(this, "_lastDocumentVersion");
    m(this, "_savePromise");
    m(this, "_domEmitter");
    m(this, "_config");
    m(this, "_pendingActions");
    m(this, "_makeImmediateSave");
    m(this, "_action", null);
    const e = t.config.get("autosave") || {}, i = e.waitingTime || 1e3;
    this.set("state", "synchronized"), this._debouncedSave = kn(this._save.bind(this), i), this._lastDocumentVersion = t.model.document.version, this._savePromise = null, this._domEmitter = new (Pe())(), this._config = e, this._pendingActions = t.plugins.get(Ta), this._makeImmediateSave = !1;
  }
  static get pluginName() {
    return "Autosave";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [Ta];
  }
  init() {
    const t = this.editor, e = t.model.document;
    this.listenTo(t, "ready", () => {
      this.listenTo(e, "change:data", (i, r) => {
        this._saveCallbacks.length && r.isLocal && (this.state === "synchronized" && (this.state = "waiting", this._setPendingAction()), this.state === "waiting" && this._debouncedSave());
      });
    }), this.listenTo(t, "destroy", () => this._flush(), { priority: "highest" }), this._domEmitter.listenTo(window, "beforeunload", (i, r) => {
      this._pendingActions.hasAny && (r.returnValue = this._pendingActions.first.message);
    });
  }
  destroy() {
    this._domEmitter.stopListening(), super.destroy();
  }
  save() {
    return this._debouncedSave.cancel(), this._save();
  }
  _flush() {
    this._debouncedSave.flush();
  }
  _save() {
    return this._savePromise ? (this._makeImmediateSave = this.editor.model.document.version > this._lastDocumentVersion, this._savePromise) : (this._setPendingAction(), this.state = "saving", this._lastDocumentVersion = this.editor.model.document.version, this._savePromise = Promise.resolve().then(() => Promise.all(this._saveCallbacks.map((t) => t(this.editor)))).finally(() => {
      this._savePromise = null;
    }).then(() => {
      if (this._makeImmediateSave) return this._makeImmediateSave = !1, this._save();
      this.editor.model.document.version > this._lastDocumentVersion ? (this.state = "waiting", this._debouncedSave()) : (this.state = "synchronized", this._pendingActions.remove(this._action), this._action = null);
    }).catch((t) => {
      throw this.state = "error", this.state = "saving", this._debouncedSave(), t;
    }), this._savePromise);
  }
  _setPendingAction() {
    const t = this.editor.t;
    this._action || (this._action = this._pendingActions.add(t("Saving changes")));
  }
  get _saveCallbacks() {
    const t = [];
    return this.adapter && this.adapter.save && t.push(this.adapter.save), this._config.save && t.push(this._config.save), t;
  }
}
class go extends q {
  constructor(t, e) {
    super(t);
    m(this, "attributeKey");
    this.attributeKey = e;
  }
  refresh() {
    const t = this.editor.model, e = t.document;
    this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey);
  }
  execute(t = {}) {
    const e = this.editor.model, i = e.document.selection, r = t.forceValue === void 0 ? !this.value : t.forceValue;
    e.change((s) => {
      if (i.isCollapsed) r ? s.setSelectionAttribute(this.attributeKey, !0) : s.removeSelectionAttribute(this.attributeKey);
      else {
        const a = e.schema.getValidRanges(i.getRanges(), this.attributeKey);
        for (const l of a) r ? s.setAttribute(this.attributeKey, r, l) : s.removeAttribute(this.attributeKey, l);
      }
    });
  }
  _getValueFromFirstAllowedNode() {
    const t = this.editor.model, e = t.schema, i = t.document.selection;
    if (i.isCollapsed) return i.hasAttribute(this.attributeKey);
    for (const r of i.getRanges()) for (const s of r.getItems()) if (e.checkAttribute(s, this.attributeKey)) return s.hasAttribute(this.attributeKey);
    return !1;
  }
}
const Eo = "bold";
class $5 extends A {
  static get pluginName() {
    return "BoldEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = this.editor.t;
    n.model.schema.extend("$text", { allowAttributes: Eo }), n.model.schema.setAttributeProperties(Eo, { isFormatting: !0, copyOnEnter: !0 }), n.conversion.attributeToElement({ model: Eo, view: "strong", upcastAlso: ["b", (e) => {
      const i = e.getStyle("font-weight");
      return i && (i == "bold" || Number(i) >= 600) ? { name: !0, styles: ["font-weight"] } : null;
    }] }), n.commands.add(Eo, new go(n, Eo)), n.keystrokes.set("CTRL+B", Eo), n.accessibility.addKeystrokeInfos({ keystrokes: [{ label: t("Bold text"), keystroke: "CTRL+B" }] });
  }
}
function fo({ editor: o, commandName: n, plugin: t, icon: e, label: i, keystroke: r }) {
  return (s) => {
    const a = o.commands.get(n), l = new s(o.locale);
    return l.set({ label: i, icon: e, keystroke: r, isToggleable: !0 }), l.bind("isEnabled").to(a, "isEnabled"), l.bind("isOn").to(a, "value"), l instanceof Et ? l.set({ role: "menuitemcheckbox" }) : l.set({ tooltip: !0 }), t.listenTo(l, "execute", () => {
      o.execute(n), o.editing.view.focus();
    }), l;
  };
}
const Xl = "bold";
class q5 extends A {
  static get pluginName() {
    return "BoldUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.locale.t, e = fo({ editor: n, commandName: Xl, plugin: this, icon: ww, label: t("Bold"), keystroke: "CTRL+B" });
    n.ui.componentFactory.add(Xl, () => e(V)), n.ui.componentFactory.add("menuBar:" + Xl, () => e(Et));
  }
}
class W5 extends A {
  static get requires() {
    return [$5, q5];
  }
  static get pluginName() {
    return "Bold";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
const ji = "code";
class G5 extends A {
  static get pluginName() {
    return "CodeEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [Da];
  }
  init() {
    const n = this.editor, t = this.editor.t;
    n.model.schema.extend("$text", { allowAttributes: ji }), n.model.schema.setAttributeProperties(ji, { isFormatting: !0, copyOnEnter: !1 }), n.conversion.attributeToElement({ model: ji, view: "code" }), n.commands.add(ji, new go(n, ji)), n.plugins.get(Da).registerAttribute(ji), n_(n, ji, "code", "ck-code_selected"), n.accessibility.addKeystrokeInfos({ keystrokes: [{ label: t("Move out of an inline code style"), keystroke: [["arrowleft", "arrowleft"], ["arrowright", "arrowright"]] }] });
  }
}
const tc = "code";
class K5 extends A {
  static get pluginName() {
    return "CodeUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.locale.t, e = fo({ editor: n, commandName: tc, plugin: this, icon: f2, label: t("Code") });
    n.ui.componentFactory.add(tc, () => e(V)), n.ui.componentFactory.add("menuBar:" + tc, () => e(Et));
  }
}
class Y5 extends A {
  static get requires() {
    return [G5, K5];
  }
  static get pluginName() {
    return "Code";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
const To = "italic";
class Z5 extends A {
  static get pluginName() {
    return "ItalicEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = this.editor.t;
    n.model.schema.extend("$text", { allowAttributes: To }), n.model.schema.setAttributeProperties(To, { isFormatting: !0, copyOnEnter: !0 }), n.conversion.attributeToElement({ model: To, view: "i", upcastAlso: ["em", { styles: { "font-style": "italic" } }] }), n.commands.add(To, new go(n, To)), n.keystrokes.set("CTRL+I", To), n.accessibility.addKeystrokeInfos({ keystrokes: [{ label: t("Italic text"), keystroke: "CTRL+I" }] });
  }
}
const ec = "italic";
class Q5 extends A {
  static get pluginName() {
    return "ItalicUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.locale.t, e = fo({ editor: n, commandName: ec, plugin: this, icon: S2, keystroke: "CTRL+I", label: t("Italic") });
    n.ui.componentFactory.add(ec, () => e(V)), n.ui.componentFactory.add("menuBar:" + ec, () => e(Et));
  }
}
class J5 extends A {
  static get requires() {
    return [Z5, Q5];
  }
  static get pluginName() {
    return "Italic";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
const yr = "strikethrough";
class X5 extends A {
  static get pluginName() {
    return "StrikethroughEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = this.editor.t;
    n.model.schema.extend("$text", { allowAttributes: yr }), n.model.schema.setAttributeProperties(yr, { isFormatting: !0, copyOnEnter: !0 }), n.conversion.attributeToElement({ model: yr, view: "s", upcastAlso: ["del", "strike", { styles: { "text-decoration": "line-through" } }] }), n.commands.add(yr, new go(n, yr)), n.keystrokes.set("CTRL+SHIFT+X", "strikethrough"), n.accessibility.addKeystrokeInfos({ keystrokes: [{ label: t("Strikethrough text"), keystroke: "CTRL+SHIFT+X" }] });
  }
}
const nc = "strikethrough";
class tT extends A {
  static get pluginName() {
    return "StrikethroughUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.locale.t, e = fo({ editor: n, commandName: nc, plugin: this, icon: sE, keystroke: "CTRL+SHIFT+X", label: t("Strikethrough") });
    n.ui.componentFactory.add(nc, () => e(V)), n.ui.componentFactory.add("menuBar:" + nc, () => e(Et));
  }
}
class eT extends A {
  static get requires() {
    return [X5, tT];
  }
  static get pluginName() {
    return "Strikethrough";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
const Cr = "subscript";
class nT extends A {
  static get pluginName() {
    return "SubscriptEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor;
    n.model.schema.extend("$text", { allowAttributes: Cr }), n.model.schema.setAttributeProperties(Cr, { isFormatting: !0, copyOnEnter: !0 }), n.conversion.attributeToElement({ model: Cr, view: "sub", upcastAlso: [{ styles: { "vertical-align": "sub" } }] }), n.commands.add(Cr, new go(n, Cr));
  }
}
const ic = "subscript";
class iT extends A {
  static get pluginName() {
    return "SubscriptUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.locale.t, e = fo({ editor: n, commandName: ic, plugin: this, icon: aE, label: t("Subscript") });
    n.ui.componentFactory.add(ic, () => e(V)), n.ui.componentFactory.add("menuBar:" + ic, () => e(Et));
  }
}
class oT extends A {
  static get requires() {
    return [nT, iT];
  }
  static get pluginName() {
    return "Subscript";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
const Ar = "superscript";
class rT extends A {
  static get pluginName() {
    return "SuperscriptEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor;
    n.model.schema.extend("$text", { allowAttributes: Ar }), n.model.schema.setAttributeProperties(Ar, { isFormatting: !0, copyOnEnter: !0 }), n.conversion.attributeToElement({ model: Ar, view: "sup", upcastAlso: [{ styles: { "vertical-align": "super" } }] }), n.commands.add(Ar, new go(n, Ar));
  }
}
const oc = "superscript";
class sT extends A {
  static get pluginName() {
    return "SuperscriptUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.locale.t, e = fo({ editor: n, commandName: oc, plugin: this, icon: lE, label: t("Superscript") });
    n.ui.componentFactory.add(oc, () => e(V)), n.ui.componentFactory.add("menuBar:" + oc, () => e(Et));
  }
}
class aT extends A {
  static get requires() {
    return [rT, sT];
  }
  static get pluginName() {
    return "Superscript";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
const xr = "underline";
class lT extends A {
  static get pluginName() {
    return "UnderlineEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = this.editor.t;
    n.model.schema.extend("$text", { allowAttributes: xr }), n.model.schema.setAttributeProperties(xr, { isFormatting: !0, copyOnEnter: !0 }), n.conversion.attributeToElement({ model: xr, view: "u", upcastAlso: { styles: { "text-decoration": "underline" } } }), n.commands.add(xr, new go(n, xr)), n.keystrokes.set("CTRL+U", "underline"), n.accessibility.addKeystrokeInfos({ keystrokes: [{ label: t("Underline text"), keystroke: "CTRL+U" }] });
  }
}
const rc = "underline";
class cT extends A {
  static get pluginName() {
    return "UnderlineUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.locale.t, e = fo({ editor: n, commandName: rc, plugin: this, icon: fE, label: t("Underline"), keystroke: "CTRL+U" });
    n.ui.componentFactory.add(rc, () => e(V)), n.ui.componentFactory.add("menuBar:" + rc, () => e(Et));
  }
}
class dT extends A {
  static get requires() {
    return [lT, cT];
  }
  static get pluginName() {
    return "Underline";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
function* i_(o, n) {
  for (const t of n) t && o.getAttributeProperties(t[0]).copyOnEnter && (yield t);
}
class uT extends q {
  execute() {
    this.editor.model.change((n) => {
      this.enterBlock(n), this.fire("afterExecute", { writer: n });
    });
  }
  enterBlock(n) {
    const t = this.editor.model, e = t.document.selection, i = t.schema, r = e.isCollapsed, s = e.getFirstRange(), a = s.start.parent, l = s.end.parent;
    if (i.isLimit(a) || i.isLimit(l)) return r || a != l || t.deleteContent(e), !1;
    if (r) {
      const c = i_(n.model.schema, e.getAttributes());
      return Sg(n, s.start), n.setSelectionAttribute(c), !0;
    }
    {
      const c = !(s.start.isAtStart && s.end.isAtEnd), d = a == l;
      if (t.deleteContent(e, { leaveUnmerged: c }), c) {
        if (d) return Sg(n, e.focus), !0;
        n.setSelection(l, 0);
      }
    }
    return !1;
  }
}
function Sg(o, n) {
  o.split(n), o.setSelection(n.parent.nextSibling, 0);
}
const hT = { insertParagraph: { isSoft: !1 }, insertLineBreak: { isSoft: !0 } };
class o_ extends yn {
  constructor(n) {
    super(n);
    const t = this.document;
    let e = !1;
    t.on("keydown", (i, r) => {
      e = r.shiftKey;
    }), t.on("beforeinput", (i, r) => {
      if (!this.isEnabled) return;
      let s = r.inputType;
      H.isSafari && e && s == "insertParagraph" && (s = "insertLineBreak");
      const a = r.domEvent, l = hT[s];
      if (!l) return;
      const c = new Jo(t, "enter", r.targetRanges[0]);
      t.fire(c, new Xo(n, a, { isSoft: l.isSoft })), c.stop.called && i.stop();
    });
  }
  observe() {
  }
  stopObserving() {
  }
}
class pl extends A {
  static get pluginName() {
    return "Enter";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.editing.view, e = t.document, i = this.editor.t;
    t.addObserver(o_), n.commands.add("enter", new uT(n)), this.listenTo(e, "enter", (r, s) => {
      e.isComposing || s.preventDefault(), s.isSoft || (n.execute("enter"), t.scrollToTheSelection());
    }, { priority: "low" }), n.accessibility.addKeystrokeInfos({ keystrokes: [{ label: i("Insert a hard break (a new paragraph)"), keystroke: "Enter" }] });
  }
}
class mT extends q {
  execute() {
    const n = this.editor.model, t = n.document;
    n.change((e) => {
      (function(i, r, s) {
        const a = s.isCollapsed, l = s.getFirstRange(), c = l.start.parent, d = l.end.parent, u = c == d;
        if (a) {
          const h = i_(i.schema, s.getAttributes());
          Ig(i, r, l.end), r.removeSelectionAttribute(s.getAttributeKeys()), r.setSelectionAttribute(h);
        } else {
          const h = !(l.start.isAtStart && l.end.isAtEnd);
          i.deleteContent(s, { leaveUnmerged: h }), u ? Ig(i, r, s.focus) : h && r.setSelection(d, 0);
        }
      })(n, e, t.selection), this.fire("afterExecute", { writer: e });
    });
  }
  refresh() {
    const n = this.editor.model, t = n.document;
    this.isEnabled = function(e, i) {
      if (i.rangeCount > 1) return !1;
      const r = i.anchor;
      if (!r || !e.checkChild(r, "softBreak")) return !1;
      const s = i.getFirstRange(), a = s.start.parent, l = s.end.parent;
      return !((pd(a, e) || pd(l, e)) && a !== l);
    }(n.schema, t.selection);
  }
}
function Ig(o, n, t) {
  const e = n.createElement("softBreak");
  o.insertContent(e, t), n.setSelection(e, "after");
}
function pd(o, n) {
  return !o.is("rootElement") && (n.isLimit(o) || pd(o.parent, n));
}
class r_ extends A {
  static get pluginName() {
    return "ShiftEnter";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.model.schema, e = n.conversion, i = n.editing.view, r = i.document, s = this.editor.t;
    t.register("softBreak", { allowWhere: "$text", isInline: !0 }), e.for("upcast").elementToElement({ model: "softBreak", view: "br" }), e.for("downcast").elementToElement({ model: "softBreak", view: (a, { writer: l }) => l.createEmptyElement("br") }), i.addObserver(o_), n.commands.add("shiftEnter", new mT(n)), this.listenTo(r, "enter", (a, l) => {
      r.isComposing || l.preventDefault(), l.isSoft && (n.execute("shiftEnter"), i.scrollToTheSelection());
    }, { priority: "low" }), n.accessibility.addKeystrokeInfos({ keystrokes: [{ label: s("Insert a soft break (a <code>&lt;br&gt;</code> element)"), keystroke: "Shift+Enter" }] });
  }
}
class gT extends q {
  refresh() {
    this.value = this._getValue(), this.isEnabled = this._checkEnabled();
  }
  execute(n = {}) {
    const t = this.editor.model, e = t.schema, i = t.document.selection, r = Array.from(i.getSelectedBlocks()), s = n.forceValue === void 0 ? !this.value : n.forceValue;
    t.change((a) => {
      if (s) {
        const l = r.filter((c) => Fs(c) || Dg(e, c));
        this._applyQuote(a, l);
      } else this._removeQuote(a, r.filter(Fs));
    });
  }
  _getValue() {
    const n = yt(this.editor.model.document.selection.getSelectedBlocks());
    return !(!n || !Fs(n));
  }
  _checkEnabled() {
    if (this.value) return !0;
    const n = this.editor.model.document.selection, t = this.editor.model.schema, e = yt(n.getSelectedBlocks());
    return !!e && Dg(t, e);
  }
  _removeQuote(n, t) {
    Mg(n, t).reverse().forEach((e) => {
      if (e.start.isAtStart && e.end.isAtEnd) return void n.unwrap(e.start.parent);
      if (e.start.isAtStart) {
        const r = n.createPositionBefore(e.start.parent);
        return void n.move(e, r);
      }
      e.end.isAtEnd || n.split(e.end);
      const i = n.createPositionAfter(e.end.parent);
      n.move(e, i);
    });
  }
  _applyQuote(n, t) {
    const e = [];
    Mg(n, t).reverse().forEach((i) => {
      let r = Fs(i.start);
      r || (r = n.createElement("blockQuote"), n.wrap(i, r)), e.push(r);
    }), e.reverse().reduce((i, r) => i.nextSibling == r ? (n.merge(n.createPositionAfter(i)), i) : r);
  }
}
function Fs(o) {
  return o.parent.name == "blockQuote" ? o.parent : null;
}
function Mg(o, n) {
  let t, e = 0;
  const i = [];
  for (; e < n.length; ) {
    const r = n[e], s = n[e + 1];
    t || (t = o.createPositionBefore(r)), s && r.nextSibling == s || (i.push(o.createRange(t, o.createPositionAfter(r))), t = null), e++;
  }
  return i;
}
function Dg(o, n) {
  const t = o.checkChild(n.parent, "blockQuote"), e = o.checkChild(["$root", "blockQuote"], n);
  return t && e;
}
class fT extends A {
  static get pluginName() {
    return "BlockQuoteEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [pl, Rn];
  }
  init() {
    const n = this.editor, t = n.model.schema;
    n.commands.add("blockQuote", new gT(n)), t.register("blockQuote", { inheritAllFrom: "$container" }), n.conversion.elementToElement({ model: "blockQuote", view: "blockquote" }), n.model.document.registerPostFixer((s) => {
      const a = n.model.document.differ.getChanges();
      for (const l of a) if (l.type == "insert") {
        const c = l.position.nodeAfter;
        if (!c) continue;
        if (c.is("element", "blockQuote") && c.isEmpty) return s.remove(c), !0;
        if (c.is("element", "blockQuote") && !t.checkChild(l.position, c)) return s.unwrap(c), !0;
        if (c.is("element")) {
          const d = s.createRangeIn(c);
          for (const u of d.getItems()) if (u.is("element", "blockQuote") && !t.checkChild(s.createPositionBefore(u), u)) return s.unwrap(u), !0;
        }
      } else if (l.type == "remove") {
        const c = l.position.parent;
        if (c.is("element", "blockQuote") && c.isEmpty) return s.remove(c), !0;
      }
      return !1;
    });
    const e = this.editor.editing.view.document, i = n.model.document.selection, r = n.commands.get("blockQuote");
    this.listenTo(e, "enter", (s, a) => {
      !i.isCollapsed || !r.value || i.getLastPosition().parent.isEmpty && (n.execute("blockQuote"), n.editing.view.scrollToTheSelection(), a.preventDefault(), s.stop());
    }, { context: "blockquote" }), this.listenTo(e, "delete", (s, a) => {
      if (a.direction != "backward" || !i.isCollapsed || !r.value) return;
      const l = i.getLastPosition().parent;
      l.isEmpty && !l.previousSibling && (n.execute("blockQuote"), n.editing.view.scrollToTheSelection(), a.preventDefault(), s.stop());
    }, { context: "blockquote" });
  }
}
class pT extends A {
  static get pluginName() {
    return "BlockQuoteUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor;
    n.ui.componentFactory.add("blockQuote", () => {
      const t = this._createButton(V);
      return t.set({ tooltip: !0 }), t;
    }), n.ui.componentFactory.add("menuBar:blockQuote", () => {
      const t = this._createButton(Et);
      return t.set({ role: "menuitemcheckbox" }), t;
    });
  }
  _createButton(n) {
    const t = this.editor, e = t.locale, i = t.commands.get("blockQuote"), r = new n(t.locale), s = e.t;
    return r.set({ label: s("Block quote"), icon: tE, isToggleable: !0 }), r.bind("isEnabled").to(i, "isEnabled"), r.bind("isOn").to(i, "value"), this.listenTo(r, "execute", () => {
      t.execute("blockQuote"), t.editing.view.focus();
    }), r;
  }
}
class bT extends A {
  static get requires() {
    return [fT, pT];
  }
  static get pluginName() {
    return "BlockQuote";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class kT extends vt() {
  constructor() {
    super(...arguments);
    m(this, "_stack", []);
  }
  add(t, e) {
    const i = this._stack, r = i[0];
    this._insertDescriptor(t);
    const s = i[0];
    r === s || sc(r, s) || this.fire("change:top", { oldDescriptor: r, newDescriptor: s, writer: e });
  }
  remove(t, e) {
    const i = this._stack, r = i[0];
    this._removeDescriptor(t);
    const s = i[0];
    r === s || sc(r, s) || this.fire("change:top", { oldDescriptor: r, newDescriptor: s, writer: e });
  }
  _insertDescriptor(t) {
    const e = this._stack, i = e.findIndex((s) => s.id === t.id);
    if (sc(t, e[i])) return;
    i > -1 && e.splice(i, 1);
    let r = 0;
    for (; e[r] && wT(e[r], t); ) r++;
    e.splice(r, 0, t);
  }
  _removeDescriptor(t) {
    const e = this._stack, i = e.findIndex((r) => r.id === t);
    i > -1 && e.splice(i, 1);
  }
}
function sc(o, n) {
  return o && n && o.priority == n.priority && Pa(o.classes) == Pa(n.classes);
}
function wT(o, n) {
  return o.priority > n.priority || !(o.priority < n.priority) && Pa(o.classes) > Pa(n.classes);
}
function Pa(o) {
  return Array.isArray(o) ? o.sort().join(",") : o;
}
const _T = "ck-widget", Pg = "ck-widget_selected";
function Yt(o) {
  return !!o.is("element") && !!o.getCustomProperty("widget");
}
function bl(o, n, t = {}) {
  if (!o.is("containerElement")) throw new v("widget-to-widget-wrong-element-type", null, { element: o });
  return n.setAttribute("contenteditable", "false", o), n.addClass(_T, o), n.setCustomProperty("widget", !0, o), o.getFillerOffset = xT, n.setCustomProperty("widgetLabel", [], o), t.label && CT(o, t.label), t.hasSelectionHandle && function(e, i) {
    const r = i.createUIElement("div", { class: "ck ck-widget__selection-handle" }, function(s) {
      const a = this.toDomElement(s), l = new cn();
      return l.set("content", k2), l.render(), a.appendChild(l.element), a;
    });
    i.insert(i.createPositionAt(e, 0), r), i.addClass(["ck-widget_with-selection-handle"], e);
  }(o, n), s_(o, n), o;
}
function vT(o, n, t) {
  if (n.classes && t.addClass(Bt(n.classes), o), n.attributes) for (const e in n.attributes) t.setAttribute(e, n.attributes[e], o);
}
function yT(o, n, t) {
  if (n.classes && t.removeClass(Bt(n.classes), o), n.attributes) for (const e in n.attributes) t.removeAttribute(e, o);
}
function s_(o, n, t = vT, e = yT) {
  const i = new kT();
  i.on("change:top", (r, s) => {
    s.oldDescriptor && e(o, s.oldDescriptor, s.writer), s.newDescriptor && t(o, s.newDescriptor, s.writer);
  }), n.setCustomProperty("addHighlight", (r, s, a) => i.add(s, a), o), n.setCustomProperty("removeHighlight", (r, s, a) => i.remove(s, a), o);
}
function CT(o, n) {
  o.getCustomProperty("widgetLabel").push(n);
}
function AT(o) {
  return o.getCustomProperty("widgetLabel").reduce((n, t) => typeof t == "function" ? n ? n + ". " + t() : t() : n ? n + ". " + t : t, "");
}
function a_(o, n, t = {}) {
  return n.addClass(["ck-editor__editable", "ck-editor__nested-editable"], o), t.withAriaRole !== !1 && n.setAttribute("role", "textbox", o), n.setAttribute("tabindex", "-1", o), t.label && n.setAttribute("aria-label", t.label, o), n.setAttribute("contenteditable", o.isReadOnly ? "false" : "true", o), o.on("change:isReadOnly", (e, i, r) => {
    n.setAttribute("contenteditable", r ? "false" : "true", o);
  }), o.on("change:isFocused", (e, i, r) => {
    r ? n.addClass("ck-editor__nested-editable_focused", o) : n.removeClass("ck-editor__nested-editable_focused", o);
  }), s_(o, n), o;
}
function Du(o, n) {
  const t = o.getSelectedElement();
  if (t) {
    const e = bi(o);
    if (e) return n.createRange(n.createPositionAt(t, e));
  }
  return n.schema.findOptimalInsertionRange(o);
}
function xT() {
  return null;
}
function bd(o) {
  const n = (s) => {
    const { width: a, paddingLeft: l, paddingRight: c } = s.ownerDocument.defaultView.getComputedStyle(s);
    return parseFloat(a) - (parseFloat(l) || 0) - (parseFloat(c) || 0);
  }, t = o.parentElement;
  if (!t) return 0;
  let e = n(t), i = 0, r = t;
  for (; isNaN(e); ) {
    if (r = r.parentElement, ++i > 5) return 0;
    e = n(r);
  }
  return e;
}
function ET(o, n = new K(o)) {
  const t = bd(o);
  return t ? n.width / t * 100 : 0;
}
const Gn = "widget-type-around";
function Hi(o, n, t) {
  return !!o && Yt(o) && !t.isInline(n);
}
function bi(o) {
  return o.getAttribute(Gn);
}
const Lg = ["before", "after"], TT = new DOMParser().parseFromString(nE, "image/svg+xml").firstChild, Bg = "ck-widget__type-around_disabled";
class ST extends A {
  constructor() {
    super(...arguments);
    m(this, "_currentFakeCaretModelElement", null);
  }
  static get pluginName() {
    return "WidgetTypeAround";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [pl, Rn];
  }
  init() {
    const t = this.editor, e = t.editing.view;
    this.on("change:isEnabled", (i, r, s) => {
      e.change((a) => {
        for (const l of e.document.roots) s ? a.removeClass(Bg, l) : a.addClass(Bg, l);
      }), s || t.model.change((a) => {
        a.removeSelectionAttribute(Gn);
      });
    }), this._enableTypeAroundUIInjection(), this._enableInsertingParagraphsOnButtonClick(), this._enableInsertingParagraphsOnEnterKeypress(), this._enableInsertingParagraphsOnTypingKeystroke(), this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(), this._enableDeleteIntegration(), this._enableInsertContentIntegration(), this._enableInsertObjectIntegration(), this._enableDeleteContentIntegration();
  }
  destroy() {
    super.destroy(), this._currentFakeCaretModelElement = null;
  }
  _insertParagraph(t, e) {
    const i = this.editor, r = i.editing.view, s = i.model.schema.getAttributesWithProperty(t, "copyOnReplace", !0);
    i.execute("insertParagraph", { position: i.model.createPositionAt(t, e), attributes: s }), r.focus(), r.scrollToTheSelection();
  }
  _listenToIfEnabled(t, e, i, r) {
    this.listenTo(t, e, (...s) => {
      this.isEnabled && i(...s);
    }, r);
  }
  _insertParagraphAccordingToFakeCaretPosition() {
    const t = this.editor.model.document.selection, e = bi(t);
    if (!e) return !1;
    const i = t.getSelectedElement();
    return this._insertParagraph(i, e), !0;
  }
  _enableTypeAroundUIInjection() {
    const t = this.editor, e = t.model.schema, i = t.locale.t, r = { before: i("Insert paragraph before block"), after: i("Insert paragraph after block") };
    t.editing.downcastDispatcher.on("insert", (s, a, l) => {
      const c = l.mapper.toViewElement(a.item);
      c && Hi(c, a.item, e) && (function(d, u, h) {
        const g = d.createUIElement("div", { class: "ck ck-reset_all ck-widget__type-around" }, function(f) {
          const p = this.toDomElement(f);
          return function(b, k) {
            for (const w of Lg) {
              const _ = new sn({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${w}`], title: k[w], "aria-hidden": "true" }, children: [b.ownerDocument.importNode(TT, !0)] });
              b.appendChild(_.render());
            }
          }(p, u), function(b) {
            const k = new sn({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__fake-caret"] } });
            b.appendChild(k.render());
          }(p), p;
        });
        d.insert(d.createPositionAt(h, "end"), g);
      }(l.writer, r, c), c.getCustomProperty("widgetLabel").push(() => this.isEnabled ? i("Press Enter to type after or press Shift + Enter to type before the widget") : ""));
    }, { priority: "low" });
  }
  _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
    const t = this.editor, e = t.model, i = e.document.selection, r = e.schema, s = t.editing.view;
    function a(l) {
      return `ck-widget_type-around_show-fake-caret_${l}`;
    }
    this._listenToIfEnabled(s.document, "arrowKey", (l, c) => {
      this._handleArrowKeyPress(l, c);
    }, { context: [Yt, "$text"], priority: "high" }), this._listenToIfEnabled(i, "change:range", (l, c) => {
      c.directChange && t.model.change((d) => {
        d.removeSelectionAttribute(Gn);
      });
    }), this._listenToIfEnabled(e.document, "change:data", () => {
      const l = i.getSelectedElement();
      l && Hi(t.editing.mapper.toViewElement(l), l, r) || t.model.change((c) => {
        c.removeSelectionAttribute(Gn);
      });
    }), this._listenToIfEnabled(t.editing.downcastDispatcher, "selection", (l, c, d) => {
      const u = d.writer;
      if (this._currentFakeCaretModelElement) {
        const p = d.mapper.toViewElement(this._currentFakeCaretModelElement);
        p && (u.removeClass(Lg.map(a), p), this._currentFakeCaretModelElement = null);
      }
      const h = c.selection.getSelectedElement();
      if (!h) return;
      const g = d.mapper.toViewElement(h);
      if (!Hi(g, h, r)) return;
      const f = bi(c.selection);
      f && (u.addClass(a(f), g), this._currentFakeCaretModelElement = h);
    }), this._listenToIfEnabled(t.ui.focusTracker, "change:isFocused", (l, c, d) => {
      d || t.model.change((u) => {
        u.removeSelectionAttribute(Gn);
      });
    });
  }
  _handleArrowKeyPress(t, e) {
    const i = this.editor, r = i.model, s = r.document.selection, a = r.schema, l = i.editing.view, c = xC(e.keyCode, i.locale.contentLanguageDirection), d = l.document.selection.getSelectedElement();
    let u;
    Hi(d, i.editing.mapper.toModelElement(d), a) ? u = this._handleArrowKeyPressOnSelectedWidget(c) : s.isCollapsed ? u = this._handleArrowKeyPressWhenSelectionNextToAWidget(c) : e.shiftKey || (u = this._handleArrowKeyPressWhenNonCollapsedSelection(c)), u && (e.preventDefault(), t.stop());
  }
  _handleArrowKeyPressOnSelectedWidget(t) {
    const e = this.editor.model, i = bi(e.document.selection);
    return e.change((r) => i ? i !== (t ? "after" : "before") ? (r.removeSelectionAttribute(Gn), !0) : !1 : (r.setSelectionAttribute(Gn, t ? "after" : "before"), !0));
  }
  _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
    const e = this.editor, i = e.model, r = i.schema, s = e.plugins.get("Widget"), a = s._getObjectElementNextToSelection(t);
    return !!Hi(e.editing.mapper.toViewElement(a), a, r) && (i.change((l) => {
      s._setSelectionOverElement(a), l.setSelectionAttribute(Gn, t ? "before" : "after");
    }), !0);
  }
  _handleArrowKeyPressWhenNonCollapsedSelection(t) {
    const e = this.editor, i = e.model, r = i.schema, s = e.editing.mapper, a = i.document.selection, l = t ? a.getLastPosition().nodeBefore : a.getFirstPosition().nodeAfter;
    return !!Hi(s.toViewElement(l), l, r) && (i.change((c) => {
      c.setSelection(l, "on"), c.setSelectionAttribute(Gn, t ? "after" : "before");
    }), !0);
  }
  _enableInsertingParagraphsOnButtonClick() {
    const t = this.editor, e = t.editing.view;
    this._listenToIfEnabled(e.document, "mousedown", (i, r) => {
      const s = r.domTarget.closest(".ck-widget__type-around__button");
      if (!s) return;
      const a = function(d) {
        return d.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
      }(s), l = function(d, u) {
        const h = d.closest(".ck-widget");
        return u.mapDomToView(h);
      }(s, e.domConverter), c = t.editing.mapper.toModelElement(l);
      this._insertParagraph(c, a), r.preventDefault(), i.stop();
    });
  }
  _enableInsertingParagraphsOnEnterKeypress() {
    const t = this.editor, e = t.model.document.selection, i = t.editing.view;
    this._listenToIfEnabled(i.document, "enter", (r, s) => {
      if (r.eventPhase != "atTarget") return;
      const a = e.getSelectedElement(), l = t.editing.mapper.toViewElement(a), c = t.model.schema;
      let d;
      this._insertParagraphAccordingToFakeCaretPosition() ? d = !0 : Hi(l, a, c) && (this._insertParagraph(a, s.isSoft ? "before" : "after"), d = !0), d && (s.preventDefault(), r.stop());
    }, { context: Yt });
  }
  _enableInsertingParagraphsOnTypingKeystroke() {
    const t = this.editor.editing.view.document;
    this._listenToIfEnabled(t, "insertText", (e, i) => {
      this._insertParagraphAccordingToFakeCaretPosition() && (i.selection = t.selection);
    }, { priority: "high" }), H.isAndroid ? this._listenToIfEnabled(t, "keydown", (e, i) => {
      i.keyCode == 229 && this._insertParagraphAccordingToFakeCaretPosition();
    }) : this._listenToIfEnabled(t, "compositionstart", () => {
      this._insertParagraphAccordingToFakeCaretPosition();
    }, { priority: "high" });
  }
  _enableDeleteIntegration() {
    const t = this.editor, e = t.editing.view, i = t.model, r = i.schema;
    this._listenToIfEnabled(e.document, "delete", (s, a) => {
      if (s.eventPhase != "atTarget") return;
      const l = bi(i.document.selection);
      if (!l) return;
      const c = a.direction, d = i.document.selection.getSelectedElement(), u = c == "forward";
      if (l === "before" === u) t.execute("delete", { selection: i.createSelection(d, "on") });
      else {
        const h = r.getNearestSelectionRange(i.createPositionAt(d, l), c);
        if (h) if (h.isCollapsed) {
          const g = i.createSelection(h.start);
          if (i.modifySelection(g, { direction: c }), g.focus.isEqual(h.start)) {
            const f = function(p, b) {
              let k = b;
              for (const w of b.getAncestors({ parentFirst: !0 })) {
                if (w.childCount > 1 || p.isLimit(w)) break;
                k = w;
              }
              return k;
            }(r, h.start.parent);
            i.deleteContent(i.createSelection(f, "on"), { doNotAutoparagraph: !0 });
          } else i.change((f) => {
            f.setSelection(h), t.execute(u ? "deleteForward" : "delete");
          });
        } else i.change((g) => {
          g.setSelection(h), t.execute(u ? "deleteForward" : "delete");
        });
      }
      a.preventDefault(), s.stop();
    }, { context: Yt });
  }
  _enableInsertContentIntegration() {
    const t = this.editor, e = this.editor.model, i = e.document.selection;
    this._listenToIfEnabled(t.model, "insertContent", (r, [s, a]) => {
      if (a && !a.is("documentSelection")) return;
      const l = bi(i);
      return l ? (r.stop(), e.change((c) => {
        const d = i.getSelectedElement(), u = e.createPositionAt(d, l), h = c.createSelection(u), g = e.insertContent(s, h);
        return c.setSelection(h), g;
      })) : void 0;
    }, { priority: "high" });
  }
  _enableInsertObjectIntegration() {
    const t = this.editor, e = this.editor.model.document.selection;
    this._listenToIfEnabled(t.model, "insertObject", (i, r) => {
      const [, s, a = {}] = r;
      if (s && !s.is("documentSelection")) return;
      const l = bi(e);
      l && (a.findOptimalPosition = l, r[3] = a);
    }, { priority: "high" });
  }
  _enableDeleteContentIntegration() {
    const t = this.editor, e = this.editor.model.document.selection;
    this._listenToIfEnabled(t.model, "deleteContent", (i, [r]) => {
      r && !r.is("documentSelection") || bi(e) && i.stop();
    }, { priority: "high" });
  }
}
function IT(o) {
  const n = o.model;
  return (t, e) => {
    const i = e.keyCode == nt.arrowup, r = e.keyCode == nt.arrowdown, s = e.shiftKey, a = n.document.selection;
    if (!i && !r) return;
    const l = r;
    if (s && function(d, u) {
      return !d.isCollapsed && d.isBackward == u;
    }(a, l)) return;
    const c = function(d, u, h) {
      const g = d.model;
      if (h) {
        const f = u.isCollapsed ? u.focus : u.getLastPosition(), p = Ng(g, f, "forward");
        if (!p) return null;
        const b = g.createRange(f, p), k = zg(g.schema, b, "backward");
        return k ? g.createRange(f, k) : null;
      }
      {
        const f = u.isCollapsed ? u.focus : u.getFirstPosition(), p = Ng(g, f, "backward");
        if (!p) return null;
        const b = g.createRange(p, f), k = zg(g.schema, b, "forward");
        return k ? g.createRange(k, f) : null;
      }
    }(o, a, l);
    if (c) {
      if (c.isCollapsed && (a.isCollapsed || s))
        return;
      (c.isCollapsed || function(d, u, h) {
        const g = d.model, f = d.view.domConverter;
        if (h) {
          const _ = g.createSelection(u.start);
          g.modifySelection(_), _.focus.isAtEnd || u.start.isEqual(_.focus) || (u = g.createRange(_.focus, u.end));
        }
        const p = d.mapper.toViewRange(u), b = f.viewRangeToDom(p), k = K.getDomRangeRects(b);
        let w;
        for (const _ of k) if (w !== void 0) {
          if (Math.round(_.top) >= w) return !1;
          w = Math.max(w, Math.round(_.bottom));
        } else w = Math.round(_.bottom);
        return !0;
      }(o, c, l)) && (n.change((d) => {
        const u = l ? c.end : c.start;
        if (s) {
          const h = n.createSelection(a.anchor);
          h.setFocus(u), d.setSelection(h);
        } else d.setSelection(u);
      }), t.stop(), e.preventDefault(), e.stopPropagation());
    }
  };
}
function Ng(o, n, t) {
  const e = o.schema, i = o.createRangeIn(n.root), r = t == "forward" ? "elementStart" : "elementEnd";
  for (const { previousPosition: s, item: a, type: l } of i.getWalker({ startPosition: n, direction: t })) {
    if (e.isLimit(a) && !e.isInline(a)) return s;
    if (l == r && e.isBlock(a)) return null;
  }
  return null;
}
function zg(o, n, t) {
  const e = t == "backward" ? n.end : n.start;
  if (o.checkChild(e, "$text")) return e;
  for (const { nextPosition: i } of n.getWalker({ direction: t })) if (o.checkChild(i, "$text")) return i;
  return null;
}
class cr extends A {
  constructor() {
    super(...arguments);
    m(this, "_previouslySelected", /* @__PURE__ */ new Set());
  }
  static get pluginName() {
    return "Widget";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [ST, Rn];
  }
  init() {
    const t = this.editor, e = t.editing.view, i = e.document, r = t.t;
    this.editor.editing.downcastDispatcher.on("selection", (s, a, l) => {
      const c = l.writer, d = a.selection;
      if (d.isCollapsed) return;
      const u = d.getSelectedElement();
      if (!u) return;
      const h = t.editing.mapper.toViewElement(u);
      Yt(h) && l.consumable.consume(d, "selection") && c.setSelection(c.createRangeOn(h), { fake: !0, label: AT(h) });
    }), this.editor.editing.downcastDispatcher.on("selection", (s, a, l) => {
      this._clearPreviouslySelectedWidgets(l.writer);
      const c = l.writer, d = c.document.selection;
      let u = null;
      for (const h of d.getRanges()) for (const g of h) {
        const f = g.item;
        Yt(f) && !MT(f, u) && (c.addClass(Pg, f), this._previouslySelected.add(f), u = f);
      }
    }, { priority: "low" }), e.addObserver(dl), this.listenTo(i, "mousedown", (...s) => this._onMousedown(...s)), this.listenTo(i, "arrowKey", (...s) => {
      this._handleSelectionChangeOnArrowKeyPress(...s);
    }, { context: [Yt, "$text"] }), this.listenTo(i, "arrowKey", (...s) => {
      this._preventDefaultOnArrowKeyPress(...s);
    }, { context: "$root" }), this.listenTo(i, "arrowKey", IT(this.editor.editing), { context: "$text" }), this.listenTo(i, "delete", (s, a) => {
      this._handleDelete(a.direction == "forward") && (a.preventDefault(), s.stop());
    }, { context: "$root" }), this.listenTo(i, "tab", (s, a) => {
      s.eventPhase == "atTarget" && (a.shiftKey || this._selectFirstNestedEditable() && (a.preventDefault(), s.stop()));
    }, { context: Yt, priority: "low" }), this.listenTo(i, "tab", (s, a) => {
      a.shiftKey && this._selectAncestorWidget() && (a.preventDefault(), s.stop());
    }, { priority: "low" }), this.listenTo(i, "keydown", (s, a) => {
      a.keystroke == nt.esc && this._selectAncestorWidget() && (a.preventDefault(), s.stop());
    }, { priority: "low" }), t.accessibility.addKeystrokeInfoGroup({ id: "widget", label: r("Keystrokes that can be used when a widget is selected (for example: image, table, etc.)"), keystrokes: [{ label: r("Move focus from an editable area back to the parent widget"), keystroke: "Esc" }, { label: r("Insert a new paragraph directly after a widget"), keystroke: "Enter" }, { label: r("Insert a new paragraph directly before a widget"), keystroke: "Shift+Enter" }, { label: r("Move the caret to allow typing directly before a widget"), keystroke: [["arrowup"], ["arrowleft"]] }, { label: r("Move the caret to allow typing directly after a widget"), keystroke: [["arrowdown"], ["arrowright"]] }] });
  }
  _onMousedown(t, e) {
    const i = this.editor, r = i.editing.view, s = r.document;
    let a = e.target;
    if (!a) return;
    if (e.domEvent.detail >= 3) return void (this._selectBlockContent(a) && e.preventDefault());
    if (!Yt(a)) {
      const c = function(d) {
        let u = d;
        for (; u; ) {
          if (u.is("editableElement") || Yt(u)) return u;
          u = u.parent;
        }
        return null;
      }(a);
      if (!c) return;
      if (Yt(c)) a = c;
      else {
        const d = function(u, h) {
          const g = wk(h.domEvent);
          let f = null;
          if (f = g ? u.domConverter.domRangeToView(g) : u.createRange(u.createPositionAt(h.target, 0)), !f) return null;
          const p = f.start;
          if (!p.parent) return null;
          let b = p.parent;
          return p.parent.is("editableElement") && (p.isAtEnd && p.nodeBefore ? b = p.nodeBefore : p.isAtStart && p.nodeAfter && (b = p.nodeAfter)), b.is("$text") ? b.parent : b;
        }(r, e);
        if (!d || !Yt(d)) return;
        a = d;
      }
    }
    H.isAndroid && e.preventDefault(), s.isFocused || r.focus();
    const l = i.editing.mapper.toModelElement(a);
    this._setSelectionOverElement(l);
  }
  _selectBlockContent(t) {
    const e = this.editor, i = e.model, r = e.editing.mapper, s = i.schema, a = r.findMappedViewAncestor(this.editor.editing.view.createPositionAt(t, 0)), l = function(c, d) {
      for (const u of c.getAncestors({ includeSelf: !0, parentFirst: !0 })) {
        if (d.checkChild(u, "$text")) return u;
        if (d.isLimit(u) && !d.isObject(u)) break;
      }
      return null;
    }(r.toModelElement(a), i.schema);
    return !!l && (i.change((c) => {
      const d = s.isLimit(l) ? null : function(g, f) {
        const p = new Jn({ startPosition: g });
        for (const { item: b } of p) {
          if (f.isLimit(b) || !b.is("element")) return null;
          if (f.checkChild(b, "$text")) return b;
        }
        return null;
      }(c.createPositionAfter(l), s), u = c.createPositionAt(l, 0), h = d ? c.createPositionAt(d, 0) : c.createPositionAt(l, "end");
      c.setSelection(c.createRange(u, h));
    }), !0);
  }
  _handleSelectionChangeOnArrowKeyPress(t, e) {
    const i = e.keyCode, r = this.editor.model, s = r.schema, a = r.document.selection, l = a.getSelectedElement(), c = rl(i, this.editor.locale.contentLanguageDirection), d = c == "down" || c == "right", u = c == "up" || c == "down";
    if (l && s.isObject(l)) {
      const g = d ? a.getLastPosition() : a.getFirstPosition(), f = s.getNearestSelectionRange(g, d ? "forward" : "backward");
      return void (f && (r.change((p) => {
        p.setSelection(f);
      }), e.preventDefault(), t.stop()));
    }
    if (!a.isCollapsed && !e.shiftKey) {
      const g = a.getFirstPosition(), f = a.getLastPosition(), p = g.nodeAfter, b = f.nodeBefore;
      return void ((p && s.isObject(p) || b && s.isObject(b)) && (r.change((k) => {
        k.setSelection(d ? f : g);
      }), e.preventDefault(), t.stop()));
    }
    if (!a.isCollapsed) return;
    const h = this._getObjectElementNextToSelection(d);
    if (h && s.isObject(h)) {
      if (s.isInline(h) && u) return;
      this._setSelectionOverElement(h), e.preventDefault(), t.stop();
    }
  }
  _preventDefaultOnArrowKeyPress(t, e) {
    const i = this.editor.model, r = i.schema, s = i.document.selection.getSelectedElement();
    s && r.isObject(s) && (e.preventDefault(), t.stop());
  }
  _handleDelete(t) {
    const e = this.editor.model.document.selection;
    if (!this.editor.model.canEditAt(e) || !e.isCollapsed) return;
    const i = this._getObjectElementNextToSelection(t);
    return i ? (this.editor.model.change((r) => {
      let s = e.anchor.parent;
      for (; s.isEmpty; ) {
        const a = s;
        s = a.parent, r.remove(a);
      }
      this._setSelectionOverElement(i);
    }), !0) : void 0;
  }
  _setSelectionOverElement(t) {
    this.editor.model.change((e) => {
      e.setSelection(e.createRangeOn(t));
    });
  }
  _getObjectElementNextToSelection(t) {
    const e = this.editor.model, i = e.schema, r = e.document.selection, s = e.createSelection(r);
    if (e.modifySelection(s, { direction: t ? "forward" : "backward" }), s.isEqual(r)) return null;
    const a = t ? s.focus.nodeBefore : s.focus.nodeAfter;
    return a && i.isObject(a) ? a : null;
  }
  _clearPreviouslySelectedWidgets(t) {
    for (const e of this._previouslySelected) t.removeClass(Pg, e);
    this._previouslySelected.clear();
  }
  _selectFirstNestedEditable() {
    const t = this.editor, e = this.editor.editing.view.document;
    for (const i of e.selection.getFirstRange().getItems()) if (i.is("editableElement")) {
      const r = t.editing.mapper.toModelElement(i);
      if (!r) continue;
      const s = t.model.createPositionAt(r, 0), a = t.model.schema.getNearestSelectionRange(s, "forward");
      return t.model.change((l) => {
        l.setSelection(a);
      }), !0;
    }
    return !1;
  }
  _selectAncestorWidget() {
    const t = this.editor, e = t.editing.mapper, i = t.editing.view.document.selection.getFirstPosition().parent, r = (i.is("$text") ? i.parent : i).findAncestor(Yt);
    if (!r) return !1;
    const s = e.toModelElement(r);
    return !!s && (t.model.change((a) => {
      a.setSelection(s, "on");
    }), !0);
  }
}
function MT(o, n) {
  return !!n && Array.from(o.getAncestors()).includes(n);
}
class La extends A {
  constructor() {
    super(...arguments);
    m(this, "_toolbarDefinitions", /* @__PURE__ */ new Map());
    m(this, "_balloon");
  }
  static get requires() {
    return [On];
  }
  static get pluginName() {
    return "WidgetToolbarRepository";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor;
    if (t.plugins.has("BalloonToolbar")) {
      const e = t.plugins.get("BalloonToolbar");
      this.listenTo(e, "show", (i) => {
        (function(r) {
          const s = r.getSelectedElement();
          return !(!s || !Yt(s));
        })(t.editing.view.document.selection) && i.stop();
      }, { priority: "high" });
    }
    this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", () => {
      this._updateToolbarsVisibility();
    }), this.listenTo(t.ui, "update", () => {
      this._updateToolbarsVisibility();
    }), this.listenTo(t.ui.focusTracker, "change:isFocused", () => {
      this._updateToolbarsVisibility();
    }, { priority: "low" });
  }
  destroy() {
    super.destroy();
    for (const t of this._toolbarDefinitions.values()) t.view.destroy();
  }
  register(t, { ariaLabel: e, items: i, getRelatedElement: r, balloonClassName: s = "ck-toolbar-container", positions: a }) {
    if (!i.length) return void at("widget-toolbar-no-items", { toolbarId: t });
    const l = this.editor, c = l.t, d = new Cs(l.locale);
    if (d.ariaLabel = e || c("Widget toolbar"), this._toolbarDefinitions.has(t)) throw new v("widget-toolbar-duplicated", this, { toolbarId: t });
    const u = { view: d, getRelatedElement: r, balloonClassName: s, itemsConfig: i, positions: a, initialized: !1 };
    l.ui.addToolbar(d, { isContextual: !0, beforeFocus: () => {
      const h = r(l.editing.view.document.selection);
      h && this._showToolbar(u, h);
    }, afterBlur: () => {
      this._hideToolbar(u);
    } }), this._toolbarDefinitions.set(t, u);
  }
  _updateToolbarsVisibility() {
    let t = 0, e = null, i = null;
    for (const r of this._toolbarDefinitions.values()) {
      const s = r.getRelatedElement(this.editor.editing.view.document.selection);
      if (this.isEnabled && s) if (this.editor.ui.focusTracker.isFocused) {
        const a = s.getAncestors().length;
        a > t && (t = a, e = s, i = r);
      } else this._isToolbarVisible(r) && this._hideToolbar(r);
      else this._isToolbarInBalloon(r) && this._hideToolbar(r);
    }
    i && this._showToolbar(i, e);
  }
  _hideToolbar(t) {
    this._balloon.remove(t.view), this.stopListening(this._balloon, "change:visibleView");
  }
  _showToolbar(t, e) {
    this._isToolbarVisible(t) ? Og(this.editor, e, t.positions) : this._isToolbarInBalloon(t) || (t.initialized || (t.initialized = !0, t.view.fillFromConfig(t.itemsConfig, this.editor.ui.componentFactory)), this._balloon.add({ view: t.view, position: l_(this.editor, e, t.positions), balloonClassName: t.balloonClassName }), this.listenTo(this._balloon, "change:visibleView", () => {
      for (const i of this._toolbarDefinitions.values()) if (this._isToolbarVisible(i)) {
        const r = i.getRelatedElement(this.editor.editing.view.document.selection);
        Og(this.editor, r, t.positions);
      }
    }));
  }
  _isToolbarVisible(t) {
    return this._balloon.visibleView === t.view;
  }
  _isToolbarInBalloon(t) {
    return this._balloon.hasView(t.view);
  }
}
function Og(o, n, t) {
  const e = o.plugins.get("ContextualBalloon"), i = l_(o, n, t);
  e.updatePosition(i);
}
function l_(o, n, t) {
  const e = o.editing.view, i = se.defaultPositions;
  return { target: e.domConverter.mapViewToDom(n), positions: t || [i.northArrowSouth, i.northArrowSouthWest, i.northArrowSouthEast, i.southArrowNorth, i.southArrowNorthWest, i.southArrowNorthEast, i.viewportStickyNorth] };
}
class DT extends _t() {
  constructor(t) {
    super();
    m(this, "_referenceCoordinates");
    m(this, "_options");
    m(this, "_originalWidth");
    m(this, "_originalHeight");
    m(this, "_originalWidthPercents");
    m(this, "_aspectRatio");
    this.set("activeHandlePosition", null), this.set("proposedWidthPercents", null), this.set("proposedWidth", null), this.set("proposedHeight", null), this.set("proposedHandleHostWidth", null), this.set("proposedHandleHostHeight", null), this._options = t, this._referenceCoordinates = null;
  }
  get originalWidth() {
    return this._originalWidth;
  }
  get originalHeight() {
    return this._originalHeight;
  }
  get originalWidthPercents() {
    return this._originalWidthPercents;
  }
  get aspectRatio() {
    return this._aspectRatio;
  }
  begin(t, e, i) {
    const r = new K(e);
    this.activeHandlePosition = function(a) {
      const l = ["top-left", "top-right", "bottom-right", "bottom-left"];
      for (const c of l) if (a.classList.contains(PT(c))) return c;
    }(t), this._referenceCoordinates = function(a, l) {
      const c = new K(a), d = l.split("-"), u = { x: d[1] == "right" ? c.right : c.left, y: d[0] == "bottom" ? c.bottom : c.top };
      return u.x += a.ownerDocument.defaultView.scrollX, u.y += a.ownerDocument.defaultView.scrollY, u;
    }(e, function(a) {
      const l = a.split("-"), c = { top: "bottom", bottom: "top", left: "right", right: "left" };
      return `${c[l[0]]}-${c[l[1]]}`;
    }(this.activeHandlePosition)), this._originalWidth = r.width, this._originalHeight = r.height, this._aspectRatio = r.width / r.height;
    const s = i.style.width;
    s && s.match(/^\d+(\.\d*)?%$/) ? this._originalWidthPercents = parseFloat(s) : this._originalWidthPercents = ET(i, r);
  }
  update(t) {
    this.proposedWidth = t.width, this.proposedHeight = t.height, this.proposedWidthPercents = t.widthPercents, this.proposedHandleHostWidth = t.handleHostWidth, this.proposedHandleHostHeight = t.handleHostHeight;
  }
}
function PT(o) {
  return `ck-widget__resizer__handle-${o}`;
}
class LT extends L {
  constructor() {
    super();
    const n = this.bindTemplate;
    this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-size-view", n.to("_viewPosition", (t) => t ? `ck-orientation-${t}` : "")], style: { display: n.if("_isVisible", "none", (t) => !t) } }, children: [{ text: n.to("_label") }] });
  }
  _bindToState(n, t) {
    this.bind("_isVisible").to(t, "proposedWidth", t, "proposedHeight", (e, i) => e !== null && i !== null), this.bind("_label").to(t, "proposedHandleHostWidth", t, "proposedHandleHostHeight", t, "proposedWidthPercents", (e, i, r) => n.unit === "px" ? `${e}${i}` : `${r}%`), this.bind("_viewPosition").to(t, "activeHandlePosition", t, "proposedHandleHostWidth", t, "proposedHandleHostHeight", (e, i, r) => i < 50 || r < 50 ? "above-center" : e);
  }
  _dismiss() {
    this.unbind(), this._isVisible = !1;
  }
}
class Rg extends _t() {
  constructor(t) {
    super();
    m(this, "_state");
    m(this, "_sizeView");
    m(this, "_options");
    m(this, "_viewResizerWrapper", null);
    m(this, "_initialViewWidth");
    this._options = t, this.set("isEnabled", !0), this.set("isSelected", !1), this.bind("isVisible").to(this, "isEnabled", this, "isSelected", (e, i) => e && i), this.decorate("begin"), this.decorate("cancel"), this.decorate("commit"), this.decorate("updateSize"), this.on("commit", (e) => {
      this.state.proposedWidth || this.state.proposedWidthPercents || (this._cleanup(), e.stop());
    }, { priority: "high" });
  }
  get state() {
    return this._state;
  }
  show() {
    this._options.editor.editing.view.change((t) => {
      t.removeClass("ck-hidden", this._viewResizerWrapper);
    });
  }
  hide() {
    this._options.editor.editing.view.change((t) => {
      t.addClass("ck-hidden", this._viewResizerWrapper);
    });
  }
  attach() {
    const t = this, e = this._options.viewElement;
    this._options.editor.editing.view.change((i) => {
      const r = i.createUIElement("div", { class: "ck ck-reset_all ck-widget__resizer" }, function(s) {
        const a = this.toDomElement(s);
        return t._appendHandles(a), t._appendSizeUI(a), a;
      });
      i.insert(i.createPositionAt(e, "end"), r), i.addClass("ck-widget_with-resizer", e), this._viewResizerWrapper = r, this.isVisible || this.hide();
    }), this.on("change:isVisible", () => {
      this.isVisible ? (this.show(), this.redraw()) : this.hide();
    });
  }
  begin(t) {
    this._state = new DT(this._options), this._sizeView._bindToState(this._options, this.state), this._initialViewWidth = this._options.viewElement.getStyle("width"), this.state.begin(t, this._getHandleHost(), this._getResizeHost());
  }
  updateSize(t) {
    const e = this._proposeNewSize(t);
    this._options.editor.editing.view.change((c) => {
      const d = this._options.unit || "%", u = (d === "%" ? e.widthPercents : e.width) + d;
      c.setStyle("width", u, this._options.viewElement);
    });
    const i = this._getHandleHost(), r = new K(i), s = Math.round(r.width), a = Math.round(r.height), l = new K(i);
    e.width = Math.round(l.width), e.height = Math.round(l.height), this.redraw(r), this.state.update({ ...e, handleHostWidth: s, handleHostHeight: a });
  }
  commit() {
    const t = this._options.unit || "%", e = (t === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + t;
    this._options.editor.editing.view.change(() => {
      this._cleanup(), this._options.onCommit(e);
    });
  }
  cancel() {
    this._cleanup();
  }
  destroy() {
    this.cancel();
  }
  redraw(t) {
    const e = this._domResizerWrapper;
    if (!((i = e) && i.ownerDocument && i.ownerDocument.contains(i))) return;
    var i;
    const r = e.parentElement, s = this._getHandleHost(), a = this._viewResizerWrapper, l = [a.getStyle("width"), a.getStyle("height"), a.getStyle("left"), a.getStyle("top")];
    let c;
    if (r.isSameNode(s)) {
      const d = t || new K(s);
      c = [d.width + "px", d.height + "px", void 0, void 0];
    } else c = [s.offsetWidth + "px", s.offsetHeight + "px", s.offsetLeft + "px", s.offsetTop + "px"];
    xe(l, c) !== "same" && this._options.editor.editing.view.change((d) => {
      d.setStyle({ width: c[0], height: c[1], left: c[2], top: c[3] }, a);
    });
  }
  containsHandle(t) {
    return this._domResizerWrapper.contains(t);
  }
  static isResizeHandle(t) {
    return t.classList.contains("ck-widget__resizer__handle");
  }
  _cleanup() {
    this._sizeView._dismiss(), this._options.editor.editing.view.change((t) => {
      t.setStyle("width", this._initialViewWidth, this._options.viewElement);
    });
  }
  _proposeNewSize(t) {
    const e = this.state, i = { x: (r = t).pageX, y: r.pageY };
    var r;
    const s = !this._options.isCentered || this._options.isCentered(this), a = { x: e._referenceCoordinates.x - (i.x + e.originalWidth), y: i.y - e.originalHeight - e._referenceCoordinates.y };
    s && e.activeHandlePosition.endsWith("-right") && (a.x = i.x - (e._referenceCoordinates.x + e.originalWidth)), s && (a.x *= 2);
    let l = Math.abs(e.originalWidth + a.x), c = Math.abs(e.originalHeight + a.y);
    return (l / e.aspectRatio > c ? "width" : "height") == "width" ? c = l / e.aspectRatio : l = c * e.aspectRatio, { width: Math.round(l), height: Math.round(c), widthPercents: Math.min(Math.round(e.originalWidthPercents / e.originalWidth * l * 100) / 100, 100) };
  }
  _getResizeHost() {
    const t = this._domResizerWrapper.parentElement;
    return this._options.getResizeHost(t);
  }
  _getHandleHost() {
    const t = this._domResizerWrapper.parentElement;
    return this._options.getHandleHost(t);
  }
  get _domResizerWrapper() {
    return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper);
  }
  _appendHandles(t) {
    const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
    for (const r of e) t.appendChild(new sn({ tag: "div", attributes: { class: "ck-widget__resizer__handle " + (i = r, `ck-widget__resizer__handle-${i}`) } }).render());
    var i;
  }
  _appendSizeUI(t) {
    this._sizeView = new LT(), this._sizeView.render(), t.appendChild(this._sizeView.element);
  }
}
class ac extends A {
  constructor() {
    super(...arguments);
    m(this, "_resizers", /* @__PURE__ */ new Map());
    m(this, "_observer");
    m(this, "_redrawSelectedResizerThrottled");
  }
  static get pluginName() {
    return "WidgetResize";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor.editing, e = N.window.document;
    this.set("selectedResizer", null), this.set("_activeResizer", null), t.view.addObserver(dl), this._observer = new (Pe())(), this.listenTo(t.view.document, "mousedown", this._mouseDownListener.bind(this), { priority: "high" }), this._observer.listenTo(e, "mousemove", this._mouseMoveListener.bind(this)), this._observer.listenTo(e, "mouseup", this._mouseUpListener.bind(this)), this._redrawSelectedResizerThrottled = Qo(() => this.redrawSelectedResizer(), 200), this.editor.ui.on("update", this._redrawSelectedResizerThrottled), this.editor.model.document.on("change", () => {
      for (const [r, s] of this._resizers) r.isAttached() || (this._resizers.delete(r), s.destroy());
    }, { priority: "lowest" }), this._observer.listenTo(N.window, "resize", this._redrawSelectedResizerThrottled);
    const i = this.editor.editing.view.document.selection;
    i.on("change", () => {
      const r = i.getSelectedElement(), s = this.getResizerByViewElement(r) || null;
      s ? this.select(s) : this.deselect();
    });
  }
  redrawSelectedResizer() {
    this.selectedResizer && this.selectedResizer.isVisible && this.selectedResizer.redraw();
  }
  destroy() {
    super.destroy(), this._observer.stopListening();
    for (const t of this._resizers.values()) t.destroy();
    this._redrawSelectedResizerThrottled.cancel();
  }
  select(t) {
    this.deselect(), this.selectedResizer = t, this.selectedResizer.isSelected = !0;
  }
  deselect() {
    this.selectedResizer && (this.selectedResizer.isSelected = !1), this.selectedResizer = null;
  }
  attachTo(t) {
    const e = new Rg(t), i = this.editor.plugins;
    if (e.attach(), i.has("WidgetToolbarRepository")) {
      const s = i.get("WidgetToolbarRepository");
      e.on("begin", () => {
        s.forceDisabled("resize");
      }, { priority: "lowest" }), e.on("cancel", () => {
        s.clearForceDisabled("resize");
      }, { priority: "highest" }), e.on("commit", () => {
        s.clearForceDisabled("resize");
      }, { priority: "highest" });
    }
    this._resizers.set(t.viewElement, e);
    const r = this.editor.editing.view.document.selection.getSelectedElement();
    return this.getResizerByViewElement(r) == e && this.select(e), e;
  }
  getResizerByViewElement(t) {
    return this._resizers.get(t);
  }
  _getResizerByHandle(t) {
    for (const e of this._resizers.values()) if (e.containsHandle(t)) return e;
  }
  _mouseDownListener(t, e) {
    const i = e.domTarget;
    Rg.isResizeHandle(i) && (this._activeResizer = this._getResizerByHandle(i) || null, this._activeResizer && (this._activeResizer.begin(i), t.stop(), e.preventDefault()));
  }
  _mouseMoveListener(t, e) {
    this._activeResizer && this._activeResizer.updateSize(e);
  }
  _mouseUpListener() {
    this._activeResizer && (this._activeResizer.commit(), this._activeResizer = null);
  }
}
class as extends Fn {
  constructor(t) {
    super(t);
    m(this, "domEventType", ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"]);
    const e = this.document;
    function i(r) {
      return (s, a) => {
        a.preventDefault();
        const l = a.dropRange ? [a.dropRange] : null, c = new oi(e, r);
        e.fire(c, { dataTransfer: a.dataTransfer, method: s.name, targetRanges: l, target: a.target, domEvent: a.domEvent }), c.stop.called && a.stopPropagation();
      };
    }
    this.listenTo(e, "paste", i("clipboardInput"), { priority: "low" }), this.listenTo(e, "drop", i("clipboardInput"), { priority: "low" }), this.listenTo(e, "dragover", i("dragging"), { priority: "low" });
  }
  onDomEvent(t) {
    const e = "clipboardData" in t ? t.clipboardData : t.dataTransfer, i = t.type == "drop" || t.type == "paste", r = { dataTransfer: new Hk(e, { cacheFiles: i }) };
    if (t.type == "drop" || t.type == "dragover") {
      const s = wk(t);
      r.dropRange = s && this.view.domConverter.domRangeToView(s);
    }
    this.fire(t.type, t, r);
  }
}
function BT(o) {
  return ((o = o.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;")).includes("</p><p>") || o.includes("<br>")) && (o = `<p>${o}</p>`), o;
}
const Vg = ["figcaption", "li"], Fg = ["ol", "ul"];
function c_(o, n) {
  if (n.is("$text") || n.is("$textProxy")) return n.data;
  if (n.is("element", "img") && n.hasAttribute("alt")) return n.getAttribute("alt");
  if (n.is("element", "br")) return `
`;
  let t = "", e = null;
  for (const i of n.getChildren()) t += NT(i, e) + c_(o, i), e = i;
  if (n.is("rawElement")) {
    const i = document.createElement("div");
    n.render(i, o), t += d_(i);
  }
  return t;
}
function d_(o) {
  let n = "";
  if (o.nodeType === Node.TEXT_NODE) return o.textContent;
  if (o.tagName === "BR") return `
`;
  for (const t of o.childNodes) n += d_(t);
  return n;
}
function NT(o, n) {
  return n ? o.is("element", "li") && !o.isEmpty && o.getChild(0).is("containerElement") || Fg.includes(o.name) && Fg.includes(n.name) ? `

` : o.is("containerElement") || n.is("containerElement") ? Vg.includes(o.name) || Vg.includes(n.name) ? `
` : o.is("element") && o.getCustomProperty("dataPipeline:transparentRendering") || n.is("element") && n.getCustomProperty("dataPipeline:transparentRendering") ? "" : `

` : "" : "";
}
class qr extends A {
  constructor() {
    super(...arguments);
    m(this, "_markersToCopy", /* @__PURE__ */ new Map());
  }
  static get pluginName() {
    return "ClipboardMarkersUtils";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  _registerMarkerToCopy(t, e) {
    this._markersToCopy.set(t, e);
  }
  _copySelectedFragmentWithMarkers(t, e, i = (r) => r.model.getSelectedContent(r.model.document.selection)) {
    return this.editor.model.change((r) => {
      const s = r.model.document.selection;
      r.setSelection(e);
      const a = this._insertFakeMarkersIntoSelection(r, r.model.document.selection, t), l = i(r), c = this._removeFakeMarkersInsideElement(r, l);
      for (const [d, u] of Object.entries(a)) {
        c[d] || (c[d] = r.createRangeIn(l));
        for (const h of u) r.remove(h);
      }
      l.markers.clear();
      for (const [d, u] of Object.entries(c)) l.markers.set(d, u);
      return r.setSelection(s), l;
    });
  }
  _pasteMarkersIntoTransformedElement(t, e) {
    const i = this._getPasteMarkersFromRangeMap(t);
    return this.editor.model.change((r) => {
      const s = this._insertFakeMarkersElements(r, i), a = e(r), l = this._removeFakeMarkersInsideElement(r, a);
      for (const c of Object.values(s).flat()) r.remove(c);
      for (const [c, d] of Object.entries(l)) r.model.markers.has(c) || r.addMarker(c, { usingOperation: !0, affectsData: !0, range: d });
      return a;
    });
  }
  _pasteFragmentWithMarkers(t) {
    const e = this._getPasteMarkersFromRangeMap(t.markers);
    t.markers.clear();
    for (const i of e) t.markers.set(i.name, i.range);
    return this.editor.model.insertContent(t);
  }
  _forceMarkersCopy(t, e, i = { allowedActions: "all", copyPartiallySelected: !0, duplicateOnPaste: !0 }) {
    const r = this._markersToCopy.get(t);
    this._markersToCopy.set(t, i), e(), r ? this._markersToCopy.set(t, r) : this._markersToCopy.delete(t);
  }
  _isMarkerCopyable(t, e) {
    const i = this._getMarkerClipboardConfig(t);
    if (!i) return !1;
    if (!e) return !0;
    const { allowedActions: r } = i;
    return r === "all" || r.includes(e);
  }
  _hasMarkerConfiguration(t) {
    return !!this._getMarkerClipboardConfig(t);
  }
  _getMarkerClipboardConfig(t) {
    const [e] = t.split(":");
    return this._markersToCopy.get(e) || null;
  }
  _insertFakeMarkersIntoSelection(t, e, i) {
    const r = this._getCopyableMarkersFromSelection(t, e, i);
    return this._insertFakeMarkersElements(t, r);
  }
  _getCopyableMarkersFromSelection(t, e, i) {
    const r = Array.from(e.getRanges()), s = new Set(r.flatMap((a) => Array.from(t.model.markers.getMarkersIntersectingRange(a))));
    return Array.from(s).filter((a) => {
      if (!this._isMarkerCopyable(a.name, i)) return !1;
      const { copyPartiallySelected: l } = this._getMarkerClipboardConfig(a.name);
      if (!l) {
        const c = a.getRange();
        return r.some((d) => d.containsRange(c, !0));
      }
      return !0;
    }).map((a) => ({ name: i === "dragstart" ? this._getUniqueMarkerName(a.name) : a.name, range: a.getRange() }));
  }
  _getPasteMarkersFromRangeMap(t, e = null) {
    const { model: i } = this.editor;
    return (t instanceof Map ? Array.from(t.entries()) : Object.entries(t)).flatMap(([r, s]) => {
      if (!this._hasMarkerConfiguration(r)) return [{ name: r, range: s }];
      if (this._isMarkerCopyable(r, e)) {
        const a = this._getMarkerClipboardConfig(r), l = i.markers.has(r) && i.markers.get(r).getRange().root.rootName === "$graveyard";
        return (a.duplicateOnPaste || l) && (r = this._getUniqueMarkerName(r)), [{ name: r, range: s }];
      }
      return [];
    });
  }
  _insertFakeMarkersElements(t, e) {
    const i = {}, r = e.flatMap((s) => {
      const { start: a, end: l } = s.range;
      return [{ position: a, marker: s, type: "start" }, { position: l, marker: s, type: "end" }];
    }).sort(({ position: s }, { position: a }) => s.isBefore(a) ? 1 : -1);
    for (const { position: s, marker: a, type: l } of r) {
      const c = t.createElement("$marker", { "data-name": a.name, "data-type": l });
      i[a.name] || (i[a.name] = []), i[a.name].push(c), t.insert(c, s);
    }
    return i;
  }
  _removeFakeMarkersInsideElement(t, e) {
    return aC(this._getAllFakeMarkersFromElement(t, e).reduce((i, r) => {
      const s = r.markerElement && t.createPositionBefore(r.markerElement);
      let a = i[r.name], l = !1;
      return a != null && a.start && (a != null && a.end) && (this._getMarkerClipboardConfig(r.name).duplicateOnPaste ? i[this._getUniqueMarkerName(r.name)] = i[r.name] : l = !0, a = null), l || (i[r.name] = { ...a, [r.type]: s }), r.markerElement && t.remove(r.markerElement), i;
    }, {}), (i) => new E(i.start || t.createPositionFromPath(e, [0]), i.end || t.createPositionAt(e, "end")));
  }
  _getAllFakeMarkersFromElement(t, e) {
    const i = Array.from(t.createRangeIn(e)).flatMap(({ item: a }) => {
      if (!a.is("element", "$marker")) return [];
      const l = a.getAttribute("data-name"), c = a.getAttribute("data-type");
      return [{ markerElement: a, name: l, type: c }];
    }), r = [], s = [];
    for (const a of i)
      a.type === "end" && (i.some((l) => l.name === a.name && l.type === "start") || r.push({ markerElement: null, name: a.name, type: "start" })), a.type === "start" && (i.some((l) => l.name === a.name && l.type === "end") || s.unshift({ markerElement: null, name: a.name, type: "end" }));
    return [...r, ...i, ...s];
  }
  _getUniqueMarkerName(t) {
    const e = t.split(":"), i = Ee().substring(1, 6);
    return e.length === 3 ? `${e.slice(0, 2).join(":")}:${i}` : `${e.join(":")}:${i}`;
  }
}
class De extends A {
  static get pluginName() {
    return "ClipboardPipeline";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [qr];
  }
  init() {
    this.editor.editing.view.addObserver(as), this._setupPasteDrop(), this._setupCopyCut();
  }
  _fireOutputTransformationEvent(n, t, e) {
    const i = this.editor.plugins.get("ClipboardMarkersUtils");
    this.editor.model.enqueueChange({ isUndoable: e === "cut" }, () => {
      const r = i._copySelectedFragmentWithMarkers(e, t);
      this.fire("outputTransformation", { dataTransfer: n, content: r, method: e });
    });
  }
  _setupPasteDrop() {
    const n = this.editor, t = n.model, e = n.editing.view, i = e.document, r = this.editor.plugins.get("ClipboardMarkersUtils");
    this.listenTo(i, "clipboardInput", (s, a) => {
      a.method != "paste" || n.model.canEditAt(n.model.document.selection) || s.stop();
    }, { priority: "highest" }), this.listenTo(i, "clipboardInput", (s, a) => {
      const l = a.dataTransfer;
      let c;
      if (a.content) c = a.content;
      else {
        let h = "";
        l.getData("text/html") ? h = function(g) {
          return g.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (f, p) => p.length == 1 ? " " : p).replace(/<!--[\s\S]*?-->/g, "");
        }(l.getData("text/html")) : l.getData("text/plain") && (h = BT(l.getData("text/plain"))), c = this.editor.data.htmlProcessor.toView(h);
      }
      const d = new oi(this, "inputTransformation"), u = l.getData("application/ckeditor5-editor-id") || null;
      this.fire(d, { content: c, dataTransfer: l, sourceEditorId: u, targetRanges: a.targetRanges, method: a.method }), d.stop.called && s.stop(), e.scrollToTheSelection();
    }, { priority: "low" }), this.listenTo(this, "inputTransformation", (s, a) => {
      if (a.content.isEmpty) return;
      const l = this.editor.data.toModel(a.content, "$clipboardHolder");
      l.childCount != 0 && (s.stop(), t.change(() => {
        this.fire("contentInsertion", { content: l, method: a.method, sourceEditorId: a.sourceEditorId, dataTransfer: a.dataTransfer, targetRanges: a.targetRanges });
      }));
    }, { priority: "low" }), this.listenTo(this, "contentInsertion", (s, a) => {
      a.resultRange = r._pasteFragmentWithMarkers(a.content);
    }, { priority: "low" });
  }
  _setupCopyCut() {
    const n = this.editor, t = n.model.document, e = n.editing.view.document, i = (r, s) => {
      const a = s.dataTransfer;
      s.preventDefault(), this._fireOutputTransformationEvent(a, t.selection, r.name);
    };
    this.listenTo(e, "copy", i, { priority: "low" }), this.listenTo(e, "cut", (r, s) => {
      n.model.canEditAt(n.model.document.selection) ? i(r, s) : s.preventDefault();
    }, { priority: "low" }), this.listenTo(this, "outputTransformation", (r, s) => {
      const a = n.data.toView(s.content, { isClipboardPipeline: !0 });
      e.fire("clipboardOutput", { dataTransfer: s.dataTransfer, content: a, method: s.method });
    }, { priority: "low" }), this.listenTo(e, "clipboardOutput", (r, s) => {
      s.content.isEmpty || (s.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(s.content)), s.dataTransfer.setData("text/plain", c_(n.data.htmlProcessor.domConverter, s.content)), s.dataTransfer.setData("application/ckeditor5-editor-id", this.editor.id)), s.method == "cut" && n.model.deleteContent(t.selection);
    }, { priority: "low" });
  }
}
const lc = Li("px");
class zT extends L {
  constructor() {
    super();
    const n = this.bindTemplate;
    this.set({ isVisible: !1, left: null, top: null, width: null }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-clipboard-drop-target-line", n.if("isVisible", "ck-hidden", (t) => !t)], style: { left: n.to("left", (t) => lc(t)), top: n.to("top", (t) => lc(t)), width: n.to("width", (t) => lc(t)) } } });
  }
}
class js extends A {
  constructor() {
    super(...arguments);
    m(this, "removeDropMarkerDelayed", au(() => this.removeDropMarker(), 40));
    m(this, "_updateDropMarkerThrottled", Qo((t) => this._updateDropMarker(t), 40));
    m(this, "_reconvertMarkerThrottled", Qo(() => {
      this.editor.model.markers.has("drop-target") && this.editor.editing.reconvertMarker("drop-target");
    }, 0));
    m(this, "_dropTargetLineView", new zT());
    m(this, "_domEmitter", new (Pe())());
    m(this, "_scrollables", /* @__PURE__ */ new Map());
  }
  static get pluginName() {
    return "DragDropTarget";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    this._setupDropMarker();
  }
  destroy() {
    this._domEmitter.stopListening();
    for (const { resizeObserver: t } of this._scrollables.values()) t.destroy();
    return this._updateDropMarkerThrottled.cancel(), this.removeDropMarkerDelayed.cancel(), this._reconvertMarkerThrottled.cancel(), super.destroy();
  }
  updateDropMarker(t, e, i, r, s, a) {
    this.removeDropMarkerDelayed.cancel();
    const l = jg(this.editor, t, e, i, r, s, a);
    if (l) return a && a.containsRange(l) ? this.removeDropMarker() : void this._updateDropMarkerThrottled(l);
  }
  getFinalDropRange(t, e, i, r, s, a) {
    const l = jg(this.editor, t, e, i, r, s, a);
    return this.removeDropMarker(), l;
  }
  removeDropMarker() {
    const t = this.editor.model;
    this.removeDropMarkerDelayed.cancel(), this._updateDropMarkerThrottled.cancel(), this._dropTargetLineView.isVisible = !1, t.markers.has("drop-target") && t.change((e) => {
      e.removeMarker("drop-target");
    });
  }
  _setupDropMarker() {
    const t = this.editor;
    t.ui.view.body.add(this._dropTargetLineView), t.conversion.for("editingDowncast").markerToHighlight({ model: "drop-target", view: { classes: ["ck-clipboard-drop-target-range"] } }), t.conversion.for("editingDowncast").markerToElement({ model: "drop-target", view: (e, { writer: i }) => {
      if (t.model.schema.checkChild(e.markerRange.start, "$text")) return this._dropTargetLineView.isVisible = !1, this._createDropTargetPosition(i);
      e.markerRange.isCollapsed ? this._updateDropTargetLine(e.markerRange) : this._dropTargetLineView.isVisible = !1;
    } });
  }
  _updateDropMarker(t) {
    const e = this.editor, i = e.model.markers;
    e.model.change((r) => {
      i.has("drop-target") ? i.get("drop-target").getRange().isEqual(t) || r.updateMarker("drop-target", { range: t }) : r.addMarker("drop-target", { range: t, usingOperation: !1, affectsData: !1 });
    });
  }
  _createDropTargetPosition(t) {
    return t.createUIElement("span", { class: "ck ck-clipboard-drop-target-position" }, function(e) {
      const i = this.toDomElement(e);
      return i.append("", e.createElement("span"), ""), i;
    });
  }
  _updateDropTargetLine(t) {
    const e = this.editor.editing, i = t.start.nodeBefore, r = t.start.nodeAfter, s = t.start.parent, a = i ? e.mapper.toViewElement(i) : null, l = a ? e.view.domConverter.mapViewToDom(a) : null, c = r ? e.mapper.toViewElement(r) : null, d = c ? e.view.domConverter.mapViewToDom(c) : null, u = e.mapper.toViewElement(s);
    if (!u) return;
    const h = e.view.domConverter.mapViewToDom(u), g = this._getScrollableRect(u), { scrollX: f, scrollY: p } = N.window, b = l ? new K(l) : null, k = d ? new K(d) : null, w = new K(h).excludeScrollbarsAndBorders(), _ = b ? b.bottom : w.top, y = k ? k.top : w.bottom, C = N.window.getComputedStyle(h), x = _ <= y ? (_ + y) / 2 : y;
    if (g.top < x && x < g.bottom) {
      const I = w.left + parseFloat(C.paddingLeft), P = w.right - parseFloat(C.paddingRight), Y = Math.max(I + f, g.left), it = Math.min(P + f, g.right);
      this._dropTargetLineView.set({ isVisible: !0, left: Y, top: x + p, width: it - Y });
    } else this._dropTargetLineView.isVisible = !1;
  }
  _getScrollableRect(t) {
    const e = t.root.rootName;
    let i;
    if (this._scrollables.has(e)) i = this._scrollables.get(e).domElement;
    else {
      i = function(s) {
        let a = s;
        do {
          a = a.parentElement;
          const l = N.window.getComputedStyle(a).overflowY;
          if (l == "auto" || l == "scroll") break;
        } while (a.tagName != "BODY");
        return a;
      }(this.editor.editing.view.domConverter.mapViewToDom(t)), this._domEmitter.listenTo(i, "scroll", this._reconvertMarkerThrottled, { usePassive: !0 });
      const r = new to(i, this._reconvertMarkerThrottled);
      this._scrollables.set(e, { domElement: i, resizeObserver: r });
    }
    return new K(i).excludeScrollbarsAndBorders();
  }
}
function jg(o, n, t, e, i, r, s) {
  const a = o.model, l = o.editing.mapper;
  let c = Hg(o, n);
  for (; c; ) {
    if (!r) {
      if (a.schema.checkChild(c, "$text")) {
        if (t) {
          const d = t[0].start, u = l.toModelPosition(d);
          if (!s || Array.from(s.getItems({ shallow: !0 })).every((h) => a.schema.checkChild(u, h))) {
            if (a.schema.checkChild(u, "$text")) return a.createRange(u);
            if (d) return Hs(o, Hg(o, d.parent), e, i);
          }
        }
      } else if (a.schema.isInline(c)) return Hs(o, c, e, i);
    }
    if (a.schema.isBlock(c)) return Hs(o, c, e, i);
    if (a.schema.checkChild(c, "$block")) {
      const d = Array.from(c.getChildren()).filter((g) => g.is("element") && !OT(o, g));
      let u = 0, h = d.length;
      if (h == 0) return a.createRange(a.createPositionAt(c, "end"));
      for (; u < h - 1; ) {
        const g = Math.floor((u + h) / 2);
        u_(o, d[g], e, i) == "before" ? h = g : u = g;
      }
      return Hs(o, d[u], e, i);
    }
    c = c.parent;
  }
  return null;
}
function OT(o, n) {
  const t = o.editing.mapper, e = o.editing.view.domConverter, i = t.toViewElement(n);
  if (!i) return !0;
  const r = e.mapViewToDom(i);
  return N.window.getComputedStyle(r).float != "none";
}
function Hs(o, n, t, e) {
  const i = o.model;
  return i.createRange(i.createPositionAt(n, u_(o, n, t, e)));
}
function u_(o, n, t, e) {
  const i = o.editing.mapper, r = o.editing.view.domConverter, s = i.toViewElement(n), a = r.mapViewToDom(s), l = new K(a);
  return o.model.schema.isInline(n) ? t < (l.left + l.right) / 2 ? "before" : "after" : e < (l.top + l.bottom) / 2 ? "before" : "after";
}
function Hg(o, n) {
  const t = o.editing.mapper, e = o.editing.view, i = t.toModelElement(n);
  if (i) return i;
  const r = e.createPositionBefore(n), s = t.findMappedViewAncestor(r);
  return t.toModelElement(s);
}
class RT extends A {
  constructor() {
    super(...arguments);
    m(this, "_isBlockDragging", !1);
    m(this, "_domEmitter", new (Pe())());
  }
  static get pluginName() {
    return "DragDropBlockToolbar";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor;
    if (this.listenTo(t, "change:isReadOnly", (e, i, r) => {
      r ? (this.forceDisabled("readOnlyMode"), this._isBlockDragging = !1) : this.clearForceDisabled("readOnlyMode");
    }), H.isAndroid && this.forceDisabled("noAndroidSupport"), t.plugins.has("BlockToolbar")) {
      const e = t.plugins.get("BlockToolbar").buttonView.element;
      this._domEmitter.listenTo(e, "dragstart", (i, r) => this._handleBlockDragStart(r)), this._domEmitter.listenTo(N.document, "dragover", (i, r) => this._handleBlockDragging(r)), this._domEmitter.listenTo(N.document, "drop", (i, r) => this._handleBlockDragging(r)), this._domEmitter.listenTo(N.document, "dragend", () => this._handleBlockDragEnd(), { useCapture: !0 }), this.isEnabled && e.setAttribute("draggable", "true"), this.on("change:isEnabled", (i, r, s) => {
        e.setAttribute("draggable", s ? "true" : "false");
      });
    }
  }
  destroy() {
    return this._domEmitter.stopListening(), super.destroy();
  }
  _handleBlockDragStart(t) {
    if (!this.isEnabled) return;
    const e = this.editor.model, i = e.document.selection, r = this.editor.editing.view, s = Array.from(i.getSelectedBlocks()), a = e.createRange(e.createPositionBefore(s[0]), e.createPositionAfter(s[s.length - 1]));
    e.change((l) => l.setSelection(a)), this._isBlockDragging = !0, r.focus(), r.getObserver(as).onDomEvent(t);
  }
  _handleBlockDragging(t) {
    if (!this.isEnabled || !this._isBlockDragging) return;
    const e = t.clientX + (this.editor.locale.contentLanguageDirection == "ltr" ? 100 : -100), i = t.clientY, r = document.elementFromPoint(e, i), s = this.editor.editing.view;
    r && r.closest(".ck-editor__editable") && s.getObserver(as).onDomEvent({ ...t, type: t.type, dataTransfer: t.dataTransfer, target: r, clientX: e, clientY: i, preventDefault: () => t.preventDefault(), stopPropagation: () => t.stopPropagation() });
  }
  _handleBlockDragEnd() {
    this._isBlockDragging = !1;
  }
}
class VT extends A {
  constructor() {
    super(...arguments);
    m(this, "_draggedRange");
    m(this, "_draggingUid");
    m(this, "_draggableElement");
    m(this, "_clearDraggableAttributesDelayed", au(() => this._clearDraggableAttributes(), 40));
    m(this, "_blockMode", !1);
    m(this, "_domEmitter", new (Pe())());
    m(this, "_previewContainer");
  }
  static get pluginName() {
    return "DragDrop";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [De, cr, js, RT];
  }
  init() {
    const t = this.editor, e = t.editing.view;
    this._draggedRange = null, this._draggingUid = "", this._draggableElement = null, e.addObserver(as), e.addObserver(dl), this._setupDragging(), this._setupContentInsertionIntegration(), this._setupClipboardInputIntegration(), this._setupDraggableAttributeHandling(), this.listenTo(t, "change:isReadOnly", (i, r, s) => {
      s ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode");
    }), this.on("change:isEnabled", (i, r, s) => {
      s || this._finalizeDragging(!1);
    }), H.isAndroid && this.forceDisabled("noAndroidSupport");
  }
  destroy() {
    return this._draggedRange && (this._draggedRange.detach(), this._draggedRange = null), this._previewContainer && this._previewContainer.remove(), this._domEmitter.stopListening(), this._clearDraggableAttributesDelayed.cancel(), super.destroy();
  }
  _setupDragging() {
    const t = this.editor, e = t.model, i = t.editing.view, r = i.document, s = t.plugins.get(js);
    this.listenTo(r, "dragstart", (a, l) => {
      var f;
      if ((f = l.target) != null && f.is("editableElement") || (this._prepareDraggedRange(l.target), !this._draggedRange)) return void l.preventDefault();
      this._draggingUid = Ee(), l.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy", l.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
      const c = e.createSelection(this._draggedRange.toRange());
      this.editor.plugins.get("ClipboardPipeline")._fireOutputTransformationEvent(l.dataTransfer, c, "dragstart");
      const { dataTransfer: d, domTarget: u, domEvent: h } = l, { clientX: g } = h;
      this._updatePreview({ dataTransfer: d, domTarget: u, clientX: g }), l.stopPropagation(), this.isEnabled || (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
    }, { priority: "low" }), this.listenTo(r, "dragend", (a, l) => {
      this._finalizeDragging(!l.dataTransfer.isCanceled && l.dataTransfer.dropEffect == "move");
    }, { priority: "low" }), this._domEmitter.listenTo(N.document, "dragend", () => {
      this._blockMode = !1;
    }, { useCapture: !0 }), this.listenTo(r, "dragenter", () => {
      this.isEnabled && i.focus();
    }), this.listenTo(r, "dragleave", () => {
      s.removeDropMarkerDelayed();
    }), this.listenTo(r, "dragging", (a, l) => {
      if (!this.isEnabled) return void (l.dataTransfer.dropEffect = "none");
      const { clientX: c, clientY: d } = l.domEvent;
      s.updateDropMarker(l.target, l.targetRanges, c, d, this._blockMode, this._draggedRange), this._draggedRange || (l.dataTransfer.dropEffect = "copy"), H.isGecko || (l.dataTransfer.effectAllowed == "copy" ? l.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(l.dataTransfer.effectAllowed) && (l.dataTransfer.dropEffect = "move")), a.stop();
    }, { priority: "low" });
  }
  _setupClipboardInputIntegration() {
    const t = this.editor, e = t.editing.view.document, i = t.plugins.get(js);
    this.listenTo(e, "clipboardInput", (r, s) => {
      if (s.method != "drop") return;
      const { clientX: a, clientY: l } = s.domEvent, c = i.getFinalDropRange(s.target, s.targetRanges, a, l, this._blockMode, this._draggedRange);
      if (!c) return this._finalizeDragging(!1), void r.stop();
      if (this._draggedRange && this._draggingUid != s.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = ""), Ug(s.dataTransfer) == "move" && this._draggedRange && this._draggedRange.containsRange(c, !0)) return this._finalizeDragging(!1), void r.stop();
      s.targetRanges = [t.editing.mapper.toViewRange(c)];
    }, { priority: "high" });
  }
  _setupContentInsertionIntegration() {
    const t = this.editor.plugins.get(De);
    t.on("contentInsertion", (e, i) => {
      if (!this.isEnabled || i.method !== "drop") return;
      const r = i.targetRanges.map((s) => this.editor.editing.mapper.toModelRange(s));
      this.editor.model.change((s) => s.setSelection(r));
    }, { priority: "high" }), t.on("contentInsertion", (e, i) => {
      if (!this.isEnabled || i.method !== "drop") return;
      const r = Ug(i.dataTransfer) == "move", s = !i.resultRange || !i.resultRange.isCollapsed;
      this._finalizeDragging(s && r);
    }, { priority: "lowest" });
  }
  _setupDraggableAttributeHandling() {
    const t = this.editor, e = t.editing.view, i = e.document;
    this.listenTo(i, "mousedown", (r, s) => {
      if (H.isAndroid || !s) return;
      this._clearDraggableAttributesDelayed.cancel();
      let a = $g(s.target);
      if (H.isBlink && !t.isReadOnly && !a && !i.selection.isCollapsed) {
        const l = i.selection.getSelectedElement();
        l && Yt(l) || (a = i.selection.editableElement);
      }
      a && (e.change((l) => {
        l.setAttribute("draggable", "true", a);
      }), this._draggableElement = t.editing.mapper.toModelElement(a));
    }), this.listenTo(i, "mouseup", () => {
      H.isAndroid || this._clearDraggableAttributesDelayed();
    });
  }
  _clearDraggableAttributes() {
    const t = this.editor.editing;
    t.view.change((e) => {
      this._draggableElement && this._draggableElement.root.rootName != "$graveyard" && e.removeAttribute("draggable", t.mapper.toViewElement(this._draggableElement)), this._draggableElement = null;
    });
  }
  _finalizeDragging(t) {
    const e = this.editor, i = e.model;
    e.plugins.get(js).removeDropMarker(), this._clearDraggableAttributes(), e.plugins.has("WidgetToolbarRepository") && e.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop"), this._draggingUid = "", this._previewContainer && (this._previewContainer.remove(), this._previewContainer = void 0), this._draggedRange && (t && this.isEnabled && i.change((r) => {
      const s = i.createSelection(this._draggedRange);
      i.deleteContent(s, { doNotAutoparagraph: !0 });
      const a = s.getFirstPosition().parent;
      a.isEmpty && !i.schema.checkChild(a, "$text") && i.schema.checkChild(a, "paragraph") && r.insertElement("paragraph", a, 0);
    }), this._draggedRange.detach(), this._draggedRange = null);
  }
  _prepareDraggedRange(t) {
    const e = this.editor, i = e.model, r = i.document.selection, s = t ? $g(t) : null;
    if (s) {
      const d = e.editing.mapper.toModelElement(s);
      this._draggedRange = Ie.fromRange(i.createRangeOn(d)), this._blockMode = i.schema.isBlock(d), e.plugins.has("WidgetToolbarRepository") && e.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop");
      return;
    }
    if (r.isCollapsed && !r.getFirstPosition().parent.isEmpty) return;
    const a = Array.from(r.getSelectedBlocks()), l = r.getFirstRange();
    if (a.length == 0) return void (this._draggedRange = Ie.fromRange(l));
    const c = h_(i, a);
    if (a.length > 1) this._draggedRange = Ie.fromRange(c), this._blockMode = !0;
    else if (a.length == 1) {
      const d = l.start.isTouching(c.start) && l.end.isTouching(c.end);
      this._draggedRange = Ie.fromRange(d ? c : l), this._blockMode = d;
    }
    i.change((d) => d.setSelection(this._draggedRange.toRange()));
  }
  _updatePreview({ dataTransfer: t, domTarget: e, clientX: i }) {
    const r = this.editor.editing.view, s = r.document.selection.editableElement, a = r.domConverter.mapViewToDom(s), l = N.window.getComputedStyle(a);
    this._previewContainer ? this._previewContainer.firstElementChild && this._previewContainer.removeChild(this._previewContainer.firstElementChild) : (this._previewContainer = mn(N.document, "div", { style: "position: fixed; left: -999999px;" }), N.document.body.appendChild(this._previewContainer));
    const c = new K(a);
    if (a.contains(e)) return;
    const d = parseFloat(l.paddingLeft), u = mn(N.document, "div");
    u.className = "ck ck-content", u.style.width = l.width, u.style.paddingLeft = `${c.left - i + d}px`, H.isiOS && (u.style.backgroundColor = "white"), r.domConverter.setContentOf(u, t.getData("text/html")), t.setDragImage(u, 0, 0), this._previewContainer.appendChild(u);
  }
}
function Ug(o) {
  return H.isGecko ? o.dropEffect : ["all", "copyMove"].includes(o.effectAllowed) ? "move" : "copy";
}
function $g(o) {
  if (o.is("editableElement")) return null;
  if (o.hasClass("ck-widget__selection-handle")) return o.findAncestor(Yt);
  if (Yt(o)) return o;
  const n = o.findAncestor((t) => Yt(t) || t.is("editableElement"));
  return Yt(n) ? n : null;
}
function h_(o, n) {
  const t = n[0], e = n[n.length - 1], i = t.getCommonAncestor(e), r = o.createPositionBefore(t), s = o.createPositionAfter(e);
  if (i && i.is("element") && !o.schema.isLimit(i)) {
    const a = o.createRangeOn(i), l = r.isTouching(a.start), c = s.isTouching(a.end);
    if (l && c) return h_(o, [i]);
  }
  return o.createRange(r, s);
}
class FT extends A {
  static get pluginName() {
    return "PastePlainText";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [De];
  }
  init() {
    const n = this.editor, t = n.model, e = n.editing.view, i = t.document.selection;
    e.addObserver(as), n.plugins.get(De).on("contentInsertion", (r, s) => {
      (function(a, l) {
        let c = l.createRangeIn(a);
        if (a.childCount == 1) {
          const d = a.getChild(0);
          d.is("element") && l.schema.isBlock(d) && !l.schema.isObject(d) && !l.schema.isLimit(d) && (c = l.createRangeIn(d));
        }
        for (const d of c.getItems())
          if (!l.schema.isInline(d) || Array.from(d.getAttributeKeys()).find((u) => l.schema.getAttributeProperties(u).isFormatting)) return !1;
        return !0;
      })(s.content, t) && t.change((a) => {
        const l = Array.from(i.getAttributes()).filter(([d]) => t.schema.getAttributeProperties(d).isFormatting);
        i.isCollapsed || t.deleteContent(i, { doNotAutoparagraph: !0 }), l.push(...i.getAttributes());
        const c = a.createRangeIn(s.content);
        for (const d of c.getItems()) for (const u of l) t.schema.checkAttribute(d, u[0]) && a.setAttribute(u[0], u[1], d);
      });
    });
  }
}
class Pu extends A {
  static get pluginName() {
    return "Clipboard";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [qr, De, VT, FT];
  }
  init() {
    const n = this.editor, t = this.editor.t;
    n.accessibility.addKeystrokeInfos({ keystrokes: [{ label: t("Copy selected content"), keystroke: "CTRL+C" }, { label: t("Paste content"), keystroke: "CTRL+V" }, { label: t("Paste content as plain text"), keystroke: "CTRL+SHIFT+V" }] });
  }
}
const cc = /^data:(\S*?);base64,/;
class _3 extends vt() {
  constructor(t, e, i) {
    super();
    m(this, "file");
    m(this, "xhr");
    m(this, "_token");
    m(this, "_apiAddress");
    if (!t) throw new v("fileuploader-missing-file", null);
    if (!e) throw new v("fileuploader-missing-token", null);
    if (!i) throw new v("fileuploader-missing-api-address", null);
    this.file = function(r) {
      var s;
      return typeof r != "string" ? !1 : !!((s = r.match(cc)) != null && s.length);
    }(t) ? function(r, s = 512) {
      try {
        const a = r.match(cc)[1], l = atob(r.replace(cc, "")), c = [];
        for (let d = 0; d < l.length; d += s) {
          const u = l.slice(d, d + s), h = new Array(u.length);
          for (let g = 0; g < u.length; g++) h[g] = u.charCodeAt(g);
          c.push(new Uint8Array(h));
        }
        return new Blob(c, { type: a });
      } catch {
        throw new v("fileuploader-decoding-image-data-error", null);
      }
    }(t) : t, this._token = e, this._apiAddress = i;
  }
  onProgress(t) {
    return this.on("progress", (e, i) => t(i)), this;
  }
  onError(t) {
    return this.once("error", (e, i) => t(i)), this;
  }
  abort() {
    this.xhr.abort();
  }
  send() {
    return this._prepareRequest(), this._attachXHRListeners(), this._sendRequest();
  }
  _prepareRequest() {
    const t = new XMLHttpRequest();
    t.open("POST", this._apiAddress), t.setRequestHeader("Authorization", this._token.value), t.responseType = "json", this.xhr = t;
  }
  _attachXHRListeners() {
    const t = this.xhr, e = (i) => () => this.fire("error", i);
    t.addEventListener("error", e("Network Error")), t.addEventListener("abort", e("Abort")), t.upload && t.upload.addEventListener("progress", (i) => {
      i.lengthComputable && this.fire("progress", { total: i.total, uploaded: i.loaded });
    }), t.addEventListener("load", () => {
      const i = t.status, r = t.response;
      if (i < 200 || i > 299) return this.fire("error", r.message || r.error);
    });
  }
  _sendRequest() {
    const t = new FormData(), e = this.xhr;
    return t.append("file", this.file), new Promise((i, r) => {
      e.addEventListener("load", () => {
        const s = e.status, a = e.response;
        return s < 200 || s > 299 ? a.message ? r(new v("fileuploader-uploading-data-failed", this, { message: a.message })) : r(a.error) : i(a);
      }), e.addEventListener("error", () => r(new Error("Network Error"))), e.addEventListener("abort", () => r(new Error("Abort"))), e.send(t);
    });
  }
}
function Ba(o) {
  const n = o.t, t = o.config.get("codeBlock.languages");
  for (const e of t) e.label === "Plain text" && (e.label = n("Plain text")), e.class === void 0 && (e.class = `language-${e.language}`);
  return t;
}
function Na(o, n, t) {
  const e = {};
  for (const i of o) n === "class" ? e[i[n].split(" ").shift()] = i[t] : e[i[n]] = i[t];
  return e;
}
function Lu(o) {
  return o.data.match(/^(\s*)/)[0];
}
function kd(o) {
  const n = o.document.selection, t = [];
  if (n.isCollapsed) return [n.anchor];
  const e = n.getFirstRange().getWalker({ ignoreElementEnd: !0, direction: "backward" });
  for (const { item: i } of e) {
    let r = i.is("$textProxy") ? i.textNode : i;
    const s = r.parent;
    if (!s.is("element", "codeBlock") || r.is("element", "softBreak")) continue;
    for (; r.previousSibling && !r.previousSibling.is("element", "softBreak"); ) r = r.previousSibling;
    const a = r.is("$text") ? r.startOffset + Lu(r).length : r.startOffset, l = o.createPositionAt(s, a);
    t.every((c) => !c.isEqual(l)) && t.push(l);
  }
  return t;
}
function m_(o) {
  const n = yt(o.getSelectedBlocks());
  return !!n && n.is("element", "codeBlock");
}
function qg(o, n) {
  return !n.is("rootElement") && !o.isLimit(n) && o.checkChild(n.parent, "codeBlock");
}
function Wg(o, n, t, e) {
  const i = Na(n, "language", "label"), r = t.getAttribute("language");
  if (r in i) {
    const s = i[r];
    return o(e === "enter" ? "Entering %0 code snippet" : "Leaving %0 code snippet", s);
  }
  return o(e === "enter" ? "Entering code snippet" : "Leaving code snippet");
}
function g_(o, n) {
  for (o.textNode && (o = n.createPositionBefore(o.textNode)); o.nodeBefore && !o.nodeBefore.is("element", "softBreak"); ) o = n.createPositionBefore(o.nodeBefore);
  const t = o.nodeAfter;
  return t && t.is("$text") ? t : null;
}
class jT extends q {
  constructor(t) {
    super(t);
    m(this, "_lastLanguage");
    this._lastLanguage = null;
  }
  refresh() {
    this.value = this._getValue(), this.isEnabled = this._checkEnabled();
  }
  execute(t = {}) {
    const e = this.editor, i = e.model, r = i.document.selection, s = Ba(e)[0], a = Array.from(r.getSelectedBlocks()), l = t.forceValue == null ? !this.value : t.forceValue, c = function(d, u, h) {
      return d.language ? d.language : d.usePreviousLanguageChoice && u ? u : h;
    }(t, this._lastLanguage, s.language);
    i.change((d) => {
      l ? this._applyCodeBlock(d, a, c) : this._removeCodeBlock(d, a);
    });
  }
  _getValue() {
    const t = yt(this.editor.model.document.selection.getSelectedBlocks());
    return !!(t != null && t.is("element", "codeBlock")) && t.getAttribute("language");
  }
  _checkEnabled() {
    if (this.value) return !0;
    const t = this.editor.model.document.selection, e = this.editor.model.schema, i = yt(t.getSelectedBlocks());
    return !!i && qg(e, i);
  }
  _applyCodeBlock(t, e, i) {
    this._lastLanguage = i;
    const r = this.editor.model.schema, s = e.filter((a) => qg(r, a));
    for (const a of s) t.rename(a, "codeBlock"), t.setAttribute("language", i, a), r.removeDisallowedAttributes([a], t), Array.from(a.getChildren()).filter((l) => !r.checkChild(a, l)).forEach((l) => t.remove(l));
    s.reverse().forEach((a, l) => {
      const c = s[l + 1];
      a.previousSibling === c && (t.appendElement("softBreak", c), t.merge(t.createPositionBefore(a)));
    });
  }
  _removeCodeBlock(t, e) {
    const i = e.filter((r) => r.is("element", "codeBlock"));
    for (const r of i) {
      const s = t.createRangeOn(r);
      for (const a of Array.from(s.getItems()).reverse()) if (a.is("element", "softBreak") && a.parent.is("element", "codeBlock")) {
        const { position: l } = t.split(t.createPositionBefore(a)), c = l.nodeAfter;
        t.rename(c, "paragraph"), t.removeAttribute("language", c), t.remove(a);
      }
      t.rename(r, "paragraph"), t.removeAttribute("language", r);
    }
  }
}
class HT extends q {
  constructor(t) {
    super(t);
    m(this, "_indentSequence");
    this._indentSequence = t.config.get("codeBlock.indentSequence");
  }
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  execute() {
    const t = this.editor.model;
    t.change((e) => {
      const i = kd(t);
      for (const r of i) {
        const s = e.createText(this._indentSequence);
        t.insertContent(s, r);
      }
    });
  }
  _checkEnabled() {
    return !!this._indentSequence && m_(this.editor.model.document.selection);
  }
}
class UT extends q {
  constructor(t) {
    super(t);
    m(this, "_indentSequence");
    this._indentSequence = t.config.get("codeBlock.indentSequence");
  }
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  execute() {
    const t = this.editor.model;
    t.change(() => {
      const e = kd(t);
      for (const i of e) {
        const r = Gg(t, i, this._indentSequence);
        r && t.deleteContent(t.createSelection(r));
      }
    });
  }
  _checkEnabled() {
    if (!this._indentSequence) return !1;
    const t = this.editor.model;
    return !!m_(t.document.selection) && kd(t).some((e) => Gg(t, e, this._indentSequence));
  }
}
function Gg(o, n, t) {
  const e = g_(n, o);
  if (!e) return null;
  const i = Lu(e), r = i.lastIndexOf(t);
  if (r + t.length !== i.length || r === -1) return null;
  const { parent: s, startOffset: a } = e;
  return o.createRange(o.createPositionAt(s, a + r), o.createPositionAt(s, a + r + t.length));
}
function Kg(o, n, t = !1) {
  const e = Na(n, "language", "class"), i = Na(n, "language", "label");
  return (r, s, a) => {
    const { writer: l, mapper: c, consumable: d } = a;
    if (!d.consume(s.item, "insert")) return;
    const u = s.item.getAttribute("language"), h = c.toViewPosition(o.createPositionBefore(s.item)), g = {};
    t && (g["data-language"] = i[u], g.spellcheck = "false");
    const f = e[u] ? { class: e[u] } : void 0, p = l.createContainerElement("code", f), b = l.createContainerElement("pre", g, p);
    l.insert(h, b), c.bindElements(s.item, p);
  };
}
const Yg = "paragraph";
class $T extends A {
  static get pluginName() {
    return "CodeBlockEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [r_];
  }
  constructor(n) {
    super(n), n.config.define("codeBlock", { languages: [{ language: "plaintext", label: "Plain text" }, { language: "c", label: "C" }, { language: "cs", label: "C#" }, { language: "cpp", label: "C++" }, { language: "css", label: "CSS" }, { language: "diff", label: "Diff" }, { language: "html", label: "HTML" }, { language: "java", label: "Java" }, { language: "javascript", label: "JavaScript" }, { language: "php", label: "PHP" }, { language: "python", label: "Python" }, { language: "ruby", label: "Ruby" }, { language: "typescript", label: "TypeScript" }, { language: "xml", label: "XML" }], indentSequence: "	" });
  }
  init() {
    const n = this.editor, t = n.model.schema, e = n.model, i = n.editing.view, r = Ba(n);
    n.commands.add("codeBlock", new jT(n)), n.commands.add("indentCodeBlock", new HT(n)), n.commands.add("outdentCodeBlock", new UT(n)), this.listenTo(i.document, "tab", (s, a) => {
      const l = a.shiftKey ? "outdentCodeBlock" : "indentCodeBlock";
      n.commands.get(l).isEnabled && (n.execute(l), a.stopPropagation(), a.preventDefault(), s.stop());
    }, { context: "pre" }), t.register("codeBlock", { allowWhere: "$block", allowChildren: "$text", disallowChildren: "$inlineObject", allowAttributes: ["language"], allowAttributesOf: "$listItem", isBlock: !0 }), t.addAttributeCheck((s, a) => {
      const l = s.getItem(s.length - 2);
      if (t.getAttributeProperties(a).isFormatting && l && l.name == "codeBlock") return !1;
    }), n.editing.downcastDispatcher.on("insert:codeBlock", Kg(e, r, !0)), n.data.downcastDispatcher.on("insert:codeBlock", Kg(e, r)), n.data.downcastDispatcher.on("insert:softBreak", /* @__PURE__ */ function(s) {
      return (a, l, c) => {
        if (l.item.parent.name !== "codeBlock") return;
        const { writer: d, mapper: u, consumable: h } = c;
        if (!h.consume(l.item, "insert")) return;
        const g = u.toViewPosition(s.createPositionBefore(l.item));
        d.insert(g, d.createText(`
`));
      };
    }(e), { priority: "high" }), n.data.upcastDispatcher.on("element:code", function(s, a) {
      const l = Na(a, "class", "language"), c = a[0].language;
      return (d, u, h) => {
        const g = u.viewItem, f = g.parent;
        if (!f || !f.is("element", "pre") || u.modelCursor.findAncestor("codeBlock")) return;
        const { consumable: p, writer: b } = h;
        if (!p.test(g, { name: !0 })) return;
        const k = b.createElement("codeBlock"), w = [...g.getClassNames()];
        w.length || w.push("");
        for (const _ of w) {
          const y = l[_];
          if (y) {
            b.setAttribute("language", y, k);
            break;
          }
        }
        k.hasAttribute("language") || b.setAttribute("language", c, k), h.convertChildren(g, k), h.safeInsert(k, u.modelCursor) && (p.consume(g, { name: !0 }), h.updateConversionResult(k, u));
      };
    }(0, r)), n.data.upcastDispatcher.on("text", (s, a, { consumable: l, writer: c }) => {
      let d = a.modelCursor;
      if (!l.test(a.viewItem) || !d.findAncestor("codeBlock")) return;
      l.consume(a.viewItem);
      const u = a.viewItem.data.split(`
`).map((g) => c.createText(g)), h = u[u.length - 1];
      for (const g of u) if (c.insert(g, d), d = d.getShiftedBy(g.offsetSize), g !== h) {
        const f = c.createElement("softBreak");
        c.insert(f, d), d = c.createPositionAfter(f);
      }
      a.modelRange = c.createRange(a.modelCursor, d), a.modelCursor = d;
    }), n.data.upcastDispatcher.on("element:pre", (s, a, { consumable: l }) => {
      const c = a.viewItem;
      if (c.findAncestor("pre")) return;
      const d = Array.from(c.getChildren()), u = d.find((h) => h.is("element", "code"));
      if (u) for (const h of d) h !== u && h.is("$text") && l.consume(h, { name: !0 });
    }, { priority: "high" }), this.listenTo(n.editing.view.document, "clipboardInput", (s, a) => {
      let l = e.createRange(e.document.selection.anchor);
      if (a.targetRanges && (l = n.editing.mapper.toModelRange(a.targetRanges[0])), !l.start.parent.is("element", "codeBlock")) return;
      const c = a.dataTransfer.getData("text/plain"), d = new Bn(n.editing.view.document);
      a.content = function(u, h) {
        const g = u.createDocumentFragment(), f = h.split(`
`), p = f.reduce((b, k, w) => (b.push(k), w < f.length - 1 && b.push(u.createElement("br")), b), []);
        return u.appendChild(p, g), g;
      }(d, c);
    }), n.plugins.has("ClipboardPipeline") && n.plugins.get(De).on("contentInsertion", (s, a) => {
      const l = n.model, c = l.document.selection;
      c.anchor.parent.is("element", "codeBlock") && l.change((d) => {
        const u = d.createRangeIn(a.content);
        for (const h of [...u.getItems()]) h.is("node") && !t.checkChild(c.anchor, h) && d.remove(h);
      });
    }), this.listenTo(e, "getSelectedContent", (s, [a]) => {
      const l = a.anchor;
      !a.isCollapsed && l.parent.is("element", "codeBlock") && l.hasSameParentAs(a.focus) && e.change((c) => {
        const d = s.return;
        if (l.parent.is("element") && (d.childCount > 1 || a.containsEntireContent(l.parent))) {
          const h = c.createElement("codeBlock", l.parent.getAttributes());
          c.append(d, h);
          const g = c.createDocumentFragment();
          return c.append(h, g), void (s.return = g);
        }
        const u = d.getChild(0);
        t.checkAttribute(u, "code") && c.setAttribute("code", !0, u);
      });
    });
  }
  afterInit() {
    const n = this.editor, t = n.commands, e = t.get("indent"), i = t.get("outdent");
    e && e.registerChildCommand(t.get("indentCodeBlock"), { priority: "highest" }), i && i.registerChildCommand(t.get("outdentCodeBlock")), this.listenTo(n.editing.view.document, "enter", (r, s) => {
      n.model.document.selection.getLastPosition().parent.is("element", "codeBlock") && (function(a, l) {
        const c = a.model, d = c.document, u = a.editing.view, h = d.selection.getLastPosition(), g = h.nodeAfter;
        return l || !d.selection.isCollapsed || !h.isAtStart || !Ui(g) ? !1 : (a.model.change((f) => {
          a.execute("enter");
          const p = d.selection.anchor.parent.previousSibling;
          f.rename(p, Yg), f.setSelection(p, "in"), a.model.schema.removeDisallowedAttributes([p], f), f.remove(g);
        }), u.scrollToTheSelection(), !0);
      }(n, s.isSoft) || function(a, l) {
        const c = a.model, d = c.document, u = a.editing.view, h = d.selection.getLastPosition(), g = h.nodeBefore;
        let f;
        if (l || !d.selection.isCollapsed || !h.isAtEnd || !g || !g.previousSibling) return !1;
        if (Ui(g) && Ui(g.previousSibling)) f = c.createRange(c.createPositionBefore(g.previousSibling), c.createPositionAfter(g));
        else if (dc(g) && Ui(g.previousSibling) && Ui(g.previousSibling.previousSibling)) f = c.createRange(c.createPositionBefore(g.previousSibling.previousSibling), c.createPositionAfter(g));
        else {
          if (!(dc(g) && Ui(g.previousSibling) && dc(g.previousSibling.previousSibling) && g.previousSibling.previousSibling && Ui(g.previousSibling.previousSibling.previousSibling))) return !1;
          f = c.createRange(c.createPositionBefore(g.previousSibling.previousSibling.previousSibling), c.createPositionAfter(g));
        }
        return a.model.change((p) => {
          p.remove(f), a.execute("enter");
          const b = d.selection.anchor.parent;
          p.rename(b, Yg), a.model.schema.removeDisallowedAttributes([b], p);
        }), u.scrollToTheSelection(), !0;
      }(n, s.isSoft) || function(a) {
        const l = a.model, c = l.document;
        let d;
        const u = g_(c.selection.getLastPosition(), l);
        u && u.is("$text") && (d = Lu(u)), a.model.change((h) => {
          a.execute("shiftEnter"), d && h.insertText(d, c.selection.anchor);
        });
      }(n), s.preventDefault(), r.stop());
    }, { context: "pre" }), this._initAriaAnnouncements();
  }
  _initAriaAnnouncements() {
    const { model: n, ui: t, t: e } = this.editor, i = Ba(this.editor);
    let r = null;
    n.document.selection.on("change:range", () => {
      const s = n.document.selection.focus.parent;
      t && r !== s && s.is("element") && (r && r.is("element", "codeBlock") && t.ariaLiveAnnouncer.announce(Wg(e, i, r, "leave")), s.is("element", "codeBlock") && t.ariaLiveAnnouncer.announce(Wg(e, i, s, "enter")), r = s);
    });
  }
}
function dc(o) {
  return o && o.is("$text") && !o.data.match(/\S/);
}
function Ui(o) {
  return o && o.is("element", "softBreak");
}
class qT extends A {
  static get pluginName() {
    return "CodeBlockUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.t, e = n.ui.componentFactory, i = Ba(n), r = this._getLanguageListItemDefinitions(i), s = n.commands.get("codeBlock");
    e.add("codeBlock", (a) => {
      const l = ge(a, mo), c = l.buttonView, d = t("Insert code block");
      return c.set({ label: d, tooltip: !0, icon: Om, isToggleable: !0 }), c.bind("isOn").to(s, "value", (u) => !!u), c.on("execute", () => {
        n.execute("codeBlock", { usePreviousLanguageChoice: !0 }), n.editing.view.focus();
      }), l.on("execute", (u) => {
        n.execute("codeBlock", { language: u.source._codeBlockLanguage, forceValue: !0 }), n.editing.view.focus();
      }), l.class = "ck-code-block-dropdown", l.bind("isEnabled").to(s), zi(l, r, { role: "menu", ariaLabel: d }), l;
    }), e.add("menuBar:codeBlock", (a) => {
      const l = new Me(a);
      l.buttonView.set({ role: "menuitem", label: t("Code block"), icon: Om }), l.bind("isEnabled").to(s);
      const c = new li(a);
      c.set({ ariaLabel: t("Insert code block") });
      for (const d of r) {
        const u = new zn(a, l), h = new Et(a);
        h.bind(...Object.keys(d.model)).to(d.model), h.set({ isToggleable: !0, role: "menuitemcheckbox" }), h.delegate("execute").to(l), h.on("execute", () => {
          n.execute("codeBlock", { language: d.model._codeBlockLanguage, forceValue: s.value != d.model._codeBlockLanguage }), n.editing.view.focus();
        }), u.children.add(h), c.items.add(u);
      }
      return l.panelView.children.add(c), l;
    });
  }
  _getLanguageListItemDefinitions(n) {
    const t = this.editor.commands.get("codeBlock"), e = new ne();
    for (const i of n) {
      const r = { type: "button", model: new ai({ _codeBlockLanguage: i.language, label: i.label, role: "menuitemradio", withText: !0 }) };
      r.model.bind("isOn").to(t, "value", (s) => s === r.model._codeBlockLanguage), e.add(r);
    }
    return e;
  }
}
class WT extends A {
  static get requires() {
    return [$T, qT];
  }
  static get pluginName() {
    return "CodeBlock";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class GT extends k5 {
  constructor(t, e) {
    super(t);
    m(this, "view");
    this.view = e;
  }
  get element() {
    return this.view.editable.element;
  }
  init() {
    const t = this.editor, e = this.view, i = t.editing.view, r = e.editable, s = i.document.getRoot();
    r.name = s.rootName, e.render();
    const a = r.element;
    this.setEditableElement(r.name, a), r.bind("isFocused").to(this.focusTracker), i.attachDomRoot(a), this._initPlaceholder(), this.initMenuBar(this.view.menuBarView), this.fire("ready");
  }
  destroy() {
    super.destroy();
    const t = this.view, e = this.editor.editing.view;
    e.getDomRoot(t.editable.name) && e.detachDomRoot(t.editable.name), t.destroy();
  }
  _initPlaceholder() {
    const t = this.editor, e = t.editing.view, i = e.document.getRoot(), r = t.config.get("placeholder");
    if (r) {
      const s = typeof r == "string" ? r : r[i.rootName];
      s && (i.placeholder = s);
    }
    uu({ view: e, element: i, isDirectHost: !1, keepOnFocus: !0 });
  }
}
class KT extends w5 {
  constructor(t, e, i, r) {
    super(t);
    m(this, "editable");
    m(this, "menuBarView");
    this.editable = new v5(t, e, i, { label: r }), this.menuBarView = new L5(t), this.menuBarView.extendTemplate({ attributes: { class: ["ck-reset_all", "ck-rounded-corners"], dir: t.uiLanguageDirection } });
  }
  render() {
    super.render(), this.registerChild(this.editable), this.registerChild(this.menuBarView);
  }
}
class YT extends od(Po) {
  constructor(t, e = {}) {
    if (!Us(t) && e.initialData !== void 0) throw new v("editor-create-initial-data", null);
    super(e);
    m(this, "ui");
    this.config.get("initialData") === void 0 && this.config.set("initialData", function(s) {
      return Us(s) ? fC(s) : s;
    }(t)), Us(t) && (this.sourceElement = t, e2(this, t));
    const i = this.config.get("plugins");
    i.push(S5), this.config.set("plugins", i), this.config.define("balloonToolbar", this.config.get("toolbar")), this.model.document.createRoot();
    const r = new KT(this.locale, this.editing.view, this.sourceElement, this.config.get("label"));
    this.ui = new GT(this, r), t2(this);
  }
  static get editorName() {
    return "BalloonEditor";
  }
  destroy() {
    const t = this.getData();
    return this.ui.destroy(), super.destroy().then(() => {
      this.sourceElement && this.updateSourceElement(t);
    });
  }
  static create(t, e = {}) {
    return new Promise((i) => {
      if (Us(t) && t.tagName === "TEXTAREA") throw new v("editor-wrong-element", null);
      const r = new this(t, e);
      i(r.initPlugins().then(() => r.ui.init()).then(() => r.data.init(r.config.get("initialData"))).then(() => r.fire("ready")).then(() => r));
    });
  }
}
function Us(o) {
  return Si(o);
}
var uc, ZT = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, f_ = { exports: {} };
uc = f_, ((o, n) => {
  uc.exports ? uc.exports = n() : o.fuzzysort = n();
})(ZT, (o) => {
  var n = (M) => {
    typeof M == "number" ? M = "" + M : typeof M != "string" && (M = "");
    var T = f(M);
    return i(M, { _targetLower: T._lower, _targetLowerCodes: T.lowerCodes, _bitflags: T.bitflags });
  };
  class t {
    get indexes() {
      return this._indexes.slice(0, this._indexes.len).sort((T, O) => T - O);
    }
    set indexes(T) {
      return this._indexes = T;
    }
    highlight(T, O) {
      return ((J, Z = "<b>", G = "</b>") => {
        for (var pt = typeof Z == "function" ? Z : void 0, bt = J.target, ot = bt.length, rt = J.indexes, Ct = "", jt = 0, Nt = 0, ft = !1, Dt = [], zt = 0; zt < ot; ++zt) {
          var oe = bt[zt];
          if (rt[Nt] === zt) {
            if (++Nt, ft || (ft = !0, pt ? (Dt.push(Ct), Ct = "") : Ct += Z), Nt === rt.length) {
              pt ? (Ct += oe, Dt.push(pt(Ct, jt++)), Ct = "", Dt.push(bt.substr(zt + 1))) : Ct += oe + G + bt.substr(zt + 1);
              break;
            }
          } else ft && (ft = !1, pt ? (Dt.push(pt(Ct, jt++)), Ct = "") : Ct += G);
          Ct += oe;
        }
        return pt ? Dt : Ct;
      })(this, T, O);
    }
    get score() {
      return r(this._score);
    }
    set score(T) {
      this._score = s(T);
    }
  }
  class e extends Array {
    get score() {
      return r(this._score);
    }
    set score(T) {
      this._score = s(T);
    }
  }
  var i = (M, T) => {
    const O = new t();
    return O.target = M, O.obj = T.obj ?? Qt, O._score = T._score ?? ct, O._indexes = T._indexes ?? [], O._targetLower = T._targetLower ?? "", O._targetLowerCodes = T._targetLowerCodes ?? Qt, O._nextBeginningIndexes = T._nextBeginningIndexes ?? Qt, O._bitflags = T._bitflags ?? 0, O;
  }, r = (M) => M === ct ? 0 : M > 1 ? M : Math.E ** (-2 * ((1 - M) ** 0.04307 - 1)), s = (M) => M === 0 ? ct : M > 1 ? M : 1 - Math.pow(Math.log(M) / -2 + 1, 1 / 0.04307), a = (M) => {
    typeof M == "number" ? M = "" + M : typeof M != "string" && (M = ""), M = M.trim();
    var T = f(M), O = [];
    if (T.containsSpace) {
      var J = M.split(/\s+/);
      J = [...new Set(J)];
      for (var Z = 0; Z < J.length; Z++) if (J[Z] !== "") {
        var G = f(J[Z]);
        O.push({ lowerCodes: G.lowerCodes, _lower: J[Z].toLowerCase(), containsSpace: !1 });
      }
    }
    return { lowerCodes: T.lowerCodes, _lower: T._lower, containsSpace: T.containsSpace, bitflags: T.bitflags, spaceSearches: O };
  }, l = (M) => {
    if (M.length > 999) return n(M);
    var T = b.get(M);
    return T !== void 0 || (T = n(M), b.set(M, T)), T;
  }, c = (M) => {
    if (M.length > 999) return a(M);
    var T = k.get(M);
    return T !== void 0 || (T = a(M), k.set(M, T)), T;
  }, d = (M, T) => {
    var O = [];
    O.total = M.length;
    var J = (T == null ? void 0 : T.limit) || te;
    if (T != null && T.key) for (var Z = 0; Z < M.length; Z++) {
      var G = M[Z];
      if ((rt = Y(G, T.key)) != Qt) {
        it(rt) || (rt = l(rt));
        var pt = i(rt.target, { _score: rt._score, obj: G });
        if (O.push(pt), O.length >= J) return O;
      }
    }
    else if (T != null && T.keys) for (Z = 0; Z < M.length; Z++) {
      G = M[Z];
      for (var bt = new e(T.keys.length), ot = T.keys.length - 1; ot >= 0; --ot) (rt = Y(G, T.keys[ot])) ? (it(rt) || (rt = l(rt)), rt._score = ct, rt._indexes.len = 0, bt[ot] = rt) : bt[ot] = ui;
      if (bt.obj = G, bt._score = ct, O.push(bt), O.length >= J) return O;
    }
    else for (Z = 0; Z < M.length; Z++) {
      var rt;
      if ((rt = M[Z]) != Qt && (it(rt) || (rt = l(rt)), rt._score = ct, rt._indexes.len = 0, O.push(rt), O.length >= J)) return O;
    }
    return O;
  }, u = (M, T, O = !1, J = !1) => {
    if (O === !1 && M.containsSpace) return h(M, T, J);
    for (var Z = M._lower, G = M.lowerCodes, pt = G[0], bt = T._targetLowerCodes, ot = G.length, rt = bt.length, Ct = 0, jt = 0, Nt = 0; ; ) {
      if (pt === bt[jt]) {
        if (w[Nt++] = jt, ++Ct === ot) break;
        pt = G[Ct];
      }
      if (++jt >= rt) return Qt;
    }
    Ct = 0;
    var ft = !1, Dt = 0, zt = T._nextBeginningIndexes;
    zt === Qt && (zt = T._nextBeginningIndexes = p(T.target));
    var oe = 0;
    if ((jt = w[0] === 0 ? 0 : zt[w[0] - 1]) !== rt) for (; ; ) if (jt >= rt) {
      if (Ct <= 0 || ++oe > 200) break;
      --Ct;
      var jn = _[--Dt];
      jt = zt[jn];
    } else if (G[Ct] === bt[jt]) {
      if (_[Dt++] = jt, ++Ct === ot) {
        ft = !0;
        break;
      }
      ++jt;
    } else jt = zt[jt];
    var Ot = ot <= 1 ? -1 : T._targetLower.indexOf(Z, w[0]), Qe = !!~Ot, kt = !!Qe && (Ot === 0 || T._nextBeginningIndexes[Ot - 1] === Ot);
    if (Qe && !kt) {
      for (var dt = 0; dt < zt.length; dt = zt[dt]) if (!(dt <= Ot)) {
        for (var An = 0; An < ot && G[An] === T._targetLowerCodes[dt + An]; An++) ;
        if (An === ot) {
          Ot = dt, kt = !0;
          break;
        }
      }
    }
    var Ht = (hi) => {
      for (var Hn = 0, Gu = 0, Un = 1; Un < ot; ++Un) hi[Un] - hi[Un - 1] != 1 && (Hn -= hi[Un], ++Gu);
      if (Hn -= (hi[ot - 1] - hi[0] - (ot - 1) + 12) * Gu, hi[0] !== 0 && (Hn -= hi[0] * hi[0] * 0.2), ft) {
        var vl = 1;
        for (Un = zt[0]; Un < rt; Un = zt[Un]) ++vl;
        vl > 24 && (Hn *= 10 * (vl - 24));
      } else Hn *= 1e3;
      return Hn -= (rt - ot) / 2, Qe && (Hn /= 1 + ot * ot * 1), kt && (Hn /= 1 + ot * ot * 1), Hn -= (rt - ot) / 2;
    };
    if (ft) if (kt) {
      for (dt = 0; dt < ot; ++dt) w[dt] = Ot + dt;
      ve = w, Oi = Ht(w);
    } else ve = _, Oi = Ht(_);
    else {
      if (Qe) for (var dt = 0; dt < ot; ++dt) w[dt] = Ot + dt;
      var ve, Oi = Ht(ve = w);
    }
    for (T._score = Oi, dt = 0; dt < ot; ++dt) T._indexes[dt] = ve[dt];
    T._indexes.len = ot;
    const tt = new t();
    return tt.target = T.target, tt._score = T._score, tt._indexes = T._indexes, tt;
  }, h = (M, T, O) => {
    for (var J = /* @__PURE__ */ new Set(), Z = 0, G = Qt, pt = 0, bt = M.spaceSearches, ot = bt.length, rt = 0, Ct = () => {
      for (let kt = rt - 1; kt >= 0; kt--) T._nextBeginningIndexes[y[2 * kt + 0]] = y[2 * kt + 1];
    }, jt = !1, Nt = 0; Nt < ot; ++Nt) {
      x[Nt] = ct;
      var ft = bt[Nt];
      if (G = u(ft, T), O) {
        if (G === Qt) continue;
        jt = !0;
      } else if (G === Qt) return Ct(), Qt;
      if (Nt !== ot - 1) {
        var Dt = G._indexes, zt = !0;
        for (let kt = 0; kt < Dt.len - 1; kt++) if (Dt[kt + 1] - Dt[kt] != 1) {
          zt = !1;
          break;
        }
        if (zt) {
          var oe = Dt[Dt.len - 1] + 1, jn = T._nextBeginningIndexes[oe - 1];
          for (let kt = oe - 1; kt >= 0 && jn === T._nextBeginningIndexes[kt]; kt--) T._nextBeginningIndexes[kt] = oe, y[2 * rt + 0] = kt, y[2 * rt + 1] = jn, rt++;
        }
      }
      Z += G._score / ot, x[Nt] = G._score / ot, G._indexes[0] < pt && (Z -= 2 * (pt - G._indexes[0])), pt = G._indexes[0];
      for (var Ot = 0; Ot < G._indexes.len; ++Ot) J.add(G._indexes[Ot]);
    }
    if (O && !jt) return Qt;
    Ct();
    var Qe = u(M, T, !0);
    if (Qe !== Qt && Qe._score > Z) {
      if (O) for (Nt = 0; Nt < ot; ++Nt) x[Nt] = Qe._score / ot;
      return Qe;
    }
    O && (G = T), G._score = Z, Nt = 0;
    for (let kt of J) G._indexes[Nt++] = kt;
    return G._indexes.len = Nt, G;
  }, g = (M) => M.replace(new RegExp("\\p{Script=Latin}+", "gu"), (T) => T.normalize("NFD")).replace(/[\u0300-\u036f]/g, ""), f = (M) => {
    for (var T = (M = g(M)).length, O = M.toLowerCase(), J = [], Z = 0, G = !1, pt = 0; pt < T; ++pt) {
      var bt = J[pt] = O.charCodeAt(pt);
      bt !== 32 ? Z |= 1 << (bt >= 97 && bt <= 122 ? bt - 97 : bt >= 48 && bt <= 57 ? 26 : bt <= 127 ? 30 : 31) : G = !0;
    }
    return { lowerCodes: J, bitflags: Z, containsSpace: G, _lower: O };
  }, p = (M) => {
    for (var T = (M = g(M)).length, O = ((bt) => {
      for (var ot = bt.length, rt = [], Ct = 0, jt = !1, Nt = !1, ft = 0; ft < ot; ++ft) {
        var Dt = bt.charCodeAt(ft), zt = Dt >= 65 && Dt <= 90, oe = zt || Dt >= 97 && Dt <= 122 || Dt >= 48 && Dt <= 57, jn = zt && !jt || !Nt || !oe;
        jt = zt, Nt = oe, jn && (rt[Ct++] = ft);
      }
      return rt;
    })(M), J = [], Z = O[0], G = 0, pt = 0; pt < T; ++pt) Z > pt ? J[pt] = Z : (Z = O[++G], J[pt] = Z === void 0 ? T : Z);
    return J;
  }, b = /* @__PURE__ */ new Map(), k = /* @__PURE__ */ new Map(), w = [], _ = [], y = [], C = [], x = [], I = [], P = [], Y = (M, T) => {
    var O = M[T];
    if (O !== void 0) return O;
    if (typeof T == "function") return T(M);
    var J = T;
    Array.isArray(T) || (J = T.split("."));
    for (var Z = J.length, G = -1; M && ++G < Z; ) M = M[J[G]];
    return M;
  }, it = (M) => typeof M == "object" && typeof M._bitflags == "number", te = 1 / 0, ct = -te, ee = [];
  ee.total = 0;
  var Vt, ie, Le, Cn, Qt = null, ui = n(""), bo = (Vt = [], ie = 0, Cn = (M) => {
    for (var T = 0, O = Vt[T], J = 1; J < ie; ) {
      var Z = J + 1;
      T = J, Z < ie && Vt[Z]._score < Vt[J]._score && (T = Z), Vt[T - 1 >> 1] = Vt[T], J = 1 + (T << 1);
    }
    for (var G = T - 1 >> 1; T > 0 && O._score < Vt[G]._score; G = (T = G) - 1 >> 1) Vt[T] = Vt[G];
    Vt[T] = O;
  }, (Le = {}).add = (M) => {
    var T = ie;
    Vt[ie++] = M;
    for (var O = T - 1 >> 1; T > 0 && M._score < Vt[O]._score; O = (T = O) - 1 >> 1) Vt[T] = Vt[O];
    Vt[T] = M;
  }, Le.poll = (M) => {
    if (ie !== 0) {
      var T = Vt[0];
      return Vt[0] = Vt[--ie], Cn(), T;
    }
  }, Le.peek = (M) => {
    if (ie !== 0) return Vt[0];
  }, Le.replaceTop = (M) => {
    Vt[0] = M, Cn();
  }, Le);
  return { single: (M, T) => {
    if (!M || !T) return Qt;
    var O = c(M);
    it(T) || (T = l(T));
    var J = O.bitflags;
    return (J & T._bitflags) !== J ? Qt : u(O, T);
  }, go: (M, T, O) => {
    if (!M) return O != null && O.all ? d(T, O) : ee;
    var J = c(M), Z = J.bitflags, G = J.containsSpace, pt = s((O == null ? void 0 : O.threshold) || 0), bt = (O == null ? void 0 : O.limit) || te, ot = 0, rt = 0, Ct = T.length;
    function jt(tt) {
      ot < bt ? (bo.add(tt), ++ot) : (++rt, tt._score > bo.peek()._score && bo.replaceTop(tt));
    }
    if (O != null && O.key) for (var Nt = O.key, ft = 0; ft < Ct; ++ft) {
      var Dt = T[ft];
      (Ht = Y(Dt, Nt)) && (it(Ht) || (Ht = l(Ht)), (Z & Ht._bitflags) === Z && (ve = u(J, Ht)) !== Qt && (ve._score < pt || (ve.obj = Dt, jt(ve))));
    }
    else if (O != null && O.keys) {
      var zt = O.keys, oe = zt.length;
      t: for (ft = 0; ft < Ct; ++ft) {
        Dt = T[ft];
        for (var jn = 0, Ot = 0; Ot < oe; ++Ot) Nt = zt[Ot], (Ht = Y(Dt, Nt)) ? (it(Ht) || (Ht = l(Ht)), I[Ot] = Ht, jn |= Ht._bitflags) : I[Ot] = ui;
        if ((Z & jn) === Z) {
          if (G) for (let tt = 0; tt < J.spaceSearches.length; tt++) C[tt] = ct;
          for (Ot = 0; Ot < oe; ++Ot) if ((Ht = I[Ot]) !== ui) if (P[Ot] = u(J, Ht, !1, G), P[Ot] !== Qt) {
            if (G) for (let tt = 0; tt < J.spaceSearches.length; tt++) x[tt] > -1e3 && C[tt] > ct && (An = (C[tt] + x[tt]) / 4) > C[tt] && (C[tt] = An), x[tt] > C[tt] && (C[tt] = x[tt]);
          } else P[Ot] = ui;
          else P[Ot] = ui;
          if (G) {
            for (let tt = 0; tt < J.spaceSearches.length; tt++) if (C[tt] === ct) continue t;
          } else {
            var Qe = !1;
            for (let tt = 0; tt < oe; tt++) if (P[tt]._score !== ct) {
              Qe = !0;
              break;
            }
            if (!Qe) continue;
          }
          var kt = new e(oe);
          for (let tt = 0; tt < oe; tt++) kt[tt] = P[tt];
          if (G) {
            var dt = 0;
            for (let tt = 0; tt < J.spaceSearches.length; tt++) dt += C[tt];
          } else {
            dt = ct;
            for (let tt = 0; tt < oe; tt++) {
              var An;
              (ve = kt[tt])._score > -1e3 && dt > ct && (An = (dt + ve._score) / 4) > dt && (dt = An), ve._score > dt && (dt = ve._score);
            }
          }
          if (kt.obj = Dt, kt._score = dt, O == null ? void 0 : O.scoreFn) {
            if (!(dt = O.scoreFn(kt))) continue;
            dt = s(dt), kt._score = dt;
          }
          dt < pt || jt(kt);
        }
      }
    } else for (ft = 0; ft < Ct; ++ft) {
      var Ht, ve;
      (Ht = T[ft]) && (it(Ht) || (Ht = l(Ht)), (Z & Ht._bitflags) === Z && (ve = u(J, Ht)) !== Qt && (ve._score < pt || jt(ve)));
    }
    if (ot === 0) return ee;
    var Oi = new Array(ot);
    for (ft = ot - 1; ft >= 0; --ft) Oi[ft] = bo.poll();
    return Oi.total = ot + rt, Oi;
  }, prepare: n, cleanup: () => {
    b.clear(), k.clear();
  } };
});
var QT = f_.exports;
function JT(o) {
  const n = function() {
    try {
      return document.createElement("canvas").getContext("2d", { willReadFrequently: !0 });
    } catch {
      return null;
    }
  }();
  if (!n) return !1;
  const t = 20, e = Math.floor(12.5);
  n.font = e + "px Arial, Sans-Serif", n.textBaseline = "top", n.canvas.width = 40, n.canvas.height = 25, n.clearRect(0, 0, 40, 25), n.fillStyle = "#FF0000", n.fillText(o, 0, 22), n.fillStyle = "#0000FF", n.fillText(o, t, 22);
  const i = n.getImageData(0, 0, t, 25).data, r = i.length;
  let s = 0;
  for (; s < r && !i[s + 3]; s += 4) ;
  if (s >= r) return !1;
  const a = t + s / 4 % t, l = Math.floor(s / 4 / t), c = n.getImageData(a, l, 1, 1).data;
  return i[s] === c[0] && i[s + 2] === c[2] && !(n.measureText(o).width >= t);
}
const XT = { 0: "default", 1: "light", 2: "medium-light", 3: "medium", 4: "medium-dark", 5: "dark" }, tS = { "": 16, "": 15.1, "": 14, "": 13.1, "": 12.1, "": 11, "": 5, "": 4, "": 3, "": 2, "": 1, "": 0.7, "": 0.6 }, Ka = class Ka extends A {
  static get pluginName() {
    return "EmojiUtils";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  isEmojiSupported(n, t, e) {
    return n.version <= t && (!this.hasZwj(n.emoji) || this.isEmojiZwjSupported(n, e));
  }
  getEmojiSupportedVersionByOs() {
    for (const [n, t] of Object.entries(tS)) if (Ka._isEmojiSupported(n)) return t;
    return 0;
  }
  hasZwj(n) {
    return n.includes("");
  }
  isEmojiZwjSupported(n, t) {
    return this.getNodeWidth(t, n.emoji) < 43.2;
  }
  getNodeWidth(n, t) {
    const e = document.createElement("span");
    e.textContent = t, n.appendChild(e);
    const i = e.offsetWidth;
    return n.removeChild(e), i;
  }
  createEmojiWidthTestingContainer() {
    const n = document.createElement("div");
    return n.setAttribute("aria-hidden", "true"), n.style.position = "absolute", n.style.left = "-9999px", n.style.whiteSpace = "nowrap", n.style.fontSize = "24px", n;
  }
  normalizeEmojiSkinTone(n) {
    const t = { ...n, skins: { default: n.emoji } };
    return n.skins && n.skins.forEach((e) => {
      const i = XT[e.tone];
      t.skins[i] = e.emoji;
    }), t;
  }
  isEmojiCategoryAllowed(n) {
    return n.group !== 2;
  }
};
m(Ka, "_isEmojiSupported", JT);
let wd = Ka;
const jo = class jo extends A {
  constructor(t) {
    super(t);
    m(this, "_items");
    m(this, "_url");
    m(this, "_repositoryPromise");
    t.config.define("emoji", { version: void 0, skinTone: "default", definitionsUrl: void 0, useCustomFont: !1 }), this._url = this._getUrl(), this._repositoryPromise = new Promise((e) => {
      this._repositoryPromiseResolveCallback = e;
    }), this._items = null;
  }
  static get requires() {
    return [wd];
  }
  static get pluginName() {
    return "EmojiRepository";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  async init() {
    return this._warnAboutCdnUse(), await this._loadAndCacheEmoji(), this._items = this._getItems(), this._items ? this._repositoryPromiseResolveCallback(!0) : (at("emoji-repository-empty"), this._repositoryPromiseResolveCallback(!1));
  }
  getEmojiByQuery(t) {
    return this._items ? t.split(/\s/).filter(Boolean).some((e) => e.length >= 2) ? QT.go(t, this._items, { threshold: 0.6, keys: ["emoticon", "annotation", (e) => t.split(/\s/).filter(Boolean).flatMap((i) => {
      var r;
      return (r = e.tags) == null ? void 0 : r.filter((s) => s.startsWith(i));
    }).join()] }).map((e) => e.obj) : [] : [];
  }
  getEmojiCategories() {
    const t = this._getItems();
    if (!t) return [];
    const { t: e } = this.editor.locale, i = [{ title: e("Smileys & Expressions"), icon: "", groupId: 0 }, { title: e("Gestures & People"), icon: "", groupId: 1 }, { title: e("Animals & Nature"), icon: "", groupId: 3 }, { title: e("Food & Drinks"), icon: "", groupId: 4 }, { title: e("Travel & Places"), icon: "", groupId: 5 }, { title: e("Activities"), icon: "", groupId: 6 }, { title: e("Objects"), icon: "", groupId: 7 }, { title: e("Symbols"), icon: "", groupId: 8 }, { title: e("Flags"), icon: "", groupId: 9 }], r = function(s, a) {
      const l = {};
      for (let c = 0; c < s.length; c++) {
        const d = s[c], u = a(d);
        Object.hasOwn(l, u) || (l[u] = []), l[u].push(d);
      }
      return l;
    }(t, (s) => s.group);
    return i.map((s) => ({ ...s, items: r[s.groupId] }));
  }
  getSkinTones() {
    const { t } = this.editor.locale;
    return [{ id: "default", icon: "", tooltip: t("Default skin tone") }, { id: "light", icon: "", tooltip: t("Light skin tone") }, { id: "medium-light", icon: "", tooltip: t("Medium Light skin tone") }, { id: "medium", icon: "", tooltip: t("Medium skin tone") }, { id: "medium-dark", icon: "", tooltip: t("Medium Dark skin tone") }, { id: "dark", icon: "", tooltip: t("Dark skin tone") }];
  }
  isReady() {
    return this._repositoryPromise;
  }
  _getUrl() {
    const { definitionsUrl: t, version: e } = this.editor.config.get("emoji");
    if (!t || t === "cdn") {
      const i = new URL("https://cdn.ckeditor.com/ckeditor5/data/emoji/{version}/en.json".replace("{version}", (e || 16).toString()));
      return i.searchParams.set("editorVersion", Rb), i;
    }
    return e && at("emoji-repository-redundant-version"), new URL(t);
  }
  _warnAboutCdnUse() {
    const t = this.editor, e = t.config.get("emoji"), i = t.config.get("licenseKey"), r = window[Symbol.for("cke distribution")];
    i !== "GPL" && r !== "cloud" && (e && e.definitionsUrl || at("emoji-repository-cdn-use"));
  }
  _getItems() {
    const t = jo._results[this._url.href];
    return t && t.length ? t : null;
  }
  async _loadAndCacheEmoji() {
    if (jo._results[this._url.href]) return;
    const t = await fetch(this._url, { cache: "force-cache" }).then((e) => e.ok ? e.json() : []).catch(() => []);
    jo._results[this._url.href] = this._normalizeEmoji(t);
  }
  _normalizeEmoji(t) {
    const e = this.editor, i = e.config.get("emoji.useCustomFont"), r = e.plugins.get("EmojiUtils"), s = t.filter((d) => r.isEmojiCategoryAllowed(d));
    if (i) return s.map((d) => r.normalizeEmojiSkinTone(d));
    const a = r.getEmojiSupportedVersionByOs(), l = r.createEmojiWidthTestingContainer();
    document.body.appendChild(l);
    const c = s.filter((d) => r.isEmojiSupported(d, a, l)).map((d) => r.normalizeEmojiSkinTone(d));
    return l.remove(), c;
  }
};
m(jo, "_results", {});
let za = jo;
const So = ":", hc = ":__EMOJI_SHOW_ALL:", mc = ":__EMOJI_HINT:";
class eS extends A {
  constructor(t) {
    super(t);
    m(this, "_emojiDropdownLimit");
    m(this, "_skinTone");
    this.editor.config.define("emoji", { dropdownLimit: 6 }), this._emojiDropdownLimit = t.config.get("emoji.dropdownLimit"), this._skinTone = t.config.get("emoji.skinTone"), this._setupMentionConfiguration(t);
  }
  static get requires() {
    return [za, gl, "Mention"];
  }
  static get pluginName() {
    return "EmojiMention";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  _setupMentionConfiguration(t) {
    const e = t.config.get("mergeFields.prefix"), i = t.config.get("mention.feeds"), r = !!e && e[0] === So;
    if (i.filter((a) => !a._isEmojiMarker).some((a) => a.marker === So) || r) return void at("emoji-config-marker-already-used", { marker: So });
    if (i.some((a) => a._isEmojiMarker)) return;
    const s = { _isEmojiMarker: !0, marker: So, dropdownLimit: this._emojiDropdownLimit, itemRenderer: this._customItemRendererFactory(this.editor.t), feed: this._queryEmojiCallbackFactory() };
    this.editor.config.set("mention.feeds", [...i, s]);
  }
  async init() {
    const t = this.editor;
    this.emojiPickerPlugin = t.plugins.has("EmojiPicker") ? t.plugins.get("EmojiPicker") : null, this.emojiRepositoryPlugin = t.plugins.get("EmojiRepository"), this._isEmojiRepositoryAvailable = await this.emojiRepositoryPlugin.isReady(), this._isEmojiRepositoryAvailable && t.once("ready", this._overrideMentionExecuteListener.bind(this));
  }
  _customItemRendererFactory(t) {
    return (e) => {
      const i = document.createElement("button");
      i.classList.add("ck"), i.classList.add("ck-button"), i.classList.add("ck-button_with-text"), i.id = `mention-list-item-id${e.id.slice(0, -1)}`, i.type = "button", i.tabIndex = -1;
      const r = document.createElement("span");
      return r.classList.add("ck"), r.classList.add("ck-button__label"), i.appendChild(r), e.id === mc ? (i.classList.add("ck-list-item-button"), i.classList.add("ck-disabled"), r.textContent = t("Keep on typing to see the emoji.")) : e.id === hc ? r.textContent = t("Show all emoji...") : r.textContent = `${e.text} ${e.id}`, i;
    };
  }
  _overrideMentionExecuteListener() {
    const t = this.editor;
    t.commands.get("mention").on("execute", (e, i) => {
      const r = i[0];
      if (r.marker === So && (e.stop(), r.mention.id !== mc)) if (r.mention.id === hc) {
        const s = [...r.range.getItems()].filter((l) => l.is("$textProxy")).map((l) => l.data).reduce((l, c) => l + c, "");
        t.model.change((l) => {
          t.model.deleteContent(l.createSelection(r.range));
        });
        const a = this.emojiPickerPlugin;
        a.showUI(s.slice(1)), setTimeout(() => {
          a.emojiPickerView.focus();
        });
      } else t.execute("insertText", { text: r.mention.text, range: r.range });
    }, { priority: "high" });
  }
  _queryEmojiCallbackFactory() {
    return (t) => {
      if (t.startsWith(" ")) return [];
      if (t.startsWith(So)) return [];
      if (!this._isEmojiRepositoryAvailable) return [];
      const e = this.emojiRepositoryPlugin.getEmojiByQuery(t).map((r) => {
        let s = r.skins[this._skinTone] || r.skins.default;
        return this.emojiPickerPlugin && (s = r.skins[this.emojiPickerPlugin.skinTone] || r.skins.default), { id: `:${r.annotation}:`, text: s };
      });
      if (!this.emojiPickerPlugin) return e.slice(0, this._emojiDropdownLimit);
      const i = { id: t.length > 1 ? hc : mc };
      return [...e.slice(0, this._emojiDropdownLimit - 1), i];
    };
  }
}
class nS extends q {
  refresh() {
    const n = this.editor.model, t = n.schema, e = n.document.selection;
    this.isEnabled = t.checkChild(e.getFirstPosition(), "$text");
  }
  execute(n = "") {
    this.editor.plugins.get("EmojiPicker").showUI(n);
  }
}
class iS extends L {
  constructor(t, { categoryName: e, emojiCategories: i, getEmojiByQuery: r, skinTone: s }) {
    super(t);
    m(this, "tiles");
    m(this, "focusTracker");
    m(this, "keystrokes");
    m(this, "emojiCategories");
    m(this, "cachedTiles");
    m(this, "_getEmojiByQuery");
    this.set("isEmpty", !0), this.set("categoryName", e), this.set("skinTone", s), this.tiles = this.createCollection(), this.cachedTiles = this.createCollection(), this.focusTracker = new gt(), this.keystrokes = new Mt(), this._getEmojiByQuery = r, this.emojiCategories = i;
    const a = this.bindTemplate;
    this.setTemplate({ tag: "div", children: [{ tag: "div", attributes: { role: "grid", class: ["ck", "ck-emoji__grid"] }, children: this.tiles }], attributes: { role: "tabpanel", class: ["ck", "ck-emoji__tiles", a.if("isEmpty", "ck-hidden", (l) => l)] } }), vs({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.tiles, numberOfColumns: () => N.window.getComputedStyle(this.element.firstChild).getPropertyValue("grid-template-columns").split(" ").length, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection });
  }
  render() {
    super.render(), this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy(), this.keystrokes.destroy(), this.focusTracker.destroy();
  }
  focus() {
    const t = this.tiles.first;
    t && t.focus();
  }
  filter(t) {
    const { matchingItems: e, allItems: i } = t ? this._getItemsByQuery(t.source) : this._getItemsByCategory();
    return this._updateGrid(e), this.set("isEmpty", e.length === 0), { resultsCount: e.length, totalItemsCount: i.length };
  }
  _getItemsByQuery(t) {
    return { matchingItems: this._getEmojiByQuery(t), allItems: this.emojiCategories.flatMap((e) => e.items) };
  }
  _getItemsByCategory() {
    const t = this.emojiCategories.find((i) => i.title === this.categoryName), { items: e } = t;
    return { matchingItems: e, allItems: e };
  }
  _updateGrid(t) {
    [...this.tiles].forEach((e) => {
      this.focusTracker.remove(e), this.tiles.remove(e);
    }), t.map((e) => {
      const i = e.skins[this.skinTone] || e.skins.default;
      return this.cachedTiles.get(i) || this._createTile(i, e.annotation);
    }).forEach((e) => {
      this.tiles.add(e), this.focusTracker.add(e);
    });
  }
  _createTile(t, e) {
    const i = new V(this.locale);
    return i.viewUid = t, i.extendTemplate({ attributes: { class: ["ck-emoji__tile"] } }), i.set({ label: t, tooltip: e, withText: !0, ariaLabel: e, ariaLabelledBy: void 0 }), i.on("execute", () => {
      this.fire("execute", { name: e, emoji: t });
    }), this.cachedTiles.add(i), i;
  }
}
class oS extends L {
  constructor(t, { emojiCategories: e, categoryName: i }) {
    super(t);
    m(this, "focusTracker");
    m(this, "keystrokes");
    m(this, "focusCycler");
    m(this, "buttonViews");
    this.buttonViews = this.createCollection(e.map((r) => this._createCategoryButton(r))), this.focusTracker = new gt(), this.keystrokes = new Mt(), this.focusCycler = new le({ focusables: this.buttonViews, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "arrowleft", focusNext: "arrowright" } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-emoji__categories-list"], role: "tablist" }, children: this.buttonViews }), this.on("change:categoryName", (r, s, a, l) => {
      const c = this.buttonViews.find((d) => d.tooltip === l);
      c && (c.isOn = !1), this.buttonViews.find((d) => d.tooltip === a).isOn = !0;
    }), this.set("categoryName", i);
  }
  render() {
    super.render(), this.buttonViews.forEach((t) => {
      this.focusTracker.add(t);
    }), this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy(), this.buttonViews.destroy();
  }
  focus() {
    this.buttonViews.first.focus();
  }
  enableCategories() {
    this.buttonViews.forEach((t) => {
      t.isEnabled = !0;
    });
  }
  disableCategories() {
    this.buttonViews.forEach((t) => {
      t.set({ class: "", isEnabled: !1, isOn: !1 });
    });
  }
  _createCategoryButton(t) {
    const e = new V(), i = e.bindTemplate;
    return e.extendTemplate({ attributes: { "aria-selected": i.to("isOn", (r) => r.toString()), class: ["ck-emoji__category-item"] } }), e.set({ ariaLabel: t.title, label: t.icon, role: "tab", tooltip: t.title, withText: !0, ariaLabelledBy: void 0 }), e.on("execute", () => {
      this.categoryName = t.title;
    }), e.on("change:isEnabled", () => {
      e.isEnabled && e.tooltip === this.categoryName && (e.isOn = !0);
    }), e;
  }
}
class rS extends L {
  constructor(t, { gridView: e, resultsView: i }) {
    super(t);
    m(this, "inputView");
    m(this, "gridView");
    this.gridView = e;
    const r = t.t;
    this.inputView = new E5(this.locale, { queryView: { label: r("Find an emoji (min. 2 characters)"), creator: Mi }, filteredView: this.gridView, infoView: { instance: i } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-search"], tabindex: "-1" }, children: [this.inputView.queryView] }), this.inputView.delegate("search").to(this);
  }
  destroy() {
    super.destroy(), this.inputView.destroy();
  }
  search(t) {
    const e = t ? new RegExp(mk(t), "ig") : null, i = this.gridView.filter(e);
    this.inputView.fire("search", { query: t, ...i });
  }
  setInputValue(t) {
    t ? this.inputView.queryView.fieldView.value = t : this.inputView.queryView.fieldView.reset();
  }
  getInputValue() {
    return this.inputView.queryView.fieldView.element.value;
  }
  focus() {
    this.inputView.focus();
  }
}
class sS extends L {
  constructor(t, { skinTone: e, skinTones: i }) {
    super(t);
    m(this, "dropdownView");
    m(this, "_skinTones");
    this.set("skinTone", e), this._skinTones = i;
    const r = (0, t.t)("Select skin tone"), s = ge(t), a = new ne();
    for (const { id: l, icon: c, tooltip: d } of this._skinTones) {
      const u = { type: "button", model: new ai({ value: l, label: c, ariaLabel: d, tooltip: d, tooltipPosition: "e", role: "menuitemradio", withText: !0, ariaLabelledBy: void 0 }) };
      u.model.bind("isOn").to(this, "skinTone", (h) => h === l), a.add(u);
    }
    zi(s, a, { ariaLabel: r, role: "menu" }), s.buttonView.set({ label: this._getSkinTone().icon, ariaLabel: r, ariaLabelledBy: void 0, isOn: !1, withText: !0, tooltip: r }), this.dropdownView = s, this.listenTo(s, "execute", (l) => {
      this.skinTone = l.source.value;
    }), s.buttonView.bind("label").to(this, "skinTone", () => this._getSkinTone().icon), s.buttonView.bind("ariaLabel").to(this, "skinTone", () => `${this._getSkinTone().tooltip}, ${r}`), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-emoji__skin-tone"] }, children: [s] });
  }
  focus() {
    this.dropdownView.buttonView.focus();
  }
  _getSkinTone() {
    return this._skinTones.find((t) => t.id === this.skinTone);
  }
}
class aS extends L {
  constructor(t, { emojiCategories: e, getEmojiByQuery: i, skinTone: r, skinTones: s }) {
    super(t);
    m(this, "items");
    m(this, "focusTracker");
    m(this, "keystrokes");
    m(this, "focusCycler");
    m(this, "searchView");
    m(this, "toneView");
    m(this, "categoriesView");
    m(this, "gridView");
    m(this, "infoView");
    const a = e[0].title;
    this.gridView = new iS(t, { categoryName: a, emojiCategories: e, getEmojiByQuery: i, skinTone: r }), this.infoView = new Yw(), this.searchView = new rS(t, { gridView: this.gridView, resultsView: this.infoView }), this.categoriesView = new oS(t, { emojiCategories: e, categoryName: a }), this.toneView = new sS(t, { skinTone: r, skinTones: s }), this.items = this.createCollection([this.searchView, this.toneView, this.categoriesView, this.gridView, this.infoView]), this.focusTracker = new gt(), this.keystrokes = new Mt(), this.focusCycler = new le({ focusables: this.items, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", children: [{ tag: "div", children: [this.searchView, this.toneView], attributes: { class: ["ck", "ck-emoji__search"] } }, this.categoriesView, this.gridView, { tag: "div", children: [this.infoView], attributes: { class: ["ck", "ck-search__results"] } }], attributes: { tabindex: "-1", class: ["ck", "ck-emoji", "ck-search"] } }), this._setupEventListeners();
  }
  render() {
    super.render(), this.focusTracker.add(this.searchView.element), this.focusTracker.add(this.toneView.element), this.focusTracker.add(this.categoriesView.element), this.focusTracker.add(this.gridView.element), this.focusTracker.add(this.infoView.element), this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  focus() {
    this.searchView.focus();
  }
  _setupEventListeners() {
    const t = this.locale.t;
    this.searchView.on("search", (e, i) => {
      i.query ? this.categoriesView.disableCategories() : this.categoriesView.enableCategories();
    }), this.searchView.on("search", (e, i) => {
      i.query.length === 1 ? this.infoView.set({ primaryText: t("Keep on typing to see the emoji."), secondaryText: t("The query must contain at least two characters."), isVisible: !0 }) : i.resultsCount ? this.infoView.set({ isVisible: !1 }) : this.infoView.set({ primaryText: t('No emojis were found matching "%0".', i.query), secondaryText: t("Please try a different phrase or check the spelling."), isVisible: !0 });
    }), this.searchView.on("search", () => {
      this.fire("update"), this.gridView.element.scrollTo(0, 0);
    }), this.categoriesView.on("change:categoryName", (e, i, r) => {
      this.gridView.categoryName = r, this.searchView.search("");
    }), this.toneView.on("change:skinTone", (e, i, r) => {
      this.gridView.skinTone = r, this.searchView.search(this.searchView.getInputValue());
    });
  }
}
class lS extends L {
  constructor(t) {
    super(t);
    m(this, "backButtonView");
    m(this, "focusTracker", new gt());
    m(this, "keystrokes", new Mt());
    m(this, "children");
    m(this, "_focusables", new Te());
    m(this, "_focusCycler");
    this.backButtonView = this._createBackButton(), this.children = this.createCollection([this._createHeaderView()]), this._focusCycler = new le({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-form", "ck-emoji-picker-form", "ck-responsive-form"], tabindex: "-1" }, children: this.children });
  }
  render() {
    super.render(), [...this.children.filter(lr), this.backButtonView].forEach((t) => {
      this._focusables.add(t), this.focusTracker.add(t.element), Sw(t) && this._focusCycler.chain(t.focusCycler);
    }), this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  focus() {
    this._focusCycler.focusFirst();
  }
  _createBackButton() {
    const t = this.locale.t, e = new V(this.locale);
    return e.set({ class: "ck-button-back", label: t("Back"), icon: co, tooltip: !0 }), e.delegate("execute").to(this, "cancel"), e;
  }
  _createHeaderView() {
    const t = this.locale.t, e = new uo(this.locale, { label: t("Emoji picker") });
    return e.children.add(this.backButtonView, 0), e;
  }
}
const fi = "emoji-picker";
class cS extends A {
  static get requires() {
    return [za, On, no, gl];
  }
  static get pluginName() {
    return "EmojiPicker";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  async init() {
    const n = this.editor;
    if (this.balloonPlugin = n.plugins.get("ContextualBalloon"), this.emojiRepositoryPlugin = n.plugins.get("EmojiRepository"), !await this.emojiRepositoryPlugin.isReady()) return;
    const t = new nS(n);
    n.commands.add("emoji", t), n.ui.componentFactory.add("emoji", () => {
      const e = this._createButton(V, t);
      return e.set({ tooltip: !0 }), e;
    }), n.ui.componentFactory.add("menuBar:emoji", () => this._createButton(Et, t)), this._setupConversion();
  }
  destroy() {
    super.destroy(), this.emojiPickerView && this.emojiPickerView.destroy();
  }
  get skinTone() {
    return this.emojiPickerView ? this.emojiPickerView.gridView.skinTone : this.editor.config.get("emoji.skinTone");
  }
  showUI(n = "") {
    this._showFakeVisualSelection(), this.emojiPickerView || (this.emojiPickerView = this._createEmojiPickerView()), n && this.emojiPickerView.searchView.setInputValue(n), this.emojiPickerView.searchView.search(n), this.emojiPickerFormView || (this.emojiPickerFormView = this._createEmojiPickerFormView()), this.balloonPlugin.hasView(this.emojiPickerFormView) || (this.emojiPickerFormView.backButtonView.isVisible = !!this.balloonPlugin.visibleView, this.balloonPlugin.add({ view: this.emojiPickerFormView, position: this._getBalloonPositionData(), balloonClassName: "ck-emoji-picker-balloon" })), this.emojiPickerView.focus();
  }
  _createButton(n, t) {
    const e = new n(this.editor.locale), i = this.editor.locale.t;
    return e.bind("isEnabled").to(t, "isEnabled"), e.set({ label: i("Emoji"), icon: _2, isToggleable: !0 }), e.on("execute", () => {
      this.editor.editing.view.scrollToTheSelection(), this.showUI();
    }), e;
  }
  _createEmojiPickerView() {
    const n = new aS(this.editor.locale, { emojiCategories: this.emojiRepositoryPlugin.getEmojiCategories(), skinTone: this.editor.config.get("emoji.skinTone"), skinTones: this.emojiRepositoryPlugin.getSkinTones(), getEmojiByQuery: (t) => this.emojiRepositoryPlugin.getEmojiByQuery(t) });
    return this.listenTo(n.gridView, "execute", (t, e) => {
      const i = this.editor, r = e.emoji;
      this._hideUI(), i.execute("insertText", { text: r });
    }), n;
  }
  _createEmojiPickerFormView() {
    const n = new lS(this.editor.locale);
    return n.children.add(this.emojiPickerView), this.listenTo(this.emojiPickerView, "update", () => {
      this.balloonPlugin.visibleView === n && this.balloonPlugin.updatePosition();
    }), this.listenTo(n, "cancel", () => {
      this._hideUI();
    }), n.keystrokes.set("Esc", (t, e) => {
      this._hideUI(), e();
    }), Ni({ emitter: n, contextElements: [this.balloonPlugin.view.element], callback: () => {
      this._hideUI(!1);
    }, activator: () => this.balloonPlugin.visibleView === n }), n;
  }
  _hideUI(n = !0) {
    this.balloonPlugin.remove(this.emojiPickerFormView), this.emojiPickerView.searchView.setInputValue(""), n && this.editor.editing.view.focus(), this._hideFakeVisualSelection();
  }
  _setupConversion() {
    const n = this.editor;
    n.conversion.for("editingDowncast").markerToHighlight({ model: fi, view: { classes: ["ck-fake-emoji-selection"] } }), n.conversion.for("editingDowncast").markerToElement({ model: fi, view: (t, { writer: e }) => {
      if (!t.markerRange.isCollapsed) return null;
      const i = e.createUIElement("span");
      return e.addClass(["ck-fake-emoji-selection", "ck-fake-emoji-selection_collapsed"], i), i;
    } });
  }
  _getBalloonPositionData() {
    const n = this.editor.editing.view, t = n.document;
    return { target: () => n.domConverter.viewRangeToDom(t.selection.getFirstRange()) };
  }
  _showFakeVisualSelection() {
    const n = this.editor.model;
    n.change((t) => {
      const e = n.document.selection.getFirstRange();
      if (n.markers.has(fi)) t.updateMarker(fi, { range: e });
      else if (e.start.isAtEnd) {
        const i = e.start.getLastMatchingPosition(({ item: r }) => !n.schema.isContent(r), { boundaries: e });
        t.addMarker(fi, { usingOperation: !1, affectsData: !1, range: t.createRange(i, e.end) });
      } else t.addMarker(fi, { usingOperation: !1, affectsData: !1, range: e });
    });
  }
  _hideFakeVisualSelection() {
    const n = this.editor.model;
    n.markers.has(fi) && n.change((t) => {
      t.removeMarker(fi);
    });
  }
}
class dS extends A {
  static get requires() {
    return [eS, cS];
  }
  static get pluginName() {
    return "Emoji";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class uS extends q {
  constructor(n) {
    super(n), this.affectsData = !1;
  }
  execute() {
    const n = this.editor.model, t = n.document.selection;
    let e = n.schema.getLimitElement(t);
    if (t.containsEntireContent(e) || !Zg(n.schema, e)) do
      if (e = e.parent, !e) return;
    while (!Zg(n.schema, e));
    n.change((i) => {
      i.setSelection(e, "in");
    });
  }
}
function Zg(o, n) {
  return o.isLimit(n) && (o.checkChild(n, "$text") || o.checkChild(n, "paragraph"));
}
const hS = ws("Ctrl+A");
class mS extends A {
  static get pluginName() {
    return "SelectAllEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.t, e = n.editing.view.document;
    n.commands.add("selectAll", new uS(n)), this.listenTo(e, "keydown", (i, r) => {
      eo(r) === hS && (n.execute("selectAll"), r.preventDefault());
    }), n.accessibility.addKeystrokeInfos({ keystrokes: [{ label: t("Select all"), keystroke: "CTRL+A" }] });
  }
}
class gS extends A {
  static get pluginName() {
    return "SelectAllUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor;
    n.ui.componentFactory.add("selectAll", () => {
      const t = this._createButton(V);
      return t.set({ tooltip: !0 }), t;
    }), n.ui.componentFactory.add("menuBar:selectAll", () => this._createButton(Et));
  }
  _createButton(n) {
    const t = this.editor, e = t.locale, i = t.commands.get("selectAll"), r = new n(t.locale), s = e.t;
    return r.set({ label: s("Select all"), icon: iE, keystroke: "Ctrl+A" }), r.bind("isEnabled").to(i, "isEnabled"), this.listenTo(r, "execute", () => {
      t.execute("selectAll"), t.editing.view.focus();
    }), r;
  }
}
class fS extends A {
  static get requires() {
    return [mS, gS];
  }
  static get pluginName() {
    return "SelectAll";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class p_ extends q {
  constructor(t) {
    super(t);
    m(this, "_stack", []);
    m(this, "_createdBatches", /* @__PURE__ */ new WeakSet());
    this.refresh(), this._isEnabledBasedOnSelection = !1, this.listenTo(t.data, "set", (e, i) => {
      i[1] = { ...i[1] };
      const r = i[1];
      r.batchType || (r.batchType = { isUndoable: !1 });
    }, { priority: "high" }), this.listenTo(t.data, "set", (e, i) => {
      i[1].batchType.isUndoable || this.clearStack();
    });
  }
  refresh() {
    this.isEnabled = this._stack.length > 0;
  }
  get createdBatches() {
    return this._createdBatches;
  }
  addBatch(t) {
    const e = this.editor.model.document.selection, i = { ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [], isBackward: e.isBackward };
    this._stack.push({ batch: t, selection: i }), this.refresh();
  }
  clearStack() {
    this._stack = [], this.refresh();
  }
  _restoreSelection(t, e, i) {
    const r = this.editor.model, s = r.document, a = [], l = t.map((d) => d.getTransformedByOperations(i)), c = l.flat();
    for (const d of l) {
      const u = d.filter((h) => h.root != s.graveyard).filter((h) => !bS(h, c));
      u.length && (pS(u), a.push(u[0]));
    }
    a.length && r.change((d) => {
      d.setSelection(a, { backward: e });
    });
  }
  _undo(t, e) {
    const i = this.editor.model, r = i.document;
    this._createdBatches.add(e);
    const s = t.operations.slice().filter((a) => a.isDocumentOperation);
    s.reverse();
    for (const a of s) {
      const l = a.baseVersion + 1, c = Array.from(r.history.getOperations(l)), d = KA([a.getReversed()], c, { useRelations: !0, document: this.editor.model.document, padWithNoOps: !1, forceWeakRemove: !0 }).operationsA;
      for (let u of d) {
        const h = u.affectedSelectable;
        h && !i.canEditAt(h) && (u = new re(u.baseVersion)), e.addOperation(u), i.applyOperation(u), r.history.setOperationAsUndone(a, u);
      }
    }
  }
}
function pS(o) {
  o.sort((n, t) => n.start.isBefore(t.start) ? -1 : 1);
  for (let n = 1; n < o.length; n++) {
    const t = o[n - 1].getJoined(o[n], !0);
    t && (n--, o.splice(n, 2, t));
  }
}
function bS(o, n) {
  return n.some((t) => t !== o && t.containsRange(o, !0));
}
class kS extends p_ {
  execute(n = null) {
    const t = n ? this._stack.findIndex((r) => r.batch == n) : this._stack.length - 1, e = this._stack.splice(t, 1)[0], i = this.editor.model.createBatch({ isUndo: !0 });
    this.editor.model.enqueueChange(i, () => {
      this._undo(e.batch, i);
      const r = this.editor.model.document.history.getOperations(e.batch.baseVersion);
      this._restoreSelection(e.selection.ranges, e.selection.isBackward, r);
    }), this.fire("revert", e.batch, i), this.refresh();
  }
}
class wS extends p_ {
  execute() {
    const n = this._stack.pop(), t = this.editor.model.createBatch({ isUndo: !0 });
    this.editor.model.enqueueChange(t, () => {
      const e = n.batch.operations[n.batch.operations.length - 1].baseVersion + 1, i = this.editor.model.document.history.getOperations(e);
      this._restoreSelection(n.selection.ranges, n.selection.isBackward, i), this._undo(n.batch, t);
    }), this.refresh();
  }
}
class _S extends A {
  constructor() {
    super(...arguments);
    m(this, "_undoCommand");
    m(this, "_redoCommand");
    m(this, "_batchRegistry", /* @__PURE__ */ new WeakSet());
  }
  static get pluginName() {
    return "UndoEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor, e = t.t;
    this._undoCommand = new kS(t), this._redoCommand = new wS(t), t.commands.add("undo", this._undoCommand), t.commands.add("redo", this._redoCommand), this.listenTo(t.model, "applyOperation", (i, r) => {
      const s = r[0];
      if (!s.isDocumentOperation) return;
      const a = s.batch, l = this._redoCommand.createdBatches.has(a), c = this._undoCommand.createdBatches.has(a);
      this._batchRegistry.has(a) || (this._batchRegistry.add(a), a.isUndoable && (l ? this._undoCommand.addBatch(a) : c || (this._undoCommand.addBatch(a), this._redoCommand.clearStack())));
    }, { priority: "highest" }), this.listenTo(this._undoCommand, "revert", (i, r, s) => {
      this._redoCommand.addBatch(s);
    }), t.keystrokes.set("CTRL+Z", "undo"), t.keystrokes.set("CTRL+Y", "redo"), t.keystrokes.set("CTRL+SHIFT+Z", "redo"), t.accessibility.addKeystrokeInfos({ keystrokes: [{ label: e("Undo"), keystroke: "CTRL+Z" }, { label: e("Redo"), keystroke: [["CTRL+Y"], ["CTRL+SHIFT+Z"]] }] });
  }
}
class vS extends A {
  static get pluginName() {
    return "UndoUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.locale, e = n.t, i = t.uiLanguageDirection == "ltr" ? $m : Hm, r = t.uiLanguageDirection == "ltr" ? Hm : $m;
    this._addButtonsToFactory("undo", e("Undo"), "CTRL+Z", i), this._addButtonsToFactory("redo", e("Redo"), "CTRL+Y", r);
  }
  _addButtonsToFactory(n, t, e, i) {
    const r = this.editor;
    r.ui.componentFactory.add(n, () => {
      const s = this._createButton(V, n, t, e, i);
      return s.set({ tooltip: !0 }), s;
    }), r.ui.componentFactory.add("menuBar:" + n, () => this._createButton(Et, n, t, e, i));
  }
  _createButton(n, t, e, i, r) {
    const s = this.editor, a = s.locale, l = s.commands.get(t), c = new n(a);
    return c.set({ label: e, icon: r, keystroke: i }), c.bind("isEnabled").to(l, "isEnabled"), this.listenTo(c, "execute", () => {
      s.execute(t), s.editing.view.focus();
    }), c;
  }
}
class Bu extends A {
  static get requires() {
    return [_S, vS];
  }
  static get pluginName() {
    return "Undo";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class yS extends A {
  static get requires() {
    return [CE, Pu, pl, fS, r_, gl, Bu];
  }
  static get pluginName() {
    return "Essentials";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class kl extends q {
  constructor(t, e) {
    super(t);
    m(this, "attributeKey");
    this.attributeKey = e;
  }
  refresh() {
    const t = this.editor.model, e = t.document;
    this.value = e.selection.getAttribute(this.attributeKey), this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey);
  }
  execute(t = {}) {
    const e = this.editor.model, i = e.document.selection, r = t.value, s = t.batch, a = (l) => {
      if (i.isCollapsed) r ? l.setSelectionAttribute(this.attributeKey, r) : l.removeSelectionAttribute(this.attributeKey);
      else {
        const c = e.schema.getValidRanges(i.getRanges(), this.attributeKey);
        for (const d of c) r ? l.setAttribute(this.attributeKey, r, d) : l.removeAttribute(this.attributeKey, d);
      }
    };
    s ? e.enqueueChange(s, (l) => {
      a(l);
    }) : e.change((l) => {
      a(l);
    });
  }
}
const Ne = "fontSize", ze = "fontFamily", Sn = "fontColor", Yn = "fontBackgroundColor";
function b_(o, n) {
  const t = { model: { key: o, values: [] }, view: {}, upcastAlso: {} };
  for (const e of n) t.model.values.push(e.model), t.view[e.model] = e.view, e.upcastAlso && (t.upcastAlso[e.model] = e.upcastAlso);
  return t;
}
function k_(o) {
  return (n) => n.getStyle(o).replace(/\s/g, "");
}
function w_(o) {
  return (n, { writer: t }) => t.createAttributeElement("span", { style: `${o}:${n}` }, { priority: 7 });
}
class CS extends kl {
  constructor(n) {
    super(n, ze);
  }
}
function __(o) {
  return o.map(AS).filter((n) => n !== void 0);
}
function AS(o) {
  return typeof o == "object" ? o : o === "default" ? { title: "Default", model: void 0 } : typeof o == "string" ? function(n) {
    const t = n.replace(/"|'/g, "").split(","), e = t[0], i = t.map(xS).join(", ");
    return { title: e, model: i, view: { name: "span", styles: { "font-family": i }, priority: 7 } };
  }(o) : void 0;
}
function xS(o) {
  return (o = o.trim()).indexOf(" ") > 0 && (o = `'${o}'`), o;
}
class ES extends A {
  static get pluginName() {
    return "FontFamilyEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  constructor(n) {
    super(n), n.config.define(ze, { options: ["default", "Arial, Helvetica, sans-serif", "Courier New, Courier, monospace", "Georgia, serif", "Lucida Sans Unicode, Lucida Grande, sans-serif", "Tahoma, Geneva, sans-serif", "Times New Roman, Times, serif", "Trebuchet MS, Helvetica, sans-serif", "Verdana, Geneva, sans-serif"], supportAllValues: !1 });
  }
  init() {
    const n = this.editor;
    n.model.schema.extend("$text", { allowAttributes: ze }), n.model.schema.setAttributeProperties(ze, { isFormatting: !0, copyOnEnter: !0 });
    const t = __(n.config.get("fontFamily.options")).filter((i) => i.model), e = b_(ze, t);
    n.config.get("fontFamily.supportAllValues") ? (this._prepareAnyValueConverters(), this._prepareCompatibilityConverter()) : n.conversion.attributeToElement(e), n.commands.add(ze, new CS(n));
  }
  _prepareAnyValueConverters() {
    const n = this.editor;
    n.conversion.for("downcast").attributeToElement({ model: ze, view: (t, { writer: e }) => e.createAttributeElement("span", { style: "font-family:" + t }, { priority: 7 }) }), n.conversion.for("upcast").elementToAttribute({ model: { key: ze, value: (t) => t.getStyle("font-family") }, view: { name: "span", styles: { "font-family": /.*/ } } });
  }
  _prepareCompatibilityConverter() {
    this.editor.conversion.for("upcast").elementToAttribute({ view: { name: "font", attributes: { face: /.*/ } }, model: { key: ze, value: (n) => n.getAttribute("face") } });
  }
}
class TS extends A {
  static get pluginName() {
    return "FontFamilyUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.t, e = this._getLocalizedOptions(), i = n.commands.get(ze), r = t("Font Family"), s = function(a, l) {
      const c = new ne();
      for (const d of a) {
        const u = { type: "button", model: new ai({ commandName: ze, commandParam: d.model, label: d.title, role: "menuitemradio", withText: !0 }) };
        u.model.bind("isOn").to(l, "value", (h) => h === d.model || !(!h || !d.model) && h.split(",")[0].replace(/'/g, "").toLowerCase() === d.model.toLowerCase()), d.view && typeof d.view != "string" && d.view.styles && u.model.set("labelStyle", `font-family: ${d.view.styles["font-family"]}`), c.add(u);
      }
      return c;
    }(e, i);
    n.ui.componentFactory.add(ze, (a) => {
      const l = ge(a);
      return zi(l, s, { role: "menu", ariaLabel: r }), l.buttonView.set({ label: r, icon: Rm, tooltip: !0 }), l.extendTemplate({ attributes: { class: "ck-font-family-dropdown" } }), l.bind("isEnabled").to(i), this.listenTo(l, "execute", (c) => {
        n.execute(c.source.commandName, { value: c.source.commandParam }), n.editing.view.focus();
      }), l;
    }), n.ui.componentFactory.add(`menuBar:${ze}`, (a) => {
      const l = new Me(a);
      l.buttonView.set({ label: r, icon: Rm }), l.bind("isEnabled").to(i);
      const c = new li(a);
      for (const d of s) {
        const u = new zn(a, l), h = new Et(a);
        h.set({ role: "menuitemradio", isToggleable: !0 }), h.bind(...Object.keys(d.model)).to(d.model), h.delegate("execute").to(l), h.on("execute", () => {
          n.execute(d.model.commandName, { value: d.model.commandParam }), n.editing.view.focus();
        }), u.children.add(h), c.items.add(u);
      }
      return l.panelView.children.add(c), l;
    });
  }
  _getLocalizedOptions() {
    const n = this.editor, t = n.t;
    return __(n.config.get(ze).options).map((e) => (e.title === "Default" && (e.title = t("Default")), e));
  }
}
class SS extends A {
  static get requires() {
    return [ES, TS];
  }
  static get pluginName() {
    return "FontFamily";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class IS extends kl {
  constructor(n) {
    super(n, Ne);
  }
}
function Nu(o) {
  return o.map((n) => function(t) {
    if (typeof t == "number" && (t = String(t)), typeof t == "object" && (e = t, e.title && e.model && e.view)) return gc(t);
    var e;
    const i = function(r) {
      return typeof r == "string" ? Qg[r] : Qg[r.model];
    }(t);
    if (i) return gc(i);
    if (t === "default") return { model: void 0, title: "Default" };
    if (!function(r) {
      let s;
      if (typeof r == "object") {
        if (!r.model) throw new v("font-size-invalid-definition", null, r);
        s = parseFloat(r.model);
      } else s = parseFloat(r);
      return isNaN(s);
    }(t))
      return function(r) {
        return typeof r == "string" && (r = { title: r, model: `${parseFloat(r)}px` }), r.view = { name: "span", styles: { "font-size": r.model } }, gc(r);
      }(t);
  }(n)).filter((n) => n !== void 0);
}
const Qg = { get tiny() {
  return { title: "Tiny", model: "tiny", view: { name: "span", classes: "text-tiny", priority: 7 } };
}, get small() {
  return { title: "Small", model: "small", view: { name: "span", classes: "text-small", priority: 7 } };
}, get big() {
  return { title: "Big", model: "big", view: { name: "span", classes: "text-big", priority: 7 } };
}, get huge() {
  return { title: "Huge", model: "huge", view: { name: "span", classes: "text-huge", priority: 7 } };
} };
function gc(o) {
  return o.view && typeof o.view != "string" && !o.view.priority && (o.view.priority = 7), o;
}
const Jg = ["x-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "xxx-large"];
class MS extends A {
  static get pluginName() {
    return "FontSizeEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  constructor(n) {
    super(n), n.config.define(Ne, { options: ["tiny", "small", "default", "big", "huge"], supportAllValues: !1 });
  }
  init() {
    const n = this.editor;
    n.model.schema.extend("$text", { allowAttributes: Ne }), n.model.schema.setAttributeProperties(Ne, { isFormatting: !0, copyOnEnter: !0 });
    const t = n.config.get("fontSize.supportAllValues"), e = Nu(this.editor.config.get("fontSize.options")).filter((r) => r.model), i = b_(Ne, e);
    t ? (this._prepareAnyValueConverters(i), this._prepareCompatibilityConverter()) : n.conversion.attributeToElement(i), n.commands.add(Ne, new IS(n));
  }
  _prepareAnyValueConverters(n) {
    const t = this.editor, e = n.model.values.filter((i) => !xx(String(i)) && !Tx(String(i)));
    if (e.length) throw new v("font-size-invalid-use-of-named-presets", null, { presets: e });
    t.conversion.for("downcast").attributeToElement({ model: Ne, view: (i, { writer: r }) => {
      if (i) return r.createAttributeElement("span", { style: "font-size:" + i }, { priority: 7 });
    } }), t.conversion.for("upcast").elementToAttribute({ model: { key: Ne, value: (i) => i.getStyle("font-size") }, view: { name: "span", styles: { "font-size": /.*/ } } });
  }
  _prepareCompatibilityConverter() {
    this.editor.conversion.for("upcast").elementToAttribute({ view: { name: "font", attributes: { size: /^[+-]?\d{1,3}$/ } }, model: { key: Ne, value: (n) => {
      const t = n.getAttribute("size"), e = t[0] === "-" || t[0] === "+";
      let i = parseInt(t, 10);
      e && (i = 3 + i);
      const r = Jg.length - 1, s = Math.min(Math.max(i, 0), r);
      return Jg[s];
    } } });
  }
}
class DS extends A {
  static get pluginName() {
    return "FontSizeUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.t, e = this._getLocalizedOptions(), i = n.commands.get(Ne), r = t("Font Size"), s = function(a, l) {
      const c = new ne();
      for (const d of a) {
        const u = { type: "button", model: new ai({ commandName: Ne, commandParam: d.model, label: d.title, class: "ck-fontsize-option", role: "menuitemradio", withText: !0 }) };
        d.view && typeof d.view != "string" && (d.view.styles && u.model.set("labelStyle", `font-size:${d.view.styles["font-size"]}`), d.view.classes && u.model.set("class", `${u.model.class} ${d.view.classes}`)), u.model.bind("isOn").to(l, "value", (h) => h === d.model), c.add(u);
      }
      return c;
    }(e, i);
    n.ui.componentFactory.add(Ne, (a) => {
      const l = ge(a);
      return zi(l, s, { role: "menu", ariaLabel: r }), l.buttonView.set({ label: r, icon: Vm, tooltip: !0 }), l.extendTemplate({ attributes: { class: ["ck-font-size-dropdown"] } }), l.bind("isEnabled").to(i), this.listenTo(l, "execute", (c) => {
        n.execute(c.source.commandName, { value: c.source.commandParam }), n.editing.view.focus();
      }), l;
    }), n.ui.componentFactory.add(`menuBar:${Ne}`, (a) => {
      const l = new Me(a);
      l.buttonView.set({ label: r, icon: Vm }), l.bind("isEnabled").to(i);
      const c = new li(a);
      for (const d of s) {
        const u = new zn(a, l), h = new Et(a);
        h.set({ role: "menuitemradio", isToggleable: !0 }), h.bind(...Object.keys(d.model)).to(d.model), h.delegate("execute").to(l), h.on("execute", () => {
          n.execute(d.model.commandName, { value: d.model.commandParam }), n.editing.view.focus();
        }), u.children.add(h), c.items.add(u);
      }
      return l.panelView.children.add(c), l;
    });
  }
  _getLocalizedOptions() {
    const n = this.editor, t = n.t, e = { Default: t("Default"), Tiny: t("Tiny"), Small: t("Small"), Big: t("Big"), Huge: t("Huge") };
    return Nu(n.config.get(Ne).options).map((i) => {
      const r = e[i.title];
      return r && r != i.title && (i = Object.assign({}, i, { title: r })), i;
    });
  }
}
class PS extends A {
  static get requires() {
    return [MS, DS];
  }
  static get pluginName() {
    return "FontSize";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  normalizeSizeOptions(n) {
    return Nu(n);
  }
}
class LS extends kl {
  constructor(n) {
    super(n, Sn);
  }
}
class BS extends A {
  static get pluginName() {
    return "FontColorEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  constructor(n) {
    super(n), n.config.define(Sn, { colors: [{ color: "hsl(0, 0%, 0%)", label: "Black" }, { color: "hsl(0, 0%, 30%)", label: "Dim grey" }, { color: "hsl(0, 0%, 60%)", label: "Grey" }, { color: "hsl(0, 0%, 90%)", label: "Light grey" }, { color: "hsl(0, 0%, 100%)", label: "White", hasBorder: !0 }, { color: "hsl(0, 75%, 60%)", label: "Red" }, { color: "hsl(30, 75%, 60%)", label: "Orange" }, { color: "hsl(60, 75%, 60%)", label: "Yellow" }, { color: "hsl(90, 75%, 60%)", label: "Light green" }, { color: "hsl(120, 75%, 60%)", label: "Green" }, { color: "hsl(150, 75%, 60%)", label: "Aquamarine" }, { color: "hsl(180, 75%, 60%)", label: "Turquoise" }, { color: "hsl(210, 75%, 60%)", label: "Light blue" }, { color: "hsl(240, 75%, 60%)", label: "Blue" }, { color: "hsl(270, 75%, 60%)", label: "Purple" }], columns: 5 }), n.conversion.for("upcast").elementToAttribute({ view: { name: "span", styles: { color: /[\s\S]+/ } }, model: { key: Sn, value: k_("color") } }), n.conversion.for("upcast").elementToAttribute({ view: { name: "font", attributes: { color: /^#?\w+$/ } }, model: { key: Sn, value: (t) => t.getAttribute("color") } }), n.conversion.for("downcast").attributeToElement({ model: Sn, view: w_("color") }), n.commands.add(Sn, new LS(n)), n.model.schema.extend("$text", { allowAttributes: Sn }), n.model.schema.setAttributeProperties(Sn, { isFormatting: !0, copyOnEnter: !0 });
  }
}
class v_ extends A {
  constructor(t, { commandName: e, componentName: i, icon: r, dropdownLabel: s }) {
    super(t);
    m(this, "commandName");
    m(this, "componentName");
    m(this, "icon");
    m(this, "dropdownLabel");
    m(this, "columns");
    this.commandName = e, this.componentName = i, this.icon = r, this.dropdownLabel = s, this.columns = t.config.get(`${this.componentName}.columns`);
  }
  init() {
    const t = this.editor, e = t.locale, i = e.t, r = t.commands.get(this.commandName), s = t.config.get(this.componentName), a = EE(e, TE(s.colors)), l = s.documentColors, c = s.colorPicker !== !1;
    t.ui.componentFactory.add(this.componentName, (d) => {
      const u = ge(d);
      let h = !1;
      const g = function({ dropdownView: f, colors: p, columns: b, removeButtonLabel: k, colorPickerLabel: w, documentColorsLabel: _, documentColorsCount: y, colorPickerViewConfig: C }) {
        const x = f.locale, I = new cg(x, { colors: p, columns: b, removeButtonLabel: k, colorPickerLabel: w, documentColorsLabel: _, documentColorsCount: y, colorPickerViewConfig: C });
        return f.colorSelectorView = I, f.panelView.children.add(I), I;
      }({ dropdownView: u, colors: a.map((f) => ({ label: f.label, color: f.model, options: { hasBorder: f.hasBorder } })), columns: this.columns, removeButtonLabel: i("Remove color"), colorPickerLabel: i("Color picker"), documentColorsLabel: l !== 0 ? i("Document colors") : "", documentColorsCount: l === void 0 ? this.columns : l, colorPickerViewConfig: !!c && (s.colorPicker || {}) });
      return g.bind("selectedColor").to(r, "value"), u.buttonView.set({ label: this.dropdownLabel, icon: this.icon, tooltip: !0 }), u.extendTemplate({ attributes: { class: "ck-color-ui-dropdown" } }), u.bind("isEnabled").to(r), g.on("execute", (f, p) => {
        u.isOpen && t.execute(this.commandName, { value: p.value, batch: this._undoStepBatch }), p.source !== "colorPicker" && t.editing.view.focus(), p.source === "colorPickerSaveButton" && (u.isOpen = !1);
      }), g.on("colorPicker:show", () => {
        this._undoStepBatch = t.model.createBatch();
      }), g.on("colorPicker:cancel", () => {
        this._undoStepBatch.operations.length && (u.isOpen = !1, t.execute("undo", this._undoStepBatch)), t.editing.view.focus();
      }), u.on("change:isOpen", (f, p, b) => {
        h || (h = !0, u.colorSelectorView.appendUI()), b && (l !== 0 && g.updateDocumentColors(t.model, this.componentName), g.updateSelectedColors(), g.showColorGridsFragment());
      }), ml(u, () => u.colorSelectorView.colorGridsFragmentView.staticColorsGrid.items.find((f) => f.isOn)), u;
    }), t.ui.componentFactory.add(`menuBar:${this.componentName}`, (d) => {
      const u = new Me(d);
      u.buttonView.set({ label: this.dropdownLabel, icon: this.icon }), u.bind("isEnabled").to(r);
      let h = !1;
      const g = new cg(d, { colors: a.map((f) => ({ label: f.label, color: f.model, options: { hasBorder: f.hasBorder } })), columns: this.columns, removeButtonLabel: i("Remove color"), colorPickerLabel: i("Color picker"), documentColorsLabel: l !== 0 ? i("Document colors") : "", documentColorsCount: l === void 0 ? this.columns : l, colorPickerViewConfig: !1 });
      return g.bind("selectedColor").to(r, "value"), g.delegate("execute").to(u), g.on("execute", (f, p) => {
        t.execute(this.commandName, { value: p.value, batch: this._undoStepBatch }), t.editing.view.focus();
      }), u.on("change:isOpen", (f, p, b) => {
        h || (h = !0, g.appendUI()), b && (l !== 0 && g.updateDocumentColors(t.model, this.componentName), g.updateSelectedColors(), g.showColorGridsFragment());
      }), u.panelView.children.add(g), u;
    });
  }
}
class NS extends v_ {
  constructor(n) {
    const t = n.locale.t;
    super(n, { commandName: Sn, componentName: Sn, icon: y2, dropdownLabel: t("Font Color") });
  }
  static get pluginName() {
    return "FontColorUI";
  }
}
class zS extends A {
  static get requires() {
    return [BS, NS];
  }
  static get pluginName() {
    return "FontColor";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class OS extends kl {
  constructor(n) {
    super(n, Yn);
  }
}
class RS extends A {
  static get pluginName() {
    return "FontBackgroundColorEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  constructor(n) {
    super(n), n.config.define(Yn, { colors: [{ color: "hsl(0, 0%, 0%)", label: "Black" }, { color: "hsl(0, 0%, 30%)", label: "Dim grey" }, { color: "hsl(0, 0%, 60%)", label: "Grey" }, { color: "hsl(0, 0%, 90%)", label: "Light grey" }, { color: "hsl(0, 0%, 100%)", label: "White", hasBorder: !0 }, { color: "hsl(0, 75%, 60%)", label: "Red" }, { color: "hsl(30, 75%, 60%)", label: "Orange" }, { color: "hsl(60, 75%, 60%)", label: "Yellow" }, { color: "hsl(90, 75%, 60%)", label: "Light green" }, { color: "hsl(120, 75%, 60%)", label: "Green" }, { color: "hsl(150, 75%, 60%)", label: "Aquamarine" }, { color: "hsl(180, 75%, 60%)", label: "Turquoise" }, { color: "hsl(210, 75%, 60%)", label: "Light blue" }, { color: "hsl(240, 75%, 60%)", label: "Blue" }, { color: "hsl(270, 75%, 60%)", label: "Purple" }], columns: 5 }), n.data.addStyleProcessorRules(Fx), n.conversion.for("upcast").elementToAttribute({ view: { name: "span", styles: { "background-color": /[\s\S]+/ } }, model: { key: Yn, value: k_("background-color") } }), n.conversion.for("downcast").attributeToElement({ model: Yn, view: w_("background-color") }), n.commands.add(Yn, new OS(n)), n.model.schema.extend("$text", { allowAttributes: Yn }), n.model.schema.setAttributeProperties(Yn, { isFormatting: !0, copyOnEnter: !0 });
  }
}
class VS extends v_ {
  constructor(n) {
    const t = n.locale.t;
    super(n, { commandName: Yn, componentName: Yn, icon: v2, dropdownLabel: t("Font Background Color") });
  }
  static get pluginName() {
    return "FontBackgroundColorUI";
  }
}
class FS extends A {
  static get requires() {
    return [RS, VS];
  }
  static get pluginName() {
    return "FontBackgroundColor";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class jS extends q {
  constructor(n) {
    super(n), this._isEnabledBasedOnSelection = !1;
  }
  refresh() {
    const n = this.editor.model, t = yt(n.document.selection.getSelectedBlocks());
    this.value = !!t && t.is("element", "paragraph"), this.isEnabled = !!t && Xg(t, n.schema);
  }
  execute(n = {}) {
    const t = this.editor.model, e = t.document, i = n.selection || e.selection;
    t.canEditAt(i) && t.change((r) => {
      const s = i.getSelectedBlocks();
      for (const a of s) !a.is("element", "paragraph") && Xg(a, t.schema) && r.rename(a, "paragraph");
    });
  }
}
function Xg(o, n) {
  return n.checkChild(o.parent, "paragraph") && !n.isObject(o);
}
class HS extends q {
  constructor(n) {
    super(n), this._isEnabledBasedOnSelection = !1;
  }
  execute(n) {
    const t = this.editor.model, e = n.attributes;
    let i = n.position;
    return t.canEditAt(i) ? t.change((r) => {
      if (i = this._findPositionToInsertParagraph(i, r), !i) return null;
      const s = r.createElement("paragraph");
      return e && t.schema.setAllowedAttributes(s, e, r), t.insertContent(s, i), r.setSelection(s, "in"), r.createPositionAt(s, 0);
    }) : null;
  }
  _findPositionToInsertParagraph(n, t) {
    const e = this.editor.model;
    if (e.schema.checkChild(n, "paragraph")) return n;
    const i = e.schema.findAllowedParent(n, "paragraph");
    if (!i) return null;
    const r = n.parent, s = e.schema.checkChild(r, "$text");
    return r.isEmpty || s && n.isAtEnd ? e.createPositionAfter(r) : !r.isEmpty && s && n.isAtStart ? e.createPositionBefore(r) : t.split(n, i).position;
  }
}
const Ya = class Ya extends A {
  static get pluginName() {
    return "Paragraph";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.model;
    n.commands.add("paragraph", new jS(n)), n.commands.add("insertParagraph", new HS(n)), t.schema.register("paragraph", { inheritAllFrom: "$block" }), n.conversion.elementToElement({ model: "paragraph", view: "p" }), n.conversion.for("upcast").elementToElement({ model: (e, { writer: i }) => Ya.paragraphLikeElements.has(e.name) ? e.isEmpty ? null : i.createElement("paragraph") : null, view: /.+/, converterPriority: "low" });
  }
};
m(Ya, "paragraphLikeElements", /* @__PURE__ */ new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]));
let Oa = Ya;
class US extends q {
  constructor(t, e) {
    super(t);
    m(this, "modelElements");
    this.modelElements = e;
  }
  refresh() {
    const t = yt(this.editor.model.document.selection.getSelectedBlocks());
    this.value = !!t && this.modelElements.includes(t.name) && t.name, this.isEnabled = !!t && this.modelElements.some((e) => tf(t, e, this.editor.model.schema));
  }
  execute(t) {
    const e = this.editor.model, i = e.document, r = t.value;
    e.change((s) => {
      const a = Array.from(i.selection.getSelectedBlocks()).filter((l) => tf(l, r, e.schema));
      for (const l of a) l.is("element", r) || s.rename(l, r);
    });
  }
}
function tf(o, n, t) {
  return t.checkChild(o.parent, n) && !t.isObject(o);
}
const ef = "paragraph";
class $S extends A {
  static get pluginName() {
    return "HeadingEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  constructor(n) {
    super(n), n.config.define("heading", { options: [{ model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" }, { model: "heading1", view: "h2", title: "Heading 1", class: "ck-heading_heading1" }, { model: "heading2", view: "h3", title: "Heading 2", class: "ck-heading_heading2" }, { model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3" }] });
  }
  static get requires() {
    return [Oa];
  }
  init() {
    const n = this.editor, t = n.config.get("heading.options"), e = [];
    for (const i of t) i.model !== "paragraph" && (n.model.schema.register(i.model, { inheritAllFrom: "$block" }), n.conversion.elementToElement(i), e.push(i.model));
    this._addDefaultH1Conversion(n), n.commands.add("heading", new US(n, e));
  }
  afterInit() {
    const n = this.editor, t = n.commands.get("enter"), e = n.config.get("heading.options");
    t && this.listenTo(t, "afterExecute", (i, r) => {
      const s = n.model.document.selection.getFirstPosition().parent;
      e.some((a) => s.is("element", a.model)) && !s.is("element", ef) && s.childCount === 0 && r.writer.rename(s, ef);
    });
  }
  _addDefaultH1Conversion(n) {
    n.conversion.for("upcast").elementToElement({ model: "heading1", view: "h1", converterPriority: Ci.low + 1 });
  }
}
function qS(o) {
  const n = o.t, t = { Paragraph: n("Paragraph"), "Heading 1": n("Heading 1"), "Heading 2": n("Heading 2"), "Heading 3": n("Heading 3"), "Heading 4": n("Heading 4"), "Heading 5": n("Heading 5"), "Heading 6": n("Heading 6") };
  return o.config.get("heading.options").map((e) => {
    const i = t[e.title];
    return i && i != e.title && (e.title = i), e;
  });
}
class WS extends A {
  static get pluginName() {
    return "HeadingUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.t, e = qS(n), i = t("Choose heading"), r = t("Heading");
    n.ui.componentFactory.add("heading", (s) => {
      const a = {}, l = new ne(), c = n.commands.get("heading"), d = n.commands.get("paragraph"), u = [c];
      for (const g of e) {
        const f = { type: "button", model: new ai({ label: g.title, class: g.class, role: "menuitemradio", withText: !0 }) };
        g.model === "paragraph" ? (f.model.bind("isOn").to(d, "value"), f.model.set("commandName", "paragraph"), u.push(d)) : (f.model.bind("isOn").to(c, "value", (p) => p === g.model), f.model.set({ commandName: "heading", commandValue: g.model })), l.add(f), a[g.model] = g.title;
      }
      const h = ge(s);
      return zi(h, l, { ariaLabel: r, role: "menu" }), h.buttonView.set({ ariaLabel: r, ariaLabelledBy: void 0, isOn: !1, withText: !0, tooltip: r }), h.extendTemplate({ attributes: { class: ["ck-heading-dropdown"] } }), h.bind("isEnabled").toMany(u, "isEnabled", (...g) => g.some((f) => f)), h.buttonView.bind("label").to(c, "value", d, "value", (g, f) => {
        const p = f ? "paragraph" : g;
        return typeof p == "boolean" ? i : a[p] ? a[p] : i;
      }), h.buttonView.bind("ariaLabel").to(c, "value", d, "value", (g, f) => {
        const p = f ? "paragraph" : g;
        return typeof p == "boolean" ? r : a[p] ? `${a[p]}, ${r}` : r;
      }), this.listenTo(h, "execute", (g) => {
        const { commandName: f, commandValue: p } = g.source;
        n.execute(f, p ? { value: p } : void 0), n.editing.view.focus();
      }), h;
    }), n.ui.componentFactory.add("menuBar:heading", (s) => {
      const a = new Me(s), l = n.commands.get("heading"), c = n.commands.get("paragraph"), d = [l], u = new li(s);
      a.set({ class: "ck-heading-dropdown" }), u.set({ ariaLabel: t("Heading"), role: "menu" }), a.buttonView.set({ label: t("Heading") }), a.panelView.children.add(u);
      for (const h of e) {
        const g = new zn(s, a), f = new Et(s);
        g.children.add(f), u.items.add(g), f.set({ isToggleable: !0, label: h.title, role: "menuitemradio", class: h.class }), f.delegate("execute").to(a), f.on("execute", () => {
          const p = h.model === "paragraph" ? "paragraph" : "heading";
          n.execute(p, { value: h.model }), n.editing.view.focus();
        }), h.model === "paragraph" ? (f.bind("isOn").to(c, "value"), d.push(c)) : f.bind("isOn").to(l, "value", (p) => p === h.model);
      }
      return a.bind("isEnabled").toMany(d, "isEnabled", (...h) => h.some((g) => g)), a;
    });
  }
}
class GS extends A {
  static get requires() {
    return [$S, WS];
  }
  static get pluginName() {
    return "Heading";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
const nf = /* @__PURE__ */ new Set(["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"]);
class KS extends A {
  constructor() {
    super(...arguments);
    m(this, "_bodyPlaceholder", /* @__PURE__ */ new Map());
  }
  static get pluginName() {
    return "Title";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return ["Paragraph"];
  }
  init() {
    const t = this.editor, e = t.model;
    e.schema.register("title", { isBlock: !0, allowIn: "$root" }), e.schema.register("title-content", { isBlock: !0, allowIn: "title", allowAttributes: ["alignment"] }), e.schema.extend("$text", { allowIn: "title-content" }), e.schema.addAttributeCheck((i) => {
      if (i.endsWith("title-content $text")) return !1;
    }), t.editing.mapper.on("modelToViewPosition", of(t.editing.view)), t.data.mapper.on("modelToViewPosition", of(t.editing.view)), t.conversion.for("downcast").elementToElement({ model: "title-content", view: "h1" }), t.conversion.for("downcast").add((i) => i.on("insert:title", (r, s, a) => {
      a.consumable.consume(s.item, r.name);
    })), t.data.upcastDispatcher.on("element:h1", fc, { priority: "high" }), t.data.upcastDispatcher.on("element:h2", fc, { priority: "high" }), t.data.upcastDispatcher.on("element:h3", fc, { priority: "high" }), e.document.registerPostFixer((i) => this._fixTitleContent(i)), e.document.registerPostFixer((i) => this._fixTitleElement(i)), e.document.registerPostFixer((i) => this._fixBodyElement(i)), e.document.registerPostFixer((i) => this._fixExtraParagraph(i)), this._attachPlaceholders(), this._attachTabPressHandling();
  }
  getTitle(t = {}) {
    const e = t.rootName ? t.rootName : void 0, i = this._getTitleElement(e).getChild(0);
    return this.editor.data.stringify(i, t);
  }
  getBody(t = {}) {
    const e = this.editor, i = e.data, r = e.model, s = t.rootName ? t.rootName : void 0, a = e.model.document.getRoot(s), l = e.editing.view, c = new fu(l.document), d = r.createRangeIn(a), u = c.createDocumentFragment(), h = r.createPositionAfter(a.getChild(0)), g = r.createRange(h, r.createPositionAt(a, "end")), f = /* @__PURE__ */ new Map();
    for (const p of r.markers) {
      const b = g.getIntersection(p.getRange());
      b && f.set(p.name, b);
    }
    return i.mapper.clearBindings(), i.mapper.bindElements(a, u), i.downcastDispatcher.convert(d, f, c, t), c.remove(c.createRangeOn(u.getChild(0))), e.data.processor.toData(u);
  }
  _getTitleElement(t) {
    const e = this.editor.model.document.getRoot(t);
    for (const i of e.getChildren()) if (rf(i)) return i;
  }
  _fixTitleContent(t) {
    let e = !1;
    for (const i of this.editor.model.document.getRootNames()) {
      const r = this._getTitleElement(i);
      if (!r || r.maxOffset === 1) continue;
      const s = Array.from(r.getChildren());
      s.shift();
      for (const a of s) t.move(t.createRangeOn(a), r, "after"), t.rename(a, "paragraph");
      e = !0;
    }
    return e;
  }
  _fixTitleElement(t) {
    let e = !1;
    const i = this.editor.model;
    for (const r of this.editor.model.document.getRoots()) {
      const s = Array.from(r.getChildren()).filter(rf), a = s[0], l = r.getChild(0);
      if (l.is("element", "title")) s.length > 1 && (sf(s, t, i), e = !0);
      else if (a || nf.has(l.name)) nf.has(l.name) ? YS(l, t, i) : t.move(t.createRangeOn(a), r, 0), sf(s, t, i), e = !0;
      else {
        const c = t.createElement("title");
        t.insert(c, r), t.insertElement("title-content", c), e = !0;
      }
    }
    return e;
  }
  _fixBodyElement(t) {
    let e = !1;
    for (const i of this.editor.model.document.getRootNames()) {
      const r = this.editor.model.document.getRoot(i);
      if (r.childCount < 2) {
        const s = t.createElement("paragraph");
        t.insert(s, r, 1), this._bodyPlaceholder.set(i, s), e = !0;
      }
    }
    return e;
  }
  _fixExtraParagraph(t) {
    let e = !1;
    for (const i of this.editor.model.document.getRootNames()) {
      const r = this.editor.model.document.getRoot(i), s = this._bodyPlaceholder.get(i);
      QS(s, r) && (this._bodyPlaceholder.delete(i), t.remove(s), e = !0);
    }
    return e;
  }
  _attachPlaceholders() {
    const t = this.editor, e = t.t, i = t.editing.view, r = t.sourceElement, s = t.config.get("title.placeholder") || e("Type your title"), a = t.config.get("placeholder") || r && r.tagName.toLowerCase() === "textarea" && r.getAttribute("placeholder") || e("Type or paste your content here.");
    t.editing.downcastDispatcher.on("insert:title-content", (c, d, u) => {
      const h = u.mapper.toViewElement(d.item);
      h.placeholder = s, uu({ view: i, element: h, keepOnFocus: !0 });
    });
    const l = /* @__PURE__ */ new Map();
    i.document.registerPostFixer((c) => {
      let d = !1;
      for (const u of i.document.roots) {
        if (u.isEmpty) continue;
        const h = u.getChild(1), g = l.get(u.rootName);
        h !== g && (g && (Gc(c, g), c.removeAttribute("data-placeholder", g)), c.setAttribute("data-placeholder", a, h), l.set(u.rootName, h), d = !0), d = Dk(h, !0) && u.childCount === 2 && h.name === "p" ? !!Mk(c, h) || d : !!Gc(c, h) || d;
      }
      return d;
    });
  }
  _attachTabPressHandling() {
    const t = this.editor, e = t.model;
    t.keystrokes.set("TAB", (i, r) => {
      e.change((s) => {
        const a = e.document.selection, l = Array.from(a.getSelectedBlocks());
        if (l.length === 1 && l[0].is("element", "title-content")) {
          const c = a.getFirstPosition().root.getChild(1);
          s.setSelection(c, 0), r();
        }
      });
    }), t.keystrokes.set("SHIFT + TAB", (i, r) => {
      e.change((s) => {
        const a = e.document.selection;
        if (!a.isCollapsed) return;
        const l = yt(a.getSelectedBlocks()), c = a.getFirstPosition(), d = t.model.document.getRoot(c.root.rootName), u = d.getChild(0);
        l === d.getChild(1) && c.isAtStart && (s.setSelection(u.getChild(0), 0), r());
      });
    });
  }
}
function fc(o, n, t) {
  const e = n.modelCursor, i = n.viewItem;
  if (!e.isAtStart || !e.parent.is("element", "$root") || !t.consumable.consume(i, { name: !0 })) return;
  const r = t.writer, s = r.createElement("title"), a = r.createElement("title-content");
  r.append(a, s), r.insert(s, e), t.convertChildren(i, a), t.updateConversionResult(s, n);
}
function of(o) {
  return (n, t) => {
    const e = t.modelPosition.parent;
    if (!e.is("element", "title")) return;
    const i = e.parent, r = t.mapper.toViewElement(i);
    t.viewPosition = o.createPositionAt(r, 0), n.stop();
  };
}
function rf(o) {
  return o.is("element", "title");
}
function YS(o, n, t) {
  const e = n.createElement("title");
  n.insert(e, o, "before"), n.insert(o, e, 0), n.rename(o, "title-content"), t.schema.removeDisallowedAttributes([o], n);
}
function sf(o, n, t) {
  let e = !1;
  for (const i of o) i.index !== 0 && (ZS(i, n, t), e = !0);
  return e;
}
function ZS(o, n, t) {
  const e = o.getChild(0);
  e.isEmpty ? n.remove(o) : (n.move(n.createRangeOn(e), o, "before"), n.rename(e, "paragraph"), n.remove(o), t.schema.removeDisallowedAttributes([e], n));
}
function QS(o, n) {
  return !(!o || !o.is("element", "paragraph") || o.childCount) && !(n.childCount <= 2 || n.getChild(n.childCount - 1) !== o);
}
class JS extends q {
  refresh() {
    const n = this.editor.model, t = n.document;
    this.value = t.selection.getAttribute("highlight"), this.isEnabled = n.schema.checkAttributeInSelection(t.selection, "highlight");
  }
  execute(n = {}) {
    const t = this.editor.model, e = t.document.selection, i = n.value;
    t.change((r) => {
      if (e.isCollapsed) {
        const s = e.getFirstPosition();
        if (e.hasAttribute("highlight")) {
          const a = (u) => u.item.hasAttribute("highlight") && u.item.getAttribute("highlight") === this.value, l = s.getLastMatchingPosition(a, { direction: "backward" }), c = s.getLastMatchingPosition(a), d = r.createRange(l, c);
          i && this.value !== i ? (s.isEqual(c) || r.setAttribute("highlight", i, d), r.setSelectionAttribute("highlight", i)) : (s.isEqual(c) || r.removeAttribute("highlight", d), r.removeSelectionAttribute("highlight"));
        } else i && r.setSelectionAttribute("highlight", i);
      } else {
        const s = t.schema.getValidRanges(e.getRanges(), "highlight");
        for (const a of s) i ? r.setAttribute("highlight", i, a) : r.removeAttribute("highlight", a);
      }
    });
  }
}
class XS extends A {
  static get pluginName() {
    return "HighlightEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  constructor(n) {
    super(n), n.config.define("highlight", { options: [{ model: "yellowMarker", class: "marker-yellow", title: "Yellow marker", color: "var(--ck-highlight-marker-yellow)", type: "marker" }, { model: "greenMarker", class: "marker-green", title: "Green marker", color: "var(--ck-highlight-marker-green)", type: "marker" }, { model: "pinkMarker", class: "marker-pink", title: "Pink marker", color: "var(--ck-highlight-marker-pink)", type: "marker" }, { model: "blueMarker", class: "marker-blue", title: "Blue marker", color: "var(--ck-highlight-marker-blue)", type: "marker" }, { model: "redPen", class: "pen-red", title: "Red pen", color: "var(--ck-highlight-pen-red)", type: "pen" }, { model: "greenPen", class: "pen-green", title: "Green pen", color: "var(--ck-highlight-pen-green)", type: "pen" }] });
  }
  init() {
    const n = this.editor;
    n.model.schema.extend("$text", { allowAttributes: "highlight" });
    const t = n.config.get("highlight.options");
    n.conversion.attributeToElement(function(e) {
      const i = { model: { key: "highlight", values: [] }, view: {} };
      for (const r of e) i.model.values.push(r.model), i.view[r.model] = { name: "mark", classes: r.class };
      return i;
    }(t)), n.commands.add("highlight", new JS(n));
  }
}
class tI extends A {
  get localizedOptionTitles() {
    const n = this.editor.t;
    return { "Yellow marker": n("Yellow marker"), "Green marker": n("Green marker"), "Pink marker": n("Pink marker"), "Blue marker": n("Blue marker"), "Red pen": n("Red pen"), "Green pen": n("Green pen") };
  }
  static get pluginName() {
    return "HighlightUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor.config.get("highlight.options");
    for (const t of n) this._addHighlighterButton(t);
    this._addRemoveHighlightButton(), this._addDropdown(n), this._addMenuBarButton(n);
  }
  _addRemoveHighlightButton() {
    const n = this.editor.t, t = this.editor.commands.get("highlight");
    this._addButton("removeHighlight", n("Remove highlight"), rd, null, (e) => {
      e.bind("isEnabled").to(t, "isEnabled");
    });
  }
  _addHighlighterButton(n) {
    const t = this.editor.commands.get("highlight");
    this._addButton("highlight:" + n.model, n.title, $s(n.type), n.model, function(e) {
      e.bind("isEnabled").to(t, "isEnabled"), e.bind("isOn").to(t, "value", (i) => i === n.model), e.iconView.fillColor = n.color, e.isToggleable = !0;
    });
  }
  _addButton(n, t, e, i, r) {
    const s = this.editor;
    s.ui.componentFactory.add(n, (a) => {
      const l = new V(a), c = this.localizedOptionTitles[t] ? this.localizedOptionTitles[t] : t;
      return l.set({ label: c, icon: e, tooltip: !0 }), l.on("execute", () => {
        s.execute("highlight", { value: i }), s.editing.view.focus();
      }), r(l), l;
    });
  }
  _addDropdown(n) {
    const t = this.editor, e = t.t, i = t.ui.componentFactory, r = n[0], s = n.reduce((a, l) => (a[l.model] = l, a), {});
    i.add("highlight", (a) => {
      const l = t.commands.get("highlight"), c = ge(a, mo), d = c.buttonView;
      d.set({ label: e("Highlight"), tooltip: !0, lastExecuted: r.model, commandValue: r.model, isToggleable: !0 }), d.bind("icon").to(l, "value", (h) => $s(u(h, "type"))), d.bind("color").to(l, "value", (h) => u(h, "color")), d.bind("commandValue").to(l, "value", (h) => u(h, "model")), d.bind("isOn").to(l, "value", (h) => !!h), d.delegate("execute").to(c);
      function u(h, g) {
        const f = h && h !== d.lastExecuted ? h : d.lastExecuted;
        return s[f][g];
      }
      return c.bind("isEnabled").to(l, "isEnabled"), As(c, () => {
        const h = n.map((g) => {
          const f = i.create("highlight:" + g.model);
          return this.listenTo(f, "execute", () => {
            c.buttonView.set({ lastExecuted: g.model });
          }), f;
        });
        return h.push(new Su()), h.push(i.create("removeHighlight")), h;
      }, { enableActiveItemFocusOnDropdownOpen: !0, ariaLabel: e("Text highlight toolbar") }), function(h) {
        h.buttonView.actionView.iconView.bind("fillColor").to(h.buttonView, "color");
      }(c), d.on("execute", () => {
        t.execute("highlight", { value: d.commandValue });
      }), this.listenTo(c, "execute", () => {
        t.editing.view.focus();
      }), c;
    });
  }
  _addMenuBarButton(n) {
    const t = this.editor, e = t.t, i = t.commands.get("highlight");
    t.ui.componentFactory.add("menuBar:highlight", (r) => {
      const s = new Me(r);
      s.buttonView.set({ label: e("Highlight"), icon: $s("marker") }), s.bind("isEnabled").to(i), s.buttonView.iconView.fillColor = "transparent";
      const a = new li(r);
      for (const d of n) {
        const u = new zn(r, s), h = new Et(r);
        h.set({ label: d.title, icon: $s(d.type), role: "menuitemradio", isToggleable: !0 }), h.iconView.fillColor = d.color, h.delegate("execute").to(s), h.bind("isOn").to(i, "value", (g) => g === d.model), h.on("execute", () => {
          t.execute("highlight", { value: d.model }), t.editing.view.focus();
        }), u.children.add(h), a.items.add(u);
      }
      a.items.add(new hl(r));
      const l = new zn(r, s), c = new Et(r);
      return c.set({ label: e("Remove highlight"), icon: rd }), c.delegate("execute").to(s), c.on("execute", () => {
        t.execute("highlight", { value: null }), t.editing.view.focus();
      }), l.children.add(c), a.items.add(l), s.panelView.children.add(a), s;
    });
  }
}
function $s(o) {
  return o === "marker" ? V2 : Z2;
}
class eI extends A {
  static get requires() {
    return [XS, tI];
  }
  static get pluginName() {
    return "Highlight";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class nI extends q {
  refresh() {
    const n = this.editor.model, t = n.schema, e = n.document.selection;
    this.isEnabled = function(i, r, s) {
      const a = function(l, c) {
        const d = Du(l, c), u = d.start.parent;
        return u.isEmpty && !u.is("element", "$root") ? u.parent : u;
      }(i, s);
      return r.checkChild(a, "horizontalLine");
    }(e, t, n);
  }
  execute() {
    const n = this.editor.model;
    n.change((t) => {
      const e = t.createElement("horizontalLine");
      n.insertObject(e, null, null, { setSelection: "after" });
    });
  }
}
class iI extends A {
  static get pluginName() {
    return "HorizontalLineEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.model.schema, e = n.t, i = n.conversion;
    t.register("horizontalLine", { inheritAllFrom: "$blockObject" }), i.for("dataDowncast").elementToElement({ model: "horizontalLine", view: (r, { writer: s }) => s.createEmptyElement("hr") }), i.for("editingDowncast").elementToStructure({ model: "horizontalLine", view: (r, { writer: s }) => {
      const a = e("Horizontal line"), l = s.createContainerElement("div", null, s.createEmptyElement("hr"));
      return s.addClass("ck-horizontal-line", l), s.setCustomProperty("hr", !0, l), function(c, d, u) {
        return d.setCustomProperty("horizontalLine", !0, c), bl(c, d, { label: u });
      }(l, s, a);
    } }), i.for("upcast").elementToElement({ view: "hr", model: "horizontalLine" }), n.commands.add("horizontalLine", new nI(n));
  }
}
class oI extends A {
  static get pluginName() {
    return "HorizontalLineUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor;
    n.ui.componentFactory.add("horizontalLine", () => {
      const t = this._createButton(V);
      return t.set({ tooltip: !0 }), t;
    }), n.ui.componentFactory.add("menuBar:horizontalLine", () => this._createButton(Et));
  }
  _createButton(n) {
    const t = this.editor, e = t.locale, i = t.commands.get("horizontalLine"), r = new n(t.locale), s = e.t;
    return r.set({ label: s("Horizontal line"), icon: C2 }), r.bind("isEnabled").to(i, "isEnabled"), this.listenTo(r, "execute", () => {
      t.execute("horizontalLine"), t.editing.view.focus();
    }), r;
  }
}
class rI extends A {
  static get requires() {
    return [iI, oI, cr];
  }
  static get pluginName() {
    return "HorizontalLine";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
function af(o) {
  return o.createContainerElement("figure", { class: "image" }, [o.createEmptyElement("img"), o.createSlot("children")]);
}
function y_(o, n) {
  const t = o.plugins.get("ImageUtils"), e = o.plugins.has("ImageInlineEditing") && o.plugins.has("ImageBlockEditing");
  return (r) => t.isInlineImageView(r) ? e && (r.getStyle("display") == "block" || r.findAncestor(t.isBlockImageView) ? "imageBlock" : "imageInline") !== n ? null : i(r) : null;
  function i(r) {
    const s = { name: !0 };
    return r.hasAttribute("src") && (s.attributes = ["src"]), s;
  }
}
function zu(o, n) {
  const t = yt(n.getSelectedBlocks());
  return !t || o.isObject(t) || t.isEmpty && t.name != "listItem" ? "imageBlock" : "imageInline";
}
function Ra(o) {
  return o && o.endsWith("px") ? parseInt(o) : null;
}
function Va(o) {
  const n = Ra(o.getStyle("width")), t = Ra(o.getStyle("height"));
  return !(!n || !t);
}
const sI = /^(image|image-inline)$/;
class _e extends A {
  constructor() {
    super(...arguments);
    m(this, "_domEmitter", new (Pe())());
  }
  static get pluginName() {
    return "ImageUtils";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  isImage(t) {
    return this.isInlineImage(t) || this.isBlockImage(t);
  }
  isInlineImageView(t) {
    return !!t && t.is("element", "img");
  }
  isBlockImageView(t) {
    return !!t && t.is("element", "figure") && t.hasClass("image");
  }
  insertImage(t = {}, e = null, i = null, r = {}) {
    const s = this.editor, a = s.model, l = a.document.selection, c = lf(s, e || l, i);
    t = { ...Object.fromEntries(l.getAttributes()), ...t };
    for (const d in t) a.schema.checkAttribute(c, d) || delete t[d];
    return a.change((d) => {
      const { setImageSizes: u = !0 } = r, h = d.createElement(c, t);
      return a.insertObject(h, e, null, { setSelection: "on", findOptimalPosition: e || c == "imageInline" ? void 0 : "auto" }), h.parent ? (u && this.setImageNaturalSizeAttributes(h), h) : null;
    });
  }
  setImageNaturalSizeAttributes(t) {
    const e = t.getAttribute("src");
    e && (t.getAttribute("width") || t.getAttribute("height") || this.editor.model.change((i) => {
      const r = new N.window.Image();
      this._domEmitter.listenTo(r, "load", () => {
        t.getAttribute("width") || t.getAttribute("height") || this.editor.model.enqueueChange(i.batch, (s) => {
          s.setAttribute("width", r.naturalWidth, t), s.setAttribute("height", r.naturalHeight, t);
        }), this._domEmitter.stopListening(r, "load");
      }), r.src = e;
    }));
  }
  getClosestSelectedImageWidget(t) {
    const e = t.getFirstPosition();
    if (!e) return null;
    const i = t.getSelectedElement();
    if (i && this.isImageWidget(i)) return i;
    let r = e.parent;
    for (; r; ) {
      if (r.is("element") && this.isImageWidget(r)) return r;
      r = r.parent;
    }
    return null;
  }
  getClosestSelectedImageElement(t) {
    const e = t.getSelectedElement();
    return this.isImage(e) ? e : t.getFirstPosition().findAncestor("imageBlock");
  }
  getImageWidgetFromImageView(t) {
    return t.findAncestor({ classes: sI });
  }
  isImageAllowed() {
    const t = this.editor.model.document.selection;
    return function(e, i) {
      if (lf(e, i, null) == "imageBlock") {
        const s = function(a, l) {
          const c = Du(a, l), d = c.start.parent;
          return d.isEmpty && !d.is("element", "$root") ? d.parent : d;
        }(i, e.model);
        if (e.model.schema.checkChild(s, "imageBlock")) return !0;
      } else if (e.model.schema.checkChild(i.focus, "imageInline")) return !0;
      return !1;
    }(this.editor, t) && function(e) {
      return [...e.focus.getAncestors()].every((i) => !i.is("element", "imageBlock"));
    }(t);
  }
  toImageWidget(t, e, i) {
    return e.setCustomProperty("image", !0, t), bl(t, e, { label: () => {
      const r = this.findViewImgElement(t).getAttribute("alt");
      return r ? `${r} ${i}` : i;
    } });
  }
  isImageWidget(t) {
    return !!t.getCustomProperty("image") && Yt(t);
  }
  isBlockImage(t) {
    return !!t && t.is("element", "imageBlock");
  }
  isInlineImage(t) {
    return !!t && t.is("element", "imageInline");
  }
  findViewImgElement(t) {
    if (this.isInlineImageView(t)) return t;
    const e = this.editor.editing.view;
    for (const { item: i } of e.createRangeIn(t)) if (this.isInlineImageView(i)) return i;
  }
  destroy() {
    return this._domEmitter.stopListening(), super.destroy();
  }
}
function lf(o, n, t) {
  const e = o.model.schema, i = o.config.get("image.insert.type");
  return o.plugins.has("ImageBlockEditing") ? o.plugins.has("ImageInlineEditing") ? t || (i === "inline" ? "imageInline" : i !== "auto" ? "imageBlock" : n.is("selection") ? zu(e, n) : e.checkChild(n, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline";
}
const aI = new RegExp(String(/^(http(s)?:\/\/)?[\w-]+\.[\w.~:/[\]@!$&'()*+,;=%-]+/.source + /\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)/.source + /(\?[\w.~:/[\]@!$&'()*+,;=%-]*)?/.source + /(#[\w.~:/[\]@!$&'()*+,;=%-]*)?$/.source));
class lI extends A {
  constructor(t) {
    super(t);
    m(this, "_timeoutId");
    m(this, "_positionToInsert");
    this._timeoutId = null, this._positionToInsert = null;
  }
  static get requires() {
    return [Pu, _e, Bu, Rn];
  }
  static get pluginName() {
    return "AutoImage";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor, e = t.model.document, i = t.plugins.get("ClipboardPipeline");
    this.listenTo(i, "inputTransformation", () => {
      const r = e.selection.getFirstRange(), s = Gt.fromPosition(r.start);
      s.stickiness = "toPrevious";
      const a = Gt.fromPosition(r.end);
      a.stickiness = "toNext", e.once("change:data", () => {
        this._embedImageBetweenPositions(s, a), s.detach(), a.detach();
      }, { priority: "high" });
    }), t.commands.get("undo").on("execute", () => {
      this._timeoutId && (N.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null);
    }, { priority: "high" });
  }
  _embedImageBetweenPositions(t, e) {
    const i = this.editor, r = new Ie(t, e), s = r.getWalker({ ignoreElementEnd: !0 }), a = Object.fromEntries(i.model.document.selection.getAttributes()), l = this.editor.plugins.get("ImageUtils");
    let c = "";
    for (const d of s) d.item.is("$textProxy") && (c += d.item.data);
    c = c.trim(), c.match(aI) ? (this._positionToInsert = Gt.fromPosition(t), this._timeoutId = setTimeout(() => {
      if (!i.commands.get("insertImage").isEnabled) return void r.detach();
      i.model.change((d) => {
        let u;
        this._timeoutId = null, d.remove(r), r.detach(), this._positionToInsert.root.rootName !== "$graveyard" && (u = this._positionToInsert.toPosition()), l.insertImage({ ...a, src: c }, u), this._positionToInsert.detach(), this._positionToInsert = null;
      }), i.plugins.get("Delete").requestUndoOnBackspace();
    }, 100)) : r.detach();
  }
}
class cI extends q {
  refresh() {
    const n = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
    this.isEnabled = !!n, this.isEnabled && n.hasAttribute("alt") ? this.value = n.getAttribute("alt") : this.value = !1;
  }
  execute(n) {
    const t = this.editor, e = t.plugins.get("ImageUtils"), i = t.model, r = e.getClosestSelectedImageElement(i.document.selection);
    i.change((s) => {
      s.setAttribute("alt", n.newValue, r);
    });
  }
}
class dI extends A {
  static get requires() {
    return [_e];
  }
  static get pluginName() {
    return "ImageTextAlternativeEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    this.editor.commands.add("imageTextAlternative", new cI(this.editor));
  }
}
class uI extends L {
  constructor(t) {
    super(t);
    m(this, "focusTracker");
    m(this, "keystrokes");
    m(this, "labeledInput");
    m(this, "backButtonView");
    m(this, "saveButtonView");
    m(this, "children");
    m(this, "_focusables");
    m(this, "_focusCycler");
    this.focusTracker = new gt(), this.keystrokes = new Mt(), this.backButtonView = this._createBackButton(), this.saveButtonView = this._createSaveButton(), this.labeledInput = this._createLabeledInputView(), this.children = this.createCollection([this._createHeaderView()]), this.children.add(new Ma(t, { children: [this.labeledInput, this.saveButtonView], class: ["ck-form__row_with-submit", "ck-form__row_large-top-padding"] })), this._focusables = new Te(), this.keystrokes.set("Esc", (e, i) => {
      this.fire("cancel"), i();
    }), this._focusCycler = new le({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-form", "ck-text-alternative-form", "ck-responsive-form"], tabindex: "-1" }, children: this.children });
  }
  render() {
    super.render(), ar({ view: this }), [this.backButtonView, this.labeledInput, this.saveButtonView].forEach((t) => {
      this._focusables.add(t), this.focusTracker.add(t.element);
    }), this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  _createBackButton() {
    const t = this.locale.t, e = new V(this.locale);
    return e.set({ class: "ck-button-back", label: t("Back"), icon: co, tooltip: !0 }), e.delegate("execute").to(this, "cancel"), e;
  }
  _createSaveButton() {
    const t = this.locale.t, e = new V(this.locale);
    return e.set({ label: t("Save"), withText: !0, type: "submit", class: "ck-button-action ck-button-bold" }), e;
  }
  _createHeaderView() {
    const t = this.locale.t, e = new uo(this.locale, { label: t("Text Alternative") });
    return e.children.add(this.backButtonView, 0), e;
  }
  _createLabeledInputView() {
    const t = this.locale.t, e = new Nn(this.locale, Mi);
    return e.label = t("Text alternative"), e.class = "ck-labeled-field-view_full-width", e;
  }
}
function _d(o) {
  const n = o.editing.view, t = se.defaultPositions, e = o.plugins.get("ImageUtils");
  return { target: n.domConverter.mapViewToDom(e.getClosestSelectedImageWidget(n.document.selection)), positions: [t.northArrowSouth, t.northArrowSouthWest, t.northArrowSouthEast, t.southArrowNorth, t.southArrowNorthWest, t.southArrowNorthEast, t.viewportStickyNorth] };
}
class hI extends A {
  constructor() {
    super(...arguments);
    m(this, "_balloon");
    m(this, "_form");
  }
  static get requires() {
    return [On];
  }
  static get pluginName() {
    return "ImageTextAlternativeUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    this._createButton();
  }
  destroy() {
    super.destroy(), this._form && this._form.destroy();
  }
  _createButton() {
    const t = this.editor, e = t.t;
    t.ui.componentFactory.add("imageTextAlternative", (i) => {
      const r = t.commands.get("imageTextAlternative"), s = new V(i);
      return s.set({ label: e("Change image text alternative"), icon: hE, tooltip: !0 }), s.bind("isEnabled").to(r, "isEnabled"), s.bind("isOn").to(r, "value", (a) => !!a), this.listenTo(s, "execute", () => {
        this._showForm();
      }), s;
    });
  }
  _createForm() {
    const t = this.editor, e = t.editing.view.document, i = t.plugins.get("ImageUtils");
    this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new (rs(uI))(t.locale), this._form.render(), this.listenTo(this._form, "submit", () => {
      t.execute("imageTextAlternative", { newValue: this._form.labeledInput.fieldView.element.value }), this._hideForm(!0);
    }), this.listenTo(this._form, "cancel", () => {
      this._hideForm(!0);
    }), this.listenTo(t.ui, "update", () => {
      i.getClosestSelectedImageWidget(e.selection) ? this._isVisible && function(r) {
        const s = r.plugins.get("ContextualBalloon");
        if (r.plugins.get("ImageUtils").getClosestSelectedImageWidget(r.editing.view.document.selection)) {
          const a = _d(r);
          s.updatePosition(a);
        }
      }(t) : this._hideForm(!0);
    }), Ni({ emitter: this._form, activator: () => this._isVisible, contextElements: () => [this._balloon.view.element], callback: () => this._hideForm() });
  }
  _showForm() {
    if (this._isVisible) return;
    this._form || this._createForm();
    const t = this.editor, e = t.commands.get("imageTextAlternative"), i = this._form.labeledInput;
    this._form.disableCssTransitions(), this._isInBalloon || this._balloon.add({ view: this._form, position: _d(t) }), i.fieldView.value = i.fieldView.element.value = e.value || "", this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions();
  }
  _hideForm(t = !1) {
    this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), t && this.editor.editing.view.focus());
  }
  get _isVisible() {
    return !!this._balloon && this._balloon.visibleView === this._form;
  }
  get _isInBalloon() {
    return !!this._balloon && this._balloon.hasView(this._form);
  }
}
class Ou extends A {
  static get requires() {
    return [dI, hI];
  }
  static get pluginName() {
    return "ImageTextAlternative";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
function C_(o, n) {
  const t = (e, i, r) => {
    if (!r.consumable.consume(i.item, e.name)) return;
    const s = r.writer, a = r.mapper.toViewElement(i.item), l = o.findViewImgElement(a);
    i.attributeNewValue === null ? (s.removeAttribute("srcset", l), s.removeAttribute("sizes", l)) : i.attributeNewValue && (s.setAttribute("srcset", i.attributeNewValue, l), s.setAttribute("sizes", "100vw", l));
  };
  return (e) => {
    e.on(`attribute:srcset:${n}`, t);
  };
}
function Fa(o, n, t) {
  const e = (i, r, s) => {
    if (!s.consumable.consume(r.item, i.name)) return;
    const a = s.writer, l = s.mapper.toViewElement(r.item), c = o.findViewImgElement(l);
    a.setAttribute(r.attributeKey, r.attributeNewValue || "", c);
  };
  return (i) => {
    i.on(`attribute:${t}:${n}`, e);
  };
}
class Ru extends yn {
  observe(n) {
    this.listenTo(n, "load", (t, e) => {
      const i = e.target;
      this.checkShouldIgnoreEventFromTarget(i) || i.tagName == "IMG" && this._fireEvents(e);
    }, { useCapture: !0 });
  }
  stopObserving(n) {
    this.stopListening(n);
  }
  _fireEvents(n) {
    this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", n));
  }
}
class mI extends q {
  constructor(n) {
    super(n);
    const t = n.config.get("image.insert.type");
    n.plugins.has("ImageBlockEditing") || t === "block" && at("image-block-plugin-required"), n.plugins.has("ImageInlineEditing") || t === "inline" && at("image-inline-plugin-required");
  }
  refresh() {
    const n = this.editor.plugins.get("ImageUtils");
    this.isEnabled = n.isImageAllowed();
  }
  execute(n) {
    const t = Bt(n.source), e = this.editor.model.document.selection, i = this.editor.plugins.get("ImageUtils"), r = Object.fromEntries(e.getAttributes());
    t.forEach((s, a) => {
      const l = e.getSelectedElement();
      if (typeof s == "string" && (s = { src: s }), a && l && i.isImage(l)) {
        const c = this.editor.model.createPositionAfter(l);
        i.insertImage({ ...s, ...r }, c, n.imageType);
      } else n.breakBlock ? i.insertImage({ ...s, ...r }, e.getFirstPosition(), n.imageType) : i.insertImage({ ...s, ...r }, null, n.imageType);
    });
  }
}
class gI extends q {
  constructor(n) {
    super(n), this.decorate("cleanupImage");
  }
  refresh() {
    const n = this.editor.plugins.get("ImageUtils"), t = this.editor.model.document.selection.getSelectedElement();
    this.isEnabled = n.isImage(t), this.value = this.isEnabled ? t.getAttribute("src") : null;
  }
  execute(n) {
    const t = this.editor.model.document.selection.getSelectedElement(), e = this.editor.plugins.get("ImageUtils");
    this.editor.model.change((i) => {
      i.setAttribute("src", n.source, t), this.cleanupImage(i, t), e.setImageNaturalSizeAttributes(t);
    });
  }
  cleanupImage(n, t) {
    n.removeAttribute("srcset", t), n.removeAttribute("sizes", t), n.removeAttribute("sources", t), n.removeAttribute("width", t), n.removeAttribute("height", t), n.removeAttribute("alt", t);
  }
}
class A_ extends A {
  static get requires() {
    return [_e];
  }
  static get pluginName() {
    return "ImageEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.conversion;
    n.editing.view.addObserver(Ru), t.for("upcast").attributeToAttribute({ view: { name: "img", key: "alt" }, model: "alt" }).attributeToAttribute({ view: { name: "img", key: "srcset" }, model: "srcset" });
    const e = new mI(n), i = new gI(n);
    n.commands.add("insertImage", e), n.commands.add("replaceImageSource", i), n.commands.add("imageInsert", e);
  }
}
class x_ extends A {
  static get requires() {
    return [_e];
  }
  static get pluginName() {
    return "ImageSizeAttributes";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  afterInit() {
    this._registerSchema(), this._registerConverters("imageBlock"), this._registerConverters("imageInline");
  }
  _registerSchema() {
    this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", { allowAttributes: ["width", "height"] }), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", { allowAttributes: ["width", "height"] });
  }
  _registerConverters(n) {
    const t = this.editor, e = t.plugins.get("ImageUtils"), i = n === "imageBlock" ? "figure" : "img";
    function r(s, a, l, c, d = !1) {
      s.on(`attribute:${a}:${n}`, (u, h, g) => {
        if (!g.consumable.consume(h.item, u.name)) return;
        const f = g.writer, p = g.mapper.toViewElement(h.item), b = e.findViewImgElement(p);
        h.attributeNewValue !== null ? f.setAttribute(l, h.attributeNewValue, b) : f.removeAttribute(l, b);
        const k = h.item.getAttribute("width"), w = h.item.getAttribute("height"), _ = k && w;
        if (_ && d && f.setAttribute("loading", "lazy", b), h.item.hasAttribute("sources")) return;
        const y = h.item.hasAttribute("resizedWidth");
        (n !== "imageInline" || y || c) && _ && f.setStyle("aspect-ratio", `${k}/${w}`, b);
      });
    }
    t.conversion.for("upcast").attributeToAttribute({ view: { name: i, styles: { width: /.+/ } }, model: { key: "width", value: (s) => Va(s) ? Ra(s.getStyle("width")) : null } }).attributeToAttribute({ view: { name: i, key: "width" }, model: "width" }).attributeToAttribute({ view: { name: i, styles: { height: /.+/ } }, model: { key: "height", value: (s) => Va(s) ? Ra(s.getStyle("height")) : null } }).attributeToAttribute({ view: { name: i, key: "height" }, model: "height" }), t.conversion.for("editingDowncast").add((s) => {
      r(s, "width", "width", !0, !0), r(s, "height", "height", !0, !0);
    }), t.conversion.for("dataDowncast").add((s) => {
      r(s, "width", "width", !1), r(s, "height", "height", !1);
    });
  }
}
class E_ extends q {
  constructor(t, e) {
    super(t);
    m(this, "_modelElementName");
    this._modelElementName = e;
  }
  refresh() {
    const t = this.editor.plugins.get("ImageUtils"), e = t.getClosestSelectedImageElement(this.editor.model.document.selection);
    this._modelElementName === "imageBlock" ? this.isEnabled = t.isInlineImage(e) : this.isEnabled = t.isBlockImage(e);
  }
  execute(t = {}) {
    const e = this.editor, i = this.editor.model, r = e.plugins.get("ImageUtils"), s = r.getClosestSelectedImageElement(i.document.selection), a = Object.fromEntries(s.getAttributes());
    return a.src || a.uploadId ? i.change((l) => {
      const { setImageSizes: c = !0 } = t, d = Array.from(i.markers).filter((g) => g.getRange().containsItem(s)), u = r.insertImage(a, i.createSelection(s, "on"), this._modelElementName, { setImageSizes: c });
      if (!u) return null;
      const h = l.createRangeOn(u);
      for (const g of d) {
        const f = g.getRange(), p = f.root.rootName != "$graveyard" ? f.getJoined(h, !0) : h;
        l.updateMarker(g, { range: p });
      }
      return { oldElement: s, newElement: u };
    }) : null;
  }
}
class T_ extends A {
  static get requires() {
    return [_e];
  }
  static get pluginName() {
    return "ImagePlaceholder";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  afterInit() {
    this._setupSchema(), this._setupConversion(), this._setupLoadListener();
  }
  _setupSchema() {
    const n = this.editor.model.schema;
    n.isRegistered("imageBlock") && n.extend("imageBlock", { allowAttributes: ["placeholder"] }), n.isRegistered("imageInline") && n.extend("imageInline", { allowAttributes: ["placeholder"] });
  }
  _setupConversion() {
    const n = this.editor, t = n.conversion, e = n.plugins.get("ImageUtils");
    t.for("editingDowncast").add((i) => {
      i.on("attribute:placeholder", (r, s, a) => {
        if (!a.consumable.test(s.item, r.name) || !s.item.is("element", "imageBlock") && !s.item.is("element", "imageInline")) return;
        a.consumable.consume(s.item, r.name);
        const l = a.writer, c = a.mapper.toViewElement(s.item), d = e.findViewImgElement(c);
        s.attributeNewValue ? (l.addClass("image_placeholder", d), l.setStyle("background-image", `url(${s.attributeNewValue})`, d), l.setCustomProperty("editingPipeline:doNotReuseOnce", !0, d)) : (l.removeClass("image_placeholder", d), l.removeStyle("background-image", d));
      });
    });
  }
  _setupLoadListener() {
    const n = this.editor, t = n.model, e = n.editing, i = e.view, r = n.plugins.get("ImageUtils");
    i.addObserver(Ru), this.listenTo(i.document, "imageLoaded", (s, a) => {
      const l = i.domConverter.mapDomToView(a.target);
      if (!l) return;
      const c = r.getImageWidgetFromImageView(l);
      if (!c) return;
      const d = e.mapper.toModelElement(c);
      d && d.hasAttribute("placeholder") && t.enqueueChange({ isUndoable: !1 }, (u) => {
        u.removeAttribute("placeholder", d);
      });
    });
  }
}
class S_ extends A {
  static get requires() {
    return [A_, x_, _e, T_, De];
  }
  static get pluginName() {
    return "ImageBlockEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor;
    n.model.schema.register("imageBlock", { inheritAllFrom: "$blockObject", allowAttributes: ["alt", "src", "srcset"] }), this._setupConversion(), n.plugins.has("ImageInlineEditing") && (n.commands.add("imageTypeBlock", new E_(this.editor, "imageBlock")), this._setupClipboardIntegration());
  }
  _setupConversion() {
    const n = this.editor, t = n.t, e = n.conversion, i = n.plugins.get("ImageUtils");
    e.for("dataDowncast").elementToStructure({ model: "imageBlock", view: (r, { writer: s }) => af(s) }), e.for("editingDowncast").elementToStructure({ model: "imageBlock", view: (r, { writer: s }) => i.toImageWidget(af(s), s, t("image widget")) }), e.for("downcast").add(Fa(i, "imageBlock", "src")).add(Fa(i, "imageBlock", "alt")).add(C_(i, "imageBlock")), e.for("upcast").elementToElement({ view: y_(n, "imageBlock"), model: (r, { writer: s }) => s.createElement("imageBlock", r.hasAttribute("src") ? { src: r.getAttribute("src") } : void 0) }).add(/* @__PURE__ */ function(r) {
      const s = (a, l, c) => {
        if (!c.consumable.test(l.viewItem, { name: !0, classes: "image" })) return;
        const d = r.findViewImgElement(l.viewItem);
        if (!d || !c.consumable.test(d, { name: !0 })) return;
        c.consumable.consume(l.viewItem, { name: !0, classes: "image" });
        const u = yt(c.convertItem(d, l.modelCursor).modelRange.getItems());
        u ? (c.convertChildren(l.viewItem, u), c.updateConversionResult(u, l)) : c.consumable.revert(l.viewItem, { name: !0, classes: "image" });
      };
      return (a) => {
        a.on("element:figure", s);
      };
    }(i));
  }
  _setupClipboardIntegration() {
    const n = this.editor, t = n.model, e = n.editing.view, i = n.plugins.get("ImageUtils"), r = n.plugins.get("ClipboardPipeline");
    this.listenTo(r, "inputTransformation", (s, a) => {
      const l = Array.from(a.content.getChildren());
      let c;
      if (!l.every(i.isInlineImageView)) return;
      c = a.targetRanges ? n.editing.mapper.toModelRange(a.targetRanges[0]) : t.document.selection.getFirstRange();
      const d = t.createSelection(c);
      if (zu(t.schema, d) === "imageBlock") {
        const u = new Bn(e.document), h = l.map((g) => u.createElement("figure", { class: "image" }, g));
        a.content = u.createDocumentFragment(h);
      }
    }), this.listenTo(r, "contentInsertion", (s, a) => {
      a.method === "paste" && t.change((l) => {
        const c = l.createRangeIn(a.content);
        for (const d of c.getItems()) d.is("element", "imageBlock") && i.setImageNaturalSizeAttributes(d);
      });
    });
  }
}
class fI extends L {
  constructor(t, e = []) {
    super(t);
    m(this, "focusTracker");
    m(this, "keystrokes");
    m(this, "_focusables");
    m(this, "_focusCycler");
    m(this, "children");
    this.focusTracker = new gt(), this.keystrokes = new Mt(), this._focusables = new Te(), this.children = this.createCollection(), this._focusCycler = new le({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } });
    for (const i of e) this.children.add(i), this._focusables.add(i), i instanceof Mw && this._focusables.addMany(i.children);
    this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-image-insert-form"], tabindex: -1 }, children: this.children });
  }
  render() {
    super.render(), ar({ view: this });
    for (const e of this._focusables) this.focusTracker.add(e.element);
    this.keystrokes.listenTo(this.element);
    const t = (e) => e.stopPropagation();
    this.keystrokes.set("arrowright", t), this.keystrokes.set("arrowleft", t), this.keystrokes.set("arrowup", t), this.keystrokes.set("arrowdown", t);
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  focus() {
    this._focusCycler.focusFirst();
  }
}
class xs extends A {
  constructor(t) {
    super(t);
    m(this, "dropdownView");
    m(this, "_integrations", /* @__PURE__ */ new Map());
    t.config.define("image.insert.integrations", ["upload", "assetManager", "url"]);
  }
  static get pluginName() {
    return "ImageInsertUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [_e];
  }
  init() {
    const t = this.editor, e = t.model.document.selection, i = t.plugins.get("ImageUtils");
    this.set("isImageSelected", !1), this.listenTo(t.model.document, "change", () => {
      this.isImageSelected = i.isImage(e.getSelectedElement());
    });
    const r = (s) => this._createToolbarComponent(s);
    t.ui.componentFactory.add("insertImage", r), t.ui.componentFactory.add("imageInsert", r), t.ui.componentFactory.add("menuBar:insertImage", (s) => this._createMenuBarComponent(s));
  }
  registerIntegration({ name: t, observable: e, buttonViewCreator: i, formViewCreator: r, menuBarButtonViewCreator: s, requiresForm: a = !1, override: l = !1 }) {
    this._integrations.has(t) && !l && at("image-insert-integration-exists", { name: t }), this._integrations.set(t, { observable: e, buttonViewCreator: i, menuBarButtonViewCreator: s, formViewCreator: r, requiresForm: a });
  }
  _createToolbarComponent(t) {
    const e = this.editor, i = t.t, r = this._prepareIntegrations();
    if (!r.length) return null;
    let s;
    const a = r[0];
    if (r.length == 1) {
      if (!a.requiresForm) return a.buttonViewCreator(!0);
      s = a.buttonViewCreator(!0);
    } else {
      const d = a.buttonViewCreator(!1);
      s = new mo(t, d), s.tooltip = !0, s.bind("label").to(this, "isImageSelected", (u) => i(u ? "Replace image" : "Insert image"));
    }
    const l = this.dropdownView = ge(t, s), c = r.map(({ observable: d }) => typeof d == "function" ? d() : d);
    return l.bind("isEnabled").toMany(c, "isEnabled", (...d) => d.some((u) => u)), l.once("change:isOpen", () => {
      const d = r.flatMap(({ formViewCreator: h }) => h(r.length == 1)), u = new fI(e.locale, d);
      l.panelView.children.add(u);
    }), l;
  }
  _createMenuBarComponent(t) {
    const e = t.t, i = this._prepareIntegrations();
    if (!i.length) return null;
    const r = i.flatMap(({ menuBarButtonViewCreator: l }) => l(i.length == 1)), s = new Me(t), a = new li(t);
    s.panelView.children.add(a), s.buttonView.set({ icon: A2, label: e("Image") });
    for (const l of r) {
      const c = new zn(t, s);
      c.children.add(l), a.items.add(c), l.delegate("execute").to(s);
    }
    return s;
  }
  _prepareIntegrations() {
    const t = this.editor.config.get("image.insert.integrations"), e = [];
    if (!t.length) return at("image-insert-integrations-not-specified"), e;
    for (const i of t) this._integrations.has(i) ? e.push(this._integrations.get(i)) : ["upload", "assetManager", "url"].includes(i) || at("image-insert-unknown-integration", { item: i });
    return e.length || at("image-insert-integrations-not-registered"), e;
  }
}
class pI extends A {
  static get requires() {
    return [S_, cr, Ou, xs];
  }
  static get pluginName() {
    return "ImageBlock";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class bI extends A {
  static get requires() {
    return [A_, x_, _e, T_, De];
  }
  static get pluginName() {
    return "ImageInlineEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor;
    n.model.schema.register("imageInline", { inheritAllFrom: "$inlineObject", allowAttributes: ["alt", "src", "srcset"], disallowIn: ["caption"] }), this._setupConversion(), n.plugins.has("ImageBlockEditing") && (n.commands.add("imageTypeInline", new E_(this.editor, "imageInline")), this._setupClipboardIntegration());
  }
  _setupConversion() {
    const n = this.editor, t = n.t, e = n.conversion, i = n.plugins.get("ImageUtils");
    e.for("dataDowncast").elementToElement({ model: "imageInline", view: (r, { writer: s }) => s.createEmptyElement("img") }), e.for("editingDowncast").elementToStructure({ model: "imageInline", view: (r, { writer: s }) => i.toImageWidget(function(a) {
      return a.createContainerElement("span", { class: "image-inline" }, a.createEmptyElement("img"));
    }(s), s, t("image widget")) }), e.for("downcast").add(Fa(i, "imageInline", "src")).add(Fa(i, "imageInline", "alt")).add(C_(i, "imageInline")), e.for("upcast").elementToElement({ view: y_(n, "imageInline"), model: (r, { writer: s }) => s.createElement("imageInline", r.hasAttribute("src") ? { src: r.getAttribute("src") } : void 0) });
  }
  _setupClipboardIntegration() {
    const n = this.editor, t = n.model, e = n.editing.view, i = n.plugins.get("ImageUtils"), r = n.plugins.get("ClipboardPipeline");
    this.listenTo(r, "inputTransformation", (s, a) => {
      const l = Array.from(a.content.getChildren());
      let c;
      if (!l.every(i.isBlockImageView)) return;
      c = a.targetRanges ? n.editing.mapper.toModelRange(a.targetRanges[0]) : t.document.selection.getFirstRange();
      const d = t.createSelection(c);
      if (zu(t.schema, d) === "imageInline") {
        const u = new Bn(e.document), h = l.map((g) => g.childCount === 1 ? (Array.from(g.getAttributes()).forEach((f) => u.setAttribute(...f, i.findViewImgElement(g))), g.getChild(0)) : g);
        a.content = u.createDocumentFragment(h);
      }
    }), this.listenTo(r, "contentInsertion", (s, a) => {
      a.method === "paste" && t.change((l) => {
        const c = l.createRangeIn(a.content);
        for (const d of c.getItems()) d.is("element", "imageInline") && i.setImageNaturalSizeAttributes(d);
      });
    });
  }
}
class kI extends A {
  static get requires() {
    return [bI, cr, Ou, xs];
  }
  static get pluginName() {
    return "ImageInline";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class I_ extends A {
  static get pluginName() {
    return "ImageCaptionUtils";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [_e];
  }
  getCaptionFromImageModelElement(n) {
    for (const t of n.getChildren()) if (t && t.is("element", "caption")) return t;
    return null;
  }
  getCaptionFromModelSelection(n) {
    const t = this.editor.plugins.get("ImageUtils"), e = n.getFirstPosition().findAncestor("caption");
    return e && t.isBlockImage(e.parent) ? e : null;
  }
  matchImageCaptionViewElement(n) {
    const t = this.editor.plugins.get("ImageUtils");
    return n.name == "figcaption" && t.isBlockImageView(n.parent) ? { name: !0 } : null;
  }
}
class wI extends q {
  refresh() {
    const n = this.editor, t = n.plugins.get("ImageCaptionUtils"), e = n.plugins.get("ImageUtils");
    if (!n.plugins.has(S_)) return this.isEnabled = !1, void (this.value = !1);
    const i = n.model.document.selection, r = i.getSelectedElement();
    if (!r) {
      const s = t.getCaptionFromModelSelection(i);
      return this.isEnabled = !!s, void (this.value = !!s);
    }
    this.isEnabled = e.isImage(r), this.isEnabled ? this.value = !!t.getCaptionFromImageModelElement(r) : this.value = !1;
  }
  execute(n = {}) {
    const { focusCaptionOnShow: t } = n;
    this.editor.model.change((e) => {
      this.value ? this._hideImageCaption(e) : this._showImageCaption(e, t);
    });
  }
  _showImageCaption(n, t) {
    const e = this.editor.model.document.selection, i = this.editor.plugins.get("ImageCaptionEditing"), r = this.editor.plugins.get("ImageUtils");
    let s = e.getSelectedElement();
    const a = i._getSavedCaption(s);
    r.isInlineImage(s) && (this.editor.execute("imageTypeBlock"), s = e.getSelectedElement());
    const l = a || n.createElement("caption");
    n.append(l, s), t && n.setSelection(l, "in");
  }
  _hideImageCaption(n) {
    const t = this.editor, e = t.model.document.selection, i = t.plugins.get("ImageCaptionEditing"), r = t.plugins.get("ImageCaptionUtils");
    let s, a = e.getSelectedElement();
    a ? s = r.getCaptionFromImageModelElement(a) : (s = r.getCaptionFromModelSelection(e), a = s.parent), i._saveCaption(a, s), n.setSelection(a, "on"), n.remove(s);
  }
}
class _I extends A {
  constructor(t) {
    super(t);
    m(this, "_savedCaptionsMap");
    this._savedCaptionsMap = /* @__PURE__ */ new WeakMap();
  }
  static get requires() {
    return [_e, I_];
  }
  static get pluginName() {
    return "ImageCaptionEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor, e = t.model.schema;
    e.isRegistered("caption") ? e.extend("caption", { allowIn: "imageBlock" }) : e.register("caption", { allowIn: "imageBlock", allowContentOf: "$block", isLimit: !0 }), t.commands.add("toggleImageCaption", new wI(this.editor)), this._setupConversion(), this._setupImageTypeCommandsIntegration(), this._registerCaptionReconversion();
  }
  _setupConversion() {
    const t = this.editor, e = t.editing.view, i = t.plugins.get("ImageUtils"), r = t.plugins.get("ImageCaptionUtils"), s = t.t;
    t.conversion.for("upcast").elementToElement({ view: (a) => r.matchImageCaptionViewElement(a), model: "caption" }), t.conversion.for("dataDowncast").elementToElement({ model: "caption", view: (a, { writer: l }) => i.isBlockImage(a.parent) ? l.createContainerElement("figcaption") : null }), t.conversion.for("editingDowncast").elementToElement({ model: "caption", view: (a, { writer: l }) => {
      if (!i.isBlockImage(a.parent)) return null;
      const c = l.createEditableElement("figcaption");
      l.setCustomProperty("imageCaption", !0, c), c.placeholder = s("Enter image caption"), uu({ view: e, element: c, keepOnFocus: !0 });
      const d = a.parent.getAttribute("alt");
      return a_(c, l, { label: d ? s("Caption for image: %0", [d]) : s("Caption for the image") });
    } });
  }
  _setupImageTypeCommandsIntegration() {
    const t = this.editor, e = t.plugins.get("ImageUtils"), i = t.plugins.get("ImageCaptionUtils"), r = t.commands.get("imageTypeInline"), s = t.commands.get("imageTypeBlock"), a = (l) => {
      if (!l.return) return;
      const { oldElement: c, newElement: d } = l.return;
      if (!c) return;
      if (e.isBlockImage(c)) {
        const h = i.getCaptionFromImageModelElement(c);
        if (h) return void this._saveCaption(d, h);
      }
      const u = this._getSavedCaption(c);
      u && this._saveCaption(d, u);
    };
    r && this.listenTo(r, "execute", a, { priority: "low" }), s && this.listenTo(s, "execute", a, { priority: "low" });
  }
  _getSavedCaption(t) {
    const e = this._savedCaptionsMap.get(t);
    return e ? Lt.fromJSON(e) : null;
  }
  _saveCaption(t, e) {
    this._savedCaptionsMap.set(t, e.toJSON());
  }
  _registerCaptionReconversion() {
    const t = this.editor, e = t.model, i = t.plugins.get("ImageUtils"), r = t.plugins.get("ImageCaptionUtils");
    e.document.on("change:data", () => {
      const s = e.document.differ.getChanges();
      for (const a of s) {
        if (a.attributeKey !== "alt") continue;
        const l = a.range.start.nodeAfter;
        if (i.isBlockImage(l)) {
          const c = r.getCaptionFromImageModelElement(l);
          if (!c) return;
          t.editing.reconvertItem(c);
        }
      }
    });
  }
}
class vI extends A {
  static get requires() {
    return [I_];
  }
  static get pluginName() {
    return "ImageCaptionUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.editing.view, e = n.plugins.get("ImageCaptionUtils"), i = n.t;
    n.ui.componentFactory.add("toggleImageCaption", (r) => {
      const s = n.commands.get("toggleImageCaption"), a = new V(r);
      return a.set({ icon: g2, tooltip: !0, isToggleable: !0 }), a.bind("isOn", "isEnabled").to(s, "value", "isEnabled"), a.bind("label").to(s, "value", (l) => i(l ? "Toggle caption off" : "Toggle caption on")), this.listenTo(a, "execute", () => {
        n.execute("toggleImageCaption", { focusCaptionOnShow: !0 });
        const l = e.getCaptionFromModelSelection(n.model.document.selection);
        if (l) {
          const c = n.editing.mapper.toViewElement(l);
          t.scrollToTheSelection(), t.change((d) => {
            d.addClass("image__caption_highlighted", c);
          });
        }
        n.editing.view.focus();
      }), a;
    });
  }
}
class yI extends A {
  static get requires() {
    return [_I, vI];
  }
  static get pluginName() {
    return "ImageCaption";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
function M_(o) {
  const n = o.map((t) => t.replace("+", "\\+"));
  return new RegExp(`^image\\/(${n.join("|")})$`);
}
function CI(o) {
  return new Promise((n, t) => {
    const e = o.getAttribute("src");
    fetch(e).then((i) => i.blob()).then((i) => {
      const r = cf(i, e), s = r.replace("image/", ""), a = new File([i], `image.${s}`, { type: r });
      n(a);
    }).catch((i) => i && i.name === "TypeError" ? function(r) {
      return function(s) {
        return new Promise((a, l) => {
          const c = N.document.createElement("img");
          c.addEventListener("load", () => {
            const d = N.document.createElement("canvas");
            d.width = c.width, d.height = c.height, d.getContext("2d").drawImage(c, 0, 0), d.toBlob((u) => u ? a(u) : l());
          }), c.addEventListener("error", () => l()), c.src = s;
        });
      }(r).then((s) => {
        const a = cf(s, r), l = a.replace("image/", "");
        return new File([s], `image.${l}`, { type: a });
      });
    }(e).then(n).catch(t) : t(i));
  });
}
function cf(o, n) {
  return o.type ? o.type : n.match(/data:(image\/\w+);base64/) ? n.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg";
}
class AI extends A {
  static get pluginName() {
    return "ImageUploadUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor;
    n.ui.componentFactory.add("uploadImage", () => this._createToolbarButton()), n.ui.componentFactory.add("imageUpload", () => this._createToolbarButton()), n.ui.componentFactory.add("menuBar:uploadImage", () => this._createMenuBarButton("standalone")), n.plugins.has("ImageInsertUI") && n.plugins.get("ImageInsertUI").registerIntegration({ name: "upload", observable: () => n.commands.get("uploadImage"), buttonViewCreator: () => this._createToolbarButton(), formViewCreator: () => this._createDropdownButton(), menuBarButtonViewCreator: (t) => this._createMenuBarButton(t ? "insertOnly" : "insertNested") });
  }
  _createButton(n) {
    const t = this.editor, e = t.locale, i = t.commands.get("uploadImage"), r = t.config.get("image.upload.types"), s = M_(r), a = new n(t.locale), l = e.t;
    return a.set({ acceptedType: r.map((c) => `image/${c}`).join(","), allowMultipleFiles: !0, label: l("Upload from computer"), icon: x2 }), a.bind("isEnabled").to(i), a.on("done", (c, d) => {
      const u = Array.from(d).filter((h) => s.test(h.type));
      u.length && (t.execute("uploadImage", { file: u }), t.editing.view.focus());
    }), a;
  }
  _createToolbarButton() {
    const n = this.editor.locale.t, t = this.editor.plugins.get("ImageInsertUI"), e = this.editor.commands.get("uploadImage"), i = this._createButton(Gm);
    return i.tooltip = !0, i.bind("label").to(t, "isImageSelected", e, "isAccessAllowed", (r, s) => n(s ? r ? "Replace image from computer" : "Upload image from computer" : "You have no image upload permissions.")), i;
  }
  _createDropdownButton() {
    const n = this.editor.locale.t, t = this.editor.plugins.get("ImageInsertUI"), e = this._createButton(Gm);
    return e.withText = !0, e.bind("label").to(t, "isImageSelected", (i) => n(i ? "Replace from computer" : "Upload from computer")), e.on("execute", () => {
      t.dropdownView.isOpen = !1;
    }), e;
  }
  _createMenuBarButton(n) {
    const t = this.editor.locale.t, e = this._createButton(Zw);
    switch (e.withText = !0, n) {
      case "standalone":
        e.label = t("Image from computer");
        break;
      case "insertOnly":
        e.label = t("Image");
        break;
      case "insertNested":
        e.label = t("From computer");
    }
    return e;
  }
}
class xI extends A {
  constructor(t) {
    super(t);
    m(this, "placeholder");
    m(this, "uploadStatusChange", (t, e, i) => {
      const r = this.editor, s = e.item, a = s.getAttribute("uploadId");
      if (!i.consumable.consume(e.item, t.name)) return;
      const l = r.plugins.get("ImageUtils"), c = r.plugins.get(vi), d = a ? e.attributeNewValue : null, u = this.placeholder, h = r.editing.mapper.toViewElement(s), g = i.writer;
      if (d == "reading") return df(h, g), void uf(l, u, h, g);
      if (d == "uploading") {
        const f = c.loaders.get(a);
        return df(h, g), void (f ? (hf(h, g), function(p, b, k, w) {
          const _ = function(y) {
            const C = y.createUIElement("div", { class: "ck-progress-bar" });
            return y.setCustomProperty("progressBar", !0, C), C;
          }(b);
          b.insert(b.createPositionAt(p, "end"), _), k.on("change:uploadedPercent", (y, C, x) => {
            w.change((I) => {
              I.setStyle("width", x + "%", _);
            });
          });
        }(h, g, f, r.editing.view), function(p, b, k, w) {
          if (w.data) {
            const _ = p.findViewImgElement(b);
            k.setAttribute("src", w.data, _);
          }
        }(l, h, g, f)) : uf(l, u, h, g));
      }
      d == "complete" && c.loaders.get(a) && function(f, p, b) {
        const k = p.createUIElement("div", { class: "ck-image-upload-complete-icon" });
        p.insert(p.createPositionAt(f, "end"), k), setTimeout(() => {
          b.change((w) => w.remove(w.createRangeOn(k)));
        }, 3e3);
      }(h, g, r.editing.view), function(f, p) {
        P_(f, p, "progressBar");
      }(h, g), hf(h, g), function(f, p) {
        p.removeClass("ck-appear", f);
      }(h, g);
    });
    this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
  }
  static get pluginName() {
    return "ImageUploadProgress";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor;
    t.plugins.has("ImageBlockEditing") && t.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange), t.plugins.has("ImageInlineEditing") && t.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange);
  }
}
function df(o, n) {
  o.hasClass("ck-appear") || n.addClass("ck-appear", o);
}
function uf(o, n, t, e) {
  t.hasClass("ck-image-upload-placeholder") || e.addClass("ck-image-upload-placeholder", t);
  const i = o.findViewImgElement(t);
  i.getAttribute("src") !== n && e.setAttribute("src", n, i), D_(t, "placeholder") || e.insert(e.createPositionAfter(i), function(r) {
    const s = r.createUIElement("div", { class: "ck-upload-placeholder-loader" });
    return r.setCustomProperty("placeholder", !0, s), s;
  }(e));
}
function hf(o, n) {
  o.hasClass("ck-image-upload-placeholder") && n.removeClass("ck-image-upload-placeholder", o), P_(o, n, "placeholder");
}
function D_(o, n) {
  for (const t of o.getChildren()) if (t.getCustomProperty(n)) return t;
}
function P_(o, n, t) {
  const e = D_(o, t);
  e && n.remove(n.createRangeOn(e));
}
class EI extends q {
  constructor(n) {
    super(n), this.set("isAccessAllowed", !0);
  }
  refresh() {
    const n = this.editor, t = n.plugins.get("ImageUtils"), e = n.model.document.selection.getSelectedElement();
    this.isEnabled = t.isImageAllowed() || t.isImage(e);
  }
  execute(n) {
    const t = Bt(n.file), e = this.editor.model.document.selection, i = this.editor.plugins.get("ImageUtils"), r = Object.fromEntries(e.getAttributes());
    t.forEach((s, a) => {
      const l = e.getSelectedElement();
      if (a && l && i.isImage(l)) {
        const c = this.editor.model.createPositionAfter(l);
        this._uploadImage(s, r, c);
      } else this._uploadImage(s, r);
    });
  }
  _uploadImage(n, t, e) {
    const i = this.editor, r = i.plugins.get(vi).createLoader(n), s = i.plugins.get("ImageUtils");
    r && s.insertImage({ ...t, uploadId: r.id }, e);
  }
}
class TI extends A {
  constructor(t) {
    super(t);
    m(this, "_uploadImageElements");
    m(this, "_uploadedImages", /* @__PURE__ */ new Map());
    t.config.define("image", { upload: { types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"] } }), this._uploadImageElements = /* @__PURE__ */ new Map();
  }
  static get requires() {
    return [vi, bg, De, _e];
  }
  static get pluginName() {
    return "ImageUploadEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor, e = t.model.document, i = t.conversion, r = t.plugins.get(vi), s = t.plugins.get("ImageUtils"), a = t.plugins.get("ClipboardPipeline"), l = M_(t.config.get("image.upload.types")), c = new EI(t);
    t.commands.add("uploadImage", c), t.commands.add("imageUpload", c), i.for("upcast").attributeToAttribute({ view: { name: "img", key: "uploadId" }, model: "uploadId" }).add((d) => d.on("element:img", (u, h, g) => {
      if (!g.consumable.test(h.viewItem, { attributes: ["data-ck-upload-id"] })) return;
      const f = h.viewItem.getAttribute("data-ck-upload-id");
      if (!f) return;
      const [p] = Array.from(h.modelRange.getItems({ shallow: !0 })), b = r.loaders.get(f);
      p && (g.writer.setAttribute("uploadId", f, p), g.consumable.consume(h.viewItem, { attributes: ["data-ck-upload-id"] }), b && b.data && g.writer.setAttribute("uploadStatus", b.status, p));
    }, { priority: "low" })), this.listenTo(t.editing.view.document, "clipboardInput", (d, u) => {
      if (h = u.dataTransfer, Array.from(h.types).includes("text/html") && h.getData("text/html") !== "") return;
      var h;
      const g = Array.from(u.dataTransfer.files).filter((f) => !!f && l.test(f.type));
      if (g.length && (d.stop(), t.model.change((f) => {
        u.targetRanges && f.setSelection(u.targetRanges.map((p) => t.editing.mapper.toModelRange(p))), t.execute("uploadImage", { file: g });
      }), !t.commands.get("uploadImage").isAccessAllowed)) {
        const f = t.plugins.get("Notification"), p = t.locale.t;
        f.showWarning(p("You have no image upload permissions."), { namespace: "image" });
      }
    }), this.listenTo(a, "inputTransformation", (d, u) => {
      const h = Array.from(t.editing.view.createRangeIn(u.content)).map((f) => f.item).filter((f) => function(p, b) {
        return !(!p.isInlineImageView(b) || !b.getAttribute("src") || !b.getAttribute("src").match(/^data:image\/\w+;base64,/g) && !b.getAttribute("src").match(/^blob:/g));
      }(s, f) && !f.getAttribute("uploadProcessed")).map((f) => ({ promise: CI(f), imageElement: f }));
      if (!h.length) return;
      const g = new Bn(t.editing.view.document);
      for (const f of h) {
        g.setAttribute("uploadProcessed", !0, f.imageElement);
        const p = r.createLoader(f.promise);
        p && (g.setAttribute("src", "", f.imageElement), g.setAttribute("uploadId", p.id, f.imageElement));
      }
    }), t.editing.view.document.on("dragover", (d, u) => {
      u.preventDefault();
    }), e.on("change", () => {
      const d = e.differ.getChanges({ includeChangesInGraveyard: !0 }).reverse(), u = /* @__PURE__ */ new Set();
      for (const h of d) if (h.type == "insert" && h.name != "$text") {
        const g = h.position.nodeAfter, f = h.position.root.rootName == "$graveyard";
        for (const p of SI(t, g)) {
          const b = p.getAttribute("uploadId");
          if (!b) continue;
          const k = r.loaders.get(b);
          k ? f ? u.has(b) || Array.from(this._uploadImageElements.get(b)).every((w) => w.root.rootName == "$graveyard") && k.abort() : (u.add(b), this._uploadImageElements.has(b) ? this._uploadImageElements.get(b).add(p) : this._uploadImageElements.set(b, /* @__PURE__ */ new Set([p])), k.status == "idle" && this._readAndUpload(k)) : !f && this._uploadedImages.has(b) && t.model.enqueueChange({ isUndoable: !1 }, (w) => {
            w.setAttribute("uploadStatus", "complete", p), this.fire("uploadComplete", { data: this._uploadedImages.get(b), imageElement: p });
          });
        }
      }
    }), this.on("uploadComplete", (d, { imageElement: u, data: h }) => {
      const g = h.urls ? h.urls : h;
      this.editor.model.change((f) => {
        f.setAttribute("src", g.default, u), this._parseAndSetSrcsetAttributeOnImage(g, u, f), s.setImageNaturalSizeAttributes(u);
      });
    }, { priority: "low" });
  }
  afterInit() {
    const t = this.editor.model.schema;
    this.editor.plugins.has("ImageBlockEditing") && (t.extend("imageBlock", { allowAttributes: ["uploadId", "uploadStatus"] }), this._registerConverters("imageBlock")), this.editor.plugins.has("ImageInlineEditing") && (t.extend("imageInline", { allowAttributes: ["uploadId", "uploadStatus"] }), this._registerConverters("imageInline"));
  }
  _readAndUpload(t) {
    const e = this.editor, i = e.model, r = e.locale.t, s = e.plugins.get(vi), a = e.plugins.get(bg), l = e.plugins.get("ImageUtils"), c = this._uploadImageElements;
    return i.enqueueChange({ isUndoable: !1 }, (u) => {
      const h = c.get(t.id);
      for (const g of h) u.setAttribute("uploadStatus", "reading", g);
    }), t.read().then(() => {
      const u = t.upload();
      e.ui && e.ui.ariaLiveAnnouncer.announce(r("Uploading image"));
      for (const h of c.get(t.id)) {
        if (H.isSafari) {
          const g = e.editing.mapper.toViewElement(h), f = l.findViewImgElement(g);
          e.editing.view.once("render", () => {
            if (!f.parent) return;
            const p = e.editing.view.domConverter.mapViewToDom(f.parent);
            if (!p) return;
            const b = p.style.display;
            p.style.display = "none", p._ckHack = p.offsetHeight, p.style.display = b;
          });
        }
        i.enqueueChange({ isUndoable: !1 }, (g) => {
          g.setAttribute("uploadStatus", "uploading", h);
        });
      }
      return u;
    }).then((u) => {
      i.enqueueChange({ isUndoable: !1 }, (h) => {
        for (const g of c.get(t.id)) h.setAttribute("uploadStatus", "complete", g), this.fire("uploadComplete", { data: u, imageElement: g });
        e.ui && e.ui.ariaLiveAnnouncer.announce(r("Image upload complete")), this._uploadedImages.set(t.id, u);
      }), d();
    }).catch((u) => {
      if (e.ui && e.ui.ariaLiveAnnouncer.announce(r("Error during image upload")), t.status !== "error" && t.status !== "aborted") throw u;
      t.status == "error" && u && a.showWarning(u, { title: r("Upload failed"), namespace: "upload" }), i.enqueueChange({ isUndoable: !1 }, (h) => {
        for (const g of c.get(t.id)) g.root.rootName !== "$graveyard" && h.remove(g);
      }), d();
    });
    function d() {
      i.enqueueChange({ isUndoable: !1 }, (u) => {
        for (const h of c.get(t.id)) u.removeAttribute("uploadId", h), u.removeAttribute("uploadStatus", h);
        c.delete(t.id);
      }), s.destroyLoader(t);
    }
  }
  _parseAndSetSrcsetAttributeOnImage(t, e, i) {
    let r = 0;
    const s = Object.keys(t).filter((a) => {
      const l = parseInt(a, 10);
      if (!isNaN(l)) return r = Math.max(r, l), !0;
    }).map((a) => `${t[a]} ${a}w`).join(", ");
    if (s != "") {
      const a = { srcset: s };
      e.hasAttribute("width") || e.hasAttribute("height") || (a.width = r), i.setAttributes(a, e);
    }
  }
  _registerConverters(t) {
    const { conversion: e, plugins: i } = this.editor, r = i.get(vi), s = i.get(_e);
    e.for("dataDowncast").add((a) => {
      a.on(`attribute:uploadId:${t}`, (l, c, d) => {
        if (!d.consumable.test(c.item, l.name)) return;
        const u = r.loaders.get(c.attributeNewValue);
        if (!u || !u.data) return null;
        const h = d.mapper.toViewElement(c.item), g = s.findViewImgElement(h);
        g && (d.consumable.consume(c.item, l.name), d.writer.setAttribute("data-ck-upload-id", u.id, g));
      });
    });
  }
}
function SI(o, n) {
  const t = o.plugins.get("ImageUtils");
  return Array.from(o.model.createRangeOn(n)).filter((e) => t.isImage(e.item)).map((e) => e.item);
}
class L_ extends A {
  static get pluginName() {
    return "ImageUpload";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [TI, AI, xI];
  }
}
class II extends L {
  constructor(t) {
    super(t);
    m(this, "urlInputView");
    m(this, "keystrokes");
    this.set("imageURLInputValue", ""), this.set("isImageSelected", !1), this.set("isEnabled", !0), this.keystrokes = new Mt(), this.urlInputView = this._createUrlInputView(), this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-image-insert-url"], tabindex: "-1" }, children: [this.urlInputView, { tag: "div", attributes: { class: ["ck", "ck-image-insert-url__action-row"] } }] });
  }
  render() {
    super.render(), ar({ view: this }), this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy(), this.keystrokes.destroy();
  }
  _createUrlInputView() {
    const t = this.locale, e = t.t, i = new Nn(t, Mi);
    return i.bind("label").to(this, "isImageSelected", (r) => e(r ? "Update image URL" : "Insert image via URL")), i.bind("isEnabled").to(this), i.fieldView.inputMode = "url", i.fieldView.placeholder = "https://example.com/image.png", i.fieldView.bind("value").to(this, "imageURLInputValue", (r) => r || ""), i.fieldView.on("input", () => {
      this.imageURLInputValue = i.fieldView.element.value.trim();
    }), i;
  }
  focus() {
    this.urlInputView.focus();
  }
}
class MI extends A {
  constructor() {
    super(...arguments);
    m(this, "_imageInsertUI");
    m(this, "_formView");
  }
  static get pluginName() {
    return "ImageInsertViaUrlUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [xs, no];
  }
  init() {
    this.editor.ui.componentFactory.add("insertImageViaUrl", () => this._createToolbarButton()), this.editor.ui.componentFactory.add("menuBar:insertImageViaUrl", () => this._createMenuBarButton("standalone"));
  }
  afterInit() {
    this._imageInsertUI = this.editor.plugins.get("ImageInsertUI"), this._imageInsertUI.registerIntegration({ name: "url", observable: () => this.editor.commands.get("insertImage"), buttonViewCreator: () => this._createToolbarButton(), formViewCreator: () => this._createDropdownButton(), menuBarButtonViewCreator: (t) => this._createMenuBarButton(t ? "insertOnly" : "insertNested") });
  }
  _createInsertUrlButton(t) {
    const e = new t(this.editor.locale);
    return e.icon = E2, e.on("execute", () => {
      this._showModal();
    }), e;
  }
  _createToolbarButton() {
    const t = this.editor.locale.t, e = this._createInsertUrlButton(V);
    return e.tooltip = !0, e.bind("label").to(this._imageInsertUI, "isImageSelected", (i) => t(i ? "Update image URL" : "Insert image via URL")), e;
  }
  _createDropdownButton() {
    const t = this.editor.locale.t, e = this._createInsertUrlButton(V);
    return e.withText = !0, e.bind("label").to(this._imageInsertUI, "isImageSelected", (i) => t(i ? "Update image URL" : "Insert via URL")), e;
  }
  _createMenuBarButton(t) {
    const e = this.editor.locale.t, i = this._createInsertUrlButton(Et);
    switch (i.withText = !0, t) {
      case "standalone":
        i.label = e("Image via URL");
        break;
      case "insertOnly":
        i.label = e("Image");
        break;
      case "insertNested":
        i.label = e("Via URL");
    }
    return i;
  }
  _createInsertUrlView() {
    const t = this.editor, e = t.locale, i = t.commands.get("replaceImageSource"), r = t.commands.get("insertImage"), s = new II(e);
    return s.bind("isImageSelected").to(this._imageInsertUI), s.bind("isEnabled").toMany([r, i], "isEnabled", (...a) => a.some((l) => l)), s;
  }
  _showModal() {
    const t = this.editor, e = t.locale.t, i = t.plugins.get("Dialog");
    this._formView || (this._formView = this._createInsertUrlView(), this._formView.on("submit", () => this._handleSave()));
    const r = t.commands.get("replaceImageSource");
    this._formView.imageURLInputValue = r.value || "", i.show({ id: "insertImageViaUrl", title: e("Image via URL"), isModal: !0, content: this._formView, actionButtons: [{ label: e("Cancel"), withText: !0, onExecute: () => i.hide() }, { label: this._imageInsertUI.isImageSelected ? e("Save") : e("Insert"), class: "ck-button-action", withText: !0, onExecute: () => this._handleSave() }] });
  }
  _handleSave() {
    this.editor.commands.get("replaceImageSource").isEnabled ? this.editor.execute("replaceImageSource", { source: this._formView.imageURLInputValue }) : this.editor.execute("insertImage", { source: this._formView.imageURLInputValue }), this.editor.plugins.get("Dialog").hide();
  }
}
class B_ extends A {
  static get pluginName() {
    return "ImageInsertViaUrl";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [MI, xs];
  }
}
class DI extends A {
  static get pluginName() {
    return "ImageInsert";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [L_, B_, xs];
  }
}
class PI extends q {
  refresh() {
    const n = this.editor, t = n.plugins.get("ImageUtils").getClosestSelectedImageElement(n.model.document.selection);
    this.isEnabled = !!t, t && t.hasAttribute("resizedWidth") ? this.value = { width: t.getAttribute("resizedWidth"), height: null } : this.value = null;
  }
  execute(n) {
    const t = this.editor, e = t.model, i = t.plugins.get("ImageUtils"), r = i.getClosestSelectedImageElement(e.document.selection);
    this.value = { width: n.width, height: null }, r && e.change((s) => {
      s.setAttribute("resizedWidth", n.width, r), s.removeAttribute("resizedHeight", r), i.setImageNaturalSizeAttributes(r);
    });
  }
}
class N_ extends A {
  static get requires() {
    return [_e];
  }
  static get pluginName() {
    return "ImageResizeEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  constructor(n) {
    super(n), n.config.define("image", { resizeUnit: "%", resizeOptions: [{ name: "resizeImage:original", value: null, icon: "original" }, { name: "resizeImage:custom", value: "custom", icon: "custom" }, { name: "resizeImage:25", value: "25", icon: "small" }, { name: "resizeImage:50", value: "50", icon: "medium" }, { name: "resizeImage:75", value: "75", icon: "large" }] });
  }
  init() {
    const n = this.editor, t = new PI(n);
    this._registerConverters("imageBlock"), this._registerConverters("imageInline"), n.commands.add("resizeImage", t), n.commands.add("imageResize", t);
  }
  afterInit() {
    this._registerSchema();
  }
  _registerSchema() {
    this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", { allowAttributes: ["resizedWidth", "resizedHeight"] }), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", { allowAttributes: ["resizedWidth", "resizedHeight"] });
  }
  _registerConverters(n) {
    const t = this.editor, e = t.plugins.get("ImageUtils");
    t.conversion.for("downcast").add((i) => i.on(`attribute:resizedWidth:${n}`, (r, s, a) => {
      if (!a.consumable.consume(s.item, r.name)) return;
      const l = a.writer, c = a.mapper.toViewElement(s.item);
      s.attributeNewValue !== null ? (l.setStyle("width", s.attributeNewValue, c), l.addClass("image_resized", c)) : (l.removeStyle("width", c), l.removeClass("image_resized", c));
    })), t.conversion.for("dataDowncast").attributeToAttribute({ model: { name: n, key: "resizedHeight" }, view: (i) => ({ key: "style", value: { height: i } }) }), t.conversion.for("editingDowncast").add((i) => i.on(`attribute:resizedHeight:${n}`, (r, s, a) => {
      if (!a.consumable.consume(s.item, r.name)) return;
      const l = a.writer, c = a.mapper.toViewElement(s.item), d = n === "imageInline" ? e.findViewImgElement(c) : c;
      s.attributeNewValue !== null ? l.setStyle("height", s.attributeNewValue, d) : l.removeStyle("height", d);
    })), t.conversion.for("upcast").attributeToAttribute({ view: { name: n === "imageBlock" ? "figure" : "img", styles: { width: /.+/ } }, model: { key: "resizedWidth", value: (i) => Va(i) ? null : i.getStyle("width") } }), t.conversion.for("upcast").attributeToAttribute({ view: { name: n === "imageBlock" ? "figure" : "img", styles: { height: /.+/ } }, model: { key: "resizedHeight", value: (i) => Va(i) ? null : i.getStyle("height") } });
  }
}
const pc = { small: G2, medium: W2, large: q2, custom: U2, original: $2 };
class LI extends A {
  constructor(t) {
    super(t);
    m(this, "_resizeUnit");
    this._resizeUnit = t.config.get("image.resizeUnit");
  }
  static get requires() {
    return [N_];
  }
  static get pluginName() {
    return "ImageResizeButtons";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor, e = t.config.get("image.resizeOptions"), i = t.commands.get("resizeImage");
    this.bind("isEnabled").to(i);
    for (const r of e) this._registerImageResizeButton(r);
    this._registerImageResizeDropdown(e);
  }
  _registerImageResizeButton(t) {
    const e = this.editor, { name: i, value: r, icon: s } = t;
    e.ui.componentFactory.add(i, (a) => {
      const l = new V(a), c = e.commands.get("resizeImage"), d = this._getOptionLabelValue(t, !0);
      if (!pc[s]) throw new v("imageresizebuttons-missing-icon", e, t);
      if (l.set({ label: d, icon: pc[s], tooltip: d, isToggleable: !0 }), l.bind("isEnabled").to(this), e.plugins.has("ImageCustomResizeUI") && Er(t)) {
        const u = e.plugins.get("ImageCustomResizeUI");
        this.listenTo(l, "execute", () => {
          u._showForm(this._resizeUnit);
        });
      } else {
        const u = r ? r + this._resizeUnit : null;
        l.bind("isOn").to(c, "value", c, "isEnabled", vd(u)), this.listenTo(l, "execute", () => {
          e.execute("resizeImage", { width: u });
        });
      }
      return l;
    });
  }
  _registerImageResizeDropdown(t) {
    const e = this.editor, i = e.t, r = t.find((a) => !a.value), s = (a) => {
      const l = e.commands.get("resizeImage"), c = ge(a, Ow), d = c.buttonView, u = i("Resize image");
      return d.set({ tooltip: u, commandValue: r.value, icon: pc.medium, isToggleable: !0, label: this._getOptionLabelValue(r), withText: !0, class: "ck-resize-image-button", ariaLabel: u, ariaLabelledBy: void 0 }), d.bind("label").to(l, "value", (h) => h && h.width ? h.width : this._getOptionLabelValue(r)), c.bind("isEnabled").to(this), zi(c, () => this._getResizeDropdownListItemDefinitions(t, l), { ariaLabel: i("Image resize list"), role: "menu" }), this.listenTo(c, "execute", (h) => {
        "onClick" in h.source ? h.source.onClick() : (e.execute(h.source.commandName, { width: h.source.commandValue }), e.editing.view.focus());
      }), c;
    };
    e.ui.componentFactory.add("resizeImage", s), e.ui.componentFactory.add("imageResize", s);
  }
  _getOptionLabelValue(t, e = !1) {
    const i = this.editor.t;
    return t.label ? t.label : e ? Er(t) ? i("Custom image size") : t.value ? i("Resize image to %0", t.value + this._resizeUnit) : i("Resize image to the original size") : Er(t) ? i("Custom") : t.value ? t.value + this._resizeUnit : i("Original");
  }
  _getResizeDropdownListItemDefinitions(t, e) {
    const { editor: i } = this, r = new ne(), s = t.map((a) => Er(a) ? { ...a, valueWithUnits: "custom" } : a.value ? { ...a, valueWithUnits: `${a.value}${this._resizeUnit}` } : { ...a, valueWithUnits: null });
    for (const a of s) {
      let l = null;
      if (i.plugins.has("ImageCustomResizeUI") && Er(a)) {
        const c = i.plugins.get("ImageCustomResizeUI");
        l = { type: "button", model: new ai({ label: this._getOptionLabelValue(a), role: "menuitemradio", withText: !0, icon: null, onClick: () => {
          c._showForm(this._resizeUnit);
        } }) };
        const d = Object.values(s).map((u) => u.valueWithUnits);
        l.model.bind("isOn").to(e, "value", e, "isEnabled", BI(d));
      } else l = { type: "button", model: new ai({ commandName: "resizeImage", commandValue: a.valueWithUnits, label: this._getOptionLabelValue(a), role: "menuitemradio", withText: !0, icon: null }) }, l.model.bind("isOn").to(e, "value", e, "isEnabled", vd(a.valueWithUnits));
      l.model.bind("isEnabled").to(e, "isEnabled"), r.add(l);
    }
    return r;
  }
}
function Er(o) {
  return o.value === "custom";
}
function vd(o) {
  return (n, t) => !(n === void 0 || !t) && (o === null && n === o || n !== null && n.width === o);
}
function BI(o) {
  return (n, t) => !o.some((e) => vd(e)(n, t));
}
const bc = "image_resized";
class NI extends A {
  static get requires() {
    return [ac, _e];
  }
  static get pluginName() {
    return "ImageResizeHandles";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor.commands.get("resizeImage");
    this.bind("isEnabled").to(n), this._setupResizerCreator();
  }
  _setupResizerCreator() {
    const n = this.editor, t = n.editing.view, e = n.plugins.get("ImageUtils");
    t.addObserver(Ru), this.listenTo(t.document, "imageLoaded", (i, r) => {
      if (!r.target.matches("figure.image.ck-widget > img,figure.image.ck-widget > picture > img,figure.image.ck-widget > a > img,figure.image.ck-widget > a > picture > img,span.image-inline.ck-widget > img,span.image-inline.ck-widget > picture > img")) return;
      const s = n.editing.view.domConverter, a = s.domToView(r.target), l = e.getImageWidgetFromImageView(a);
      let c = this.editor.plugins.get(ac).getResizerByViewElement(l);
      if (c) return void c.redraw();
      const d = n.editing.mapper, u = d.toModelElement(l);
      c = n.plugins.get(ac).attachTo({ unit: n.config.get("image.resizeUnit"), modelElement: u, viewElement: l, editor: n, getHandleHost: (h) => h.querySelector("img"), getResizeHost: () => s.mapViewToDom(d.toViewElement(u)), isCentered: () => u.getAttribute("imageStyle") == "alignCenter", onCommit(h) {
        t.change((g) => {
          g.removeClass(bc, l);
        }), n.execute("resizeImage", { width: h });
      } }), c.on("updateSize", () => {
        l.hasClass(bc) || t.change((g) => {
          g.addClass(bc, l);
        });
        const h = u.name === "imageInline" ? a : l;
        h.getStyle("height") && t.change((g) => {
          g.removeStyle("height", h);
        });
      }), c.bind("isEnabled").to(this);
    });
  }
}
function mf(o) {
  if (!o) return null;
  const [, n, t] = o.trim().match(/([.,\d]+)(%|px)$/) || [], e = Number.parseFloat(n);
  return Number.isNaN(e) ? null : { value: e, unit: t };
}
function gf(o, n, t) {
  return t === "px" ? { value: n.value, unit: "px" } : { value: n.value / o * 100, unit: "%" };
}
function ff(o) {
  const { editing: n } = o, t = o.plugins.get("ImageUtils").getClosestSelectedImageElement(o.model.document.selection);
  if (!t) return null;
  const e = n.mapper.toViewElement(t);
  return { model: t, view: e, dom: n.view.domConverter.mapViewToDom(e) };
}
class zI extends L {
  constructor(t, e, i) {
    super(t);
    m(this, "focusTracker");
    m(this, "keystrokes");
    m(this, "unit");
    m(this, "backButtonView");
    m(this, "saveButtonView");
    m(this, "labeledInput");
    m(this, "children");
    m(this, "_focusables");
    m(this, "_focusCycler");
    m(this, "_validators");
    this.focusTracker = new gt(), this.keystrokes = new Mt(), this.unit = e, this.backButtonView = this._createBackButton(), this.saveButtonView = this._createSaveButton(), this.labeledInput = this._createLabeledInputView(), this.children = this.createCollection([this._createHeaderView()]), this.children.add(new Ma(t, { children: [this.labeledInput, this.saveButtonView], class: ["ck-form__row_with-submit", "ck-form__row_large-top-padding"] })), this._focusables = new Te(), this._validators = i, this.keystrokes.set("Esc", (r, s) => {
      this.fire("cancel"), s();
    }), this._focusCycler = new le({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-form", "ck-image-custom-resize-form", "ck-responsive-form"], tabindex: "-1" }, children: this.children });
  }
  render() {
    super.render(), ar({ view: this }), [this.backButtonView, this.labeledInput, this.saveButtonView].forEach((t) => {
      this._focusables.add(t), this.focusTracker.add(t.element);
    }), this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  _createBackButton() {
    const t = this.locale.t, e = new V(this.locale);
    return e.set({ class: "ck-button-back", label: t("Back"), icon: co, tooltip: !0 }), e.delegate("execute").to(this, "cancel"), e;
  }
  _createSaveButton() {
    const t = this.locale.t, e = new V(this.locale);
    return e.set({ label: t("Save"), withText: !0, type: "submit", class: "ck-button-action ck-button-bold" }), e;
  }
  _createHeaderView() {
    const t = this.locale.t, e = new uo(this.locale, { label: t("Image Resize") });
    return e.children.add(this.backButtonView, 0), e;
  }
  _createLabeledInputView() {
    const t = this.locale.t, e = new Nn(this.locale, Fw);
    return e.label = t("Resize image (in %0)", this.unit), e.class = "ck-labeled-field-view_full-width", e.fieldView.set({ step: 0.1 }), e;
  }
  isValid() {
    this.resetFormStatus();
    for (const t of this._validators) {
      const e = t(this);
      if (e) return this.labeledInput.errorText = e, !1;
    }
    return !0;
  }
  resetFormStatus() {
    this.labeledInput.errorText = null;
  }
  get rawSize() {
    const { element: t } = this.labeledInput.fieldView;
    return t ? t.value : null;
  }
  get parsedSize() {
    const { rawSize: t } = this;
    if (t === null) return null;
    const e = Number.parseFloat(t);
    return Number.isNaN(e) ? null : e;
  }
  get sizeWithUnits() {
    const { parsedSize: t, unit: e } = this;
    return t === null ? null : `${t}${e}`;
  }
}
class OI extends A {
  constructor() {
    super(...arguments);
    m(this, "_balloon");
    m(this, "_form");
  }
  static get requires() {
    return [On];
  }
  static get pluginName() {
    return "ImageCustomResizeUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  destroy() {
    super.destroy(), this._form && this._form.destroy();
  }
  _createForm(t) {
    const e = this.editor;
    this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new (rs(zI))(e.locale, t, function(i) {
      const r = i.t;
      return [(s) => s.rawSize.trim() === "" ? r("The value must not be empty.") : s.parsedSize === null ? r("The value should be a plain number.") : void 0];
    }(e)), this._form.render(), this.listenTo(this._form, "submit", () => {
      this._form.isValid() && (e.execute("resizeImage", { width: this._form.sizeWithUnits }), this._hideForm(!0));
    }), this.listenTo(this._form.labeledInput, "change:errorText", () => {
      e.ui.update();
    }), this.listenTo(this._form, "cancel", () => {
      this._hideForm(!0);
    }), Ni({ emitter: this._form, activator: () => this._isVisible, contextElements: () => [this._balloon.view.element], callback: () => this._hideForm() });
  }
  _showForm(t) {
    if (this._isVisible) return;
    this._form || this._createForm(t);
    const e = this.editor, i = this._form.labeledInput;
    this._form.disableCssTransitions(), this._form.resetFormStatus(), this._isInBalloon || this._balloon.add({ view: this._form, position: _d(e) });
    const r = function(l, c) {
      const d = ff(l);
      if (!d) return null;
      const u = mf(d.model.getAttribute("resizedWidth") || null);
      return u ? u.unit === c ? u : gf(bd(d.dom), { value: new K(d.dom).width }, c) : null;
    }(e, t), s = r ? r.value.toFixed(1) : "", a = function(l, c) {
      const d = ff(l);
      if (!d) return null;
      const u = bd(d.dom), h = mf(window.getComputedStyle(d.dom).minWidth) || { value: 1 };
      return { unit: c, lower: Math.max(0.1, gf(u, h, c).value), upper: c === "px" ? u : 100 };
    }(e, t);
    i.fieldView.value = i.fieldView.element.value = s, a && Object.assign(i.fieldView, { min: a.lower.toFixed(1), max: Math.ceil(a.upper).toFixed(1) }), this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions();
  }
  _hideForm(t = !1) {
    this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), t && this.editor.editing.view.focus());
  }
  get _isVisible() {
    return !!this._balloon && this._balloon.visibleView === this._form;
  }
  get _isInBalloon() {
    return !!this._balloon && this._balloon.hasView(this._form);
  }
}
class RI extends A {
  static get requires() {
    return [N_, NI, OI, LI];
  }
  static get pluginName() {
    return "ImageResize";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class VI extends q {
  constructor(t, e) {
    super(t);
    m(this, "_defaultStyles");
    m(this, "_styles");
    this._defaultStyles = { imageBlock: !1, imageInline: !1 }, this._styles = new Map(e.map((i) => {
      if (i.isDefault) for (const r of i.modelElements) this._defaultStyles[r] = i.name;
      return [i.name, i];
    }));
  }
  refresh() {
    const t = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
    this.isEnabled = !!t, this.isEnabled ? t.hasAttribute("imageStyle") ? this.value = t.getAttribute("imageStyle") : this.value = this._defaultStyles[t.name] : this.value = !1;
  }
  execute(t = {}) {
    const e = this.editor, i = e.model, r = e.plugins.get("ImageUtils");
    i.change((s) => {
      const a = t.value, { setImageSizes: l = !0 } = t;
      let c = r.getClosestSelectedImageElement(i.document.selection);
      a && this.shouldConvertImageType(a, c) && (this.editor.execute(r.isBlockImage(c) ? "imageTypeInline" : "imageTypeBlock", { setImageSizes: l }), c = r.getClosestSelectedImageElement(i.document.selection)), !a || this._styles.get(a).isDefault ? s.removeAttribute("imageStyle", c) : s.setAttribute("imageStyle", a, c), l && r.setImageNaturalSizeAttributes(c);
    });
  }
  shouldConvertImageType(t, e) {
    return !this._styles.get(t).modelElements.includes(e.name);
  }
}
const qs = { get inline() {
  return { name: "inline", title: "In line", icon: Aw, modelElements: ["imageInline"], isDefault: !0 };
}, get alignLeft() {
  return { name: "alignLeft", title: "Left aligned image", icon: Cw, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-left" };
}, get alignBlockLeft() {
  return { name: "alignBlockLeft", title: "Left aligned image", icon: xw, modelElements: ["imageBlock"], className: "image-style-block-align-left" };
}, get alignCenter() {
  return { name: "alignCenter", title: "Centered image", icon: sd, modelElements: ["imageBlock"], className: "image-style-align-center" };
}, get alignRight() {
  return { name: "alignRight", title: "Right aligned image", icon: ad, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-right" };
}, get alignBlockRight() {
  return { name: "alignBlockRight", title: "Right aligned image", icon: Ew, modelElements: ["imageBlock"], className: "image-style-block-align-right" };
}, get block() {
  return { name: "block", title: "Centered image", icon: sd, modelElements: ["imageBlock"], isDefault: !0 };
}, get side() {
  return { name: "side", title: "Side image", icon: ad, modelElements: ["imageBlock"], className: "image-style-side" };
} }, pf = { full: H2, left: xw, right: Ew, center: sd, inlineLeft: Cw, inlineRight: ad, inline: Aw }, bf = [{ name: "imageStyle:wrapText", title: "Wrap text", defaultItem: "imageStyle:alignLeft", items: ["imageStyle:alignLeft", "imageStyle:alignRight"] }, { name: "imageStyle:breakText", title: "Break text", defaultItem: "imageStyle:block", items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"] }];
function kf(o) {
  at("image-style-configuration-definition-invalid", o);
}
var yd = { normalizeStyles: function(o) {
  return (o.configuredStyles.options || []).map((n) => function(t) {
    return t = typeof t == "string" ? qs[t] ? { ...qs[t] } : { name: t } : function(e, i) {
      const r = { ...i };
      for (const s in e) Object.prototype.hasOwnProperty.call(i, s) || (r[s] = e[s]);
      return r;
    }(qs[t.name], t), typeof t.icon == "string" && (t.icon = pf[t.icon] || t.icon), t;
  }(n)).filter((n) => function(t, { isBlockPluginLoaded: e, isInlinePluginLoaded: i }) {
    const { modelElements: r, name: s } = t;
    if (!(r && r.length && s)) return kf({ style: t }), !1;
    {
      const a = [e ? "imageBlock" : null, i ? "imageInline" : null];
      if (!r.some((l) => a.includes(l))) return at("image-style-missing-dependency", { style: t, missingPlugins: r.map((l) => l === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing") }), !1;
    }
    return !0;
  }(n, o));
}, getDefaultStylesConfiguration: function(o, n) {
  return o && n ? { options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"] } : o ? { options: ["block", "side"] } : n ? { options: ["inline", "alignLeft", "alignRight"] } : {};
}, getDefaultDropdownDefinitions: function(o) {
  return o.has("ImageBlockEditing") && o.has("ImageInlineEditing") ? [...bf] : [];
}, warnInvalidStyle: kf, DEFAULT_OPTIONS: qs, DEFAULT_ICONS: pf, DEFAULT_DROPDOWN_DEFINITIONS: bf };
function wf(o, n) {
  for (const t of n) if (t.name === o) return t;
}
class z_ extends A {
  constructor() {
    super(...arguments);
    m(this, "normalizedStyles");
  }
  static get pluginName() {
    return "ImageStyleEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [_e];
  }
  init() {
    const { normalizeStyles: t, getDefaultStylesConfiguration: e } = yd, i = this.editor, r = i.plugins.has("ImageBlockEditing"), s = i.plugins.has("ImageInlineEditing");
    i.config.define("image.styles", e(r, s)), this.normalizedStyles = t({ configuredStyles: i.config.get("image.styles"), isBlockPluginLoaded: r, isInlinePluginLoaded: s }), this._setupConversion(r, s), this._setupPostFixer(), i.commands.add("imageStyle", new VI(i, this.normalizedStyles));
  }
  _setupConversion(t, e) {
    const i = this.editor, r = i.model.schema, s = (a = this.normalizedStyles, (c, d, u) => {
      if (!u.consumable.consume(d.item, c.name)) return;
      const h = wf(d.attributeNewValue, a), g = wf(d.attributeOldValue, a), f = u.mapper.toViewElement(d.item), p = u.writer;
      g && p.removeClass(g.className, f), h && p.addClass(h.className, f);
    });
    var a;
    const l = function(c) {
      const d = { imageInline: c.filter((u) => !u.isDefault && u.modelElements.includes("imageInline")), imageBlock: c.filter((u) => !u.isDefault && u.modelElements.includes("imageBlock")) };
      return (u, h, g) => {
        if (!h.modelRange) return;
        const f = h.viewItem, p = yt(h.modelRange.getItems());
        if (p && g.schema.checkAttribute(p, "imageStyle")) for (const b of d[p.name]) g.consumable.consume(f, { classes: b.className }) && g.writer.setAttribute("imageStyle", b.name, p);
      };
    }(this.normalizedStyles);
    i.editing.downcastDispatcher.on("attribute:imageStyle", s), i.data.downcastDispatcher.on("attribute:imageStyle", s), t && (r.extend("imageBlock", { allowAttributes: "imageStyle" }), i.data.upcastDispatcher.on("element:figure", l, { priority: "low" })), e && (r.extend("imageInline", { allowAttributes: "imageStyle" }), i.data.upcastDispatcher.on("element:img", l, { priority: "low" }));
  }
  _setupPostFixer() {
    const t = this.editor, e = t.model.document, i = t.plugins.get(_e), r = new Map(this.normalizedStyles.map((s) => [s.name, s]));
    e.registerPostFixer((s) => {
      let a = !1;
      for (const l of e.differ.getChanges()) if (l.type == "insert" || l.type == "attribute" && l.attributeKey == "imageStyle") {
        let c = l.type == "insert" ? l.position.nodeAfter : l.range.start.nodeAfter;
        if (c && c.is("element", "paragraph") && c.childCount > 0 && (c = c.getChild(0)), !i.isImage(c)) continue;
        const d = c.getAttribute("imageStyle");
        if (!d) continue;
        const u = r.get(d);
        u && u.modelElements.includes(c.name) || (s.removeAttribute("imageStyle", c), a = !0);
      }
      return a;
    });
  }
}
class FI extends A {
  static get requires() {
    return [z_];
  }
  static get pluginName() {
    return "ImageStyleUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  get localizedDefaultStylesTitles() {
    const n = this.editor.t;
    return { "Wrap text": n("Wrap text"), "Break text": n("Break text"), "In line": n("In line"), "Full size image": n("Full size image"), "Side image": n("Side image"), "Left aligned image": n("Left aligned image"), "Centered image": n("Centered image"), "Right aligned image": n("Right aligned image") };
  }
  init() {
    const n = this.editor.plugins, t = this.editor.config.get("image.toolbar") || [], e = _f(n.get("ImageStyleEditing").normalizedStyles, this.localizedDefaultStylesTitles);
    for (const r of e) this._createButton(r);
    const i = _f([...t.filter(bn), ...yd.getDefaultDropdownDefinitions(n)], this.localizedDefaultStylesTitles);
    for (const r of i) this._createDropdown(r, e);
  }
  _createDropdown(n, t) {
    const e = this.editor.ui.componentFactory;
    e.add(n.name, (i) => {
      let r;
      const { defaultItem: s, items: a, title: l } = n, c = a.filter((g) => t.find(({ name: f }) => vf(f) === g)).map((g) => {
        const f = e.create(g);
        return g === s && (r = f), f;
      });
      a.length !== c.length && yd.warnInvalidStyle({ dropdown: n });
      const d = ge(i, mo), u = d.buttonView, h = u.arrowView;
      return As(d, c, { enableActiveItemFocusOnDropdownOpen: !0 }), u.set({ label: yf(l, r.label), class: null, tooltip: !0 }), h.unbind("label"), h.set({ label: l }), u.bind("icon").toMany(c, "isOn", (...g) => {
        const f = g.findIndex(Mo);
        return f < 0 ? r.icon : c[f].icon;
      }), u.bind("label").toMany(c, "isOn", (...g) => {
        const f = g.findIndex(Mo);
        return yf(l, f < 0 ? r.label : c[f].label);
      }), u.bind("isOn").toMany(c, "isOn", (...g) => g.some(Mo)), u.bind("class").toMany(c, "isOn", (...g) => g.some(Mo) ? "ck-splitbutton_flatten" : void 0), u.on("execute", () => {
        c.some(({ isOn: g }) => g) ? d.isOpen = !d.isOpen : r.fire("execute");
      }), d.bind("isEnabled").toMany(c, "isEnabled", (...g) => g.some(Mo)), this.listenTo(d, "execute", () => {
        this.editor.editing.view.focus();
      }), d;
    });
  }
  _createButton(n) {
    const t = n.name;
    this.editor.ui.componentFactory.add(vf(t), (e) => {
      const i = this.editor.commands.get("imageStyle"), r = new V(e);
      return r.set({ label: n.title, icon: n.icon, tooltip: !0, isToggleable: !0 }), r.bind("isEnabled").to(i, "isEnabled"), r.bind("isOn").to(i, "value", (s) => s === t), r.on("execute", this._executeCommand.bind(this, t)), r;
    });
  }
  _executeCommand(n) {
    this.editor.execute("imageStyle", { value: n }), this.editor.editing.view.focus();
  }
}
function _f(o, n) {
  for (const t of o) n[t.title] && (t.title = n[t.title]);
  return o;
}
function vf(o) {
  return `imageStyle:${o}`;
}
function yf(o, n) {
  return (o ? o + ": " : "") + n;
}
class jI extends A {
  static get requires() {
    return [z_, FI];
  }
  static get pluginName() {
    return "ImageStyle";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class HI extends A {
  static get requires() {
    return [La, _e];
  }
  static get pluginName() {
    return "ImageToolbar";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  afterInit() {
    const n = this.editor, t = n.t, e = n.plugins.get(La), i = n.plugins.get("ImageUtils");
    var r;
    e.register("image", { ariaLabel: t("Image toolbar"), items: (r = n.config.get("image.toolbar") || [], r.map((s) => bn(s) ? s.name : s)), getRelatedElement: (s) => i.getClosestSelectedImageWidget(s) });
  }
}
class UI extends A {
  static get pluginName() {
    return "IndentEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor;
    n.commands.add("indent", new Nh(n)), n.commands.add("outdent", new Nh(n));
  }
}
class $I extends A {
  static get pluginName() {
    return "IndentUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.locale, e = n.t, i = t.uiLanguageDirection == "ltr" ? Fm : jm, r = t.uiLanguageDirection == "ltr" ? jm : Fm;
    this._defineButton("indent", e("Increase indent"), i), this._defineButton("outdent", e("Decrease indent"), r);
  }
  _defineButton(n, t, e) {
    const i = this.editor;
    i.ui.componentFactory.add(n, () => {
      const r = this._createButton(V, n, t, e);
      return r.set({ tooltip: !0 }), r;
    }), i.ui.componentFactory.add("menuBar:" + n, () => this._createButton(Et, n, t, e));
  }
  _createButton(n, t, e, i) {
    const r = this.editor, s = r.commands.get(t), a = new n(r.locale);
    return a.set({ label: e, icon: i }), a.bind("isEnabled").to(s, "isEnabled"), this.listenTo(a, "execute", () => {
      r.execute(t), r.editing.view.focus();
    }), a;
  }
}
class qI extends A {
  static get pluginName() {
    return "Indent";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [UI, $I];
  }
}
class Ws extends q {
  constructor(t, e) {
    super(t);
    m(this, "_indentBehavior");
    this._indentBehavior = e;
  }
  refresh() {
    const t = yt(this.editor.model.document.selection.getSelectedBlocks());
    t && this._isIndentationChangeAllowed(t) ? this.isEnabled = this._indentBehavior.checkEnabled(t.getAttribute("blockIndent")) : this.isEnabled = !1;
  }
  execute() {
    const t = this.editor.model, e = this._getBlocksToChange();
    t.change((i) => {
      for (const r of e) {
        const s = r.getAttribute("blockIndent"), a = this._indentBehavior.getNextIndent(s);
        a ? i.setAttribute("blockIndent", a, r) : i.removeAttribute("blockIndent", r);
      }
    });
  }
  _getBlocksToChange() {
    const t = this.editor.model.document.selection;
    return Array.from(t.getSelectedBlocks()).filter((e) => this._isIndentationChangeAllowed(e));
  }
  _isIndentationChangeAllowed(t) {
    const e = this.editor;
    return e.model.schema.checkAttribute(t, "blockIndent") ? !e.plugins.has("ListUtils") || !this._indentBehavior.isForward ? !0 : !e.plugins.get("ListUtils").isListItemBlock(t) : !1;
  }
}
class Cf {
  constructor(n) {
    m(this, "isForward");
    m(this, "offset");
    m(this, "unit");
    this.isForward = n.direction === "forward", this.offset = n.offset, this.unit = n.unit;
  }
  checkEnabled(n) {
    const t = parseFloat(n || "0");
    return this.isForward || t > 0;
  }
  getNextIndent(n) {
    const t = parseFloat(n || "0");
    if (!(!n || n.endsWith(this.unit))) return this.isForward ? this.offset + this.unit : void 0;
    const e = t + (this.isForward ? this.offset : -this.offset);
    return e > 0 ? e + this.unit : void 0;
  }
}
class Af {
  constructor(n) {
    m(this, "isForward");
    m(this, "classes");
    this.isForward = n.direction === "forward", this.classes = n.classes;
  }
  checkEnabled(n) {
    const t = this.classes.indexOf(n);
    return this.isForward ? t < this.classes.length - 1 : t >= 0;
  }
  getNextIndent(n) {
    const t = this.classes.indexOf(n), e = this.isForward ? 1 : -1;
    return this.classes[t + e];
  }
}
const WI = ["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"];
class GI extends A {
  constructor(n) {
    super(n), n.config.define("indentBlock", { offset: 40, unit: "px" });
  }
  static get pluginName() {
    return "IndentBlock";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.config.get("indentBlock");
    t.classes && t.classes.length ? (this._setupConversionUsingClasses(t.classes), n.commands.add("indentBlock", new Ws(n, new Af({ direction: "forward", classes: t.classes }))), n.commands.add("outdentBlock", new Ws(n, new Af({ direction: "backward", classes: t.classes })))) : (n.data.addStyleProcessorRules(jx), this._setupConversionUsingOffset(), n.commands.add("indentBlock", new Ws(n, new Cf({ direction: "forward", offset: t.offset, unit: t.unit }))), n.commands.add("outdentBlock", new Ws(n, new Cf({ direction: "backward", offset: t.offset, unit: t.unit }))));
  }
  afterInit() {
    const n = this.editor, t = n.model.schema, e = n.commands.get("indent"), i = n.commands.get("outdent"), r = n.config.get("heading.options");
    (r && r.map((s) => s.model) || WI).forEach((s) => {
      t.isRegistered(s) && t.extend(s, { allowAttributes: "blockIndent" });
    }), t.setAttributeProperties("blockIndent", { isFormatting: !0 }), e.registerChildCommand(n.commands.get("indentBlock")), i.registerChildCommand(n.commands.get("outdentBlock"));
  }
  _setupConversionUsingOffset() {
    const n = this.editor.conversion, t = this.editor.locale.contentLanguageDirection === "rtl" ? "margin-right" : "margin-left";
    n.for("upcast").attributeToAttribute({ view: { styles: { [t]: /[\s\S]+/ } }, model: { key: "blockIndent", value: (e) => {
      if (!e.is("element", "li")) return e.getStyle(t);
    } } }), n.for("downcast").attributeToAttribute({ model: "blockIndent", view: (e) => ({ key: "style", value: { [t]: e } }) });
  }
  _setupConversionUsingClasses(n) {
    const t = { model: { key: "blockIndent", values: [] }, view: {} };
    for (const e of n) t.model.values.push(e), t.view[e] = { key: "class", value: [e] };
    this.editor.conversion.attributeToAttribute(t);
  }
}
class KI {
  constructor() {
    m(this, "_definitions", /* @__PURE__ */ new Set());
  }
  get length() {
    return this._definitions.size;
  }
  add(n) {
    Array.isArray(n) ? n.forEach((t) => this._definitions.add(t)) : this._definitions.add(n);
  }
  getDispatcher() {
    return (n) => {
      n.on("attribute:linkHref", (t, e, i) => {
        if (!i.consumable.test(e.item, "attribute:linkHref") || !e.item.is("selection") && !i.schema.isInline(e.item)) return;
        const r = i.writer, s = r.document.selection;
        for (const a of this._definitions) {
          const l = r.createAttributeElement("a", a.attributes, { priority: 5 });
          a.classes && r.addClass(a.classes, l);
          for (const c in a.styles) r.setStyle(c, a.styles[c], l);
          r.setCustomProperty("link", !0, l), a.callback(e.attributeNewValue) ? e.item.is("selection") ? r.wrap(s.getFirstRange(), l) : r.wrap(i.mapper.toViewRange(e.range), l) : r.unwrap(i.mapper.toViewRange(e.range), l);
        }
      }, { priority: "high" });
    };
  }
  getDispatcherForLinkedImage() {
    return (n) => {
      n.on("attribute:linkHref:imageBlock", (t, e, { writer: i, mapper: r }) => {
        const s = r.toViewElement(e.item), a = Array.from(s.getChildren()).find((l) => l.is("element", "a"));
        if (a) for (const l of this._definitions) {
          const c = wn(l.attributes);
          if (l.callback(e.attributeNewValue)) {
            for (const [d, u] of c) d === "class" ? i.addClass(u, a) : i.setAttribute(d, u, a);
            l.classes && i.addClass(l.classes, a);
            for (const d in l.styles) i.setStyle(d, l.styles[d], a);
          } else {
            for (const [d, u] of c) d === "class" ? i.removeClass(u, a) : i.removeAttribute(d, a);
            l.classes && i.removeClass(l.classes, a);
            for (const d in l.styles) i.removeStyle(d, a);
          }
        }
      });
    };
  }
}
const YI = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, ZI = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i, QI = /^((\w+:(\/{2,})?)|(\W))/i, JI = ["https?", "ftps?", "mailto"], Pr = "Ctrl+K";
function xf(o, { writer: n }) {
  const t = n.createAttributeElement("a", { href: o }, { priority: 5 });
  return n.setCustomProperty("link", !0, t), t;
}
function O_(o, n = JI) {
  const t = String(o), e = n.join("|");
  return function(i, r) {
    return !!i.replace(YI, "").match(r);
  }(t, new RegExp(`${"^(?:(?:<protocols>):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))".replace("<protocols>", e)}`, "i")) ? t : "#";
}
function Cd(o, n) {
  return !!o && n.checkAttribute(o.name, "linkHref");
}
function Vu(o, n) {
  const t = (e = o, ZI.test(e) ? "mailto:" : n);
  var e;
  const i = !!t && !R_(o);
  return o && i ? t + o : o;
}
function R_(o) {
  return QI.test(o);
}
function Ad(o) {
  let n = "";
  for (const t of o.getItems()) {
    if (!t.is("$text") && !t.is("$textProxy")) return;
    n += t.data;
  }
  return n;
}
class XI extends q {
  constructor() {
    super(...arguments);
    m(this, "manualDecorators", new ne());
    m(this, "automaticDecorators", new KI());
  }
  restoreManualDecoratorStates() {
    for (const t of this.manualDecorators) t.value = this._getDecoratorStateFromModel(t.id);
  }
  refresh() {
    const t = this.editor.model, e = t.document.selection, i = e.getSelectedElement() || yt(e.getSelectedBlocks());
    Cd(i, t.schema) ? (this.value = i.getAttribute("linkHref"), this.isEnabled = t.schema.checkAttribute(i, "linkHref")) : (this.value = e.getAttribute("linkHref"), this.isEnabled = t.schema.checkAttributeInSelection(e, "linkHref"));
    for (const r of this.manualDecorators) r.value = this._getDecoratorStateFromModel(r.id);
  }
  execute(t, e = {}, i) {
    const r = this.editor.model, s = r.document.selection, a = [], l = [];
    for (const c in e) e[c] ? a.push(c) : l.push(c);
    r.change((c) => {
      const d = (g) => {
        c.setAttribute("linkHref", t, g), a.forEach((f) => c.setAttribute(f, !0, g)), l.forEach((f) => c.removeAttribute(f, g));
      }, u = (g, f) => {
        const p = Ad(g);
        if (!p) return g;
        let b = i;
        if (b || (b = f && f == p ? t : p), b != p) {
          const k = function(_, y) {
            const C = Go(_, y), x = { equal: 0, insert: 0, delete: 0 }, I = [];
            let P = "", Y = "";
            for (const it of [...C, null]) it == "insert" ? Y += y[x.equal + x.insert] : it == "delete" ? P += _[x.equal + x.delete] : (P.length || Y.length) && (I.push({ offset: x.equal, actual: P, expected: Y }), P = "", Y = ""), it && x[it]++;
            return I;
          }(p, b);
          let w = 0;
          for (const { offset: _, actual: y, expected: C } of k) {
            const x = _ + w, I = c.createRange(g.start.getShiftedBy(x), g.start.getShiftedBy(x + y.length)), P = tM(I, g).getAttributes(), Y = Array.from(P).filter(([te]) => r.schema.getAttributeProperties(te).isFormatting), it = c.createText(C, Y);
            d(it), r.insertContent(it, I), w += C.length;
          }
          return c.createRange(g.start, g.start.getShiftedBy(b.length));
        }
      }, h = (g) => {
        const { plugins: f } = this.editor;
        if (c.setSelection(g.end), f.has("TwoStepCaretMovement")) f.get("TwoStepCaretMovement")._handleForwardMovement();
        else for (const p of ["linkHref", ...a, ...l]) c.removeSelectionAttribute(p);
      };
      if (s.isCollapsed) {
        const g = s.getFirstPosition();
        if (s.hasAttribute("linkHref")) {
          const f = s.getAttribute("linkHref"), p = fl(g, "linkHref", f, r), b = u(p, f);
          d(b || p), b && h(b);
        } else if (t !== "") {
          const f = wn(s.getAttributes());
          f.set("linkHref", t), a.forEach((p) => {
            f.set(p, !0);
          }), h(r.insertContent(c.createText(i || t, f), g));
        }
      } else {
        const g = Array.from(s.getRanges()), f = r.schema.getValidRanges(g, "linkHref"), p = [];
        for (const w of s.getSelectedBlocks()) r.schema.checkAttribute(w, "linkHref") && p.push(c.createRangeOn(w));
        const b = p.slice();
        for (const w of f) this._isRangeToUpdate(w, p) && b.push(w);
        const k = g.map((w) => ({ start: Gt.fromPosition(w.start, "toPrevious"), end: Gt.fromPosition(w.end, "toNext") }));
        for (let w of b)
          w = u(w, (w.start.textNode || w.start.nodeAfter).getAttribute("linkHref")) || w, d(w);
        c.setSelection(k.map((w) => {
          const _ = w.start.toPosition(), y = w.end.toPosition();
          return w.start.detach(), w.end.detach(), r.createRange(_, y);
        }));
      }
    });
  }
  _getDecoratorStateFromModel(t) {
    const e = this.editor.model, i = e.document.selection, r = i.getSelectedElement();
    return Cd(r, e.schema) ? r.getAttribute(t) : i.getAttribute(t);
  }
  _isRangeToUpdate(t, e) {
    for (const i of e) if (i.containsRange(t)) return !1;
    return !0;
  }
}
function tM(o, n) {
  if (!o.isCollapsed) return yt(o.getItems());
  const t = o.start;
  return t.textNode ? t.textNode : !t.nodeBefore || t.isEqual(n.start) ? t.nodeAfter : t.nodeBefore;
}
class eM extends q {
  refresh() {
    const n = this.editor.model, t = n.document.selection, e = t.getSelectedElement();
    Cd(e, n.schema) ? this.isEnabled = n.schema.checkAttribute(e, "linkHref") : this.isEnabled = n.schema.checkAttributeInSelection(t, "linkHref");
  }
  execute() {
    const n = this.editor, t = this.editor.model, e = t.document.selection, i = n.commands.get("link");
    t.change((r) => {
      const s = e.isCollapsed ? [fl(e.getFirstPosition(), "linkHref", e.getAttribute("linkHref"), t)] : t.schema.getValidRanges(e.getRanges(), "linkHref");
      for (const a of s) if (r.removeAttribute("linkHref", a), i) for (const l of i.manualDecorators) r.removeAttribute(l.id, a);
    });
  }
}
class nM extends _t() {
  constructor({ id: t, label: e, attributes: i, classes: r, styles: s, defaultValue: a }) {
    super();
    m(this, "id");
    m(this, "defaultValue");
    m(this, "label");
    m(this, "attributes");
    m(this, "classes");
    m(this, "styles");
    this.id = t, this.set("value", void 0), this.defaultValue = a, this.label = e, this.attributes = i, this.classes = r, this.styles = s;
  }
  _createPattern() {
    return { attributes: this.attributes, classes: this.classes, styles: this.styles };
  }
}
const Ef = "automatic", iM = /^(https?:)?\/\//;
class nr extends A {
  constructor(t) {
    super(t);
    m(this, "_linkOpeners", []);
    t.config.define("link", { allowCreatingEmptyLinks: !1, addTargetToExternalLinks: !1, toolbar: ["linkPreview", "|", "editLink", "linkProperties", "unlink"] });
  }
  static get pluginName() {
    return "LinkEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [Da, Xw, De];
  }
  init() {
    const t = this.editor, e = this.editor.config.get("link.allowedProtocols");
    t.model.schema.extend("$text", { allowAttributes: "linkHref" }), t.conversion.for("dataDowncast").attributeToElement({ model: "linkHref", view: xf }), t.conversion.for("editingDowncast").attributeToElement({ model: "linkHref", view: (r, s) => xf(O_(r, e), s) }), t.conversion.for("upcast").elementToAttribute({ view: { name: "a", attributes: { href: !0 } }, model: { key: "linkHref", value: (r) => r.getAttribute("href") } }), t.commands.add("link", new XI(t)), t.commands.add("unlink", new eM(t));
    const i = function(r, s) {
      const a = { "Open in a new tab": r("Open in a new tab"), Downloadable: r("Downloadable") };
      return s.forEach((l) => ("label" in l && a[l.label] && (l.label = a[l.label]), l)), s;
    }(t.t, function(r) {
      const s = [];
      if (r) for (const [l, c] of Object.entries(r)) {
        const d = Object.assign({}, c, { id: `link${a = l, function(u) {
          return u.substring(0, 1).toUpperCase() + u.substring(1);
        }(iu(a))}` });
        s.push(d);
      }
      var a;
      return s;
    }(t.config.get("link.decorators")));
    this._enableAutomaticDecorators(i.filter((r) => r.mode === Ef)), this._enableManualDecorators(i.filter((r) => r.mode === "manual")), t.plugins.get(Da).registerAttribute("linkHref"), n_(t, "linkHref", "a", "ck-link_selected"), this._enableLinkOpen(), this._enableSelectionAttributesFixer(), this._enableClipboardIntegration();
  }
  _registerLinkOpener(t) {
    this._linkOpeners.push(t);
  }
  _enableAutomaticDecorators(t) {
    const e = this.editor, i = e.commands.get("link").automaticDecorators;
    e.config.get("link.addTargetToExternalLinks") && i.add({ id: "linkIsExternal", mode: Ef, callback: (r) => !!r && iM.test(r), attributes: { target: "_blank", rel: "noopener noreferrer" } }), i.add(t), i.length && e.conversion.for("downcast").add(i.getDispatcher());
  }
  _enableManualDecorators(t) {
    if (!t.length) return;
    const e = this.editor, i = e.commands.get("link").manualDecorators;
    t.forEach((r) => {
      e.model.schema.extend("$text", { allowAttributes: r.id });
      const s = new nM(r);
      i.add(s), e.conversion.for("downcast").attributeToElement({ model: s.id, view: (a, { writer: l, schema: c }, { item: d }) => {
        if ((d.is("selection") || c.isInline(d)) && a) {
          const u = l.createAttributeElement("a", s.attributes, { priority: 5 });
          s.classes && l.addClass(s.classes, u);
          for (const h in s.styles) l.setStyle(h, s.styles[h], u);
          return l.setCustomProperty("link", !0, u), u;
        }
      } }), e.conversion.for("upcast").elementToAttribute({ view: { name: "a", ...s._createPattern() }, model: { key: s.id } });
    });
  }
  _enableLinkOpen() {
    const t = this.editor, e = t.editing.view.document, i = (r) => {
      this._linkOpeners.some((s) => s(r)) || function(s) {
        window.open(s, "_blank", "noopener");
      }(r);
    };
    this.listenTo(e, "click", (r, s) => {
      if (!(H.isMac ? s.domEvent.metaKey : s.domEvent.ctrlKey)) return;
      let a = s.domTarget;
      if (a.tagName.toLowerCase() != "a" && (a = a.closest("a")), !a) return;
      const l = a.getAttribute("href");
      l && (r.stop(), s.preventDefault(), i(l));
    }, { context: "$capture" }), this.listenTo(e, "keydown", (r, s) => {
      const a = t.commands.get("link").value;
      a && s.keyCode === nt.enter && s.altKey && (r.stop(), i(a));
    });
  }
  _enableSelectionAttributesFixer() {
    const t = this.editor.model, e = t.document.selection;
    this.listenTo(e, "change:attribute", (i, { attributeKeys: r }) => {
      r.includes("linkHref") && !e.hasAttribute("linkHref") && t.change((s) => {
        var a;
        (function(l, c) {
          l.removeSelectionAttribute("linkHref");
          for (const d of c) l.removeSelectionAttribute(d);
        })(s, (a = t.schema, a.getDefinition("$text").allowAttributes.filter((l) => l.startsWith("link"))));
      });
    });
  }
  _enableClipboardIntegration() {
    const t = this.editor, e = t.model, i = this.editor.config.get("link.defaultProtocol");
    i && this.listenTo(t.plugins.get("ClipboardPipeline"), "contentInsertion", (r, s) => {
      e.change((a) => {
        const l = a.createRangeIn(s.content);
        for (const c of l.getItems()) if (c.hasAttribute("linkHref")) {
          const d = Vu(c.getAttribute("linkHref"), i);
          a.setAttribute("linkHref", d, c);
        }
      });
    });
  }
}
class oM extends V {
  constructor(n) {
    super(n);
    const t = this.bindTemplate;
    this.set({ href: void 0, withText: !0 }), this.extendTemplate({ attributes: { class: ["ck-link-toolbar__preview"], href: t.to("href"), target: "_blank", rel: "noopener noreferrer" }, on: { click: t.to((e) => {
      if (this.href) {
        const i = () => e.preventDefault();
        this.fire("navigate", this.href, i);
      }
    }) } }), this.template.tag = "a";
  }
}
class rM extends L {
  constructor(t, e) {
    super(t);
    m(this, "focusTracker", new gt());
    m(this, "keystrokes", new Mt());
    m(this, "backButtonView");
    m(this, "saveButtonView");
    m(this, "displayedTextInputView");
    m(this, "urlInputView");
    m(this, "children");
    m(this, "providersListChildren");
    m(this, "_validators");
    m(this, "_focusables", new Te());
    m(this, "_focusCycler");
    this._validators = e, this.backButtonView = this._createBackButton(), this.saveButtonView = this._createSaveButton(), this.displayedTextInputView = this._createDisplayedTextInput(), this.urlInputView = this._createUrlInput(), this.providersListChildren = this.createCollection(), this.children = this.createCollection([this._createHeaderView()]), this._createFormChildren(), this.listenTo(this.providersListChildren, "add", () => {
      this.stopListening(this.providersListChildren, "add"), this.children.add(this._createProvidersListView());
    }), this._focusCycler = new le({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-form", "ck-link-form", "ck-responsive-form"], tabindex: "-1" }, children: this.children });
  }
  render() {
    super.render(), ar({ view: this }), [this.urlInputView, this.saveButtonView, ...this.providersListChildren, this.backButtonView, this.displayedTextInputView].forEach((t) => {
      this._focusables.add(t), this.focusTracker.add(t.element);
    }), this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  focus() {
    this._focusCycler.focusFirst();
  }
  isValid() {
    this.resetFormStatus();
    for (const t of this._validators) {
      const e = t(this);
      if (e) return this.urlInputView.errorText = e, !1;
    }
    return !0;
  }
  resetFormStatus() {
    this.urlInputView.errorText = null;
  }
  _createBackButton() {
    const t = this.locale.t, e = new V(this.locale);
    return e.set({ class: "ck-button-back", label: t("Back"), icon: co, tooltip: !0 }), e.delegate("execute").to(this, "cancel"), e;
  }
  _createSaveButton() {
    const t = this.locale.t, e = new V(this.locale);
    return e.set({ label: t("Insert"), tooltip: !1, withText: !0, type: "submit", class: "ck-button-action ck-button-bold" }), e;
  }
  _createHeaderView() {
    const t = this.locale.t, e = new uo(this.locale, { label: t("Link") });
    return e.children.add(this.backButtonView, 0), e;
  }
  _createProvidersListView() {
    const t = new ho(this.locale);
    return t.extendTemplate({ attributes: { class: ["ck-link-form__providers-list"] } }), t.items.bindTo(this.providersListChildren).using((e) => {
      const i = new dn(this.locale);
      return i.children.add(e), i;
    }), t;
  }
  _createDisplayedTextInput() {
    const t = this.locale.t, e = new Nn(this.locale, Mi);
    return e.label = t("Displayed text"), e.class = "ck-labeled-field-view_full-width", e;
  }
  _createUrlInput() {
    const t = this.locale.t, e = new Nn(this.locale, Mi);
    return e.fieldView.inputMode = "url", e.label = t("Link URL"), e.class = "ck-labeled-field-view_full-width", e;
  }
  _createFormChildren() {
    this.children.add(new Ma(this.locale, { children: [this.displayedTextInputView], class: ["ck-form__row_large-top-padding"] })), this.children.add(new Ma(this.locale, { children: [this.urlInputView, this.saveButtonView], class: ["ck-form__row_with-submit", "ck-form__row_large-top-padding", "ck-form__row_large-bottom-padding"] }));
  }
  get url() {
    const { element: t } = this.urlInputView.fieldView;
    return t ? t.value.trim() : null;
  }
}
class sM extends L {
  constructor(t) {
    super(t);
    m(this, "focusTracker", new gt());
    m(this, "keystrokes", new Mt());
    m(this, "backButtonView");
    m(this, "listView");
    m(this, "listChildren");
    m(this, "emptyListInformation");
    m(this, "children");
    m(this, "_focusables", new Te());
    m(this, "_focusCycler");
    this.listChildren = this.createCollection(), this.backButtonView = this._createBackButton(), this.listView = this._createListView(), this.emptyListInformation = this._createEmptyLinksListItemView(), this.children = this.createCollection([this._createHeaderView(), this.emptyListInformation]), this.set("title", ""), this.set("emptyListPlaceholder", ""), this.set("hasItems", !1), this.listenTo(this.listChildren, "change", () => {
      this.hasItems = this.listChildren.length > 0;
    }), this.on("change:hasItems", (e, i, r) => {
      r ? (this.children.remove(this.emptyListInformation), this.children.add(this.listView)) : (this.children.remove(this.listView), this.children.add(this.emptyListInformation));
    }), this.keystrokes.set("Esc", (e, i) => {
      this.fire("cancel"), i();
    }), this._focusCycler = new le({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-link-providers"], tabindex: "-1" }, children: this.children });
  }
  render() {
    super.render(), [this.listView, this.backButtonView].forEach((t) => {
      this._focusables.add(t), this.focusTracker.add(t.element);
    }), this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  focus() {
    this._focusCycler.focusFirst();
  }
  _createListView() {
    const t = new ho(this.locale);
    return t.extendTemplate({ attributes: { class: ["ck-link-providers__list"] } }), t.items.bindTo(this.listChildren).using((e) => {
      const i = new dn(this.locale);
      return i.children.add(e), i;
    }), t;
  }
  _createBackButton() {
    const t = this.locale.t, e = new V(this.locale);
    return e.set({ class: "ck-button-back", label: t("Back"), icon: co, tooltip: !0 }), e.delegate("execute").to(this, "cancel"), e;
  }
  _createHeaderView() {
    const t = new uo(this.locale);
    return t.bind("label").to(this, "title"), t.children.add(this.backButtonView, 0), t;
  }
  _createEmptyLinksListItemView() {
    const t = new L(this.locale);
    return t.setTemplate({ tag: "p", attributes: { class: ["ck", "ck-link__empty-list-info"] }, children: [{ text: this.bindTemplate.to("emptyListPlaceholder") }] }), t;
  }
}
class aM extends L {
  constructor(t) {
    super(t);
    m(this, "focusTracker", new gt());
    m(this, "keystrokes", new Mt());
    m(this, "backButtonView");
    m(this, "children");
    m(this, "listChildren");
    m(this, "_focusables", new Te());
    m(this, "_focusCycler");
    this.backButtonView = this._createBackButton(), this.listChildren = this.createCollection(), this.children = this.createCollection([this._createHeaderView(), this._createListView()]), this._focusCycler = new le({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-link-properties"], tabindex: "-1" }, children: this.children }), this.keystrokes.set("Esc", (e, i) => {
      this.fire("back"), i();
    });
  }
  render() {
    super.render(), [...this.listChildren, this.backButtonView].forEach((t) => {
      this._focusables.add(t), this.focusTracker.add(t.element);
    }), this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  focus() {
    this._focusCycler.focusFirst();
  }
  _createBackButton() {
    const t = this.locale.t, e = new V(this.locale);
    return e.set({ class: "ck-button-back", label: t("Back"), icon: co, tooltip: !0 }), e.delegate("execute").to(this, "back"), e;
  }
  _createHeaderView() {
    const t = this.locale.t, e = new uo(this.locale, { label: t("Link properties") });
    return e.children.add(this.backButtonView, 0), e;
  }
  _createListView() {
    const t = new ho(this.locale);
    return t.extendTemplate({ attributes: { class: ["ck-link__list"] } }), t.items.bindTo(this.listChildren).using((e) => {
      const i = new dn(this.locale);
      return i.children.add(e), i;
    }), t;
  }
}
class lM extends V {
  constructor(t) {
    super(t);
    m(this, "arrowView");
    this.set({ withText: !0 }), this.arrowView = this._createArrowView(), this.extendTemplate({ attributes: { class: ["ck-link__button"] } });
  }
  render() {
    super.render(), this.children.add(this.arrowView);
  }
  _createArrowView() {
    const t = new cn();
    return t.content = yw, t;
  }
}
const En = "link-ui";
class V_ extends A {
  constructor() {
    super(...arguments);
    m(this, "toolbarView", null);
    m(this, "formView", null);
    m(this, "linkProviderItemsView", null);
    m(this, "propertiesView", null);
    m(this, "_balloon");
    m(this, "_linksProviders", new ne());
  }
  static get requires() {
    return [On, nr];
  }
  static get pluginName() {
    return "LinkUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor, e = this.editor.t;
    this.set("selectedLinkableText", void 0), t.editing.view.addObserver(gx), this._balloon = t.plugins.get(On), this._registerComponents(), this._registerEditingOpeners(), this._enableBalloonActivators(), t.conversion.for("editingDowncast").markerToHighlight({ model: En, view: { classes: ["ck-fake-link-selection"] } }), t.conversion.for("editingDowncast").markerToElement({ model: En, view: (i, { writer: r }) => {
      if (!i.markerRange.isCollapsed) return null;
      const s = r.createUIElement("span");
      return r.addClass(["ck-fake-link-selection", "ck-fake-link-selection_collapsed"], s), s;
    } }), t.accessibility.addKeystrokeInfos({ keystrokes: [{ label: e("Create link"), keystroke: Pr }, { label: e("Move out of a link"), keystroke: [["arrowleft", "arrowleft"], ["arrowright", "arrowright"]] }] });
  }
  destroy() {
    super.destroy(), this.propertiesView && this.propertiesView.destroy(), this.formView && this.formView.destroy(), this.toolbarView && this.toolbarView.destroy(), this.linkProviderItemsView && this.linkProviderItemsView.destroy();
  }
  registerLinksListProvider(t) {
    const e = this._linksProviders.filter((i) => (i.order || 0) <= (t.order || 0)).length;
    this._linksProviders.add(t, e);
  }
  _createViews() {
    const t = this.editor.commands.get("link");
    this.toolbarView = this._createToolbarView(), this.formView = this._createFormView(), t.manualDecorators.length && (this.propertiesView = this._createPropertiesView()), this._enableUserBalloonInteractions();
  }
  _createToolbarView() {
    const t = this.editor, e = new Cs(t.locale), i = t.commands.get("link");
    e.class = "ck-link-toolbar";
    let r = t.config.get("link.toolbar");
    return i.manualDecorators.length || (r = r.filter((s) => s !== "linkProperties")), e.fillFromConfig(r, t.ui.componentFactory), e.keystrokes.set("Esc", (s, a) => {
      this._hideUI(), a();
    }), e.keystrokes.set(Pr, (s, a) => {
      this._addFormView(), a();
    }), t.ui.addToolbar(e, { isContextual: !0, beforeFocus: () => {
      this._getSelectedLinkElement() && !this._isToolbarVisible && this._showUI(!0);
    }, afterBlur: () => {
      this._hideUI(!1);
    } }), e;
  }
  _createFormView() {
    const t = this.editor, e = t.locale.t, i = t.commands.get("link"), r = t.config.get("link.defaultProtocol"), s = new (rs(rM))(t.locale, function(a) {
      const l = a.t, c = a.config.get("link.allowCreatingEmptyLinks");
      return [(d) => {
        if (!c && !d.url.length) return l("Link URL must not be empty.");
      }];
    }(t));
    return s.displayedTextInputView.bind("isEnabled").to(this, "selectedLinkableText", (a) => a !== void 0), s.urlInputView.bind("isEnabled").to(i, "isEnabled"), s.saveButtonView.bind("isEnabled").to(i, "isEnabled"), s.saveButtonView.bind("label").to(i, "value", (a) => e(a ? "Update" : "Insert")), this.listenTo(s, "submit", () => {
      if (s.isValid()) {
        const a = Vu(s.urlInputView.fieldView.element.value, r), l = s.displayedTextInputView.fieldView.element.value;
        t.execute("link", a, this._getDecoratorSwitchesState(), l !== this.selectedLinkableText ? l : void 0), this._closeFormView();
      }
    }), this.listenTo(s.urlInputView, "change:errorText", () => {
      t.ui.update();
    }), this.listenTo(s, "cancel", () => {
      this._closeFormView();
    }), s.keystrokes.set("Esc", (a, l) => {
      this._closeFormView(), l();
    }), s.providersListChildren.bindTo(this._linksProviders).using((a) => this._createLinksListProviderButton(a)), s;
  }
  _createLinkProviderListView(t) {
    return t.getListItems().map(({ href: e, label: i, icon: r }) => {
      const s = new V();
      return s.set({ label: i, icon: r, tooltip: !1, withText: !0 }), s.on("execute", () => {
        this.formView.resetFormStatus(), this.formView.urlInputView.fieldView.value = e, this.editor.editing.view.focus(), this._removeLinksProviderView(), this.formView.focus();
      }), s;
    });
  }
  _createLinkProviderItemsView(t) {
    const e = this.editor, i = e.locale.t, r = new sM(e.locale), { emptyListPlaceholder: s, label: a } = t;
    return r.emptyListPlaceholder = s || i("No links available"), r.title = a, this.listenTo(r, "cancel", () => {
      e.editing.view.focus(), this._removeLinksProviderView(), this.formView.focus();
    }), r;
  }
  _createPropertiesView() {
    const t = this.editor, e = this.editor.commands.get("link"), i = new (rs(aM))(t.locale);
    return this.listenTo(i, "back", () => {
      t.editing.view.focus(), this._removePropertiesView();
    }), i.listChildren.bindTo(e.manualDecorators).using((r) => {
      const s = new ys(t.locale);
      return s.set({ label: r.label, withText: !0 }), s.bind("isOn").toMany([r, e], "value", (a, l) => l === void 0 && a === void 0 ? !!r.defaultValue : !!a), s.on("execute", () => {
        r.set("value", !s.isOn), t.execute("link", e.value, this._getDecoratorSwitchesState());
      }), s;
    }), i;
  }
  _getDecoratorSwitchesState() {
    const t = this.editor.commands.get("link");
    return Array.from(t.manualDecorators).reduce((e, i) => {
      const r = t.value === void 0 && i.value === void 0 ? i.defaultValue : i.value;
      return { ...e, [i.id]: !!r };
    }, {});
  }
  _registerEditingOpeners() {
    this.editor.plugins.get(nr)._registerLinkOpener((t) => {
      const e = this._getLinkProviderLinkByHref(t);
      if (!e) return !1;
      const { item: i, provider: r } = e;
      return !!r.navigate && r.navigate(i);
    });
  }
  _registerComponents() {
    const t = this.editor;
    t.ui.componentFactory.add("link", () => {
      const e = this._createButton(V);
      return e.set({ tooltip: !0 }), e;
    }), t.ui.componentFactory.add("menuBar:link", () => {
      const e = this._createButton(Et);
      return e.set({ role: "menuitemcheckbox" }), e;
    }), t.ui.componentFactory.add("linkPreview", (e) => {
      const i = new oM(e), r = t.config.get("link.allowedProtocols"), s = t.commands.get("link"), a = e.t;
      i.bind("isEnabled").to(s, "value", (c) => !!c), i.bind("href").to(s, "value", (c) => c && O_(c, r));
      const l = (c) => {
        if (!c) return i.label = void 0, i.icon = void 0, void (i.tooltip = a("Open link in new tab"));
        const d = this._getLinkProviderLinkByHref(c);
        if (d) {
          const { label: u, tooltip: h, icon: g } = d.item;
          i.label = u, i.tooltip = h || !1, i.icon = g;
        } else i.label = c, i.icon = void 0, i.tooltip = a("Open link in new tab");
      };
      return l(s.value), this.listenTo(s, "change:value", (c, d, u) => {
        l(u);
      }), this.listenTo(i, "navigate", (c, d, u) => {
        const h = this._getLinkProviderLinkByHref(d);
        if (!h) return;
        const { provider: g, item: f } = h, { navigate: p } = g;
        p && p(f) && (c.stop(), u());
      }), i;
    }), t.ui.componentFactory.add("unlink", (e) => {
      const i = t.commands.get("unlink"), r = new V(e), s = e.t;
      return r.set({ label: s("Unlink"), icon: pE, tooltip: !0 }), r.bind("isEnabled").to(i), this.listenTo(r, "execute", () => {
        t.execute("unlink"), this._hideUI();
      }), r;
    }), t.ui.componentFactory.add("editLink", (e) => {
      const i = t.commands.get("link"), r = new V(e), s = e.t;
      return r.set({ label: s("Edit link"), icon: Y2, tooltip: !0 }), r.bind("isEnabled").to(i), this.listenTo(r, "execute", () => {
        this._addFormView();
      }), r;
    }), t.ui.componentFactory.add("linkProperties", (e) => {
      const i = t.commands.get("link"), r = new V(e), s = e.t;
      return r.set({ label: s("Link properties"), icon: oE, tooltip: !0 }), r.bind("isEnabled").to(i, "isEnabled", i, "value", i, "manualDecorators", (a, l, c) => a && !!l && c.length > 0), this.listenTo(r, "execute", () => {
        this._addPropertiesView();
      }), r;
    });
  }
  _createLinksListProviderButton(t) {
    const e = this.editor.locale, i = new lM(e);
    return i.set({ label: t.label }), this.listenTo(i, "execute", () => {
      this._showLinksProviderView(t);
    }), i;
  }
  _createButton(t) {
    const e = this.editor, i = e.locale, r = e.commands.get("link"), s = new t(e.locale), a = i.t;
    return s.set({ label: a("Link"), icon: vw, keystroke: Pr, isToggleable: !0 }), s.bind("isEnabled").to(r, "isEnabled"), s.bind("isOn").to(r, "value", (l) => !!l), this.listenTo(s, "execute", () => {
      e.editing.view.scrollToTheSelection(), this._showUI(!0), this._getSelectedLinkElement() && this._addFormView();
    }), s;
  }
  _enableBalloonActivators() {
    const t = this.editor, e = t.editing.view.document;
    this.listenTo(e, "click", () => {
      this._getSelectedLinkElement() && this._showUI();
    }), t.keystrokes.set(Pr, (i, r) => {
      r(), t.commands.get("link").isEnabled && (t.editing.view.scrollToTheSelection(), this._showUI(!0));
    });
  }
  _enableUserBalloonInteractions() {
    this.editor.keystrokes.set("Tab", (t, e) => {
      this._isToolbarVisible && !this.toolbarView.focusTracker.isFocused && (this.toolbarView.focus(), e());
    }, { priority: "high" }), this.editor.keystrokes.set("Esc", (t, e) => {
      this._isUIVisible && (this._hideUI(), e());
    }), Ni({ emitter: this.formView, activator: () => this._isUIInPanel, contextElements: () => [this._balloon.view.element], callback: () => {
      this._hideUI(!1);
    } });
  }
  _addToolbarView() {
    this.toolbarView || this._createViews(), this._isToolbarInPanel || this._balloon.add({ view: this.toolbarView, position: this._getBalloonPositionData(), balloonClassName: "ck-toolbar-container" });
  }
  _addFormView() {
    if (this.formView || this._createViews(), this._isFormInPanel) return;
    const t = this.editor.commands.get("link");
    this.formView.disableCssTransitions(), this.formView.resetFormStatus(), this.formView.backButtonView.isVisible = t.isEnabled && !!t.value, this._balloon.add({ view: this.formView, position: this._getBalloonPositionData() }), this.selectedLinkableText = this._getSelectedLinkableText(), this.formView.displayedTextInputView.fieldView.value = this.selectedLinkableText || "", this.formView.urlInputView.fieldView.value = t.value || "", this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.enableCssTransitions();
  }
  _addPropertiesView() {
    this.propertiesView || this._createViews(), this._arePropertiesInPanel || (this.propertiesView.disableCssTransitions(), this._balloon.add({ view: this.propertiesView, position: this._getBalloonPositionData() }), this.propertiesView.enableCssTransitions(), this.propertiesView.focus());
  }
  _showLinksProviderView(t) {
    this.linkProviderItemsView && this._removeLinksProviderView(), this.linkProviderItemsView = this._createLinkProviderItemsView(t), this._addLinkProviderItemsView(t);
  }
  _addLinkProviderItemsView(t) {
    this.linkProviderItemsView.listChildren.clear(), this.linkProviderItemsView.listChildren.addMany(this._createLinkProviderListView(t)), this._balloon.add({ view: this.linkProviderItemsView, position: this._getBalloonPositionData() }), this.linkProviderItemsView.focus();
  }
  _closeFormView() {
    const t = this.editor.commands.get("link");
    this.selectedLinkableText = void 0, t.value !== void 0 ? this._removeFormView() : this._hideUI();
  }
  _removePropertiesView() {
    this._arePropertiesInPanel && this._balloon.remove(this.propertiesView);
  }
  _removeLinksProviderView() {
    this._isLinksListInPanel && this._balloon.remove(this.linkProviderItemsView);
  }
  _removeFormView(t = !0) {
    this._isFormInPanel && (this.formView.saveButtonView.focus(), this.formView.displayedTextInputView.fieldView.reset(), this.formView.urlInputView.fieldView.reset(), this._balloon.remove(this.formView), t && this.editor.editing.view.focus(), this._hideFakeVisualSelection());
  }
  _showUI(t = !1) {
    this.formView || this._createViews(), this._getSelectedLinkElement() ? (this._isToolbarVisible ? this._addFormView() : this._addToolbarView(), t && this._balloon.showStack("main")) : (this._showFakeVisualSelection(), this._addToolbarView(), t && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI();
  }
  _hideUI(t = !0) {
    const e = this.editor;
    this._isUIInPanel && (this.stopListening(e.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), t && e.editing.view.focus(), this._removeLinksProviderView(), this._removePropertiesView(), this._removeFormView(t), this._isToolbarInPanel && this._balloon.remove(this.toolbarView), this._hideFakeVisualSelection());
  }
  _startUpdatingUI() {
    const t = this.editor, e = t.editing.view.document;
    let i = this._getSelectedLinkElement(), r = a();
    const s = () => {
      const l = this._getSelectedLinkElement(), c = a();
      i && !l || !i && c !== r ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), i = l, r = c;
    };
    function a() {
      return e.selection.focus.getAncestors().reverse().find((l) => l.is("element"));
    }
    this.listenTo(t.ui, "update", s), this.listenTo(this._balloon, "change:visibleView", s);
  }
  get _arePropertiesInPanel() {
    return !!this.propertiesView && this._balloon.hasView(this.propertiesView);
  }
  get _isLinksListInPanel() {
    return !!this.linkProviderItemsView && this._balloon.hasView(this.linkProviderItemsView);
  }
  get _isFormInPanel() {
    return !!this.formView && this._balloon.hasView(this.formView);
  }
  get _isToolbarInPanel() {
    return !!this.toolbarView && this._balloon.hasView(this.toolbarView);
  }
  get _isPropertiesVisible() {
    return !!this.propertiesView && this._balloon.visibleView === this.propertiesView;
  }
  get _isFormVisible() {
    return !!this.formView && this._balloon.visibleView == this.formView;
  }
  get _isToolbarVisible() {
    return !!this.toolbarView && this._balloon.visibleView === this.toolbarView;
  }
  get _isUIInPanel() {
    return this._arePropertiesInPanel || this._isLinksListInPanel || this._isFormInPanel || this._isToolbarInPanel;
  }
  get _isUIVisible() {
    return this._isPropertiesVisible || this._isLinksListInPanel || this._isFormVisible || this._isToolbarVisible;
  }
  _getBalloonPositionData() {
    const t = this.editor.editing.view, e = t.document;
    if (this.editor.model.markers.has(En)) {
      const i = this.editor.editing.mapper.markerNameToElements(En);
      if (i) {
        const r = Array.from(i), s = t.createRange(t.createPositionBefore(r[0]), t.createPositionAfter(r[r.length - 1]));
        return { target: t.domConverter.viewRangeToDom(s) };
      }
    }
    return { target: () => {
      const i = this._getSelectedLinkElement();
      return i ? t.domConverter.mapViewToDom(i) : t.domConverter.viewRangeToDom(e.selection.getFirstRange());
    } };
  }
  _getSelectedLinkElement() {
    const t = this.editor.editing.view, e = t.document.selection, i = e.getSelectedElement();
    if (e.isCollapsed || i && Yt(i)) return kc(e.getFirstPosition());
    {
      const r = e.getFirstRange().getTrimmed(), s = kc(r.start), a = kc(r.end);
      return s && s == a && t.createRangeIn(s).getTrimmed().isEqual(r) ? s : null;
    }
  }
  _getSelectedLinkableText() {
    const t = this.editor.model, e = this.editor.editing, i = this._getSelectedLinkElement();
    if (!i) return Ad(t.document.selection.getFirstRange());
    const r = e.view.createRangeOn(i);
    return Ad(e.mapper.toModelRange(r));
  }
  _getLinkProviderLinkByHref(t) {
    if (!t) return null;
    for (const e of this._linksProviders) {
      const i = e.getItem ? e.getItem(t) : e.getListItems().find((r) => r.href === t);
      if (i) return { provider: e, item: i };
    }
    return null;
  }
  _showFakeVisualSelection() {
    const t = this.editor.model;
    t.change((e) => {
      const i = t.document.selection.getFirstRange();
      if (t.markers.has(En)) e.updateMarker(En, { range: i });
      else if (i.start.isAtEnd) {
        const r = i.start.getLastMatchingPosition(({ item: s }) => !t.schema.isContent(s), { boundaries: i });
        e.addMarker(En, { usingOperation: !1, affectsData: !1, range: e.createRange(r, i.end) });
      } else e.addMarker(En, { usingOperation: !1, affectsData: !1, range: i });
    });
  }
  _hideFakeVisualSelection() {
    const t = this.editor.model;
    t.markers.has(En) && t.change((e) => {
      e.removeMarker(En);
    });
  }
}
function kc(o) {
  return o.getAncestors().find((n) => {
    return (t = n).is("attributeElement") && !!t.getCustomProperty("link");
    var t;
  }) || null;
}
const F_ = new RegExp("(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63}))|localhost)(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$", "i");
class j_ extends A {
  static get requires() {
    return [Rn, nr];
  }
  static get pluginName() {
    return "AutoLink";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor.model.document.selection;
    n.on("change:range", () => {
      this.isEnabled = !n.anchor.parent.is("element", "codeBlock");
    }), this._enableTypingHandling();
  }
  afterInit() {
    this._enableEnterHandling(), this._enableShiftEnterHandling(), this._enablePasteLinking();
  }
  _expandLinkRange(n, t) {
    return t.textNode && t.textNode.hasAttribute("linkHref") ? fl(t, "linkHref", t.textNode.getAttribute("linkHref"), n) : null;
  }
  _selectEntireLinks(n, t) {
    const e = this.editor.model, i = e.document.selection, r = i.getFirstPosition(), s = i.getLastPosition();
    let a = t.getJoined(this._expandLinkRange(e, r) || t);
    a && (a = a.getJoined(this._expandLinkRange(e, s) || t)), a && (a.start.isBefore(r) || a.end.isAfter(s)) && n.setSelection(a);
  }
  _enablePasteLinking() {
    const n = this.editor, t = n.model, e = t.document.selection, i = n.plugins.get("ClipboardPipeline"), r = n.commands.get("link");
    i.on("inputTransformation", (s, a) => {
      if (!this.isEnabled || !r.isEnabled || e.isCollapsed || a.method !== "paste" || e.rangeCount > 1) return;
      const l = e.getFirstRange(), c = a.dataTransfer.getData("text/plain");
      if (!c) return;
      const d = c.match(F_);
      d && d[2] === c && (t.change((u) => {
        this._selectEntireLinks(u, l), r.execute(c);
      }), s.stop());
    }, { priority: "high" });
  }
  _enableTypingHandling() {
    const n = this.editor, t = new e_(n.model, (e) => {
      let i = e;
      if (!function(s) {
        return s.length > 4 && s[s.length - 1] === " " && s[s.length - 2] !== " ";
      }(i)) return;
      i = i.slice(0, -1), "!.:,;?".includes(i[i.length - 1]) && (i = i.slice(0, -1));
      const r = Tf(i);
      return r ? { url: r, removedTrailingCharacters: e.length - i.length } : void 0;
    });
    t.on("matched:data", (e, i) => {
      const { batch: r, range: s, url: a, removedTrailingCharacters: l } = i;
      if (!r.isTyping) return;
      const c = s.end.getShiftedBy(-l), d = c.getShiftedBy(-a.length), u = n.model.createRange(d, c);
      this._applyAutoLink(a, u);
    }), t.bind("isEnabled").to(this);
  }
  _enableEnterHandling() {
    const n = this.editor, t = n.model, e = n.commands.get("enter");
    e && e.on("execute", () => {
      const i = t.document.selection.getFirstPosition();
      if (!i.parent.previousSibling) return;
      const r = t.createRangeIn(i.parent.previousSibling);
      this._checkAndApplyAutoLinkOnRange(r);
    });
  }
  _enableShiftEnterHandling() {
    const n = this.editor, t = n.model, e = n.commands.get("shiftEnter");
    e && e.on("execute", () => {
      const i = t.document.selection.getFirstPosition(), r = t.createRange(t.createPositionAt(i.parent, 0), i.getShiftedBy(-1));
      this._checkAndApplyAutoLinkOnRange(r);
    });
  }
  _checkAndApplyAutoLinkOnRange(n) {
    const t = this.editor.model, { text: e, range: i } = t_(n, t), r = Tf(e);
    if (r) {
      const s = t.createRange(i.end.getShiftedBy(-r.length), i.end);
      this._applyAutoLink(r, s);
    }
  }
  _applyAutoLink(n, t) {
    const e = this.editor.model, i = Vu(n, this.editor.config.get("link.defaultProtocol"));
    this.isEnabled && function(r, s) {
      return s.schema.checkAttributeInSelection(s.createSelection(r), "linkHref");
    }(t, e) && R_(i) && !function(r) {
      const s = r.start.nodeAfter;
      return !!s && s.hasAttribute("linkHref");
    }(t) && this._persistAutoLink(i, t);
  }
  _persistAutoLink(n, t) {
    const e = this.editor.model, i = this.editor.plugins.get("Delete");
    e.enqueueChange((r) => {
      r.setAttribute("linkHref", n, t), e.enqueueChange(() => {
        i.requestUndoOnBackspace();
      });
    });
  }
}
function Tf(o) {
  const n = F_.exec(o);
  return n ? n[2] : null;
}
class cM extends A {
  static get requires() {
    return [nr, V_, j_];
  }
  static get pluginName() {
    return "Link";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class dM extends A {
  static get requires() {
    return ["ImageEditing", "ImageUtils", nr];
  }
  static get pluginName() {
    return "LinkImageEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  afterInit() {
    const n = this.editor, t = n.model.schema;
    n.plugins.has("ImageBlockEditing") && t.extend("imageBlock", { allowAttributes: ["linkHref"] }), n.conversion.for("upcast").add(function(e) {
      const i = e.plugins.has("ImageInlineEditing"), r = e.plugins.get("ImageUtils");
      return (s) => {
        s.on("element:a", (a, l, c) => {
          const d = l.viewItem, u = r.findViewImgElement(d);
          if (!u) return;
          const h = u.findAncestor((b) => r.isBlockImageView(b));
          if (i && !h) return;
          const g = { attributes: ["href"] };
          if (!c.consumable.consume(d, g)) return;
          const f = d.getAttribute("href");
          if (!f) return;
          let p = l.modelCursor.parent;
          if (!p.is("element", "imageBlock")) {
            const b = c.convertItem(u, l.modelCursor);
            l.modelRange = b.modelRange, l.modelCursor = b.modelCursor, p = l.modelCursor.nodeBefore;
          }
          p && p.is("element", "imageBlock") && c.writer.setAttribute("linkHref", f, p);
        }, { priority: "high" });
      };
    }(n)), n.conversion.for("downcast").add(function(e) {
      const i = e.plugins.get("ImageUtils");
      return (r) => {
        r.on("attribute:linkHref:imageBlock", (s, a, l) => {
          if (!l.consumable.consume(a.item, s.name)) return;
          const c = l.mapper.toViewElement(a.item), d = l.writer, u = Array.from(c.getChildren()).find((f) => f.is("element", "a")), h = i.findViewImgElement(c), g = h.parent.is("element", "picture") ? h.parent : h;
          if (u) a.attributeNewValue ? d.setAttribute("href", a.attributeNewValue, u) : (d.move(d.createRangeOn(g), d.createPositionAt(c, 0)), d.remove(u));
          else {
            const f = d.createContainerElement("a", { href: a.attributeNewValue });
            d.insert(d.createPositionAt(c, 0), f), d.move(d.createRangeOn(g), d.createPositionAt(f, 0));
          }
        }, { priority: "high" });
      };
    }(n)), this._enableAutomaticDecorators(), this._enableManualDecorators();
  }
  _enableAutomaticDecorators() {
    const n = this.editor, t = n.commands.get("link").automaticDecorators;
    t.length && n.conversion.for("downcast").add(t.getDispatcherForLinkedImage());
  }
  _enableManualDecorators() {
    const n = this.editor, t = n.commands.get("link");
    for (const e of t.manualDecorators) n.plugins.has("ImageBlockEditing") && n.model.schema.extend("imageBlock", { allowAttributes: e.id }), n.plugins.has("ImageInlineEditing") && n.model.schema.extend("imageInline", { allowAttributes: e.id }), n.conversion.for("downcast").add(uM(e)), n.conversion.for("upcast").add(hM(n, e));
  }
}
function uM(o) {
  return (n) => {
    n.on(`attribute:${o.id}:imageBlock`, (t, e, i) => {
      const r = i.mapper.toViewElement(e.item), s = Array.from(r.getChildren()).find((a) => a.is("element", "a"));
      if (s) if (o.value !== void 0) {
        for (const [a, l] of wn(o.attributes)) i.writer.setAttribute(a, l, s);
        o.classes && i.writer.addClass(o.classes, s);
        for (const a in o.styles) i.writer.setStyle(a, o.styles[a], s);
      } else {
        for (const a in o.attributes) i.writer.removeAttribute(a, s);
        o.classes && i.writer.removeClass(o.classes, s);
        for (const a in o.styles) i.writer.removeStyle(a, s);
      }
    });
  };
}
function hM(o, n) {
  const t = o.plugins.has("ImageInlineEditing"), e = o.plugins.get("ImageUtils");
  return (i) => {
    i.on("element:a", (r, s, a) => {
      const l = s.viewItem, c = e.findViewImgElement(l);
      if (!c) return;
      const d = c.findAncestor((g) => e.isBlockImageView(g));
      if (t && !d) return;
      const u = new We(n._createPattern()).match(l);
      if (!u || !a.consumable.consume(l, u.match)) return;
      const h = s.modelCursor.nodeBefore || s.modelCursor.parent;
      a.writer.setAttribute(n.id, !0, h);
    }, { priority: "high" });
  };
}
class mM extends A {
  static get requires() {
    return [nr, V_, "ImageBlockEditing"];
  }
  static get pluginName() {
    return "LinkImageUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.editing.view.document;
    this.listenTo(t, "click", (e, i) => {
      this._isSelectedLinkedImage(n.model.document.selection) && (i.preventDefault(), e.stop());
    }, { priority: "high" }), this._createToolbarLinkImageButton();
  }
  _createToolbarLinkImageButton() {
    const n = this.editor, t = n.t;
    n.ui.componentFactory.add("linkImage", (e) => {
      const i = new V(e), r = n.plugins.get("LinkUI"), s = n.commands.get("link");
      return i.set({ isEnabled: !0, label: t("Link image"), icon: vw, keystroke: Pr, tooltip: !0, isToggleable: !0 }), i.bind("isEnabled").to(s, "isEnabled"), i.bind("isOn").to(s, "value", (a) => !!a), this.listenTo(i, "execute", () => {
        this._isSelectedLinkedImage(n.model.document.selection) ? r._addToolbarView() : r._showUI(!0);
      }), i;
    });
  }
  _isSelectedLinkedImage(n) {
    const t = n.getSelectedElement();
    return this.editor.plugins.get("ImageUtils").isImage(t) && t.hasAttribute("linkHref");
  }
}
class gM extends A {
  static get requires() {
    return [dM, mM];
  }
  static get pluginName() {
    return "LinkImage";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class an {
  constructor(n, t) {
    m(this, "_startElement");
    m(this, "_referenceIndent");
    m(this, "_isForward");
    m(this, "_includeSelf");
    m(this, "_sameAttributes");
    m(this, "_sameIndent");
    m(this, "_lowerIndent");
    m(this, "_higherIndent");
    this._startElement = n, this._referenceIndent = n.getAttribute("listIndent"), this._isForward = t.direction == "forward", this._includeSelf = !!t.includeSelf, this._sameAttributes = Bt(t.sameAttributes || []), this._sameIndent = !!t.sameIndent, this._lowerIndent = !!t.lowerIndent, this._higherIndent = !!t.higherIndent;
  }
  static first(n, t) {
    return yt(new this(n, t)[Symbol.iterator]());
  }
  *[Symbol.iterator]() {
    const n = [];
    for (const { node: t } of new Es(this._getStartNode(), this._isForward ? "forward" : "backward")) {
      const e = t.getAttribute("listIndent");
      if (e < this._referenceIndent) {
        if (!this._lowerIndent) break;
        this._referenceIndent = e;
      } else if (e > this._referenceIndent) {
        if (!this._higherIndent) continue;
        if (!this._isForward) {
          n.push(t);
          continue;
        }
      } else {
        if (!this._sameIndent) {
          if (this._higherIndent) {
            n.length && (yield* n, n.length = 0);
            break;
          }
          continue;
        }
        if (this._sameAttributes.some((i) => t.getAttribute(i) !== this._startElement.getAttribute(i))) break;
      }
      n.length && (yield* n, n.length = 0), yield t;
    }
  }
  _getStartNode() {
    return this._includeSelf ? this._startElement : this._isForward ? this._startElement.nextSibling : this._startElement.previousSibling;
  }
}
class Es {
  constructor(n, t = "forward") {
    m(this, "_node");
    m(this, "_isForward");
    m(this, "_previousNodesByIndent", []);
    m(this, "_previous", null);
    m(this, "_previousNodeIndent", null);
    this._node = n, this._isForward = t === "forward";
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    if (!St(this._node)) return { done: !0, value: void 0 };
    const n = this._node.getAttribute("listIndent");
    let t = null;
    if (this._previous) {
      const i = this._previousNodeIndent;
      n > i ? this._previousNodesByIndent[i] = this._previous : n < i ? (t = this._previousNodesByIndent[n] || null, this._previousNodesByIndent.length = n) : t = this._previous;
    }
    const e = { node: this._node, previous: this._previous, previousNodeInList: t };
    return this._previous = this._node, this._previousNodeIndent = n, this._node = this._isForward ? this._node.nextSibling : this._node.previousSibling, { value: e, done: !1 };
  }
}
class fM {
  constructor(n) {
    m(this, "_listHead");
    this._listHead = n;
  }
  [Symbol.iterator]() {
    return new Es(this._listHead);
  }
}
class Yo {
  static next() {
    return Ee();
  }
}
function St(o) {
  return !!o && o.is("element") && o.hasAttribute("listItemId");
}
function ir(o, n = {}) {
  return [...Di(o, { ...n, direction: "backward" }), ...Di(o, { ...n, direction: "forward" })];
}
function Di(o, n = {}) {
  const t = n.direction == "forward", e = Array.from(new an(o, { ...n, includeSelf: t, sameIndent: !0, sameAttributes: "listItemId" }));
  return t ? e : e.reverse();
}
function H_(o, n) {
  const t = new an(o, { sameIndent: !0, sameAttributes: "listType", ...n }), e = new an(o, { sameIndent: !0, sameAttributes: "listType", includeSelf: !0, direction: "forward", ...n });
  return [...Array.from(t).reverse(), ...e];
}
function ci(o) {
  return !an.first(o, { sameIndent: !0, sameAttributes: "listItemId" });
}
function Sf(o) {
  return !an.first(o, { direction: "forward", sameIndent: !0, sameAttributes: "listItemId" });
}
function ls(o, n = {}) {
  o = Bt(o);
  const t = n.withNested !== !1, e = /* @__PURE__ */ new Set();
  for (const i of o) for (const r of ir(i, { higherIndent: t })) e.add(r);
  return io(e);
}
function wl(o) {
  o = Bt(o);
  const n = /* @__PURE__ */ new Set();
  for (const t of o) for (const e of H_(t)) n.add(e);
  return io(n);
}
function Fu(o, n) {
  const t = Di(o, { direction: "forward" }), e = Yo.next();
  for (const i of t) n.setAttribute("listItemId", e, i);
  return t;
}
function xd(o, n, t) {
  const e = {};
  for (const [r, s] of n.getAttributes()) r.startsWith("list") && (e[r] = s);
  const i = Di(o, { direction: "forward" });
  for (const r of i) t.setAttributes(e, r);
  return i;
}
function Ed(o, n, { expand: t, indentBy: e = 1 } = {}) {
  o = Bt(o);
  const i = t ? ls(o) : o;
  for (const r of i) {
    const s = r.getAttribute("listIndent") + e;
    s < 0 ? _l(r, n) : n.setAttribute("listIndent", s, r);
  }
  return i;
}
function _l(o, n) {
  o = Bt(o);
  for (const t of o) t.is("element", "listItem") && n.rename(t, "paragraph");
  for (const t of o) for (const e of t.getAttributeKeys()) e.startsWith("list") && n.removeAttribute(e, t);
  return o;
}
function cs(o) {
  if (!o.length) return !1;
  const n = o[0].getAttribute("listItemId");
  return !!n && !o.some((t) => t.getAttribute("listItemId") != n);
}
function io(o) {
  return Array.from(o).filter((n) => n.root.rootName !== "$graveyard").sort((n, t) => n.index - t.index);
}
function ds(o) {
  const n = o.document.selection.getSelectedElement();
  return n && o.schema.isObject(n) && o.schema.isBlock(n) ? n : null;
}
function wc(o, n) {
  return n.checkChild(o.parent, "listItem") && n.checkChild(o, "$text") && !n.isObject(o);
}
function ja(o) {
  return o == "numbered" || o == "customNumbered";
}
function pM(o, n, t) {
  return Di(n, { direction: "forward" }).pop().index > o.index ? xd(o, n, t) : [];
}
class If extends q {
  constructor(t, e) {
    super(t);
    m(this, "_direction");
    this._direction = e;
  }
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  execute() {
    const t = this.editor.model, e = Mf(t.document.selection);
    t.change((i) => {
      const r = [];
      cs(e) && !ci(e[0]) ? (this._direction == "forward" && r.push(...Ed(e, i)), r.push(...Fu(e[0], i))) : this._direction == "forward" ? r.push(...Ed(e, i, { expand: !0 })) : r.push(...function(s, a) {
        const l = ls(s = Bt(s)), c = /* @__PURE__ */ new Set(), d = Math.min(...l.map((h) => h.getAttribute("listIndent"))), u = /* @__PURE__ */ new Map();
        for (const h of l) u.set(h, an.first(h, { lowerIndent: !0 }));
        for (const h of l) {
          if (c.has(h)) continue;
          c.add(h);
          const g = h.getAttribute("listIndent") - 1;
          if (g < 0) _l(h, a);
          else {
            if (h.getAttribute("listIndent") == d) {
              const f = pM(h, u.get(h), a);
              for (const p of f) c.add(p);
              if (f.length) continue;
            }
            a.setAttribute("listIndent", g, h);
          }
        }
        return io(c);
      }(e, i));
      for (const s of r) {
        if (!s.hasAttribute("listType")) continue;
        const a = an.first(s, { sameIndent: !0 });
        a && i.setAttribute("listType", a.getAttribute("listType"), s);
      }
      this._fireAfterExecute(r);
    });
  }
  _fireAfterExecute(t) {
    this.fire("afterExecute", io(new Set(t)));
  }
  _checkEnabled() {
    let t = Mf(this.editor.model.document.selection), e = t[0];
    if (!e) return !1;
    if (this._direction == "backward" || cs(t) && !ci(t[0])) return !0;
    t = ls(t), e = t[0];
    const i = an.first(e, { sameIndent: !0 });
    return !!i && i.getAttribute("listType") == e.getAttribute("listType");
  }
}
function Mf(o) {
  const n = Array.from(o.getSelectedBlocks()), t = n.findIndex((e) => !St(e));
  return t != -1 && (n.length = t), n;
}
class Lr extends q {
  constructor(t, e, i = {}) {
    super(t);
    m(this, "type");
    m(this, "_listWalkerOptions");
    this.type = e, this._listWalkerOptions = i.multiLevel ? { higherIndent: !0, lowerIndent: !0, sameAttributes: [] } : void 0;
  }
  refresh() {
    this.value = this._getValue(), this.isEnabled = this._checkEnabled();
  }
  execute(t = {}) {
    const e = this.editor.model, i = e.document, r = ds(e), s = Array.from(i.selection.getSelectedBlocks()).filter((l) => e.schema.checkAttribute(l, "listType") || wc(l, e.schema)), a = t.forceValue !== void 0 ? !t.forceValue : this.value;
    e.change((l) => {
      if (a) {
        const c = s[s.length - 1], d = Di(c, { direction: "forward" }), u = [];
        d.length > 1 && u.push(...Fu(d[1], l)), u.push(..._l(s, l)), u.push(...function(h, g) {
          const f = [];
          let p = Number.POSITIVE_INFINITY;
          for (const { node: b } of new Es(h.nextSibling)) {
            const k = b.getAttribute("listIndent");
            if (k == 0) break;
            k < p && (p = k);
            const w = k - p;
            g.setAttribute("listIndent", w, b), f.push(b);
          }
          return f;
        }(c, l)), this._fireAfterExecute(u);
      } else if ((r || i.selection.isCollapsed) && St(s[0])) {
        const c = H_(r || s[0], this._listWalkerOptions);
        for (const d of c) l.setAttributes({ ...t.additionalAttributes, listType: this.type }, d);
        this._fireAfterExecute(c);
      } else {
        const c = [];
        for (const d of s) if (d.hasAttribute("listType")) for (const u of ls(d, { withNested: !1 })) u.getAttribute("listType") != this.type && (l.setAttributes({ ...t.additionalAttributes, listType: this.type }, u), c.push(u));
        else !d.is("element", "listItem") && wc(d, e.schema) && l.rename(d, "listItem"), l.setAttributes({ ...t.additionalAttributes, listIndent: 0, listItemId: Yo.next(), listType: this.type }, d), c.push(d);
        this._fireAfterExecute(c);
      }
    });
  }
  _fireAfterExecute(t) {
    this.fire("afterExecute", io(new Set(t)));
  }
  _getValue() {
    const t = this.editor.model.document.selection, e = Array.from(t.getSelectedBlocks());
    if (!e.length) return !1;
    for (const i of e) if (i.getAttribute("listType") != this.type) return !1;
    return !0;
  }
  _checkEnabled() {
    const t = this.editor.model, e = t.schema, i = t.document.selection, r = Array.from(i.getSelectedBlocks());
    if (!r.length) return !1;
    if (this.value) return !0;
    for (const s of r) if (e.checkAttribute(s, "listType") || wc(s, e)) return !0;
    return !1;
  }
}
class Df extends q {
  constructor(t, e) {
    super(t);
    m(this, "_direction");
    this._direction = e;
  }
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  execute({ shouldMergeOnBlocksContentLevel: t = !1 } = {}) {
    const e = this.editor.model, i = e.document.selection, r = [];
    e.change((s) => {
      const { firstElement: a, lastElement: l } = this._getMergeSubjectElements(i, t), c = a.getAttribute("listIndent") || 0, d = l.getAttribute("listIndent"), u = l.getAttribute("listItemId");
      if (c != d) {
        const g = (h = l, Array.from(new an(h, { direction: "forward", higherIndent: !0 })));
        r.push(...Ed([l, ...g], s, { indentBy: c - d, expand: c < d }));
      }
      var h;
      if (t) {
        let g = i;
        i.isCollapsed && (g = s.createSelection(s.createRange(s.createPositionAt(a, "end"), s.createPositionAt(l, 0)))), e.deleteContent(g, { doNotResetEntireContent: i.isCollapsed });
        const f = g.getLastPosition().parent, p = f.nextSibling;
        r.push(f), p && p !== l && p.getAttribute("listItemId") == u && r.push(...xd(p, f, s));
      } else r.push(...xd(l, a, s));
      this._fireAfterExecute(r);
    });
  }
  _fireAfterExecute(t) {
    this.fire("afterExecute", io(new Set(t)));
  }
  _checkEnabled() {
    const t = this.editor.model, e = t.document.selection, i = ds(t);
    if (e.isCollapsed || i) {
      const r = i || e.getFirstPosition().parent;
      if (!St(r)) return !1;
      const s = this._direction == "backward" ? r.previousSibling : r.nextSibling;
      if (!s || cs([r, s])) return !1;
    } else {
      const r = e.getLastPosition(), s = e.getFirstPosition();
      if (r.parent === s.parent || !St(r.parent)) return !1;
    }
    return !0;
  }
  _getMergeSubjectElements(t, e) {
    const i = ds(this.editor.model);
    let r, s;
    if (t.isCollapsed || i) {
      const a = i || t.getFirstPosition().parent, l = ci(a);
      this._direction == "backward" ? (s = a, r = l && !e ? an.first(a, { sameIndent: !0, lowerIndent: !0 }) : a.previousSibling) : (r = a, s = a.nextSibling);
    } else r = t.getFirstPosition().parent, s = t.getLastPosition().parent;
    return { firstElement: r, lastElement: s };
  }
}
class Pf extends q {
  constructor(t, e) {
    super(t);
    m(this, "_direction");
    this._direction = e;
  }
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  execute() {
    this.editor.model.change((t) => {
      const e = Fu(this._getStartBlock(), t);
      this._fireAfterExecute(e);
    });
  }
  _fireAfterExecute(t) {
    this.fire("afterExecute", io(new Set(t)));
  }
  _checkEnabled() {
    const t = this.editor.model.document.selection, e = this._getStartBlock();
    return t.isCollapsed && St(e) && !ci(e);
  }
  _getStartBlock() {
    const t = this.editor.model.document.selection.getFirstPosition().parent;
    return this._direction == "before" ? t : t.nextSibling;
  }
}
class bM extends A {
  static get pluginName() {
    return "ListUtils";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  expandListBlocksToCompleteList(n) {
    return wl(n);
  }
  isFirstBlockOfListItem(n) {
    return ci(n);
  }
  isListItemBlock(n) {
    return St(n);
  }
  expandListBlocksToCompleteItems(n, t = {}) {
    return ls(n, t);
  }
  isNumberedListType(n) {
    return ja(n);
  }
}
function kM(o) {
  return o.is("element", "ol") || o.is("element", "ul");
}
function Td(o) {
  return o.is("element", "li");
}
function wM(o, n, t, e = $_(t, n)) {
  return o.createAttributeElement(U_(t), null, { priority: 2 * n / 100 - 100, id: e });
}
function _M(o, n, t) {
  return o.createAttributeElement("li", null, { priority: (2 * n + 1) / 100 - 100, id: t });
}
function U_(o) {
  return o == "numbered" || o == "customNumbered" ? "ol" : "ul";
}
function $_(o, n) {
  return `list-${o}-${n}`;
}
function un(o, n, t) {
  const e = o.nodeBefore;
  if (St(e)) {
    let i = e;
    for (const { node: r } of new Es(i, "backward"))
      if (i = r, t.has(i) || (t.add(i), n.has(e))) return;
    n.add(i);
  } else {
    const i = o.nodeAfter;
    St(i) && n.add(i);
  }
}
function vM() {
  return (o, n, t) => {
    const { writer: e, schema: i } = t;
    if (!n.modelRange) return;
    const r = Array.from(n.modelRange.getItems({ shallow: !0 })).filter((u) => i.checkAttribute(u, "listItemId"));
    if (!r.length) return;
    const s = Yo.next(), a = function(u) {
      let h = 0, g = u.parent;
      for (; g; ) {
        if (Td(g)) h++;
        else {
          const f = g.previousSibling;
          f && Td(f) && h++;
        }
        g = g.parent;
      }
      return h;
    }(n.viewItem);
    let l = n.viewItem.parent && n.viewItem.parent.is("element", "ol") ? "numbered" : "bulleted";
    const c = r[0].getAttribute("listType");
    c && (l = c);
    const d = { listItemId: s, listIndent: a, listType: l };
    for (const u of r) u.hasAttribute("listItemId") || e.setAttributes(d, u);
    r.length > 1 && r[1].getAttribute("listItemId") != d.listItemId && t.keepEmptyElement(r[0]);
  };
}
function Lf(o, n, t, { dataPipeline: e } = {}) {
  const i = /* @__PURE__ */ function(r) {
    return (s, a) => {
      const l = [];
      for (const c of r) s.hasAttribute(c) && l.push(`attribute:${c}`);
      return !!l.every((c) => a.test(s, c) !== !1) && (l.forEach((c) => a.consume(s, c)), !0);
    };
  }(o);
  return (r, s, a) => {
    const { writer: l, mapper: c, consumable: d } = a, u = s.item;
    if (!o.includes(s.attributeKey) || !i(u, d)) return;
    const h = function(f, p, b) {
      const k = b.createRangeOn(f);
      return p.toViewRange(k).getTrimmed().end.nodeBefore;
    }(u, c, t);
    q_(h, l, c), function(f, p) {
      let b = f.parent;
      for (; b.is("attributeElement") && ["ul", "ol", "li"].includes(b.name); ) {
        const k = b.parent;
        p.unwrap(p.createRangeOn(f), b), b = k;
      }
    }(h, l);
    const g = function(f, p, b, k, { dataPipeline: w }) {
      let _ = k.createRangeOn(p);
      if (!ci(f)) return _;
      for (const y of b) {
        if (y.scope != "itemMarker") continue;
        const C = y.createElement(k, f, { dataPipeline: w });
        if (!C || (k.setCustomProperty("listItemMarker", !0, C), y.canInjectMarkerIntoElement && y.canInjectMarkerIntoElement(f) ? k.insert(k.createPositionAt(p, 0), C) : (k.insert(_.start, C), _ = k.createRange(k.createPositionBefore(C), k.createPositionAfter(p))), !y.createWrapperElement || !y.canWrapElement)) continue;
        const x = y.createWrapperElement(k, f, { dataPipeline: w });
        k.setCustomProperty("listItemWrapper", !0, x), y.canWrapElement(f) ? _ = k.wrap(_, x) : (_ = k.wrap(k.createRangeOn(C), x), _ = k.createRange(_.start, k.createPositionAfter(p)));
      }
      return _;
    }(u, h, n, l, { dataPipeline: e });
    (function(f, p, b, k) {
      if (!f.hasAttribute("listIndent")) return;
      const w = f.getAttribute("listIndent");
      let _ = f;
      for (let y = w; y >= 0; y--) {
        const C = _M(k, y, _.getAttribute("listItemId")), x = wM(k, y, _.getAttribute("listType"));
        for (const I of b) I.scope != "list" && I.scope != "item" || !_.hasAttribute(I.attributeName) || I.setAttributeOnDowncast(k, _.getAttribute(I.attributeName), I.scope == "list" ? x : C);
        if (p = k.wrap(p, C), p = k.wrap(p, x), y == 0 || (_ = an.first(_, { lowerIndent: !0 }), !_)) break;
      }
    })(u, g, n, l);
  };
}
function Bf(o, { dataPipeline: n } = {}) {
  return (t, { writer: e }) => {
    if (!W_(t, o)) return null;
    if (!n) return e.createContainerElement("span", { class: "ck-list-bogus-paragraph" });
    const i = e.createContainerElement("p");
    return e.setCustomProperty("dataPipeline:transparentRendering", !0, i), i;
  };
}
function q_(o, n, t) {
  for (; o.parent.is("attributeElement") && o.parent.getCustomProperty("listItemWrapper"); ) n.unwrap(n.createRangeOn(o), o.parent);
  const e = [];
  i(n.createPositionBefore(o).getWalker({ direction: "backward" })), i(n.createRangeIn(o).getWalker());
  for (const r of e) n.remove(r);
  function i(r) {
    for (const { item: s } of r) {
      if (s.is("element") && t.toModelElement(s)) break;
      s.is("element") && s.getCustomProperty("listItemMarker") && e.push(s);
    }
  }
}
function W_(o, n, t = ir(o)) {
  if (!St(o)) return !1;
  for (const e of o.getAttributeKeys()) if (!e.startsWith("selection:") && e != "htmlEmptyBlock" && !n.includes(e)) return !1;
  return t.length < 2;
}
const Gs = ["listType", "listIndent", "listItemId"];
class us extends A {
  constructor(t) {
    super(t);
    m(this, "_downcastStrategies", []);
    t.config.define("list.multiBlock", !0);
  }
  static get pluginName() {
    return "ListEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [pl, Rn, bM, De];
  }
  init() {
    const t = this.editor, e = t.model, i = t.config.get("list.multiBlock");
    if (t.plugins.has("LegacyListEditing")) throw new v("list-feature-conflict", this, { conflictPlugin: "LegacyListEditing" });
    e.schema.register("$listItem", { allowAttributes: Gs }), i ? (e.schema.extend("$container", { allowAttributesOf: "$listItem" }), e.schema.extend("$block", { allowAttributesOf: "$listItem" }), e.schema.extend("$blockObject", { allowAttributesOf: "$listItem" })) : e.schema.register("listItem", { inheritAllFrom: "$block", allowAttributesOf: "$listItem" });
    for (const r of Gs) e.schema.setAttributeProperties(r, { copyOnReplace: !0 });
    t.commands.add("numberedList", new Lr(t, "numbered")), t.commands.add("bulletedList", new Lr(t, "bulleted")), t.commands.add("customNumberedList", new Lr(t, "customNumbered", { multiLevel: !0 })), t.commands.add("customBulletedList", new Lr(t, "customBulleted", { multiLevel: !0 })), t.commands.add("indentList", new If(t, "forward")), t.commands.add("outdentList", new If(t, "backward")), t.commands.add("splitListItemBefore", new Pf(t, "before")), t.commands.add("splitListItemAfter", new Pf(t, "after")), i && (t.commands.add("mergeListItemBackward", new Df(t, "backward")), t.commands.add("mergeListItemForward", new Df(t, "forward"))), this._setupDeleteIntegration(), this._setupEnterIntegration(), this._setupTabIntegration(), this._setupClipboardIntegration(), this._setupAccessibilityIntegration();
  }
  afterInit() {
    const t = this.editor.commands, e = t.get("indent"), i = t.get("outdent");
    e && e.registerChildCommand(t.get("indentList"), { priority: "high" }), i && i.registerChildCommand(t.get("outdentList"), { priority: "lowest" }), this._setupModelPostFixing(), this._setupConversion();
  }
  registerDowncastStrategy(t) {
    this._downcastStrategies.push(t);
  }
  getListAttributeNames() {
    return [...Gs, ...this._downcastStrategies.map((t) => t.attributeName)];
  }
  _setupDeleteIntegration() {
    const t = this.editor, e = t.commands.get("mergeListItemBackward"), i = t.commands.get("mergeListItemForward");
    this.listenTo(t.editing.view.document, "delete", (r, s) => {
      const a = t.model.document.selection;
      ds(t.model) || t.model.change(() => {
        const l = a.getFirstPosition();
        if (a.isCollapsed && s.direction == "backward") {
          if (!l.isAtStart) return;
          const c = l.parent;
          if (!St(c)) return;
          if (an.first(c, { sameAttributes: "listType", sameIndent: !0 }) || c.getAttribute("listIndent") !== 0) {
            if (!e || !e.isEnabled) return;
            e.execute({ shouldMergeOnBlocksContentLevel: Nf(t.model, "backward") });
          } else Sf(c) || t.execute("splitListItemAfter"), t.execute("outdentList");
          s.preventDefault(), r.stop();
        } else {
          if (a.isCollapsed && !a.getLastPosition().isAtEnd || !i || !i.isEnabled) return;
          i.execute({ shouldMergeOnBlocksContentLevel: Nf(t.model, "forward") }), s.preventDefault(), r.stop();
        }
      });
    }, { context: "li" });
  }
  _setupEnterIntegration() {
    const t = this.editor, e = t.model, i = t.commands, r = i.get("enter");
    this.listenTo(t.editing.view.document, "enter", (s, a) => {
      const l = e.document, c = l.selection.getFirstPosition().parent;
      if (l.selection.isCollapsed && St(c) && c.isEmpty && !a.isSoft) {
        const d = ci(c), u = Sf(c);
        d && u ? (t.execute("outdentList"), a.preventDefault(), s.stop()) : d && !u ? (t.execute("splitListItemAfter"), a.preventDefault(), s.stop()) : u && (t.execute("splitListItemBefore"), a.preventDefault(), s.stop());
      }
    }, { context: "li" }), this.listenTo(r, "afterExecute", () => {
      const s = i.get("splitListItemBefore");
      s.refresh(), s.isEnabled && ir(t.model.document.selection.getLastPosition().parent).length === 2 && s.execute();
    });
  }
  _setupTabIntegration() {
    const t = this.editor;
    this.listenTo(t.editing.view.document, "tab", (e, i) => {
      const r = i.shiftKey ? "outdentList" : "indentList";
      this.editor.commands.get(r).isEnabled && (t.execute(r), i.stopPropagation(), i.preventDefault(), e.stop());
    }, { context: "li" });
  }
  _setupConversion() {
    const t = this.editor, e = t.model, i = this.getListAttributeNames(), r = t.config.get("list.multiBlock"), s = r ? "paragraph" : "listItem";
    t.conversion.for("upcast").elementToElement({ view: "li", model: (d, { writer: u }) => u.createElement(s, { listType: "" }) }).elementToElement({ view: "p", model: (d, { writer: u }) => d.parent && d.parent.is("element", "li") ? u.createElement(s, { listType: "" }) : null, converterPriority: "high" }).add((d) => {
      d.on("element:li", vM());
    }), r || t.conversion.for("downcast").elementToElement({ model: "listItem", view: "p" }), t.conversion.for("editingDowncast").elementToElement({ model: s, view: Bf(i), converterPriority: "high" }).add((d) => {
      var u;
      d.on("attribute", Lf(i, this._downcastStrategies, e)), d.on("remove", (u = e.schema, (h, g, f) => {
        const { writer: p, mapper: b } = f, k = h.name.split(":")[1];
        if (!u.checkAttribute(k, "listItemId")) return;
        const w = b.toViewPosition(g.position), _ = g.position.getShiftedBy(g.length), y = b.toViewPosition(_, { isPhantom: !0 }), C = p.createRange(w, y).getTrimmed().end.nodeBefore;
        C && q_(C, p, b);
      }));
    }), t.conversion.for("dataDowncast").elementToElement({ model: s, view: Bf(i, { dataPipeline: !0 }), converterPriority: "high" }).add((d) => {
      d.on("attribute", Lf(i, this._downcastStrategies, e, { dataPipeline: !0 }));
    });
    const a = (l = this._downcastStrategies, c = t.editing.view, (d, u) => {
      if (u.modelPosition.offset > 0) return;
      const h = u.modelPosition.parent;
      if (!St(h) || !l.some((k) => k.scope == "itemMarker" && k.canInjectMarkerIntoElement && k.canInjectMarkerIntoElement(h))) return;
      const g = u.mapper.toViewElement(h), f = c.createRangeIn(g), p = f.getWalker();
      let b = f.start;
      for (const { item: k } of p) {
        if (k.is("element") && u.mapper.toModelElement(k) || k.is("$textProxy")) break;
        k.is("element") && k.getCustomProperty("listItemMarker") && (b = c.createPositionAfter(k), p.skip(({ previousPosition: w }) => !w.isEqual(b)));
      }
      u.viewPosition = b;
    });
    var l, c;
    t.editing.mapper.on("modelToViewPosition", a), t.data.mapper.on("modelToViewPosition", a), this.listenTo(e.document, "change:data", /* @__PURE__ */ function(d, u, h, g) {
      return () => {
        const k = d.document.differ.getChanges(), w = [], _ = /* @__PURE__ */ new Set(), y = /* @__PURE__ */ new Set(), C = /* @__PURE__ */ new Set();
        for (const x of k) if (x.type == "insert" && x.name != "$text") un(x.position, _, C), x.attributes.has("listItemId") ? y.add(x.position.nodeAfter) : un(x.position.getShiftedBy(x.length), _, C);
        else if (x.type == "remove" && x.attributes.has("listItemId")) un(x.position, _, C);
        else if (x.type == "attribute") {
          const I = x.range.start.nodeAfter;
          h.includes(x.attributeKey) ? (un(x.range.start, _, C), x.attributeNewValue === null ? (un(x.range.start.getShiftedBy(1), _, C), p(I) && w.push(I)) : y.add(I)) : St(I) && p(I) && w.push(I);
        }
        for (const x of _.values()) w.push(...f(x, y));
        for (const x of new Set(w)) u.reconvertItem(x);
      };
      function f(k, w) {
        const _ = [], y = /* @__PURE__ */ new Set(), C = [];
        for (const { node: x, previous: I } of new Es(k)) {
          if (y.has(x)) continue;
          const P = x.getAttribute("listIndent");
          I && P < I.getAttribute("listIndent") && (C.length = P + 1), C[P] = Object.fromEntries(Array.from(x.getAttributes()).filter(([it]) => h.includes(it)));
          const Y = Di(x, { direction: "forward" });
          for (const it of Y) y.add(it), (p(it, Y) || b(it, C, w)) && _.push(it);
        }
        return _;
      }
      function p(k, w) {
        const _ = u.mapper.toViewElement(k);
        if (!_) return !1;
        if (g.fire("checkElement", { modelElement: k, viewElement: _ })) return !0;
        if (!k.is("element", "paragraph") && !k.is("element", "listItem")) return !1;
        const y = W_(k, h, w);
        return !(!y || !_.is("element", "p")) || !(y || !_.is("element", "span"));
      }
      function b(k, w, _) {
        if (_.has(k)) return !1;
        const y = u.mapper.toViewElement(k);
        let C = w.length - 1;
        for (let x = y.parent; !x.is("editableElement"); x = x.parent) {
          const I = Td(x), P = kM(x);
          if (!P && !I) continue;
          const Y = "checkAttributes:" + (I ? "item" : "list");
          if (g.fire(Y, { viewElement: x, modelAttributes: w[C] })) break;
          if (P && (C--, C < 0)) return !1;
        }
        return !0;
      }
    }(e, t.editing, i, this), { priority: "high" }), this.on("checkAttributes:item", (d, { viewElement: u, modelAttributes: h }) => {
      u.id != h.listItemId && (d.return = !0, d.stop());
    }), this.on("checkAttributes:list", (d, { viewElement: u, modelAttributes: h }) => {
      u.name == U_(h.listType) && u.id == $_(h.listType, h.listIndent) || (d.return = !0, d.stop());
    });
  }
  _setupModelPostFixing() {
    const t = this.editor.model, e = this.getListAttributeNames();
    t.document.registerPostFixer((i) => function(r, s, a, l) {
      const c = r.document.differ.getChanges(), d = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set(), h = l.editor.config.get("list.multiBlock");
      let g = !1;
      for (const p of c) {
        if (p.type == "insert" && p.name != "$text") {
          const b = p.position.nodeAfter;
          if (!r.schema.checkAttribute(b, "listItemId")) for (const k of Array.from(b.getAttributeKeys())) a.includes(k) && (s.removeAttribute(k, b), g = !0);
          un(p.position, u, d), p.attributes.has("listItemId") || un(p.position.getShiftedBy(p.length), u, d);
          for (const { item: k, previousPosition: w } of r.createRangeIn(b)) St(k) && un(w, u, d);
        } else p.type == "remove" ? un(p.position, u, d) : p.type == "attribute" && a.includes(p.attributeKey) && (un(p.range.start, u, d), p.attributeNewValue === null && un(p.range.start.getShiftedBy(1), u, d));
        if (!h && p.type == "attribute" && Gs.includes(p.attributeKey)) {
          const b = p.range.start.nodeAfter;
          p.attributeNewValue === null && b && b.is("element", "listItem") ? (s.rename(b, "paragraph"), g = !0) : p.attributeOldValue === null && b && b.is("element") && b.name != "listItem" && (s.rename(b, "listItem"), g = !0);
        }
      }
      const f = /* @__PURE__ */ new Set();
      for (const p of u.values()) g = l.fire("postFixer", { listNodes: new fM(p), listHead: p, writer: s, seenIds: f }) || g;
      return g;
    }(t, i, e, this)), this.on("postFixer", (i, { listNodes: r, writer: s }) => {
      i.return = function(a, l) {
        let c = 0, d = -1, u = null, h = !1;
        for (const { node: g } of a) {
          const f = g.getAttribute("listIndent");
          if (f > c) {
            let p;
            u === null ? (u = f - c, p = c) : (u > f && (u = f), p = f - u), p > d + 1 && (p = d + 1), l.setAttribute("listIndent", p, g), h = !0, d = p;
          } else u = null, c = f + 1, d = f;
        }
        return h;
      }(r, s) || i.return;
    }, { priority: "high" }), this.on("postFixer", (i, { listNodes: r, writer: s, seenIds: a }) => {
      i.return = function(l, c, d) {
        const u = /* @__PURE__ */ new Set();
        let h = !1;
        for (const { node: g } of l) {
          if (u.has(g)) continue;
          let f = g.getAttribute("listType"), p = g.getAttribute("listItemId");
          if (c.has(p) && (p = Yo.next()), c.add(p), g.is("element", "listItem")) g.getAttribute("listItemId") != p && (d.setAttribute("listItemId", p, g), h = !0);
          else for (const b of Di(g, { direction: "forward" })) u.add(b), b.getAttribute("listType") != f && (p = Yo.next(), f = b.getAttribute("listType")), b.getAttribute("listItemId") != p && (d.setAttribute("listItemId", p, b), h = !0);
        }
        return h;
      }(r, a, s) || i.return;
    }, { priority: "high" });
  }
  _setupClipboardIntegration() {
    const t = this.editor.model, e = this.editor.plugins.get("ClipboardPipeline");
    this.listenTo(t, "insertContent", /* @__PURE__ */ function(i) {
      return (r, [s, a]) => {
        const l = s.is("documentFragment") ? Array.from(s.getChildren()) : [s];
        if (!l.length) return;
        const c = (a ? i.createSelection(a) : i.document.selection).getFirstPosition();
        let d;
        if (St(c.parent)) d = c.parent;
        else {
          if (!St(c.nodeBefore) || !St(c.nodeAfter)) return;
          d = c.nodeBefore;
        }
        i.change((u) => {
          const h = d.getAttribute("listType"), g = d.getAttribute("listIndent"), f = l[0].getAttribute("listIndent") || 0, p = Math.max(g - f, 0);
          for (const b of l) {
            const k = St(b);
            d.is("element", "listItem") && b.is("element", "paragraph") && u.rename(b, "listItem"), u.setAttributes({ listIndent: (k ? b.getAttribute("listIndent") : 0) + p, listItemId: k ? b.getAttribute("listItemId") : Yo.next(), listType: h }, b);
          }
        });
      };
    }(t), { priority: "high" }), this.listenTo(e, "outputTransformation", (i, r) => {
      t.change((s) => {
        const a = Array.from(r.content.getChildren()), l = a[a.length - 1];
        if (a.length > 1 && l.is("element") && l.isEmpty && a.slice(0, -1).every(St) && s.remove(l), r.method == "copy" || r.method == "cut") {
          const c = Array.from(r.content.getChildren());
          cs(c) && _l(c, s);
        }
      });
    });
  }
  _setupAccessibilityIntegration() {
    const t = this.editor, e = t.t;
    t.accessibility.addKeystrokeInfoGroup({ id: "list", label: e("Keystrokes that can be used in a list"), keystrokes: [{ label: e("Increase list item indent"), keystroke: "Tab" }, { label: e("Decrease list item indent"), keystroke: "Shift+Tab" }] });
  }
}
function Nf(o, n) {
  const t = o.document.selection;
  if (!t.isCollapsed) return !ds(o);
  if (n === "forward") return !0;
  const e = t.getFirstPosition().parent, i = e.previousSibling;
  return !o.schema.isObject(i) && (!!i.isEmpty || cs([e, i]));
}
function Sd(o, n, t, e) {
  o.ui.componentFactory.add(n, () => {
    const i = zf(V, o, n, t, e);
    return i.set({ tooltip: !0, isToggleable: !0 }), i;
  }), o.ui.componentFactory.add(`menuBar:${n}`, () => {
    const i = zf(Et, o, n, t, e);
    return i.set({ role: "menuitemcheckbox", isToggleable: !0 }), i;
  });
}
function zf(o, n, t, e, i) {
  const r = n.commands.get(t), s = new o(n.locale);
  return s.set({ label: e, icon: i }), s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), s.on("execute", () => {
    n.execute(t), n.editing.view.focus();
  }), s;
}
class yM extends A {
  static get pluginName() {
    return "ListUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor.t;
    this.editor.ui.componentFactory.has("numberedList") || Sd(this.editor, "numberedList", n("Numbered List"), xu), this.editor.ui.componentFactory.has("bulletedList") || Sd(this.editor, "bulletedList", n("Bulleted List"), Cu);
  }
}
class CM extends A {
  static get requires() {
    return [us, yM];
  }
  static get pluginName() {
    return "List";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class AM extends q {
  refresh() {
    const n = this._getValue();
    this.value = n, this.isEnabled = n != null;
  }
  execute({ startIndex: n = 1 } = {}) {
    const t = this.editor.model, e = t.document;
    let i = Array.from(e.selection.getSelectedBlocks()).filter((r) => St(r) && ja(r.getAttribute("listType")));
    i = wl(i), t.change((r) => {
      for (const s of i) r.setAttribute("listStart", n >= 0 ? n : 1, s);
    });
  }
  _getValue() {
    const n = yt(this.editor.model.document.selection.getSelectedBlocks());
    return n && St(n) && ja(n.getAttribute("listType")) ? n.getAttribute("listStart") : null;
  }
}
const G_ = {}, K_ = {}, Y_ = {}, Z_ = [{ listStyle: "disc", typeAttribute: "disc", listType: "bulleted" }, { listStyle: "circle", typeAttribute: "circle", listType: "bulleted" }, { listStyle: "square", typeAttribute: "square", listType: "bulleted" }, { listStyle: "decimal", typeAttribute: "1", listType: "numbered" }, { listStyle: "decimal-leading-zero", typeAttribute: null, listType: "numbered" }, { listStyle: "lower-roman", typeAttribute: "i", listType: "numbered" }, { listStyle: "upper-roman", typeAttribute: "I", listType: "numbered" }, { listStyle: "lower-alpha", typeAttribute: "a", listType: "numbered" }, { listStyle: "upper-alpha", typeAttribute: "A", listType: "numbered" }, { listStyle: "lower-latin", typeAttribute: "a", listType: "numbered" }, { listStyle: "upper-latin", typeAttribute: "A", listType: "numbered" }];
for (const { listStyle: o, typeAttribute: n, listType: t } of Z_) G_[o] = t, K_[o] = n, n && (Y_[n] = o);
function Q_() {
  return Z_.map((o) => o.listStyle);
}
function ju(o) {
  return G_[o] || null;
}
function J_(o) {
  return Y_[o] || null;
}
function Id(o) {
  return K_[o] || null;
}
function xM(o) {
  switch (o) {
    case "lower-alpha":
      return "lower-latin";
    case "upper-alpha":
      return "upper-latin";
    default:
      return o;
  }
}
class EM extends q {
  constructor(t, e, i) {
    super(t);
    m(this, "defaultType");
    m(this, "_supportedTypes");
    this.defaultType = e, this._supportedTypes = i;
  }
  refresh() {
    this.value = this._getValue(), this.isEnabled = this._checkEnabled();
  }
  execute(t = {}) {
    const e = this.editor.model, i = e.document;
    e.change((r) => {
      this._tryToConvertItemsToList(t);
      let s = Array.from(i.selection.getSelectedBlocks()).filter((a) => a.hasAttribute("listType"));
      if (s.length) {
        s = wl(s);
        for (const a of s) r.setAttribute("listStyle", t.type || this.defaultType, a);
      }
    });
  }
  isStyleTypeSupported(t) {
    return !this._supportedTypes || this._supportedTypes.includes(t);
  }
  _getValue() {
    const t = yt(this.editor.model.document.selection.getSelectedBlocks());
    return St(t) ? t.getAttribute("listStyle") : null;
  }
  _checkEnabled() {
    const t = this.editor, e = t.commands.get("numberedList"), i = t.commands.get("bulletedList");
    return e.isEnabled || i.isEnabled;
  }
  _tryToConvertItemsToList(t) {
    if (!t.type) return;
    const e = ju(t.type);
    if (!e) return;
    const i = this.editor, r = `${e}List`;
    i.commands.get(r).value || i.execute(r);
  }
}
class TM extends q {
  refresh() {
    const n = this._getValue();
    this.value = n, this.isEnabled = n != null;
  }
  execute(n = {}) {
    const t = this.editor.model, e = t.document;
    let i = Array.from(e.selection.getSelectedBlocks()).filter((r) => St(r) && r.getAttribute("listType") == "numbered");
    i = wl(i), t.change((r) => {
      for (const s of i) r.setAttribute("listReversed", !!n.reversed, s);
    });
  }
  _getValue() {
    const n = yt(this.editor.model.document.selection.getSelectedBlocks());
    return St(n) && n.getAttribute("listType") == "numbered" ? n.getAttribute("listReversed") : null;
  }
}
function Of(o) {
  return (n, t, e) => {
    const { writer: i, schema: r, consumable: s } = e;
    if (s.test(t.viewItem, o.viewConsumables) === !1) return;
    t.modelRange || Object.assign(t, e.convertChildren(t.viewItem, t.modelCursor));
    let a = !1;
    for (const l of t.modelRange.getItems({ shallow: !0 })) r.checkAttribute(l, o.attributeName) && o.appliesToListItem(l) && (l.hasAttribute(o.attributeName) || (i.setAttribute(o.attributeName, o.getAttributeOnUpcast(t.viewItem), l), a = !0));
    a && s.consume(t.viewItem, o.viewConsumables);
  };
}
class SM extends A {
  static get pluginName() {
    return "ListPropertiesUtils";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  getAllSupportedStyleTypes() {
    return Q_();
  }
  getListTypeFromListStyleType(n) {
    return ju(n);
  }
  getListStyleTypeFromTypeAttribute(n) {
    return J_(n);
  }
  getTypeAttributeFromListStyleType(n) {
    return Id(n);
  }
}
function X_(o) {
  const { startIndex: n, reversed: t, styles: e } = o;
  return { styles: IM(e), startIndex: n || !1, reversed: t || !1 };
}
function IM(o) {
  const n = { listTypes: ["bulleted", "numbered"], useAttribute: !1 };
  return o === !0 || (o ? Array.isArray(o) || typeof o == "string" ? n.listTypes = Bt(o) : (n.listTypes = o.listTypes ? Bt(o.listTypes) : n.listTypes, n.useAttribute = !!o.useAttribute, o.listStyleTypes && (n.listStyleTypes = o.listStyleTypes)) : n.listTypes = []), n;
}
const Tr = "default";
class MM extends A {
  static get requires() {
    return [us, SM];
  }
  static get pluginName() {
    return "ListPropertiesEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  constructor(n) {
    super(n), n.config.define("list.properties", { styles: !0, startIndex: !1, reversed: !1 });
  }
  init() {
    const n = this.editor, t = n.model, e = n.plugins.get(us), i = function(r) {
      const s = [], a = X_(r);
      if (r.styles) {
        const l = a.styles.useAttribute;
        s.push({ attributeName: "listStyle", defaultValue: Tr, viewConsumables: { styles: "list-style-type" }, addCommand(c) {
          let d = Q_();
          l && (d = d.filter((u) => !!Id(u))), c.commands.add("listStyle", new EM(c, Tr, d));
        }, appliesToListItem: (c) => c.getAttribute("listType") == "numbered" || c.getAttribute("listType") == "bulleted", hasValidAttribute(c) {
          if (!this.appliesToListItem(c)) return !c.hasAttribute("listStyle");
          if (!c.hasAttribute("listStyle")) return !1;
          const d = c.getAttribute("listStyle");
          return d == Tr || ju(d) == c.getAttribute("listType");
        }, setAttributeOnDowncast(c, d, u) {
          if (d && d !== Tr) {
            if (!l) return void c.setStyle("list-style-type", d, u);
            {
              const h = Id(d);
              if (h) return void c.setAttribute("type", h, u);
            }
          }
          c.removeStyle("list-style-type", u), c.removeAttribute("type", u);
        }, getAttributeOnUpcast(c) {
          const d = c.getStyle("list-style-type");
          if (d) return xM(d);
          const u = c.getAttribute("type");
          return u ? J_(u) : Tr;
        } });
      }
      return r.reversed && s.push({ attributeName: "listReversed", defaultValue: !1, viewConsumables: { attributes: "reversed" }, addCommand(l) {
        l.commands.add("listReversed", new TM(l));
      }, appliesToListItem: (l) => l.getAttribute("listType") == "numbered", hasValidAttribute(l) {
        return this.appliesToListItem(l) == l.hasAttribute("listReversed");
      }, setAttributeOnDowncast(l, c, d) {
        c ? l.setAttribute("reversed", "reversed", d) : l.removeAttribute("reversed", d);
      }, getAttributeOnUpcast: (l) => l.hasAttribute("reversed") }), r.startIndex && s.push({ attributeName: "listStart", defaultValue: 1, viewConsumables: { attributes: "start" }, addCommand(l) {
        l.commands.add("listStart", new AM(l));
      }, appliesToListItem: (l) => ja(l.getAttribute("listType")), hasValidAttribute(l) {
        return this.appliesToListItem(l) == l.hasAttribute("listStart");
      }, setAttributeOnDowncast(l, c, d) {
        c == 0 || c > 1 ? l.setAttribute("start", c, d) : l.removeAttribute("start", d);
      }, getAttributeOnUpcast(l) {
        const c = l.getAttribute("start");
        return c >= 0 ? c : 1;
      } }), s;
    }(n.config.get("list.properties"));
    for (const r of i) r.addCommand(n), t.schema.extend("$listItem", { allowAttributes: r.attributeName }), e.registerDowncastStrategy({ scope: "list", attributeName: r.attributeName, setAttributeOnDowncast(s, a, l) {
      r.setAttributeOnDowncast(s, a, l);
    } });
    n.conversion.for("upcast").add((r) => {
      for (const s of i) r.on("element:ol", Of(s)), r.on("element:ul", Of(s));
    }), e.on("checkAttributes:list", (r, { viewElement: s, modelAttributes: a }) => {
      for (const l of i) l.getAttributeOnUpcast(s) != a[l.attributeName] && (r.return = !0, r.stop());
    }), this.listenTo(n.commands.get("indentList"), "afterExecute", (r, s) => {
      t.change((a) => {
        for (const l of s) for (const c of i) c.appliesToListItem(l) && a.setAttribute(c.attributeName, c.defaultValue, l);
      });
    }), e.on("postFixer", (r, { listNodes: s, writer: a }) => {
      for (const { node: l } of s) for (const c of i) c.hasValidAttribute(l) || (c.appliesToListItem(l) ? a.setAttribute(c.attributeName, c.defaultValue, l) : a.removeAttribute(c.attributeName, l), r.return = !0);
    }), e.on("postFixer", (r, { listNodes: s, writer: a }) => {
      for (const { node: l, previousNodeInList: c } of s) if (c && c.getAttribute("listType") == l.getAttribute("listType")) for (const d of i) {
        const { attributeName: u } = d;
        if (!d.appliesToListItem(l)) continue;
        const h = c.getAttribute(u);
        l.getAttribute(u) != h && (a.setAttribute(u, h, l), r.return = !0);
      }
    });
  }
}
class tv extends L {
  constructor(t, { enabledProperties: e, styleButtonViews: i, styleGridAriaLabel: r }) {
    super(t);
    m(this, "children");
    m(this, "stylesView", null);
    m(this, "additionalPropertiesCollapsibleView", null);
    m(this, "startIndexFieldView", null);
    m(this, "reversedSwitchButtonView", null);
    m(this, "focusTracker", new gt());
    m(this, "keystrokes", new Mt());
    m(this, "focusables", new Te());
    m(this, "focusCycler");
    const s = ["ck", "ck-list-properties"];
    this.children = this.createCollection(), this.focusCycler = new le({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), i && i.length ? (this.stylesView = this._createStylesView(i, r), this.children.add(this.stylesView)) : s.push("ck-list-properties_without-styles"), (e.startIndex || e.reversed) && (this._addNumberedListPropertyViews(e), s.push("ck-list-properties_with-numbered-properties")), this.setTemplate({ tag: "div", attributes: { class: s }, children: this.children });
  }
  render() {
    if (super.render(), this.stylesView) {
      this.focusables.add(this.stylesView), this.focusTracker.add(this.stylesView.element), (this.startIndexFieldView || this.reversedSwitchButtonView) && (this.focusables.add(this.children.last.buttonView), this.focusTracker.add(this.children.last.buttonView.element));
      for (const t of this.stylesView.children) this.stylesView.focusTracker.add(t.element);
      vs({ keystrokeHandler: this.stylesView.keystrokes, focusTracker: this.stylesView.focusTracker, gridItems: this.stylesView.children, numberOfColumns: () => N.window.getComputedStyle(this.stylesView.element).getPropertyValue("grid-template-columns").split(" ").length, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection });
    }
    if (this.startIndexFieldView) {
      this.focusables.add(this.startIndexFieldView), this.focusTracker.add(this.startIndexFieldView.element);
      const t = (e) => e.stopPropagation();
      this.keystrokes.set("arrowright", t), this.keystrokes.set("arrowleft", t), this.keystrokes.set("arrowup", t), this.keystrokes.set("arrowdown", t);
    }
    this.reversedSwitchButtonView && (this.focusables.add(this.reversedSwitchButtonView), this.focusTracker.add(this.reversedSwitchButtonView.element)), this.keystrokes.listenTo(this.element);
  }
  focus() {
    this.focusCycler.focusFirst();
  }
  focusLast() {
    this.focusCycler.focusLast();
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  _createStylesView(t, e) {
    const i = new L(this.locale);
    return i.children = i.createCollection(), i.children.addMany(t), i.setTemplate({ tag: "div", attributes: { "aria-label": e, class: ["ck", "ck-list-styles-list"] }, children: i.children }), i.children.delegate("execute").to(this), i.focus = function() {
      for (const r of this.children) if (r instanceof V && r.isOn) return void r.focus();
      this.children.first.focus();
    }, i.focusTracker = new gt(), i.keystrokes = new Mt(), i.render(), i.keystrokes.listenTo(i.element), i;
  }
  _addNumberedListPropertyViews(t) {
    const e = this.locale.t, i = [];
    t.startIndex && (this.startIndexFieldView = this._createStartIndexField(), i.push(this.startIndexFieldView)), t.reversed && (this.reversedSwitchButtonView = this._createReversedSwitchButton(), i.push(this.reversedSwitchButtonView)), this.stylesView ? (this.additionalPropertiesCollapsibleView = new Mw(this.locale, i), this.additionalPropertiesCollapsibleView.set({ label: e("List properties"), isCollapsed: !0 }), this.additionalPropertiesCollapsibleView.buttonView.bind("isEnabled").toMany(i, "isEnabled", (...r) => r.some((s) => s)), this.additionalPropertiesCollapsibleView.buttonView.on("change:isEnabled", (r, s, a) => {
      a || (this.additionalPropertiesCollapsibleView.isCollapsed = !0);
    }), this.children.add(this.additionalPropertiesCollapsibleView)) : this.children.addMany(i);
  }
  _createStartIndexField() {
    const t = this.locale.t, e = new Nn(this.locale, Fw);
    return e.set({ label: t("Start at"), class: "ck-numbered-list-properties__start-index" }), e.fieldView.set({ min: 0, step: 1, value: 1, inputMode: "numeric" }), e.fieldView.on("input", () => {
      const i = e.fieldView.element, r = i.valueAsNumber;
      Number.isNaN(r) ? e.errorText = t("Invalid start index value.") : i.checkValidity() ? this.fire("listStart", { startIndex: r }) : e.errorText = t("Start index must be greater than 0.");
    }), e;
  }
  _createReversedSwitchButton() {
    const t = this.locale.t, e = new ys(this.locale);
    return e.set({ withText: !0, label: t("Reversed order"), class: "ck-numbered-list-properties__reversed-order" }), e.delegate("execute").to(this, "listReversed"), e;
  }
}
class DM extends A {
  static get pluginName() {
    return "ListPropertiesUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.locale.t, e = n.config.get("list.properties"), i = X_(e), r = i.styles.listTypes;
    if (r.includes("bulleted")) {
      const s = [{ label: t("Toggle the disc list style"), tooltip: t("Disc"), type: "disc", icon: P2 }, { label: t("Toggle the circle list style"), tooltip: t("Circle"), type: "circle", icon: I2 }, { label: t("Toggle the square list style"), tooltip: t("Square"), type: "square", icon: N2 }], a = t("Bulleted List"), l = t("Bulleted list styles toolbar"), c = "bulletedList";
      n.ui.componentFactory.add(c, Rf({ editor: n, normalizedConfig: i, parentCommandName: c, buttonLabel: a, buttonIcon: Cu, styleGridAriaLabel: l, styleDefinitions: s })), n.ui.componentFactory.add(`menuBar:${c}`, Vf({ editor: n, normalizedConfig: i, parentCommandName: c, buttonLabel: a, styleGridAriaLabel: l, styleDefinitions: s }));
    }
    if (r.includes("numbered") || e.startIndex || e.reversed) {
      const s = [{ label: t("Toggle the decimal list style"), tooltip: t("Decimal"), type: "decimal", icon: D2 }, { label: t("Toggle the decimal with leading zero list style"), tooltip: t("Decimal with leading zero"), type: "decimal-leading-zero", icon: M2 }, { label: t("Toggle the lowerroman list style"), tooltip: t("Lowerroman"), type: "lower-roman", icon: B2 }, { label: t("Toggle the upperroman list style"), tooltip: t("Upper-roman"), type: "upper-roman", icon: O2 }, { label: t("Toggle the lowerlatin list style"), tooltip: t("Lower-latin"), type: "lower-latin", icon: L2 }, { label: t("Toggle the upperlatin list style"), tooltip: t("Upper-latin"), type: "upper-latin", icon: z2 }], a = t("Numbered List"), l = t("Numbered list styles toolbar"), c = "numberedList";
      n.ui.componentFactory.add(c, Rf({ editor: n, normalizedConfig: i, parentCommandName: c, buttonLabel: a, buttonIcon: xu, styleGridAriaLabel: l, styleDefinitions: s })), r.includes("numbered") && n.ui.componentFactory.add(`menuBar:${c}`, Vf({ editor: n, normalizedConfig: i, parentCommandName: c, buttonLabel: a, styleGridAriaLabel: l, styleDefinitions: s }));
    }
  }
}
function Rf({ editor: o, normalizedConfig: n, parentCommandName: t, buttonLabel: e, buttonIcon: i, styleGridAriaLabel: r, styleDefinitions: s }) {
  const a = o.commands.get(t);
  return (l) => {
    const c = ge(l, mo), d = c.buttonView;
    return c.bind("isEnabled").to(a), c.class = "ck-list-styles-dropdown", d.on("execute", () => {
      o.execute(t), o.editing.view.focus();
    }), d.set({ label: e, icon: i, tooltip: !0, isToggleable: !0 }), d.bind("isOn").to(a, "value", (u) => !!u), c.once("change:isOpen", () => {
      const u = function({ editor: h, normalizedConfig: g, dropdownView: f, parentCommandName: p, styleDefinitions: b, styleGridAriaLabel: k }) {
        const w = h.locale, _ = { ...g, ...p != "numberedList" ? { startIndex: !1, reversed: !1 } : null }, y = p.replace("List", "");
        let C = null;
        if (g.styles.listTypes.includes(y)) {
          const I = h.commands.get("listStyle"), P = ev({ editor: h, parentCommandName: p, listStyleCommand: I }), Y = g.styles.listStyleTypes;
          let it = b;
          if (Y) {
            const ct = Y[y];
            ct && (it = b.filter((ee) => ct.includes(ee.type)));
          }
          const te = nv(I);
          C = it.filter(te).map(P);
        }
        const x = new tv(w, { styleGridAriaLabel: k, enabledProperties: _, styleButtonViews: C });
        if (g.styles.listTypes.includes(y) && ml(f, () => x.stylesView.children.find((I) => I.isOn)), _.startIndex) {
          const I = h.commands.get("listStart");
          x.startIndexFieldView.bind("isEnabled").to(I), x.startIndexFieldView.fieldView.bind("value").to(I), x.on("listStart", (P, Y) => h.execute("listStart", Y));
        }
        if (_.reversed) {
          const I = h.commands.get("listReversed");
          x.reversedSwitchButtonView.bind("isEnabled").to(I), x.reversedSwitchButtonView.bind("isOn").to(I, "value", (P) => !!P), x.on("listReversed", () => {
            const P = I.value;
            h.execute("listReversed", { reversed: !P });
          });
        }
        return x.delegate("execute").to(f), x;
      }({ editor: o, normalizedConfig: n, dropdownView: c, parentCommandName: t, styleGridAriaLabel: r, styleDefinitions: s });
      c.panelView.children.add(u);
    }), c.on("execute", () => {
      o.editing.view.focus();
    }), c;
  };
}
function ev({ editor: o, listStyleCommand: n, parentCommandName: t }) {
  const e = o.locale, i = o.commands.get(t);
  return ({ label: r, type: s, icon: a, tooltip: l }) => {
    const c = new V(e);
    return c.set({ label: r, icon: a, tooltip: l }), c.bind("isOn").to(n, "value", (d) => d === s), c.on("execute", () => {
      i.value ? n.value === s ? o.execute(t) : n.value !== s && o.execute("listStyle", { type: s }) : o.model.change(() => {
        o.execute("listStyle", { type: s });
      });
    }), c;
  };
}
function Vf({ editor: o, normalizedConfig: n, parentCommandName: t, buttonLabel: e, styleGridAriaLabel: i, styleDefinitions: r }) {
  return (s) => {
    const a = new Me(s), l = o.commands.get(t), c = o.commands.get("listStyle"), d = nv(c), u = ev({ editor: o, parentCommandName: t, listStyleCommand: c }), h = n.styles.listStyleTypes;
    let g = r;
    if (h) {
      const b = h[l.type];
      b && (g = r.filter((k) => b.includes(k.type)));
    }
    const f = g.filter(d).map(u), p = new tv(s, { styleGridAriaLabel: i, enabledProperties: { ...n, startIndex: !1, reversed: !1 }, styleButtonViews: f });
    return p.delegate("execute").to(a), a.buttonView.set({ label: e, icon: t === "bulletedList" ? Cu : xu }), a.panelView.children.add(p), a.bind("isEnabled").to(l, "isEnabled"), a.on("execute", () => {
      o.editing.view.focus();
    }), a;
  };
}
function nv(o) {
  return typeof o.isStyleTypeSupported == "function" ? (n) => o.isStyleTypeSupported(n.type) : () => !0;
}
class PM extends A {
  static get requires() {
    return [MM, DM];
  }
  static get pluginName() {
    return "ListProperties";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class LM extends q {
  constructor(n) {
    super(n), this.on("execute", () => {
      this.refresh();
    }, { priority: "highest" });
  }
  refresh() {
    const n = this._getSelectedItems();
    this.value = this._getValue(n), this.isEnabled = !!n.length;
  }
  execute(n = {}) {
    this.editor.model.change((t) => {
      const e = this._getSelectedItems(), i = n.forceValue === void 0 ? !this._getValue(e) : n.forceValue;
      for (const r of e) i ? t.setAttribute("todoListChecked", !0, r) : t.removeAttribute("todoListChecked", r);
    });
  }
  _getValue(n) {
    return n.every((t) => t.getAttribute("todoListChecked"));
  }
  _getSelectedItems() {
    const n = this.editor.model, t = n.schema, e = n.document.selection.getFirstRange(), i = e.start.parent, r = [];
    t.checkAttribute(i, "todoListChecked") && r.push(...ir(i));
    for (const s of e.getItems({ shallow: !0 })) t.checkAttribute(s, "todoListChecked") && !r.includes(s) && r.push(...ir(s));
    return r;
  }
}
class BM extends Fn {
  constructor() {
    super(...arguments);
    m(this, "domEventType", ["change"]);
  }
  onDomEvent(t) {
    if (t.target) {
      const e = this.view.domConverter.mapDomToView(t.target);
      e && e.is("element", "input") && e.getAttribute("type") == "checkbox" && e.findAncestor({ classes: "todo-list__label" }) && this.fire("todoCheckboxChange", t);
    }
  }
}
const NM = ws("Ctrl+Enter");
class zM extends A {
  static get pluginName() {
    return "TodoListEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [us];
  }
  init() {
    const n = this.editor, t = n.model, e = n.editing, i = n.plugins.get(us), r = n.config.get("list.multiBlock") ? "paragraph" : "listItem";
    n.commands.add("todoList", new Lr(n, "todo")), n.commands.add("checkTodoList", new LM(n)), e.view.addObserver(BM), t.schema.extend("$listItem", { allowAttributes: "todoListChecked" }), t.schema.addAttributeCheck((s) => {
      const a = s.last;
      if (!a.getAttribute("listItemId") || a.getAttribute("listType") != "todo") return !1;
    }, "todoListChecked"), n.conversion.for("upcast").add((s) => {
      s.on("element:input", (a, l, c) => {
        const d = l.modelCursor, u = d.parent, h = l.viewItem;
        if (!c.consumable.test(h, { name: !0 }) || h.getAttribute("type") != "checkbox" || !d.isAtStart || !u.hasAttribute("listType")) return;
        c.consumable.consume(h, { name: !0 });
        const g = c.writer;
        g.setAttribute("listType", "todo", u), l.viewItem.hasAttribute("checked") && g.setAttribute("todoListChecked", !0, u), l.modelRange = g.createRange(d);
      }), s.on("element:li", (a, l, c) => {
        const { writer: d, schema: u } = c;
        if (!l.modelRange) return;
        const h = Array.from(l.modelRange.getItems({ shallow: !0 })).filter((g) => g.getAttribute("listType") === "todo" && u.checkAttribute(g, "listItemId")).reduce((g, f) => {
          const p = f.getAttribute("listItemId");
          return g.has(p) || g.set(p, ir(f)), g;
        }, /* @__PURE__ */ new Map());
        for (const [, g] of h.entries()) if (g.some((f) => f.getAttribute("todoListChecked"))) for (const f of g) d.setAttribute("todoListChecked", !0, f);
      }, { priority: "low" }), s.on("element:label", _c({ name: "label", classes: "todo-list__label" })), s.on("element:label", _c({ name: "label", classes: ["todo-list__label", "todo-list__label_without-description"] })), s.on("element:span", _c({ name: "span", classes: "todo-list__label__description" })), s.on("element:ul", function(a) {
        const l = new We(a);
        return (c, d, u) => {
          const h = l.match(d.viewItem);
          if (!h) return;
          const g = h.match;
          g.name = !1, u.consumable.consume(d.viewItem, g);
        };
      }({ name: "ul", classes: "todo-list" }));
    }), n.conversion.for("downcast").elementToElement({ model: r, view: (s, { writer: a }) => {
      if (Ks(s, i.getListAttributeNames())) return a.createContainerElement("span", { class: "todo-list__label__description" });
    }, converterPriority: "highest" }), i.registerDowncastStrategy({ scope: "list", attributeName: "listType", setAttributeOnDowncast(s, a, l) {
      a == "todo" ? s.addClass("todo-list", l) : s.removeClass("todo-list", l);
    } }), i.registerDowncastStrategy({ scope: "itemMarker", attributeName: "todoListChecked", createElement(s, a, { dataPipeline: l }) {
      if (a.getAttribute("listType") != "todo") return null;
      const c = s.createUIElement("input", { type: "checkbox", ...a.getAttribute("todoListChecked") ? { checked: "checked" } : null, ...l ? { disabled: "disabled" } : { tabindex: "-1" } });
      if (l) return c;
      const d = s.createContainerElement("span", { contenteditable: "false" }, c);
      return d.getFillerOffset = () => null, d;
    }, canWrapElement: (s) => Ks(s, i.getListAttributeNames()), createWrapperElement(s, a, { dataPipeline: l }) {
      const c = ["todo-list__label"];
      return Ks(a, i.getListAttributeNames()) || c.push("todo-list__label_without-description"), s.createAttributeElement(l ? "label" : "span", { class: c.join(" ") });
    } }), i.on("checkElement", (s, { modelElement: a, viewElement: l }) => {
      const c = Ks(a, i.getListAttributeNames());
      l.hasClass("todo-list__label__description") != c && (s.return = !0, s.stop());
    }), i.on("checkElement", (s, { modelElement: a, viewElement: l }) => {
      const c = a.getAttribute("listType") == "todo" && ci(a);
      let d = !1;
      const u = n.editing.view.createPositionBefore(l).getWalker({ direction: "backward" });
      for (const { item: h } of u) {
        if (h.is("element") && n.editing.mapper.toModelElement(h)) break;
        h.is("element", "input") && h.getAttribute("type") == "checkbox" && (d = !0);
      }
      d != c && (s.return = !0, s.stop());
    }), i.on("postFixer", (s, { listNodes: a, writer: l }) => {
      for (const { node: c, previousNodeInList: d } of a) {
        if (!d || d.getAttribute("listItemId") != c.getAttribute("listItemId")) continue;
        const u = d.hasAttribute("todoListChecked"), h = c.hasAttribute("todoListChecked");
        h && !u ? (l.removeAttribute("todoListChecked", c), s.return = !0) : !h && u && (l.setAttribute("todoListChecked", !0, c), s.return = !0);
      }
    }), t.document.registerPostFixer((s) => {
      const a = t.document.differ.getChanges();
      let l = !1;
      for (const c of a) if (c.type == "attribute" && c.attributeKey == "listType") {
        const d = c.range.start.nodeAfter;
        c.attributeOldValue == "todo" && d.hasAttribute("todoListChecked") && (s.removeAttribute("todoListChecked", d), l = !0);
      } else if (c.type == "insert" && c.name != "$text") for (const { item: d } of s.createRangeOn(c.position.nodeAfter)) d.is("element") && d.getAttribute("listType") != "todo" && d.hasAttribute("todoListChecked") && (s.removeAttribute("todoListChecked", d), l = !0);
      return l;
    }), this.listenTo(e.view.document, "keydown", (s, a) => {
      eo(a) === NM && (n.execute("checkTodoList"), s.stop());
    }, { priority: "high" }), this.listenTo(e.view.document, "todoCheckboxChange", (s, a) => {
      const l = a.target;
      if (!l || !l.is("element", "input")) return;
      const c = e.view.createPositionAfter(l), d = e.mapper.toModelPosition(c).parent;
      d && St(d) && d.getAttribute("listType") == "todo" && this._handleCheckmarkChange(d);
    }), this.listenTo(e.view.document, "arrowKey", /* @__PURE__ */ function(s, a) {
      return (l, c) => {
        const d = rl(c.keyCode, a.contentLanguageDirection), u = s.schema, h = s.document.selection;
        if (!h.isCollapsed) return;
        const g = h.getFirstPosition(), f = g.parent;
        if (d == "right" && g.isAtEnd) {
          const p = u.getNearestSelectionRange(s.createPositionAfter(f), "forward");
          if (!p) return;
          const b = p.start.parent;
          b && St(b) && b.getAttribute("listType") == "todo" && (s.change((k) => k.setSelection(p)), c.preventDefault(), c.stopPropagation(), l.stop());
        } else if (d == "left" && g.isAtStart && St(f) && f.getAttribute("listType") == "todo") {
          const p = u.getNearestSelectionRange(s.createPositionBefore(f), "backward");
          if (!p) return;
          s.change((b) => b.setSelection(p)), c.preventDefault(), c.stopPropagation(), l.stop();
        }
      };
    }(t, n.locale), { context: "$text" }), this.listenTo(e.mapper, "viewToModelPosition", (s, a) => {
      const l = a.viewPosition.parent, c = l.is("attributeElement", "li") && a.viewPosition.offset == 0, d = Ff(l) && a.viewPosition.offset <= 1, u = l.is("element", "span") && l.getAttribute("contenteditable") == "false" && Ff(l.parent);
      if (!c && !d && !u) return;
      const h = a.modelPosition.nodeAfter;
      h && h.getAttribute("listType") == "todo" && (a.modelPosition = t.createPositionAt(h, 0));
    }, { priority: "low" }), this._initAriaAnnouncements();
  }
  _handleCheckmarkChange(n) {
    const t = this.editor, e = t.model, i = Array.from(e.document.selection.getRanges());
    e.change((r) => {
      r.setSelection(n, "end"), t.execute("checkTodoList"), r.setSelection(i);
    });
  }
  _initAriaAnnouncements() {
    const { model: n, ui: t, t: e } = this.editor;
    let i = null;
    t && n.document.selection.on("change:range", () => {
      const r = n.document.selection.focus.parent, s = jf(i), a = jf(r);
      s && !a ? t.ariaLiveAnnouncer.announce(e("Leaving a to-do list")) : !s && a && t.ariaLiveAnnouncer.announce(e("Entering a to-do list")), i = r;
    });
  }
}
function _c(o) {
  const n = new We(o);
  return (t, e, i) => {
    const r = n.match(e.viewItem);
    r && i.consumable.consume(e.viewItem, r.match) && Object.assign(e, i.convertChildren(e.viewItem, e.modelCursor));
  };
}
function Ks(o, n) {
  return (o.is("element", "paragraph") || o.is("element", "listItem")) && o.getAttribute("listType") == "todo" && ci(o) && function(t, e) {
    for (const i of t.getAttributeKeys()) if (!i.startsWith("selection:") && !e.includes(i)) return !1;
    return !0;
  }(o, n);
}
function Ff(o) {
  return !!o && o.is("attributeElement") && o.hasClass("todo-list__label");
}
function jf(o) {
  return !!o && !(!o.is("element", "paragraph") && !o.is("element", "listItem")) && o.getAttribute("listType") == "todo";
}
class OM extends A {
  static get pluginName() {
    return "TodoListUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor.t;
    Sd(this.editor, "todoList", n("To-do List"), gE);
  }
}
class RM extends A {
  static get requires() {
    return [zM, OM];
  }
  static get pluginName() {
    return "TodoList";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
ws("Ctrl+Enter");
function VM() {
  return { baseUrl: null, breaks: !1, extensions: null, gfm: !0, headerIds: !0, headerPrefix: "", highlight: null, langPrefix: "language-", mangle: !0, pedantic: !1, renderer: null, sanitize: !1, sanitizer: null, silent: !1, smartLists: !1, smartypants: !1, tokenizer: null, walkTokens: null, xhtml: !1 };
}
let or = { baseUrl: null, breaks: !1, extensions: null, gfm: !0, headerIds: !0, headerPrefix: "", highlight: null, langPrefix: "language-", mangle: !0, pedantic: !1, renderer: null, sanitize: !1, sanitizer: null, silent: !1, smartLists: !1, smartypants: !1, tokenizer: null, walkTokens: null, xhtml: !1 };
const FM = /[&<>"']/, jM = /[&<>"']/g, HM = /[<>"']|&(?!#?\w+;)/, UM = /[<>"']|&(?!#?\w+;)/g, $M = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, Hf = (o) => $M[o];
function ue(o, n) {
  if (n) {
    if (FM.test(o)) return o.replace(jM, Hf);
  } else if (HM.test(o)) return o.replace(UM, Hf);
  return o;
}
const qM = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;
function iv(o) {
  return o.replace(qM, (n, t) => (t = t.toLowerCase()) === "colon" ? ":" : t.charAt(0) === "#" ? t.charAt(1) === "x" ? String.fromCharCode(parseInt(t.substring(2), 16)) : String.fromCharCode(+t.substring(1)) : "");
}
const WM = /(^|[^\[])\^/g;
function Pt(o, n) {
  o = o.source || o, n = n || "";
  const t = { replace: (e, i) => (i = (i = i.source || i).replace(WM, "$1"), o = o.replace(e, i), t), getRegex: () => new RegExp(o, n) };
  return t;
}
const GM = /[^\w:]/g, KM = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function Uf(o, n, t) {
  if (o) {
    let e;
    try {
      e = decodeURIComponent(iv(t)).replace(GM, "").toLowerCase();
    } catch {
      return null;
    }
    if (e.indexOf("javascript:") === 0 || e.indexOf("vbscript:") === 0 || e.indexOf("data:") === 0) return null;
  }
  n && !KM.test(t) && (t = function(e, i) {
    Ys[" " + e] || (YM.test(e) ? Ys[" " + e] = e + "/" : Ys[" " + e] = sa(e, "/", !0)), e = Ys[" " + e];
    const r = e.indexOf(":") === -1;
    return i.substring(0, 2) === "//" ? r ? i : e.replace(ZM, "$1") + i : i.charAt(0) === "/" ? r ? i : e.replace(QM, "$1") + i : e + i;
  }(n, t));
  try {
    t = encodeURI(t).replace(/%25/g, "%");
  } catch {
    return null;
  }
  return t;
}
const Ys = {}, YM = /^[^:]+:\/*[^/]*$/, ZM = /^([^:]+:)[\s\S]*$/, QM = /^([^:]+:\/*[^/]*)[\s\S]*$/, Ha = { exec: function() {
} };
function fn(o) {
  let n, t, e = 1;
  for (; e < arguments.length; e++) for (t in n = arguments[e], n) Object.prototype.hasOwnProperty.call(n, t) && (o[t] = n[t]);
  return o;
}
function $f(o, n) {
  const t = o.replace(/\|/g, (i, r, s) => {
    let a = !1, l = r;
    for (; --l >= 0 && s[l] === "\\"; ) a = !a;
    return a ? "|" : " |";
  }).split(/ \|/);
  let e = 0;
  if (t[0].trim() || t.shift(), t.length > 0 && !t[t.length - 1].trim() && t.pop(), t.length > n) t.splice(n);
  else for (; t.length < n; ) t.push("");
  for (; e < t.length; e++) t[e] = t[e].trim().replace(/\\\|/g, "|");
  return t;
}
function sa(o, n, t) {
  const e = o.length;
  if (e === 0) return "";
  let i = 0;
  for (; i < e; ) {
    const r = o.charAt(e - i - 1);
    if (r !== n || t) {
      if (r === n || !t) break;
      i++;
    } else i++;
  }
  return o.substr(0, e - i);
}
function ov(o) {
  o && o.sanitize && !o.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
}
function qf(o, n) {
  if (n < 1) return "";
  let t = "";
  for (; n > 1; ) 1 & n && (t += o), n >>= 1, o += o;
  return t + o;
}
function Wf(o, n, t, e) {
  const i = n.href, r = n.title ? ue(n.title) : null, s = o[1].replace(/\\([\[\]])/g, "$1");
  if (o[0].charAt(0) !== "!") {
    e.state.inLink = !0;
    const a = { type: "link", raw: t, href: i, title: r, text: s, tokens: e.inlineTokens(s, []) };
    return e.state.inLink = !1, a;
  }
  return { type: "image", raw: t, href: i, title: r, text: ue(s) };
}
class Md {
  constructor(n) {
    this.options = n || or;
  }
  space(n) {
    const t = this.rules.block.newline.exec(n);
    if (t && t[0].length > 0) return { type: "space", raw: t[0] };
  }
  code(n) {
    const t = this.rules.block.code.exec(n);
    if (t) {
      const e = t[0].replace(/^ {1,4}/gm, "");
      return { type: "code", raw: t[0], codeBlockStyle: "indented", text: this.options.pedantic ? e : sa(e, `
`) };
    }
  }
  fences(n) {
    const t = this.rules.block.fences.exec(n);
    if (t) {
      const e = t[0], i = function(r, s) {
        const a = r.match(/^(\s+)(?:```)/);
        if (a === null) return s;
        const l = a[1];
        return s.split(`
`).map((c) => {
          const d = c.match(/^\s+/);
          if (d === null) return c;
          const [u] = d;
          return u.length >= l.length ? c.slice(l.length) : c;
        }).join(`
`);
      }(e, t[3] || "");
      return { type: "code", raw: e, lang: t[2] ? t[2].trim() : t[2], text: i };
    }
  }
  heading(n) {
    const t = this.rules.block.heading.exec(n);
    if (t) {
      let e = t[2].trim();
      if (/#$/.test(e)) {
        const r = sa(e, "#");
        this.options.pedantic ? e = r.trim() : r && !/ $/.test(r) || (e = r.trim());
      }
      const i = { type: "heading", raw: t[0], depth: t[1].length, text: e, tokens: [] };
      return this.lexer.inline(i.text, i.tokens), i;
    }
  }
  hr(n) {
    const t = this.rules.block.hr.exec(n);
    if (t) return { type: "hr", raw: t[0] };
  }
  blockquote(n) {
    const t = this.rules.block.blockquote.exec(n);
    if (t) {
      const e = t[0].replace(/^ *> ?/gm, "");
      return { type: "blockquote", raw: t[0], tokens: this.lexer.blockTokens(e, []), text: e };
    }
  }
  list(n) {
    let t = this.rules.block.list.exec(n);
    if (t) {
      let e, i, r, s, a, l, c, d, u, h, g, f, p = t[1].trim();
      const b = p.length > 1, k = { type: "list", raw: "", ordered: b, start: b ? +p.slice(0, -1) : "", loose: !1, items: [] };
      p = b ? `\\d{1,9}\\${p.slice(-1)}` : `\\${p}`, this.options.pedantic && (p = b ? p : "[*+-]");
      const w = new RegExp(`^( {0,3}${p})((?: [^\\n]*)?(?:\\n|$))`);
      for (; n && (f = !1, t = w.exec(n)) && !this.rules.block.hr.test(n); ) {
        if (e = t[0], n = n.substring(e.length), d = t[2].split(`
`, 1)[0], u = n.split(`
`, 1)[0], this.options.pedantic ? (s = 2, g = d.trimLeft()) : (s = t[2].search(/[^ ]/), s = s > 4 ? 1 : s, g = d.slice(s), s += t[1].length), l = !1, !d && /^ *$/.test(u) && (e += u + `
`, n = n.substring(u.length + 1), f = !0), !f) {
          const y = new RegExp(`^ {0,${Math.min(3, s - 1)}}(?:[*+-]|\\d{1,9}[.)])`);
          for (; n && (h = n.split(`
`, 1)[0], d = h, this.options.pedantic && (d = d.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), !y.test(d)); ) {
            if (d.search(/[^ ]/) >= s || !d.trim()) g += `
` + d.slice(s);
            else {
              if (l) break;
              g += `
` + d;
            }
            l || d.trim() || (l = !0), e += h + `
`, n = n.substring(h.length + 1);
          }
        }
        k.loose || (c ? k.loose = !0 : /\n *\n *$/.test(e) && (c = !0)), this.options.gfm && (i = /^\[[ xX]\] /.exec(g), i && (r = i[0] !== "[ ] ", g = g.replace(/^\[[ xX]\] +/, ""))), k.items.push({ type: "list_item", raw: e, task: !!i, checked: r, loose: !1, text: g }), k.raw += e;
      }
      k.items[k.items.length - 1].raw = e.trimRight(), k.items[k.items.length - 1].text = g.trimRight(), k.raw = k.raw.trimRight();
      const _ = k.items.length;
      for (a = 0; a < _; a++) {
        this.lexer.state.top = !1, k.items[a].tokens = this.lexer.blockTokens(k.items[a].text, []);
        const y = k.items[a].tokens.filter((x) => x.type === "space"), C = y.every((x) => {
          const I = x.raw.split("");
          let P = 0;
          for (const Y of I) if (Y === `
` && (P += 1), P > 1) return !0;
          return !1;
        });
        !k.loose && y.length && C && (k.loose = !0, k.items[a].loose = !0);
      }
      return k;
    }
  }
  html(n) {
    const t = this.rules.block.html.exec(n);
    if (t) {
      const e = { type: "html", raw: t[0], pre: !this.options.sanitizer && (t[1] === "pre" || t[1] === "script" || t[1] === "style"), text: t[0] };
      return this.options.sanitize && (e.type = "paragraph", e.text = this.options.sanitizer ? this.options.sanitizer(t[0]) : ue(t[0]), e.tokens = [], this.lexer.inline(e.text, e.tokens)), e;
    }
  }
  def(n) {
    const t = this.rules.block.def.exec(n);
    if (t)
      return t[3] && (t[3] = t[3].substring(1, t[3].length - 1)), { type: "def", tag: t[1].toLowerCase().replace(/\s+/g, " "), raw: t[0], href: t[2], title: t[3] };
  }
  table(n) {
    const t = this.rules.block.table.exec(n);
    if (t) {
      const e = { type: "table", header: $f(t[1]).map((i) => ({ text: i })), align: t[2].replace(/^ *|\| *$/g, "").split(/ *\| */), rows: t[3] && t[3].trim() ? t[3].replace(/\n[ \t]*$/, "").split(`
`) : [] };
      if (e.header.length === e.align.length) {
        e.raw = t[0];
        let i, r, s, a, l = e.align.length;
        for (i = 0; i < l; i++) /^ *-+: *$/.test(e.align[i]) ? e.align[i] = "right" : /^ *:-+: *$/.test(e.align[i]) ? e.align[i] = "center" : /^ *:-+ *$/.test(e.align[i]) ? e.align[i] = "left" : e.align[i] = null;
        for (l = e.rows.length, i = 0; i < l; i++) e.rows[i] = $f(e.rows[i], e.header.length).map((c) => ({ text: c }));
        for (l = e.header.length, r = 0; r < l; r++) e.header[r].tokens = [], this.lexer.inlineTokens(e.header[r].text, e.header[r].tokens);
        for (l = e.rows.length, r = 0; r < l; r++) for (a = e.rows[r], s = 0; s < a.length; s++) a[s].tokens = [], this.lexer.inlineTokens(a[s].text, a[s].tokens);
        return e;
      }
    }
  }
  lheading(n) {
    const t = this.rules.block.lheading.exec(n);
    if (t) {
      const e = { type: "heading", raw: t[0], depth: t[2].charAt(0) === "=" ? 1 : 2, text: t[1], tokens: [] };
      return this.lexer.inline(e.text, e.tokens), e;
    }
  }
  paragraph(n) {
    const t = this.rules.block.paragraph.exec(n);
    if (t) {
      const e = { type: "paragraph", raw: t[0], text: t[1].charAt(t[1].length - 1) === `
` ? t[1].slice(0, -1) : t[1], tokens: [] };
      return this.lexer.inline(e.text, e.tokens), e;
    }
  }
  text(n) {
    const t = this.rules.block.text.exec(n);
    if (t) {
      const e = { type: "text", raw: t[0], text: t[0], tokens: [] };
      return this.lexer.inline(e.text, e.tokens), e;
    }
  }
  escape(n) {
    const t = this.rules.inline.escape.exec(n);
    if (t) return { type: "escape", raw: t[0], text: ue(t[1]) };
  }
  tag(n) {
    const t = this.rules.inline.tag.exec(n);
    if (t) return !this.lexer.state.inLink && /^<a /i.test(t[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(t[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(t[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(t[0]) && (this.lexer.state.inRawBlock = !1), { type: this.options.sanitize ? "text" : "html", raw: t[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(t[0]) : ue(t[0]) : t[0] };
  }
  link(n) {
    const t = this.rules.inline.link.exec(n);
    if (t) {
      const e = t[2].trim();
      if (!this.options.pedantic && /^</.test(e)) {
        if (!/>$/.test(e)) return;
        const s = sa(e.slice(0, -1), "\\");
        if ((e.length - s.length) % 2 == 0) return;
      } else {
        const s = function(a, l) {
          if (a.indexOf(l[1]) === -1) return -1;
          const c = a.length;
          let d = 0, u = 0;
          for (; u < c; u++) if (a[u] === "\\") u++;
          else if (a[u] === l[0]) d++;
          else if (a[u] === l[1] && (d--, d < 0)) return u;
          return -1;
        }(t[2], "()");
        if (s > -1) {
          const a = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + s;
          t[2] = t[2].substring(0, s), t[0] = t[0].substring(0, a).trim(), t[3] = "";
        }
      }
      let i = t[2], r = "";
      if (this.options.pedantic) {
        const s = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(i);
        s && (i = s[1], r = s[3]);
      } else r = t[3] ? t[3].slice(1, -1) : "";
      return i = i.trim(), /^</.test(i) && (i = this.options.pedantic && !/>$/.test(e) ? i.slice(1) : i.slice(1, -1)), Wf(t, { href: i && i.replace(this.rules.inline._escapes, "$1"), title: r && r.replace(this.rules.inline._escapes, "$1") }, t[0], this.lexer);
    }
  }
  reflink(n, t) {
    let e;
    if ((e = this.rules.inline.reflink.exec(n)) || (e = this.rules.inline.nolink.exec(n))) {
      let i = (e[2] || e[1]).replace(/\s+/g, " ");
      if (i = t[i.toLowerCase()], !i || !i.href) {
        const r = e[0].charAt(0);
        return { type: "text", raw: r, text: r };
      }
      return Wf(e, i, e[0], this.lexer);
    }
  }
  emStrong(n, t, e = "") {
    let i = this.rules.inline.emStrong.lDelim.exec(n);
    if (!i || i[3] && e.match(/[\p{L}\p{N}]/u)) return;
    const r = i[1] || i[2] || "";
    if (!r || r && (e === "" || this.rules.inline.punctuation.exec(e))) {
      const s = i[0].length - 1;
      let a, l, c = s, d = 0;
      const u = i[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      for (u.lastIndex = 0, t = t.slice(-1 * n.length + s); (i = u.exec(t)) != null; ) {
        if (a = i[1] || i[2] || i[3] || i[4] || i[5] || i[6], !a) continue;
        if (l = a.length, i[3] || i[4]) {
          c += l;
          continue;
        }
        if ((i[5] || i[6]) && s % 3 && !((s + l) % 3)) {
          d += l;
          continue;
        }
        if (c -= l, c > 0) continue;
        if (l = Math.min(l, l + c + d), Math.min(s, l) % 2) {
          const g = n.slice(1, s + i.index + l);
          return { type: "em", raw: n.slice(0, s + i.index + l + 1), text: g, tokens: this.lexer.inlineTokens(g, []) };
        }
        const h = n.slice(2, s + i.index + l - 1);
        return { type: "strong", raw: n.slice(0, s + i.index + l + 1), text: h, tokens: this.lexer.inlineTokens(h, []) };
      }
    }
  }
  codespan(n) {
    const t = this.rules.inline.code.exec(n);
    if (t) {
      let e = t[2].replace(/\n/g, " ");
      const i = /[^ ]/.test(e), r = /^ /.test(e) && / $/.test(e);
      return i && r && (e = e.substring(1, e.length - 1)), e = ue(e, !0), { type: "codespan", raw: t[0], text: e };
    }
  }
  br(n) {
    const t = this.rules.inline.br.exec(n);
    if (t) return { type: "br", raw: t[0] };
  }
  del(n) {
    const t = this.rules.inline.del.exec(n);
    if (t) return { type: "del", raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2], []) };
  }
  autolink(n, t) {
    const e = this.rules.inline.autolink.exec(n);
    if (e) {
      let i, r;
      return e[2] === "@" ? (i = ue(this.options.mangle ? t(e[1]) : e[1]), r = "mailto:" + i) : (i = ue(e[1]), r = i), { type: "link", raw: e[0], text: i, href: r, tokens: [{ type: "text", raw: i, text: i }] };
    }
  }
  url(n, t) {
    let e;
    if (e = this.rules.inline.url.exec(n)) {
      let i, r;
      if (e[2] === "@") i = ue(this.options.mangle ? t(e[0]) : e[0]), r = "mailto:" + i;
      else {
        let s;
        do
          s = e[0], e[0] = this.rules.inline._backpedal.exec(e[0])[0];
        while (s !== e[0]);
        i = ue(e[0]), r = e[1] === "www." ? "http://" + i : i;
      }
      return { type: "link", raw: e[0], text: i, href: r, tokens: [{ type: "text", raw: i, text: i }] };
    }
  }
  inlineText(n, t) {
    const e = this.rules.inline.text.exec(n);
    if (e) {
      let i;
      return i = this.lexer.state.inRawBlock ? this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(e[0]) : ue(e[0]) : e[0] : ue(this.options.smartypants ? t(e[0]) : e[0]), { type: "text", raw: e[0], text: i };
    }
  }
}
const Q = { newline: /^(?: *(?:\n|$))+/, code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/, hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/, heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/, list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/, html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/, table: Ha, lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/, _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, text: /^[^\n]+/, _label: /(?!\s*\])(?:\\.|[^\[\]\\])+/, _title: /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/ };
Q.def = Pt(Q.def).replace("label", Q._label).replace("title", Q._title).getRegex(), Q.bullet = /(?:[*+-]|\d{1,9}[.)])/, Q.listItemStart = Pt(/^( *)(bull) */).replace("bull", Q.bullet).getRegex(), Q.list = Pt(Q.list).replace(/bull/g, Q.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + Q.def.source + ")").getRegex(), Q._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", Q._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/, Q.html = Pt(Q.html, "i").replace("comment", Q._comment).replace("tag", Q._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), Q.paragraph = Pt(Q._paragraph).replace("hr", Q.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Q._tag).getRegex(), Q.blockquote = Pt(Q.blockquote).replace("paragraph", Q.paragraph).getRegex(), Q.normal = fn({}, Q), Q.gfm = fn({}, Q.normal, { table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)" }), Q.gfm.table = Pt(Q.gfm.table).replace("hr", Q.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Q._tag).getRegex(), Q.gfm.paragraph = Pt(Q._paragraph).replace("hr", Q.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", Q.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Q._tag).getRegex(), Q.pedantic = fn({}, Q.normal, { html: Pt(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", Q._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: Ha, paragraph: Pt(Q.normal._paragraph).replace("hr", Q.hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", Q.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex() });
const F = { escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/, url: Ha, tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/, reflink: /^!?\[(label)\]\[(ref)\]/, nolink: /^!?\[(ref)\](?:\[\])?/, reflinkSearch: "reflink|nolink(?!\\()", emStrong: { lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/, rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/, rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ }, code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, br: /^( {2,}|\\)\n(?!\s*$)/, del: Ha, text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, punctuation: /^([\spunctuation])/ };
function JM(o) {
  return o.replace(/---/g, "").replace(/--/g, "").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1").replace(/'/g, "").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1").replace(/"/g, "").replace(/\.{3}/g, "");
}
function Gf(o) {
  let n, t, e = "";
  const i = o.length;
  for (n = 0; n < i; n++) t = o.charCodeAt(n), Math.random() > 0.5 && (t = "x" + t.toString(16)), e += "&#" + t + ";";
  return e;
}
F._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~", F.punctuation = Pt(F.punctuation).replace(/punctuation/g, F._punctuation).getRegex(), F.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g, F.escapedEmSt = /\\\*|\\_/g, F._comment = Pt(Q._comment).replace("(?:-->|$)", "-->").getRegex(), F.emStrong.lDelim = Pt(F.emStrong.lDelim).replace(/punct/g, F._punctuation).getRegex(), F.emStrong.rDelimAst = Pt(F.emStrong.rDelimAst, "g").replace(/punct/g, F._punctuation).getRegex(), F.emStrong.rDelimUnd = Pt(F.emStrong.rDelimUnd, "g").replace(/punct/g, F._punctuation).getRegex(), F._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g, F._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/, F._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/, F.autolink = Pt(F.autolink).replace("scheme", F._scheme).replace("email", F._email).getRegex(), F._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/, F.tag = Pt(F.tag).replace("comment", F._comment).replace("attribute", F._attribute).getRegex(), F._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, F._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/, F._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/, F.link = Pt(F.link).replace("label", F._label).replace("href", F._href).replace("title", F._title).getRegex(), F.reflink = Pt(F.reflink).replace("label", F._label).replace("ref", Q._label).getRegex(), F.nolink = Pt(F.nolink).replace("ref", Q._label).getRegex(), F.reflinkSearch = Pt(F.reflinkSearch, "g").replace("reflink", F.reflink).replace("nolink", F.nolink).getRegex(), F.normal = fn({}, F), F.pedantic = fn({}, F.normal, { strong: { start: /^__|\*\*/, middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/, endAst: /\*\*(?!\*)/g, endUnd: /__(?!_)/g }, em: { start: /^_|\*/, middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/, endAst: /\*(?!\*)/g, endUnd: /_(?!_)/g }, link: Pt(/^!?\[(label)\]\((.*?)\)/).replace("label", F._label).getRegex(), reflink: Pt(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", F._label).getRegex() }), F.gfm = fn({}, F.normal, { escape: Pt(F.escape).replace("])", "~|])").getRegex(), _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/, url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ }), F.gfm.url = Pt(F.gfm.url, "i").replace("email", F.gfm._extended_email).getRegex(), F.breaks = fn({}, F.gfm, { br: Pt(F.br).replace("{2,}", "*").getRegex(), text: Pt(F.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() });
class Xn {
  constructor(n) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = n || or, this.options.tokenizer = this.options.tokenizer || new Md(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 };
    const t = { block: Q.normal, inline: F.normal };
    this.options.pedantic ? (t.block = Q.pedantic, t.inline = F.pedantic) : this.options.gfm && (t.block = Q.gfm, this.options.breaks ? t.inline = F.breaks : t.inline = F.gfm), this.tokenizer.rules = t;
  }
  static get rules() {
    return { block: Q, inline: F };
  }
  static lex(n, t) {
    return new Xn(t).lex(n);
  }
  static lexInline(n, t) {
    return new Xn(t).inlineTokens(n);
  }
  lex(n) {
    let t;
    for (n = n.replace(/\r\n|\r/g, `
`).replace(/\t/g, "    "), this.blockTokens(n, this.tokens); t = this.inlineQueue.shift(); ) this.inlineTokens(t.src, t.tokens);
    return this.tokens;
  }
  blockTokens(n, t = []) {
    let e, i, r, s;
    for (this.options.pedantic && (n = n.replace(/^ +$/gm, "")); n; ) if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((a) => !!(e = a.call({ lexer: this }, n, t)) && (n = n.substring(e.raw.length), t.push(e), !0)))) if (e = this.tokenizer.space(n)) n = n.substring(e.raw.length), e.raw.length === 1 && t.length > 0 ? t[t.length - 1].raw += `
` : t.push(e);
    else if (e = this.tokenizer.code(n)) n = n.substring(e.raw.length), i = t[t.length - 1], !i || i.type !== "paragraph" && i.type !== "text" ? t.push(e) : (i.raw += `
` + e.raw, i.text += `
` + e.text, this.inlineQueue[this.inlineQueue.length - 1].src = i.text);
    else if (e = this.tokenizer.fences(n)) n = n.substring(e.raw.length), t.push(e);
    else if (e = this.tokenizer.heading(n)) n = n.substring(e.raw.length), t.push(e);
    else if (e = this.tokenizer.hr(n)) n = n.substring(e.raw.length), t.push(e);
    else if (e = this.tokenizer.blockquote(n)) n = n.substring(e.raw.length), t.push(e);
    else if (e = this.tokenizer.list(n)) n = n.substring(e.raw.length), t.push(e);
    else if (e = this.tokenizer.html(n)) n = n.substring(e.raw.length), t.push(e);
    else if (e = this.tokenizer.def(n)) n = n.substring(e.raw.length), i = t[t.length - 1], !i || i.type !== "paragraph" && i.type !== "text" ? this.tokens.links[e.tag] || (this.tokens.links[e.tag] = { href: e.href, title: e.title }) : (i.raw += `
` + e.raw, i.text += `
` + e.raw, this.inlineQueue[this.inlineQueue.length - 1].src = i.text);
    else if (e = this.tokenizer.table(n)) n = n.substring(e.raw.length), t.push(e);
    else if (e = this.tokenizer.lheading(n)) n = n.substring(e.raw.length), t.push(e);
    else {
      if (r = n, this.options.extensions && this.options.extensions.startBlock) {
        let a = 1 / 0;
        const l = n.slice(1);
        let c;
        this.options.extensions.startBlock.forEach(function(d) {
          c = d.call({ lexer: this }, l), typeof c == "number" && c >= 0 && (a = Math.min(a, c));
        }), a < 1 / 0 && a >= 0 && (r = n.substring(0, a + 1));
      }
      if (this.state.top && (e = this.tokenizer.paragraph(r))) i = t[t.length - 1], s && i.type === "paragraph" ? (i.raw += `
` + e.raw, i.text += `
` + e.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : t.push(e), s = r.length !== n.length, n = n.substring(e.raw.length);
      else if (e = this.tokenizer.text(n)) n = n.substring(e.raw.length), i = t[t.length - 1], i && i.type === "text" ? (i.raw += `
` + e.raw, i.text += `
` + e.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : t.push(e);
      else if (n) {
        const a = "Infinite loop on byte: " + n.charCodeAt(0);
        if (this.options.silent) {
          console.error(a);
          break;
        }
        throw new Error(a);
      }
    }
    return this.state.top = !0, t;
  }
  inline(n, t) {
    this.inlineQueue.push({ src: n, tokens: t });
  }
  inlineTokens(n, t = []) {
    let e, i, r, s, a, l, c = n;
    if (this.tokens.links) {
      const d = Object.keys(this.tokens.links);
      if (d.length > 0) for (; (s = this.tokenizer.rules.inline.reflinkSearch.exec(c)) != null; ) d.includes(s[0].slice(s[0].lastIndexOf("[") + 1, -1)) && (c = c.slice(0, s.index) + "[" + qf("a", s[0].length - 2) + "]" + c.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (s = this.tokenizer.rules.inline.blockSkip.exec(c)) != null; ) c = c.slice(0, s.index) + "[" + qf("a", s[0].length - 2) + "]" + c.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    for (; (s = this.tokenizer.rules.inline.escapedEmSt.exec(c)) != null; ) c = c.slice(0, s.index) + "++" + c.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
    for (; n; ) if (a || (l = ""), a = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((d) => !!(e = d.call({ lexer: this }, n, t)) && (n = n.substring(e.raw.length), t.push(e), !0)))) if (e = this.tokenizer.escape(n)) n = n.substring(e.raw.length), t.push(e);
    else if (e = this.tokenizer.tag(n)) n = n.substring(e.raw.length), i = t[t.length - 1], i && e.type === "text" && i.type === "text" ? (i.raw += e.raw, i.text += e.text) : t.push(e);
    else if (e = this.tokenizer.link(n)) n = n.substring(e.raw.length), t.push(e);
    else if (e = this.tokenizer.reflink(n, this.tokens.links)) n = n.substring(e.raw.length), i = t[t.length - 1], i && e.type === "text" && i.type === "text" ? (i.raw += e.raw, i.text += e.text) : t.push(e);
    else if (e = this.tokenizer.emStrong(n, c, l)) n = n.substring(e.raw.length), t.push(e);
    else if (e = this.tokenizer.codespan(n)) n = n.substring(e.raw.length), t.push(e);
    else if (e = this.tokenizer.br(n)) n = n.substring(e.raw.length), t.push(e);
    else if (e = this.tokenizer.del(n)) n = n.substring(e.raw.length), t.push(e);
    else if (e = this.tokenizer.autolink(n, Gf)) n = n.substring(e.raw.length), t.push(e);
    else if (this.state.inLink || !(e = this.tokenizer.url(n, Gf))) {
      if (r = n, this.options.extensions && this.options.extensions.startInline) {
        let d = 1 / 0;
        const u = n.slice(1);
        let h;
        this.options.extensions.startInline.forEach(function(g) {
          h = g.call({ lexer: this }, u), typeof h == "number" && h >= 0 && (d = Math.min(d, h));
        }), d < 1 / 0 && d >= 0 && (r = n.substring(0, d + 1));
      }
      if (e = this.tokenizer.inlineText(r, JM)) n = n.substring(e.raw.length), e.raw.slice(-1) !== "_" && (l = e.raw.slice(-1)), a = !0, i = t[t.length - 1], i && i.type === "text" ? (i.raw += e.raw, i.text += e.text) : t.push(e);
      else if (n) {
        const d = "Infinite loop on byte: " + n.charCodeAt(0);
        if (this.options.silent) {
          console.error(d);
          break;
        }
        throw new Error(d);
      }
    } else n = n.substring(e.raw.length), t.push(e);
    return t;
  }
}
class Dd {
  constructor(n) {
    this.options = n || or;
  }
  code(n, t, e) {
    const i = (t || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const r = this.options.highlight(n, i);
      r != null && r !== n && (e = !0, n = r);
    }
    return n = n.replace(/\n$/, "") + `
`, i ? '<pre><code class="' + this.options.langPrefix + ue(i, !0) + '">' + (e ? n : ue(n, !0)) + `</code></pre>
` : "<pre><code>" + (e ? n : ue(n, !0)) + `</code></pre>
`;
  }
  blockquote(n) {
    return `<blockquote>
` + n + `</blockquote>
`;
  }
  html(n) {
    return n;
  }
  heading(n, t, e, i) {
    return this.options.headerIds ? "<h" + t + ' id="' + this.options.headerPrefix + i.slug(e) + '">' + n + "</h" + t + `>
` : "<h" + t + ">" + n + "</h" + t + `>
`;
  }
  hr() {
    return this.options.xhtml ? `<hr/>
` : `<hr>
`;
  }
  list(n, t, e) {
    const i = t ? "ol" : "ul";
    return "<" + i + (t && e !== 1 ? ' start="' + e + '"' : "") + `>
` + n + "</" + i + `>
`;
  }
  listitem(n) {
    return "<li>" + n + `</li>
`;
  }
  checkbox(n) {
    return "<input " + (n ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  paragraph(n) {
    return "<p>" + n + `</p>
`;
  }
  table(n, t) {
    return t && (t = "<tbody>" + t + "</tbody>"), `<table>
<thead>
` + n + `</thead>
` + t + `</table>
`;
  }
  tablerow(n) {
    return `<tr>
` + n + `</tr>
`;
  }
  tablecell(n, t) {
    const e = t.header ? "th" : "td";
    return (t.align ? "<" + e + ' align="' + t.align + '">' : "<" + e + ">") + n + "</" + e + `>
`;
  }
  strong(n) {
    return "<strong>" + n + "</strong>";
  }
  em(n) {
    return "<em>" + n + "</em>";
  }
  codespan(n) {
    return "<code>" + n + "</code>";
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  del(n) {
    return "<del>" + n + "</del>";
  }
  link(n, t, e) {
    if ((n = Uf(this.options.sanitize, this.options.baseUrl, n)) === null) return e;
    let i = '<a href="' + ue(n) + '"';
    return t && (i += ' title="' + t + '"'), i += ">" + e + "</a>", i;
  }
  image(n, t, e) {
    if ((n = Uf(this.options.sanitize, this.options.baseUrl, n)) === null) return e;
    let i = '<img src="' + n + '" alt="' + e + '"';
    return t && (i += ' title="' + t + '"'), i += this.options.xhtml ? "/>" : ">", i;
  }
  text(n) {
    return n;
  }
}
class rv {
  strong(n) {
    return n;
  }
  em(n) {
    return n;
  }
  codespan(n) {
    return n;
  }
  del(n) {
    return n;
  }
  html(n) {
    return n;
  }
  text(n) {
    return n;
  }
  link(n, t, e) {
    return "" + e;
  }
  image(n, t, e) {
    return "" + e;
  }
  br() {
    return "";
  }
}
class sv {
  constructor() {
    this.seen = {};
  }
  serialize(n) {
    return n.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  getNextSafeSlug(n, t) {
    let e = n, i = 0;
    if (this.seen.hasOwnProperty(e)) {
      i = this.seen[n];
      do
        i++, e = n + "-" + i;
      while (this.seen.hasOwnProperty(e));
    }
    return t || (this.seen[n] = i, this.seen[e] = 0), e;
  }
  slug(n, t = {}) {
    const e = this.serialize(n);
    return this.getNextSafeSlug(e, t.dryrun);
  }
}
class ti {
  constructor(n) {
    this.options = n || or, this.options.renderer = this.options.renderer || new Dd(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new rv(), this.slugger = new sv();
  }
  static parse(n, t) {
    return new ti(t).parse(n);
  }
  static parseInline(n, t) {
    return new ti(t).parseInline(n);
  }
  parse(n, t = !0) {
    let e, i, r, s, a, l, c, d, u, h, g, f, p, b, k, w, _, y, C, x = "";
    const I = n.length;
    for (e = 0; e < I; e++) if (h = n[e], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[h.type] && (C = this.options.extensions.renderers[h.type].call({ parser: this }, h), C !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(h.type))) x += C || "";
    else switch (h.type) {
      case "space":
        continue;
      case "hr":
        x += this.renderer.hr();
        continue;
      case "heading":
        x += this.renderer.heading(this.parseInline(h.tokens), h.depth, iv(this.parseInline(h.tokens, this.textRenderer)), this.slugger);
        continue;
      case "code":
        x += this.renderer.code(h.text, h.lang, h.escaped);
        continue;
      case "table":
        for (d = "", c = "", s = h.header.length, i = 0; i < s; i++) c += this.renderer.tablecell(this.parseInline(h.header[i].tokens), { header: !0, align: h.align[i] });
        for (d += this.renderer.tablerow(c), u = "", s = h.rows.length, i = 0; i < s; i++) {
          for (l = h.rows[i], c = "", a = l.length, r = 0; r < a; r++) c += this.renderer.tablecell(this.parseInline(l[r].tokens), { header: !1, align: h.align[r] });
          u += this.renderer.tablerow(c);
        }
        x += this.renderer.table(d, u);
        continue;
      case "blockquote":
        u = this.parse(h.tokens), x += this.renderer.blockquote(u);
        continue;
      case "list":
        for (g = h.ordered, f = h.start, p = h.loose, s = h.items.length, u = "", i = 0; i < s; i++) k = h.items[i], w = k.checked, _ = k.task, b = "", k.task && (y = this.renderer.checkbox(w), p ? k.tokens.length > 0 && k.tokens[0].type === "paragraph" ? (k.tokens[0].text = y + " " + k.tokens[0].text, k.tokens[0].tokens && k.tokens[0].tokens.length > 0 && k.tokens[0].tokens[0].type === "text" && (k.tokens[0].tokens[0].text = y + " " + k.tokens[0].tokens[0].text)) : k.tokens.unshift({ type: "text", text: y }) : b += y), b += this.parse(k.tokens, p), u += this.renderer.listitem(b, _, w);
        x += this.renderer.list(u, g, f);
        continue;
      case "html":
        x += this.renderer.html(h.text);
        continue;
      case "paragraph":
        x += this.renderer.paragraph(this.parseInline(h.tokens));
        continue;
      case "text":
        for (u = h.tokens ? this.parseInline(h.tokens) : h.text; e + 1 < I && n[e + 1].type === "text"; ) h = n[++e], u += `
` + (h.tokens ? this.parseInline(h.tokens) : h.text);
        x += t ? this.renderer.paragraph(u) : u;
        continue;
      default: {
        const P = 'Token with "' + h.type + '" type was not found.';
        if (this.options.silent) return void console.error(P);
        throw new Error(P);
      }
    }
    return x;
  }
  parseInline(n, t) {
    t = t || this.renderer;
    let e, i, r, s = "";
    const a = n.length;
    for (e = 0; e < a; e++) if (i = n[e], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[i.type] && (r = this.options.extensions.renderers[i.type].call({ parser: this }, i), r !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(i.type))) s += r || "";
    else switch (i.type) {
      case "escape":
      case "text":
        s += t.text(i.text);
        break;
      case "html":
        s += t.html(i.text);
        break;
      case "link":
        s += t.link(i.href, i.title, this.parseInline(i.tokens, t));
        break;
      case "image":
        s += t.image(i.href, i.title, i.text);
        break;
      case "strong":
        s += t.strong(this.parseInline(i.tokens, t));
        break;
      case "em":
        s += t.em(this.parseInline(i.tokens, t));
        break;
      case "codespan":
        s += t.codespan(i.text);
        break;
      case "br":
        s += t.br();
        break;
      case "del":
        s += t.del(this.parseInline(i.tokens, t));
        break;
      default: {
        const l = 'Token with "' + i.type + '" type was not found.';
        if (this.options.silent) return void console.error(l);
        throw new Error(l);
      }
    }
    return s;
  }
}
function X(o, n, t) {
  if (o == null) throw new Error("marked(): input parameter is undefined or null");
  if (typeof o != "string") throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(o) + ", string expected");
  if (typeof n == "function" && (t = n, n = null), ov(n = fn({}, X.defaults, n || {})), t) {
    const e = n.highlight;
    let i;
    try {
      i = Xn.lex(o, n);
    } catch (a) {
      return t(a);
    }
    const r = function(a) {
      let l;
      if (!a) try {
        n.walkTokens && X.walkTokens(i, n.walkTokens), l = ti.parse(i, n);
      } catch (c) {
        a = c;
      }
      return n.highlight = e, a ? t(a) : t(null, l);
    };
    if (!e || e.length < 3 || (delete n.highlight, !i.length)) return r();
    let s = 0;
    return X.walkTokens(i, function(a) {
      a.type === "code" && (s++, setTimeout(() => {
        e(a.text, a.lang, function(l, c) {
          if (l) return r(l);
          c != null && c !== a.text && (a.text = c, a.escaped = !0), s--, s === 0 && r();
        });
      }, 0));
    }), void (s === 0 && r());
  }
  try {
    const e = Xn.lex(o, n);
    return n.walkTokens && X.walkTokens(e, n.walkTokens), ti.parse(e, n);
  } catch (e) {
    if (e.message += `
Please report this to https://github.com/markedjs/marked.`, n.silent) return "<p>An error occurred:</p><pre>" + ue(e.message + "", !0) + "</pre>";
    throw e;
  }
}
X.options = X.setOptions = function(o) {
  var n;
  return fn(X.defaults, o), n = X.defaults, or = n, X;
}, X.getDefaults = VM, X.defaults = or, X.use = function(...o) {
  const n = fn({}, ...o), t = X.defaults.extensions || { renderers: {}, childTokens: {} };
  let e;
  o.forEach((i) => {
    if (i.extensions && (e = !0, i.extensions.forEach((r) => {
      if (!r.name) throw new Error("extension name required");
      if (r.renderer) {
        const s = t.renderers ? t.renderers[r.name] : null;
        t.renderers[r.name] = s ? function(...a) {
          let l = r.renderer.apply(this, a);
          return l === !1 && (l = s.apply(this, a)), l;
        } : r.renderer;
      }
      if (r.tokenizer) {
        if (!r.level || r.level !== "block" && r.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
        t[r.level] ? t[r.level].unshift(r.tokenizer) : t[r.level] = [r.tokenizer], r.start && (r.level === "block" ? t.startBlock ? t.startBlock.push(r.start) : t.startBlock = [r.start] : r.level === "inline" && (t.startInline ? t.startInline.push(r.start) : t.startInline = [r.start]));
      }
      r.childTokens && (t.childTokens[r.name] = r.childTokens);
    })), i.renderer) {
      const r = X.defaults.renderer || new Dd();
      for (const s in i.renderer) {
        const a = r[s];
        r[s] = (...l) => {
          let c = i.renderer[s].apply(r, l);
          return c === !1 && (c = a.apply(r, l)), c;
        };
      }
      n.renderer = r;
    }
    if (i.tokenizer) {
      const r = X.defaults.tokenizer || new Md();
      for (const s in i.tokenizer) {
        const a = r[s];
        r[s] = (...l) => {
          let c = i.tokenizer[s].apply(r, l);
          return c === !1 && (c = a.apply(r, l)), c;
        };
      }
      n.tokenizer = r;
    }
    if (i.walkTokens) {
      const r = X.defaults.walkTokens;
      n.walkTokens = function(s) {
        i.walkTokens.call(this, s), r && r.call(this, s);
      };
    }
    e && (n.extensions = t), X.setOptions(n);
  });
}, X.walkTokens = function(o, n) {
  for (const t of o) switch (n.call(X, t), t.type) {
    case "table":
      for (const e of t.header) X.walkTokens(e.tokens, n);
      for (const e of t.rows) for (const i of e) X.walkTokens(i.tokens, n);
      break;
    case "list":
      X.walkTokens(t.items, n);
      break;
    default:
      X.defaults.extensions && X.defaults.extensions.childTokens && X.defaults.extensions.childTokens[t.type] ? X.defaults.extensions.childTokens[t.type].forEach(function(e) {
        X.walkTokens(t[e], n);
      }) : t.tokens && X.walkTokens(t.tokens, n);
  }
}, X.parseInline = function(o, n) {
  if (o == null) throw new Error("marked.parseInline(): input parameter is undefined or null");
  if (typeof o != "string") throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(o) + ", string expected");
  ov(n = fn({}, X.defaults, n || {}));
  try {
    const t = Xn.lexInline(o, n);
    return n.walkTokens && X.walkTokens(t, n.walkTokens), ti.parseInline(t, n);
  } catch (t) {
    if (t.message += `
Please report this to https://github.com/markedjs/marked.`, n.silent) return "<p>An error occurred:</p><pre>" + ue(t.message + "", !0) + "</pre>";
    throw t;
  }
}, X.Parser = ti, X.parser = ti.parse, X.Renderer = Dd, X.TextRenderer = rv, X.Lexer = Xn, X.lexer = Xn.lex, X.Tokenizer = Md, X.Slugger = sv, X.parse = X, X.options, X.setOptions, X.use, X.walkTokens, X.parseInline, ti.parse, Xn.lex;
class XM {
  constructor() {
    m(this, "_parser");
    m(this, "_options", { gfm: !0, breaks: !0, tables: !0, xhtml: !0, headerIds: !1 });
    X.use({ tokenizer: { autolink: () => null, url: () => null }, renderer: { checkbox(...n) {
      return Object.getPrototypeOf(this).checkbox.call(this, ...n).trimRight();
    }, code(...n) {
      return Object.getPrototypeOf(this).code.call(this, ...n).replace(`
</code>`, "</code>");
    } } }), this._parser = X;
  }
  parse(n) {
    return this._parser.parse(n, this._options);
  }
}
function vc(o, n) {
  return Array(n + 1).join(o);
}
var tD = ["ADDRESS", "ARTICLE", "ASIDE", "AUDIO", "BLOCKQUOTE", "BODY", "CANVAS", "CENTER", "DD", "DIR", "DIV", "DL", "DT", "FIELDSET", "FIGCAPTION", "FIGURE", "FOOTER", "FORM", "FRAMESET", "H1", "H2", "H3", "H4", "H5", "H6", "HEADER", "HGROUP", "HR", "HTML", "ISINDEX", "LI", "MAIN", "MENU", "NAV", "NOFRAMES", "NOSCRIPT", "OL", "OUTPUT", "P", "PRE", "SECTION", "TABLE", "TBODY", "TD", "TFOOT", "TH", "THEAD", "TR", "UL"];
function Hu(o) {
  return Uu(o, tD);
}
var av = ["AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "META", "PARAM", "SOURCE", "TRACK", "WBR"];
function lv(o) {
  return Uu(o, av);
}
var Kf = ["A", "TABLE", "THEAD", "TBODY", "TFOOT", "TH", "TD", "IFRAME", "SCRIPT", "AUDIO", "VIDEO"];
function Uu(o, n) {
  return n.indexOf(o.nodeName) >= 0;
}
function Yf(o, n) {
  return o.getElementsByTagName && n.some(function(t) {
    return o.getElementsByTagName(t).length;
  });
}
var Ce = {};
function Zs(o) {
  return o ? o.replace(/(\n+\s*)+/g, `
`) : "";
}
function cv(o) {
  for (var n in this.options = o, this._keep = [], this._remove = [], this.blankRule = { replacement: o.blankReplacement }, this.keepReplacement = o.keepReplacement, this.defaultRule = { replacement: o.defaultReplacement }, this.array = [], o.rules) this.array.push(o.rules[n]);
}
function yc(o, n, t) {
  for (var e = 0; e < o.length; e++) {
    var i = o[e];
    if (eD(i, n, t)) return i;
  }
}
function eD(o, n, t) {
  var e = o.filter;
  if (typeof e == "string") {
    if (e === n.nodeName.toLowerCase()) return !0;
  } else if (Array.isArray(e)) {
    if (e.indexOf(n.nodeName.toLowerCase()) > -1) return !0;
  } else {
    if (typeof e != "function") throw new TypeError("`filter` needs to be a string, array, or function");
    if (e.call(o, n, t)) return !0;
  }
}
function Cc(o) {
  var n = o.nextSibling || o.parentNode;
  return o.parentNode.removeChild(o), n;
}
function Zf(o, n, t) {
  return o && o.parentNode === n || t(n) ? n.nextSibling || n.parentNode : n.firstChild || n.nextSibling || n.parentNode;
}
Ce.paragraph = { filter: "p", replacement: function(o) {
  return `

` + o + `

`;
} }, Ce.lineBreak = { filter: "br", replacement: function(o, n, t) {
  return t.br + `
`;
} }, Ce.heading = { filter: ["h1", "h2", "h3", "h4", "h5", "h6"], replacement: function(o, n, t) {
  var e = Number(n.nodeName.charAt(1));
  return t.headingStyle === "setext" && e < 3 ? `

` + o + `
` + vc(e === 1 ? "=" : "-", o.length) + `

` : `

` + vc("#", e) + " " + o + `

`;
} }, Ce.blockquote = { filter: "blockquote", replacement: function(o) {
  return `

` + (o = (o = o.replace(/^\n+|\n+$/g, "")).replace(/^/gm, "> ")) + `

`;
} }, Ce.list = { filter: ["ul", "ol"], replacement: function(o, n) {
  var t = n.parentNode;
  return t.nodeName === "LI" && t.lastElementChild === n ? `
` + o : `

` + o + `

`;
} }, Ce.listItem = { filter: "li", replacement: function(o, n, t) {
  o = o.replace(/^\n+/, "").replace(/\n+$/, `
`).replace(/\n/gm, `
    `);
  var e = t.bulletListMarker + "   ", i = n.parentNode;
  if (i.nodeName === "OL") {
    var r = i.getAttribute("start"), s = Array.prototype.indexOf.call(i.children, n);
    e = (r ? Number(r) + s : s + 1) + ".  ";
  }
  return e + o + (n.nextSibling && !/\n$/.test(o) ? `
` : "");
} }, Ce.indentedCodeBlock = { filter: function(o, n) {
  return n.codeBlockStyle === "indented" && o.nodeName === "PRE" && o.firstChild && o.firstChild.nodeName === "CODE";
}, replacement: function(o, n, t) {
  return `

    ` + n.firstChild.textContent.replace(/\n/g, `
    `) + `

`;
} }, Ce.fencedCodeBlock = { filter: function(o, n) {
  return n.codeBlockStyle === "fenced" && o.nodeName === "PRE" && o.firstChild && o.firstChild.nodeName === "CODE";
}, replacement: function(o, n, t) {
  for (var e, i = ((n.firstChild.getAttribute("class") || "").match(/language-(\S+)/) || [null, ""])[1], r = n.firstChild.textContent, s = t.fence.charAt(0), a = 3, l = new RegExp("^" + s + "{3,}", "gm"); e = l.exec(r); ) e[0].length >= a && (a = e[0].length + 1);
  var c = vc(s, a);
  return `

` + c + i + `
` + r.replace(/\n$/, "") + `
` + c + `

`;
} }, Ce.horizontalRule = { filter: "hr", replacement: function(o, n, t) {
  return `

` + t.hr + `

`;
} }, Ce.inlineLink = { filter: function(o, n) {
  return n.linkStyle === "inlined" && o.nodeName === "A" && o.getAttribute("href");
}, replacement: function(o, n) {
  var t = n.getAttribute("href");
  t && (t = t.replace(/([()])/g, "\\$1"));
  var e = Zs(n.getAttribute("title"));
  return e && (e = ' "' + e.replace(/"/g, '\\"') + '"'), "[" + o + "](" + t + e + ")";
} }, Ce.referenceLink = { filter: function(o, n) {
  return n.linkStyle === "referenced" && o.nodeName === "A" && o.getAttribute("href");
}, replacement: function(o, n, t) {
  var e, i, r = n.getAttribute("href"), s = Zs(n.getAttribute("title"));
  switch (s && (s = ' "' + s + '"'), t.linkReferenceStyle) {
    case "collapsed":
      e = "[" + o + "][]", i = "[" + o + "]: " + r + s;
      break;
    case "shortcut":
      e = "[" + o + "]", i = "[" + o + "]: " + r + s;
      break;
    default:
      var a = this.references.length + 1;
      e = "[" + o + "][" + a + "]", i = "[" + a + "]: " + r + s;
  }
  return this.references.push(i), e;
}, references: [], append: function(o) {
  var n = "";
  return this.references.length && (n = `

` + this.references.join(`
`) + `

`, this.references = []), n;
} }, Ce.emphasis = { filter: ["em", "i"], replacement: function(o, n, t) {
  return o.trim() ? t.emDelimiter + o + t.emDelimiter : "";
} }, Ce.strong = { filter: ["strong", "b"], replacement: function(o, n, t) {
  return o.trim() ? t.strongDelimiter + o + t.strongDelimiter : "";
} }, Ce.code = { filter: function(o) {
  var n = o.previousSibling || o.nextSibling, t = o.parentNode.nodeName === "PRE" && !n;
  return o.nodeName === "CODE" && !t;
}, replacement: function(o) {
  if (!o) return "";
  o = o.replace(/\r?\n|\r/g, " ");
  for (var n = /^`|^ .*?[^ ].* $|`$/.test(o) ? " " : "", t = "`", e = o.match(/`+/gm) || []; e.indexOf(t) !== -1; ) t += "`";
  return t + n + o + n + t;
} }, Ce.image = { filter: "img", replacement: function(o, n) {
  var t = Zs(n.getAttribute("alt")), e = n.getAttribute("src") || "", i = Zs(n.getAttribute("title"));
  return e ? "![" + t + "](" + e + (i ? ' "' + i + '"' : "") + ")" : "";
} }, cv.prototype = { add: function(o, n) {
  this.array.unshift(n);
}, keep: function(o) {
  this._keep.unshift({ filter: o, replacement: this.keepReplacement });
}, remove: function(o) {
  this._remove.unshift({ filter: o, replacement: function() {
    return "";
  } });
}, forNode: function(o) {
  return o.isBlank ? this.blankRule : (n = yc(this.array, o, this.options)) || (n = yc(this._keep, o, this.options)) || (n = yc(this._remove, o, this.options)) ? n : this.defaultRule;
  var n;
}, forEach: function(o) {
  for (var n = 0; n < this.array.length; n++) o(this.array[n], n);
} };
var Ac = typeof window < "u" ? window : {}, Qf, nD = function() {
  var o = Ac.DOMParser, n = !1;
  try {
    new o().parseFromString("", "text/html") && (n = !0);
  } catch {
  }
  return n;
}() ? Ac.DOMParser : function() {
  var o = function() {
  };
  return function() {
    var n = !1;
    try {
      document.implementation.createHTMLDocument("").open();
    } catch {
      Ac.ActiveXObject && (n = !0);
    }
    return n;
  }() ? o.prototype.parseFromString = function(n) {
    var t = new window.ActiveXObject("htmlfile");
    return t.designMode = "on", t.open(), t.write(n), t.close(), t;
  } : o.prototype.parseFromString = function(n) {
    var t = document.implementation.createHTMLDocument("");
    return t.open(), t.write(n), t.close(), t;
  }, o;
}();
function iD(o, n) {
  var t;
  return typeof o == "string" ? t = (Qf = Qf || new nD()).parseFromString('<x-turndown id="turndown-root">' + o + "</x-turndown>", "text/html").getElementById("turndown-root") : t = o.cloneNode(!0), function(e) {
    var i = e.element, r = e.isBlock, s = e.isVoid, a = e.isPre || function(f) {
      return f.nodeName === "PRE";
    };
    if (i.firstChild && !a(i)) {
      for (var l = null, c = !1, d = null, u = Zf(d, i, a); u !== i; ) {
        if (u.nodeType === 3 || u.nodeType === 4) {
          var h = u.data.replace(/[ \r\n\t]+/g, " ");
          if (l && !/ $/.test(l.data) || c || h[0] !== " " || (h = h.substr(1)), !h) {
            u = Cc(u);
            continue;
          }
          u.data = h, l = u;
        } else {
          if (u.nodeType !== 1) {
            u = Cc(u);
            continue;
          }
          r(u) || u.nodeName === "BR" ? (l && (l.data = l.data.replace(/ $/, "")), l = null, c = !1) : s(u) || a(u) ? (l = null, c = !0) : l && (c = !1);
        }
        var g = Zf(d, u, a);
        d = u, u = g;
      }
      l && (l.data = l.data.replace(/ $/, ""), l.data || Cc(l));
    }
  }({ element: t, isBlock: Hu, isVoid: lv, isPre: n.preformattedCode ? oD : null }), t;
}
function oD(o) {
  return o.nodeName === "PRE" || o.nodeName === "CODE";
}
function rD(o, n) {
  return o.isBlock = Hu(o), o.isCode = o.nodeName === "CODE" || o.parentNode.isCode, o.isBlank = function(t) {
    return !lv(t) && !function(e) {
      return Uu(e, Kf);
    }(t) && /^\s*$/i.test(t.textContent) && !function(e) {
      return Yf(e, av);
    }(t) && !function(e) {
      return Yf(e, Kf);
    }(t);
  }(o), o.flankingWhitespace = function(t, e) {
    if (t.isBlock || e.preformattedCode && t.isCode) return { leading: "", trailing: "" };
    var i = (r = t.textContent, s = r.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/), { leading: s[1], leadingAscii: s[2], leadingNonAscii: s[3], trailing: s[4], trailingNonAscii: s[5], trailingAscii: s[6] }), r, s;
    return i.leadingAscii && Jf("left", t, e) && (i.leading = i.leadingNonAscii), i.trailingAscii && Jf("right", t, e) && (i.trailing = i.trailingNonAscii), { leading: i.leading, trailing: i.trailing };
  }(o, n), o;
}
function Jf(o, n, t) {
  var e, i, r;
  return o === "left" ? (e = n.previousSibling, i = / $/) : (e = n.nextSibling, i = /^ /), e && (e.nodeType === 3 ? r = i.test(e.nodeValue) : t.preformattedCode && e.nodeName === "CODE" ? r = !1 : e.nodeType !== 1 || Hu(e) || (r = i.test(e.textContent))), r;
}
var sD = Array.prototype.reduce, aD = [[/\\/g, "\\\\"], [/\*/g, "\\*"], [/^-/g, "\\-"], [/^\+ /g, "\\+ "], [/^(=+)/g, "\\$1"], [/^(#{1,6}) /g, "\\$1 "], [/`/g, "\\`"], [/^~~~/g, "\\~~~"], [/\[/g, "\\["], [/\]/g, "\\]"], [/^>/g, "\\>"], [/_/g, "\\_"], [/^(\d+)\. /g, "$1\\. "]];
function Ua(o) {
  if (!(this instanceof Ua)) return new Ua(o);
  var n = { rules: Ce, headingStyle: "setext", hr: "* * *", bulletListMarker: "*", codeBlockStyle: "indented", fence: "```", emDelimiter: "_", strongDelimiter: "**", linkStyle: "inlined", linkReferenceStyle: "full", br: "  ", preformattedCode: !1, blankReplacement: function(t, e) {
    return e.isBlock ? `

` : "";
  }, keepReplacement: function(t, e) {
    return e.isBlock ? `

` + e.outerHTML + `

` : e.outerHTML;
  }, defaultReplacement: function(t, e) {
    return e.isBlock ? `

` + t + `

` : t;
  } };
  this.options = function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var r in i) i.hasOwnProperty(r) && (t[r] = i[r]);
    }
    return t;
  }({}, n, o), this.rules = new cv(this.options);
}
function dv(o) {
  var n = this;
  return sD.call(o.childNodes, function(t, e) {
    var i = "";
    return (e = new rD(e, n.options)).nodeType === 3 ? i = e.isCode ? e.nodeValue : n.escape(e.nodeValue) : e.nodeType === 1 && (i = cD.call(n, e)), uv(t, i);
  }, "");
}
function lD(o) {
  var n = this;
  return this.rules.forEach(function(t) {
    typeof t.append == "function" && (o = uv(o, t.append(n.options)));
  }), o.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function cD(o) {
  var n = this.rules.forNode(o), t = dv.call(this, o), e = o.flankingWhitespace;
  return (e.leading || e.trailing) && (t = t.trim()), e.leading + n.replacement(t, o, this.options) + e.trailing;
}
function uv(o, n) {
  var t = function(r) {
    for (var s = r.length; s > 0 && r[s - 1] === `
`; ) s--;
    return r.substring(0, s);
  }(o), e = n.replace(/^\n*/, ""), i = Math.max(o.length - t.length, n.length - e.length);
  return t + `

`.substring(0, i) + e;
}
Ua.prototype = { turndown: function(o) {
  if (!function(t) {
    return t != null && (typeof t == "string" || t.nodeType && (t.nodeType === 1 || t.nodeType === 9 || t.nodeType === 11));
  }(o)) throw new TypeError(o + " is not a string, or an element/document/fragment node.");
  if (o === "") return "";
  var n = dv.call(this, new iD(o, this.options));
  return lD.call(this, n);
}, use: function(o) {
  if (Array.isArray(o)) for (var n = 0; n < o.length; n++) this.use(o[n]);
  else {
    if (typeof o != "function") throw new TypeError("plugin must be a Function or an Array of Functions");
    o(this);
  }
  return this;
}, addRule: function(o, n) {
  return this.rules.add(o, n), this;
}, keep: function(o) {
  return this.rules.keep(o), this;
}, remove: function(o) {
  return this.rules.remove(o), this;
}, escape: function(o) {
  return aD.reduce(function(n, t) {
    return n.replace(t[0], t[1]);
  }, o);
} };
var Xf = /highlight-(?:text|source)-([a-z0-9]+)/;
function dD(o) {
  o.addRule("highlightedCodeBlock", { filter: function(n) {
    var t = n.firstChild;
    return n.nodeName === "DIV" && Xf.test(n.className) && t && t.nodeName === "PRE";
  }, replacement: function(n, t, e) {
    var i = ((t.className || "").match(Xf) || [null, ""])[1];
    return `

` + e.fence + i + `
` + t.firstChild.textContent + `
` + e.fence + `

`;
  } });
}
function uD(o) {
  o.addRule("strikethrough", { filter: ["del", "s", "strike"], replacement: function(n) {
    return "~" + n + "~";
  } });
}
var hD = Array.prototype.indexOf, mD = Array.prototype.every, Vo = {};
function Pd(o) {
  var n, t, e = o.parentNode;
  return e.nodeName === "THEAD" || e.firstChild === o && (e.nodeName === "TABLE" || (t = (n = e).previousSibling, n.nodeName === "TBODY" && (!t || t.nodeName === "THEAD" && /^\s*$/i.test(t.textContent)))) && mD.call(o.childNodes, function(i) {
    return i.nodeName === "TH";
  });
}
function tp(o, n) {
  var t = " ";
  return hD.call(n.parentNode.childNodes, n) === 0 && (t = "| "), t + o + " |";
}
function gD(o) {
  for (var n in o.keep(function(t) {
    return t.nodeName === "TABLE" && !Pd(t.rows[0]);
  }), Vo) o.addRule(n, Vo[n]);
}
function fD(o) {
  o.addRule("taskListItems", { filter: function(n) {
    return n.type === "checkbox" && n.parentNode.nodeName === "LI";
  }, replacement: function(n, t) {
    return (t.checked ? "[x]" : "[ ]") + " ";
  } });
}
function pD(o) {
  o.use([dD, uD, gD, fD]);
}
Vo.tableCell = { filter: ["th", "td"], replacement: function(o, n) {
  return tp(o, n);
} }, Vo.tableRow = { filter: "tr", replacement: function(o, n) {
  var t = "", e = { left: ":--", right: "--:", center: ":-:" };
  if (Pd(n)) for (var i = 0; i < n.childNodes.length; i++) {
    var r = "---", s = (n.childNodes[i].getAttribute("align") || "").toLowerCase();
    s && (r = e[s] || r), t += tp(r, n.childNodes[i]);
  }
  return `
` + o + (t ? `
` + t : "");
} }, Vo.table = { filter: function(o) {
  return o.nodeName === "TABLE" && Pd(o.rows[0]);
}, replacement: function(o) {
  return `

` + (o = o.replace(`

`, `
`)) + `

`;
} }, Vo.tableSection = { filter: ["thead", "tbody", "tfoot"], replacement: function(o) {
  return o;
} };
const bD = new RegExp(/\b(?:(?:https?|ftp):\/\/|www\.)/.source + /(?![-_])(?:[-_a-z0-9\u00a1-\uffff]{1,63}\.)+(?:[a-z\u00a1-\uffff]{2,63})/.source + /(?:[^\s<>]*)/.source, "gi");
class kD extends Ua {
  escape(n) {
    const t = super.escape;
    function e(s) {
      return s = (s = t(s)).replace(/</g, "\\<");
    }
    let i = "", r = 0;
    for (const s of this._matchAutolink(n)) {
      const a = s.index;
      a > r && (i += e(n.substring(r, a)));
      const l = s[0];
      i += l, r = a + l.length;
    }
    return r < n.length && (i += e(n.substring(r, n.length))), i;
  }
  *_matchAutolink(n) {
    for (const t of n.matchAll(bD)) {
      const e = t[0], i = this._autolinkFindEnd(e);
      yield Object.assign([e.substring(0, i)], { index: t.index });
    }
  }
  _autolinkFindEnd(n) {
    let t = n.length;
    for (; t > 0; ) {
      const e = n[t - 1];
      if (`?!.,:*_~'"`.includes(e)) t--;
      else {
        if (e != ")") break;
        {
          let i = 0;
          for (let r = 0; r < t; r++) n[r] == "(" ? i++ : n[r] == ")" && i--;
          if (!(i < 0)) break;
          t--;
        }
      }
    }
    return t;
  }
}
class wD {
  constructor() {
    m(this, "_parser");
    this._parser = this._createParser();
  }
  parse(n) {
    return this._parser.turndown(n);
  }
  keep(n) {
    this._parser.keep(n);
  }
  _createParser() {
    const n = new kD({ codeBlockStyle: "fenced", hr: "---", headingStyle: "atx" });
    return n.use([pD, this._todoList]), n;
  }
  _todoList(n) {
    n.addRule("taskListItems", { filter: (t) => t.type === "checkbox" && (t.parentNode.nodeName === "LI" || t.parentNode.parentNode.nodeName === "LI"), replacement: (t, e) => (e.checked ? "[x]" : "[ ]") + " " });
  }
}
class hv {
  constructor(n) {
    m(this, "_htmlDP");
    m(this, "_markdown2html");
    m(this, "_html2markdown");
    this._htmlDP = new tw(n), this._markdown2html = new XM(), this._html2markdown = new wD();
  }
  keepHtml(n) {
    this._html2markdown.keep([n]);
  }
  toView(n) {
    const t = this._markdown2html.parse(n);
    return this._htmlDP.toView(t);
  }
  toData(n) {
    const t = this._htmlDP.toData(n);
    return this._html2markdown.parse(t);
  }
  registerRawContentMatcher(n) {
    this._htmlDP.registerRawContentMatcher(n);
  }
  useFillerType() {
  }
}
class _D extends A {
  constructor(n) {
    super(n), n.data.processor = new hv(n.data.viewDocument);
  }
  static get pluginName() {
    return "Markdown";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
const vD = ["SPAN", "BR", "PRE", "CODE"];
class yD extends A {
  constructor(t) {
    super(t);
    m(this, "_gfmDataProcessor");
    this._gfmDataProcessor = new hv(t.data.viewDocument);
  }
  static get pluginName() {
    return "PasteFromMarkdownExperimental";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [De];
  }
  init() {
    const t = this.editor, e = t.editing.view.document, i = t.plugins.get("ClipboardPipeline");
    let r = !1;
    this.listenTo(e, "keydown", (s, a) => {
      r = a.shiftKey;
    }), this.listenTo(i, "inputTransformation", (s, a) => {
      if (r) return;
      const l = a.dataTransfer.getData("text/html");
      if (!l) {
        const d = a.dataTransfer.getData("text/plain");
        return void (a.content = this._gfmDataProcessor.toView(d));
      }
      const c = this._parseMarkdownFromHtml(l);
      c && (a.content = this._gfmDataProcessor.toView(c));
    });
  }
  _parseMarkdownFromHtml(t) {
    const e = this._removeOsSpecificTags(t);
    if (!this._containsOnlyAllowedFirstLevelTags(e)) return null;
    const i = this._removeFirstLevelWrapperTagsAndBrs(e);
    return this._containsAnyRemainingHtmlTags(i) ? null : this._replaceHtmlReservedEntitiesWithCharacters(i);
  }
  _removeOsSpecificTags(t) {
    return t.replace(/^<meta\b[^>]*>/, "").trim().replace(/^<html>/, "").replace(/<\/html>$/, "").trim().replace(/^<body>/, "").replace(/<\/body>$/, "").trim().replace(/^<!--StartFragment-->/, "").replace(/<!--EndFragment-->$/, "").trim();
  }
  _containsOnlyAllowedFirstLevelTags(t) {
    const e = new DOMParser(), { body: i } = e.parseFromString(t, "text/html");
    return Array.from(i.children).map((r) => r.tagName).every((r) => vD.includes(r));
  }
  _removeFirstLevelWrapperTagsAndBrs(t) {
    const e = new DOMParser(), { body: i } = e.parseFromString(t, "text/html"), r = i.querySelectorAll("br");
    for (const a of r) a.replaceWith(`
`);
    const s = i.querySelectorAll(":scope > *");
    for (const a of s) {
      const l = a.cloneNode(!0);
      a.replaceWith(...l.childNodes);
    }
    return i.innerHTML;
  }
  _containsAnyRemainingHtmlTags(t) {
    return t.includes("<");
  }
  _replaceHtmlReservedEntitiesWithCharacters(t) {
    return t.replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&nbsp;/g, " ");
  }
}
function ep(o, n) {
  const t = (e, i, r) => {
    if (!r.consumable.consume(i.item, e.name)) return;
    const s = i.attributeNewValue, a = r.writer, l = r.mapper.toViewElement(i.item), c = [...l.getChildren()].find((u) => u.getCustomProperty("media-content"));
    a.remove(c);
    const d = o.getMediaViewElement(a, s, n);
    a.insert(a.createPositionAt(l, 0), d);
  };
  return (e) => {
    e.on("attribute:url:media", t);
  };
}
function np(o, n, t, e) {
  return o.createContainerElement("figure", { class: "media" }, [n.getMediaViewElement(o, t, e), o.createSlot()]);
}
function ip(o) {
  const n = o.getSelectedElement();
  return n && n.is("element", "media") ? n : null;
}
function mv(o, n, t, e) {
  o.change((i) => {
    const r = i.createElement("media", { url: n });
    o.insertObject(r, t, null, { setSelection: "on", findOptimalPosition: e ? "auto" : void 0 });
  });
}
class CD extends q {
  refresh() {
    const n = this.editor.model, t = n.document.selection, e = ip(t);
    this.value = e ? e.getAttribute("url") : void 0, this.isEnabled = function(i) {
      const r = i.getSelectedElement();
      return !!r && r.name === "media";
    }(t) || function(i, r) {
      let a = Du(i, r).start.parent;
      return a.isEmpty && !r.schema.isLimit(a) && (a = a.parent), r.schema.checkChild(a, "media");
    }(t, n);
  }
  execute(n) {
    const t = this.editor.model, e = t.document.selection, i = ip(e);
    i ? t.change((r) => {
      r.setAttribute("url", n, i);
    }) : mv(t, n, e, !0);
  }
}
class AD {
  constructor(n, t) {
    m(this, "locale");
    m(this, "providerDefinitions");
    const e = t.providers, i = t.extraProviders || [], r = new Set(t.removeProviders), s = e.concat(i).filter((a) => {
      const l = a.name;
      return l ? !r.has(l) : (at("media-embed-no-provider-name", { provider: a }), !1);
    });
    this.locale = n, this.providerDefinitions = s;
  }
  hasMedia(n) {
    return !!this._getMedia(n);
  }
  getMediaViewElement(n, t, e) {
    return this._getMedia(t).getViewElement(n, e);
  }
  _getMedia(n) {
    if (!n) return new op(this.locale);
    n = n.trim();
    for (const t of this.providerDefinitions) {
      const e = t.html, i = Bt(t.url);
      for (const r of i) {
        const s = this._getUrlMatches(n, r);
        if (s) return new op(this.locale, n, s, e);
      }
    }
    return null;
  }
  _getUrlMatches(n, t) {
    let e = n.match(t);
    if (e) return e;
    let i = n.replace(/^https?:\/\//, "");
    return e = i.match(t), e || (i = i.replace(/^www\./, ""), e = i.match(t), e || null);
  }
}
class op {
  constructor(n, t, e, i) {
    m(this, "url");
    m(this, "_locale");
    m(this, "_match");
    m(this, "_previewRenderer");
    this.url = this._getValidUrl(t), this._locale = n, this._match = e, this._previewRenderer = i;
  }
  getViewElement(n, t) {
    const e = {};
    let i;
    if (t.renderForEditingView || t.renderMediaPreview && this.url && this._previewRenderer) {
      this.url && (e["data-oembed-url"] = this.url), t.renderForEditingView && (e.class = "ck-media__wrapper");
      const r = this._getPreviewHtml(t);
      i = n.createRawElement("div", e, (s, a) => {
        a.setContentOf(s, r);
      });
    } else this.url && (e.url = this.url), i = n.createEmptyElement(t.elementName, e);
    return n.setCustomProperty("media-content", !0, i), i;
  }
  _getPreviewHtml(n) {
    return this._previewRenderer ? this._previewRenderer(this._match) : this.url && n.renderForEditingView ? this._getPlaceholderHtml() : "";
  }
  _getPlaceholderHtml() {
    const n = new cn(), t = this._locale.t;
    return n.content = F2, n.viewBox = "0 0 64 42", new sn({ tag: "div", attributes: { class: "ck ck-reset_all ck-media__placeholder" }, children: [{ tag: "div", attributes: { class: "ck-media__placeholder__icon" }, children: [n] }, { tag: "a", attributes: { class: "ck-media__placeholder__url", target: "_blank", rel: "noopener noreferrer", href: this.url, "data-cke-tooltip-text": t("Open media in new tab") }, children: [{ tag: "span", attributes: { class: "ck-media__placeholder__url__text" }, children: [this.url] }] }] }).render().outerHTML;
  }
  _getValidUrl(n) {
    return n ? n.match(/^https?/) ? n : "https://" + n : null;
  }
}
class $a extends A {
  constructor(t) {
    super(t);
    m(this, "registry");
    t.config.define("mediaEmbed", { elementName: "oembed", providers: [{ name: "dailymotion", url: [/^dailymotion\.com\/video\/(\w+)/, /^dai.ly\/(\w+)/], html: (e) => `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${e[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>` }, { name: "spotify", url: [/^open\.spotify\.com\/(artist\/\w+)/, /^open\.spotify\.com\/(album\/\w+)/, /^open\.spotify\.com\/(track\/\w+)/], html: (e) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${e[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>` }, { name: "youtube", url: [/^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/, /^(?:m\.)?youtube\.com\/shorts\/([\w-]+)(?:\?t=(\d+))?/, /^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/, /^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/, /^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/], html: (e) => {
      const i = e[1], r = e[2];
      return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${i}${r ? `?start=${r}` : ""}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>`;
    } }, { name: "vimeo", url: [/^vimeo\.com\/(\d+)/, /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/channels\/[^/]+\/(\d+)/, /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/, /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/, /^player\.vimeo\.com\/video\/(\d+)/], html: (e) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${e[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>` }, { name: "instagram", url: [/^instagram\.com\/p\/(\w+)/, /^instagram\.com\/reel\/(\w+)/] }, { name: "twitter", url: [/^twitter\.com/, /^x\.com/] }, { name: "googleMaps", url: [/^google\.com\/maps/, /^goo\.gl\/maps/, /^maps\.google\.com/, /^maps\.app\.goo\.gl/] }, { name: "flickr", url: /^flickr\.com/ }, { name: "facebook", url: /^facebook\.com/ }] }), this.registry = new AD(t.locale, t.config.get("mediaEmbed"));
  }
  static get pluginName() {
    return "MediaEmbedEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor, e = t.model.schema, i = t.t, r = t.conversion, s = t.config.get("mediaEmbed.previewsInData"), a = t.config.get("mediaEmbed.elementName"), l = this.registry;
    t.commands.add("mediaEmbed", new CD(t)), e.register("media", { inheritAllFrom: "$blockObject", allowAttributes: ["url"] }), r.for("dataDowncast").elementToStructure({ model: "media", view: (c, { writer: d }) => {
      const u = c.getAttribute("url");
      return np(d, l, u, { elementName: a, renderMediaPreview: !!u && s });
    } }), r.for("dataDowncast").add(ep(l, { elementName: a, renderMediaPreview: s })), r.for("editingDowncast").elementToStructure({ model: "media", view: (c, { writer: d }) => {
      const u = c.getAttribute("url");
      return function(h, g, f) {
        return g.setCustomProperty("media", !0, h), bl(h, g, { label: f });
      }(np(d, l, u, { elementName: a, renderForEditingView: !0 }), d, i("media widget"));
    } }), r.for("editingDowncast").add(ep(l, { elementName: a, renderForEditingView: !0 })), r.for("upcast").elementToElement({ view: (c) => ["oembed", a].includes(c.name) && c.getAttribute("url") ? { name: !0 } : null, model: (c, { writer: d }) => {
      const u = c.getAttribute("url");
      return l.hasMedia(u) ? d.createElement("media", { url: u }) : null;
    } }).elementToElement({ view: { name: "div", attributes: { "data-oembed-url": !0 } }, model: (c, { writer: d }) => {
      const u = c.getAttribute("data-oembed-url");
      return l.hasMedia(u) ? d.createElement("media", { url: u }) : null;
    } }).add((c) => {
      c.on("element:figure", (d, u, h) => {
        if (!h.consumable.consume(u.viewItem, { name: !0, classes: "media" })) return;
        const { modelRange: g, modelCursor: f } = h.convertChildren(u.viewItem, u.modelCursor);
        u.modelRange = g, u.modelCursor = f, yt(g.getItems()) || h.consumable.revert(u.viewItem, { name: !0, classes: "media" });
      });
    });
  }
}
const xD = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;
class ED extends A {
  constructor(t) {
    super(t);
    m(this, "_timeoutId");
    m(this, "_positionToInsert");
    this._timeoutId = null, this._positionToInsert = null;
  }
  static get requires() {
    return [Pu, Rn, Bu];
  }
  static get pluginName() {
    return "AutoMediaEmbed";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor, e = t.model.document, i = t.plugins.get("ClipboardPipeline");
    this.listenTo(i, "inputTransformation", () => {
      const r = e.selection.getFirstRange(), s = Gt.fromPosition(r.start);
      s.stickiness = "toPrevious";
      const a = Gt.fromPosition(r.end);
      a.stickiness = "toNext", e.once("change:data", () => {
        this._embedMediaBetweenPositions(s, a), s.detach(), a.detach();
      }, { priority: "high" });
    }), t.commands.get("undo").on("execute", () => {
      this._timeoutId && (N.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null);
    }, { priority: "high" });
  }
  _embedMediaBetweenPositions(t, e) {
    const i = this.editor, r = i.plugins.get($a).registry, s = new Ie(t, e), a = s.getWalker({ ignoreElementEnd: !0 });
    let l = "";
    for (const c of a) c.item.is("$textProxy") && (l += c.item.data);
    if (l = l.trim(), !l.match(xD) || !r.hasMedia(l)) return void s.detach();
    i.commands.get("mediaEmbed").isEnabled ? (this._positionToInsert = Gt.fromPosition(t), this._timeoutId = N.window.setTimeout(() => {
      i.model.change((c) => {
        this._timeoutId = null, c.remove(s), s.detach();
        let d = null;
        this._positionToInsert.root.rootName !== "$graveyard" && (d = this._positionToInsert), mv(i.model, l, d, !1), this._positionToInsert.detach(), this._positionToInsert = null;
      }), i.plugins.get(Rn).requestUndoOnBackspace();
    }, 100)) : s.detach();
  }
}
class TD extends L {
  constructor(t, e) {
    super(e);
    m(this, "focusTracker");
    m(this, "keystrokes");
    m(this, "urlInputView");
    m(this, "_validators");
    m(this, "_urlInputViewInfoDefault");
    m(this, "_urlInputViewInfoTip");
    this.focusTracker = new gt(), this.keystrokes = new Mt(), this.set("mediaURLInputValue", ""), this.urlInputView = this._createUrlInput(), this._validators = t, this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-media-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.urlInputView] });
  }
  render() {
    super.render(), ar({ view: this }), this.focusTracker.add(this.urlInputView.element), this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  focus() {
    this.urlInputView.focus();
  }
  get url() {
    return this.urlInputView.fieldView.element.value.trim();
  }
  set url(t) {
    this.urlInputView.fieldView.value = t.trim();
  }
  isValid() {
    this.resetFormStatus();
    for (const t of this._validators) {
      const e = t(this);
      if (e) return this.urlInputView.errorText = e, !1;
    }
    return !0;
  }
  resetFormStatus() {
    this.urlInputView.errorText = null, this.urlInputView.infoText = this._urlInputViewInfoDefault;
  }
  _createUrlInput() {
    const t = this.locale.t, e = new Nn(this.locale, Mi), i = e.fieldView;
    return this._urlInputViewInfoDefault = t("Paste the media URL in the input."), this._urlInputViewInfoTip = t("Tip: Paste the URL into the content to embed faster."), e.label = t("Media URL"), e.infoText = this._urlInputViewInfoDefault, i.inputMode = "url", i.on("input", () => {
      e.infoText = i.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault, this.mediaURLInputValue = i.element.value.trim();
    }), e;
  }
}
class SD extends A {
  constructor() {
    super(...arguments);
    m(this, "_formView");
  }
  static get requires() {
    return [$a, no];
  }
  static get pluginName() {
    return "MediaEmbedUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor;
    t.ui.componentFactory.add("mediaEmbed", () => {
      const e = this.editor.locale.t, i = this._createDialogButton(V);
      return i.tooltip = !0, i.label = e("Insert media"), i;
    }), t.ui.componentFactory.add("menuBar:mediaEmbed", () => {
      const e = this.editor.locale.t, i = this._createDialogButton(Et);
      return i.label = e("Media"), i;
    });
  }
  _createDialogButton(t) {
    const e = this.editor, i = new t(e.locale), r = e.commands.get("mediaEmbed"), s = this.editor.plugins.get("Dialog");
    return i.icon = j2, i.bind("isEnabled").to(r, "isEnabled"), i.on("execute", () => {
      s.id === "mediaEmbed" ? s.hide() : this._showDialog();
    }), i;
  }
  _showDialog() {
    const t = this.editor, e = t.plugins.get("Dialog"), i = t.commands.get("mediaEmbed"), r = t.locale.t, s = i.value !== void 0;
    if (!this._formView) {
      const a = t.plugins.get($a).registry;
      this._formView = new (rs(TD))(/* @__PURE__ */ function(l, c) {
        return [(d) => {
          if (!d.url.length) return l("The URL must not be empty.");
        }, (d) => {
          if (!c.hasMedia(d.url)) return l("This media URL is not supported.");
        }];
      }(t.t, a), t.locale), this._formView.on("submit", () => this._handleSubmitForm());
    }
    e.show({ id: "mediaEmbed", title: r("Media embed"), content: this._formView, isModal: !0, onShow: () => {
      this._formView.url = i.value || "", this._formView.resetFormStatus(), this._formView.urlInputView.fieldView.select();
    }, actionButtons: [{ label: r("Cancel"), withText: !0, onExecute: () => e.hide() }, { label: r(s ? "Save" : "Insert"), class: "ck-button-action", withText: !0, onExecute: () => this._handleSubmitForm() }] });
  }
  _handleSubmitForm() {
    const t = this.editor, e = t.plugins.get("Dialog");
    this._formView.isValid() && (t.execute("mediaEmbed", this._formView.url), e.hide(), t.editing.view.focus());
  }
}
class ID extends A {
  static get requires() {
    return [$a, SD, ED, cr];
  }
  static get pluginName() {
    return "MediaEmbed";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
const rp = { "(": ")", "[": "]", "{": "}" };
class MD extends q {
  constructor(n) {
    super(n), this._isEnabledBasedOnSelection = !1;
  }
  refresh() {
    const n = this.editor.model, t = n.document;
    this.isEnabled = n.schema.checkAttributeInSelection(t.selection, "mention");
  }
  execute(n) {
    const t = this.editor.model, e = t.document.selection, i = typeof n.mention == "string" ? { id: n.mention } : n.mention, r = i.id, s = n.range || e.getFirstRange();
    if (!t.canEditAt(s)) return;
    const a = n.text || r, l = gv({ _text: a, id: r }, i);
    if (!r.startsWith(n.marker)) throw new v("mentioncommand-incorrect-id", this);
    t.change((c) => {
      const d = wn(e.getAttributes()), u = new Map(d.entries());
      u.set("mention", l);
      const h = t.insertContent(c.createText(a, u), s), g = h.start.nodeBefore, f = h.end.nodeAfter, p = f && f.is("$text") && f.data.startsWith(" ");
      let b = !1;
      if (g && f && g.is("$text") && f.is("$text")) {
        const k = g.data.slice(-1), w = k in rp, _ = w && f.data.startsWith(rp[k]);
        b = w && _;
      }
      b || p || t.insertContent(c.createText(" ", d), s.start.getShiftedBy(a.length));
    });
  }
}
class DD extends A {
  static get pluginName() {
    return "MentionEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.model, e = t.document;
    t.schema.extend("$text", { allowAttributes: "mention" }), n.conversion.for("upcast").elementToAttribute({ view: { name: "span", attributes: "data-mention", classes: "mention" }, model: { key: "mention", value: (i) => fv(i) } }), n.conversion.for("downcast").attributeToElement({ model: "mention", view: LD }), n.conversion.for("downcast").add(PD), e.registerPostFixer((i) => function(r, s, a) {
      const l = s.differ.getChanges();
      let c = !1;
      for (const d of l) {
        if (d.type == "attribute") continue;
        const u = d.position;
        if (d.name == "$text") {
          const h = u.textNode && u.textNode.nextSibling;
          c = $i(u.textNode, r) || c, c = $i(h, r) || c, c = $i(u.nodeBefore, r) || c, c = $i(u.nodeAfter, r) || c;
        }
        if (d.name != "$text" && d.type == "insert") {
          const h = u.nodeAfter;
          for (const g of r.createRangeIn(h).getItems()) c = $i(g, r) || c;
        }
        if (d.type == "insert" && a.isInline(d.name)) {
          const h = u.nodeAfter && u.nodeAfter.nextSibling;
          c = $i(u.nodeBefore, r) || c, c = $i(h, r) || c;
        }
      }
      return c;
    }(i, e, t.schema)), e.registerPostFixer((i) => function(r, s) {
      const a = s.differ.getChanges();
      let l = !1;
      for (const c of a) if (c.type === "attribute" && c.attributeKey != "mention") {
        const d = c.range.start.nodeBefore, u = c.range.end.nodeAfter;
        for (const h of [d, u]) pv(h) && h.getAttribute(c.attributeKey) != c.attributeNewValue && (r.setAttribute(c.attributeKey, c.attributeNewValue, h), l = !0);
      }
      return l;
    }(i, e)), e.registerPostFixer((i) => function(r, s) {
      const a = s.selection, l = a.focus;
      return a.isCollapsed && a.hasAttribute("mention") && function(c) {
        const d = c.isAtStart;
        return c.nodeBefore && c.nodeBefore.is("$text") || d;
      }(l) ? (r.removeSelectionAttribute("mention"), !0) : !1;
    }(i, e)), n.commands.add("mention", new MD(n));
  }
}
function gv(o, n) {
  return Object.assign({ uid: Ee() }, o, n || {});
}
function fv(o, n) {
  const t = o.getAttribute("data-mention"), e = o.getChild(0);
  if (e)
    return gv({ id: t, _text: e.data }, n);
}
function PD(o) {
  o.on("attribute:mention", (n, t, e) => {
    const i = t.attributeNewValue;
    if (!t.item.is("$textProxy") || !i) return;
    const r = t.range.start;
    (r.textNode || r.nodeAfter).data != i._text && e.consumable.consume(t.item, n.name);
  }, { priority: "highest" });
}
function LD(o, { writer: n }) {
  if (!o) return;
  const t = { class: "mention", "data-mention": o.id }, e = { id: o.uid, priority: 20 };
  return n.createAttributeElement("span", t, e);
}
function pv(o) {
  return !o || !o.is("$text") && !o.is("$textProxy") || !o.hasAttribute("mention") ? !1 : o.data != o.getAttribute("mention")._text;
}
function $i(o, n) {
  return !!pv(o) && (n.removeAttribute("mention", o), !0);
}
class BD extends ho {
  constructor(t) {
    super(t);
    m(this, "selected");
    m(this, "position");
    this.extendTemplate({ attributes: { class: ["ck-mentions"], tabindex: "-1" } });
  }
  selectFirst() {
    this.select(0);
  }
  selectNext() {
    const t = this.selected, e = this.items.getIndex(t);
    this.select(e + 1);
  }
  selectPrevious() {
    const t = this.selected, e = this.items.getIndex(t);
    this.select(e - 1);
  }
  select(t) {
    let e = 0;
    t > 0 && t < this.items.length ? e = t : t < 0 && (e = this.items.length - 1);
    const i = this.items.get(e);
    this.selected !== i && (this.selected && this.selected.removeHighlight(), i.highlight(), this.selected = i, this._isItemVisibleInScrolledArea(i) || (this.element.scrollTop = i.element.offsetTop));
  }
  executeSelected() {
    this.selected.fire("execute");
  }
  _isItemVisibleInScrolledArea(t) {
    return new K(this.element).contains(new K(t.element));
  }
}
class ND extends L {
  constructor(t, e) {
    super(t);
    m(this, "domElement");
    this.template = void 0, this.domElement = e, this.domElement.classList.add("ck-button"), this.set("isOn", !1), this.on("change:isOn", (i, r, s) => {
      s ? (this.domElement.classList.add("ck-on"), this.domElement.classList.remove("ck-off")) : (this.domElement.classList.add("ck-off"), this.domElement.classList.remove("ck-on"));
    }), this.listenTo(this.domElement, "click", () => {
      this.fire("execute");
    });
  }
  render() {
    super.render(), this.element = this.domElement;
  }
  focus() {
    this.domElement.focus();
  }
}
class zD extends dn {
  constructor() {
    super(...arguments);
    m(this, "item");
    m(this, "marker");
  }
  highlight() {
    this.children.first.isOn = !0;
  }
  removeHighlight() {
    this.children.first.isOn = !1;
  }
}
const OD = [nt.arrowup, nt.arrowdown, nt.esc], RD = [nt.enter, nt.tab];
class VD extends A {
  constructor(t) {
    super(t);
    m(this, "_mentionsView");
    m(this, "_mentionsConfigurations");
    m(this, "_balloon");
    m(this, "_items", new ne());
    m(this, "_lastRequested");
    m(this, "_requestFeedDebounced");
    this._mentionsView = this._createMentionView(), this._mentionsConfigurations = /* @__PURE__ */ new Map(), this._requestFeedDebounced = kn(this._requestFeed, 100), t.config.define("mention", { feeds: [] });
  }
  static get pluginName() {
    return "MentionUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [On];
  }
  init() {
    const t = this.editor, e = t.config.get("mention.commitKeys") || RD, i = OD.concat(e);
    this._balloon = t.plugins.get(On), t.editing.view.document.on("keydown", (s, a) => {
      var l;
      l = a.keyCode, i.includes(l) && this._isUIVisible && (a.preventDefault(), s.stop(), a.keyCode == nt.arrowdown && this._mentionsView.selectNext(), a.keyCode == nt.arrowup && this._mentionsView.selectPrevious(), e.includes(a.keyCode) && this._mentionsView.executeSelected(), a.keyCode == nt.esc && this._hideUIAndRemoveMarker());
    }, { priority: "highest" }), Ni({ emitter: this._mentionsView, activator: () => this._isUIVisible, contextElements: () => [this._balloon.view.element], callback: () => this._hideUIAndRemoveMarker() });
    const r = t.config.get("mention.feeds");
    for (const s of r) {
      const { feed: a, marker: l, dropdownLimit: c } = s;
      if (!HD(l)) throw new v("mentionconfig-incorrect-marker", null, { marker: l });
      const d = { marker: l, feedCallback: typeof a == "function" ? a.bind(this.editor) : jD(a), itemRenderer: s.itemRenderer, dropdownLimit: c };
      this._mentionsConfigurations.set(l, d);
    }
    this._setupTextWatcher(r), this.listenTo(t, "change:isReadOnly", () => {
      this._hideUIAndRemoveMarker();
    }), this.on("requestFeed:response", (s, a) => this._handleFeedResponse(a)), this.on("requestFeed:error", () => this._hideUIAndRemoveMarker());
  }
  destroy() {
    super.destroy(), this._mentionsView.destroy();
  }
  get _isUIVisible() {
    return this._balloon.visibleView === this._mentionsView;
  }
  _createMentionView() {
    const t = this.editor.locale, e = new BD(t);
    return e.items.bindTo(this._items).using((i) => {
      const { item: r, marker: s } = i, { dropdownLimit: a } = this._mentionsConfigurations.get(s), l = a || this.editor.config.get("mention.dropdownLimit") || 10;
      if (e.items.length >= l) return null;
      const c = new zD(t), d = this._renderItem(r, s);
      return d.delegate("execute").to(c), c.children.add(d), c.item = r, c.marker = s, c.on("execute", () => {
        e.fire("execute", { item: r, marker: s });
      }), c;
    }), e.on("execute", (i, r) => {
      const s = this.editor, a = s.model, l = r.item, c = r.marker, d = s.model.markers.get("mention"), u = a.createPositionAt(a.document.selection.focus), h = a.createPositionAt(d.getStart()), g = a.createRange(h, u);
      this._hideUIAndRemoveMarker(), s.execute("mention", { mention: l, text: l.text, marker: c, range: g }), s.editing.view.focus();
    }), e;
  }
  _getItemRenderer(t) {
    const { itemRenderer: e } = this._mentionsConfigurations.get(t);
    return e;
  }
  _requestFeed(t, e) {
    this._lastRequested = e;
    const { feedCallback: i } = this._mentionsConfigurations.get(t), r = i(e);
    r instanceof Promise ? r.then((s) => {
      this._lastRequested == e ? this.fire("requestFeed:response", { feed: s, marker: t, feedText: e }) : this.fire("requestFeed:discarded", { feed: s, marker: t, feedText: e });
    }).catch((s) => {
      this.fire("requestFeed:error", { error: s }), at("mention-feed-callback-error", { marker: t });
    }) : this.fire("requestFeed:response", { feed: r, marker: t, feedText: e });
  }
  _setupTextWatcher(t) {
    const e = this.editor, i = t.map((a) => ({ ...a, pattern: ap(a.marker, a.minimumCharacters || 0) })), r = new e_(e.model, /* @__PURE__ */ function(a) {
      return (c) => {
        const d = sp(a, c);
        if (!d) return !1;
        let u = 0;
        d.position !== 0 && (u = d.position - 1);
        const h = c.substring(u);
        return d.pattern.test(h);
      };
    }(i));
    r.on("matched", (a, l) => {
      const c = sp(i, l.text), d = e.model.document.selection.focus, u = e.model.createPositionAt(d.parent, c.position);
      if (function(k) {
        const w = k.textNode && k.textNode.hasAttribute("mention"), _ = k.nodeBefore;
        return w || _ && _.is("$text") && _.hasAttribute("mention");
      }(d) || function(k) {
        const w = k.nodeAfter;
        return w && w.is("$text") && w.hasAttribute("mention");
      }(u)) return void this._hideUIAndRemoveMarker();
      const h = function(k, w) {
        let _ = 0;
        k.position !== 0 && (_ = k.position - 1);
        const y = ap(k.marker, 0);
        return w.substring(_).match(y)[2];
      }(c, l.text), g = c.marker.length + h.length, f = d.getShiftedBy(-g), p = d.getShiftedBy(-h.length), b = e.model.createRange(f, p);
      if (xc(e)) {
        const k = e.model.markers.get("mention");
        e.model.change((w) => {
          w.updateMarker(k, { range: b });
        });
      } else e.model.change((k) => {
        k.addMarker("mention", { range: b, usingOperation: !1, affectsData: !1 });
      });
      this._requestFeedDebounced(c.marker, h);
    }), r.on("unmatched", () => {
      this._hideUIAndRemoveMarker();
    });
    const s = e.commands.get("mention");
    return r.bind("isEnabled").to(s), r;
  }
  _handleFeedResponse(t) {
    const { feed: e, marker: i } = t;
    if (!xc(this.editor)) return;
    this._items.clear();
    for (const s of e) {
      const a = typeof s != "object" ? { id: s, text: s } : s;
      this._items.add({ item: a, marker: i });
    }
    const r = this.editor.model.markers.get("mention");
    this._items.length ? this._showOrUpdateUI(r) : this._hideUIAndRemoveMarker();
  }
  _showOrUpdateUI(t) {
    this._isUIVisible ? this._balloon.updatePosition(this._getBalloonPanelPositionData(t, this._mentionsView.position)) : this._balloon.add({ view: this._mentionsView, position: this._getBalloonPanelPositionData(t, this._mentionsView.position), singleViewMode: !0, balloonClassName: "ck-mention-balloon" }), this._mentionsView.position = this._balloon.view.position, this._mentionsView.selectFirst();
  }
  _hideUIAndRemoveMarker() {
    this._balloon.hasView(this._mentionsView) && this._balloon.remove(this._mentionsView), xc(this.editor) && this.editor.model.change((t) => t.removeMarker("mention")), this._mentionsView.position = void 0;
  }
  _renderItem(t, e) {
    const i = this.editor;
    let r, s = t.id;
    const a = this._getItemRenderer(e);
    if (a) {
      const l = a(t);
      typeof l != "string" ? r = new ND(i.locale, l) : s = l;
    }
    if (!r) {
      const l = new V(i.locale);
      l.label = s, l.withText = !0, r = l;
    }
    return r;
  }
  _getBalloonPanelPositionData(t, e) {
    const i = this.editor, r = i.editing, s = r.view.domConverter, a = r.mapper;
    return { target: () => {
      let l = t.getRange();
      l.start.root.rootName == "$graveyard" && (l = i.model.document.selection.getFirstRange());
      const c = a.toViewRange(l);
      return K.getDomRangeRects(s.viewRangeToDom(c)).pop();
    }, limiter: () => {
      const l = this.editor.editing.view, c = l.document.selection.editableElement;
      return c ? l.domConverter.mapViewToDom(c.root) : null;
    }, positions: FD(e, i.locale.uiLanguageDirection) };
  }
}
function FD(o, n) {
  const t = { caret_se: (e) => ({ top: e.bottom + 3, left: e.right, name: "caret_se", config: { withArrow: !1 } }), caret_ne: (e, i) => ({ top: e.top - i.height - 3, left: e.right, name: "caret_ne", config: { withArrow: !1 } }), caret_sw: (e, i) => ({ top: e.bottom + 3, left: e.right - i.width, name: "caret_sw", config: { withArrow: !1 } }), caret_nw: (e, i) => ({ top: e.top - i.height - 3, left: e.right - i.width, name: "caret_nw", config: { withArrow: !1 } }) };
  return Object.prototype.hasOwnProperty.call(t, o) ? [t[o]] : n !== "rtl" ? [t.caret_se, t.caret_sw, t.caret_ne, t.caret_nw] : [t.caret_sw, t.caret_se, t.caret_nw, t.caret_ne];
}
function sp(o, n) {
  let t;
  for (const e of o) {
    const i = n.lastIndexOf(e.marker);
    i > 0 && !n.substring(i - 1).match(e.pattern) || (!t || i >= t.position) && (t = { marker: e.marker, position: i, minimumCharacters: e.minimumCharacters, pattern: e.pattern });
  }
  return t;
}
function ap(o, n) {
  const t = n == 0 ? "*" : `{${n},}`, e = H.features.isRegExpUnicodePropertySupported ? `\\p{Ps}\\p{Pi}"'` : `\\(\\[{"'`;
  return o = o.replace(/[.*+?^${}()\-|[\]\\]/g, "\\$&"), new RegExp(`(?:^|[ ${e}])(${o})(.${t})$`, "u");
}
function jD(o) {
  return (n) => o.filter((t) => (typeof t == "string" ? t : String(t.id)).toLowerCase().includes(n.toLowerCase()));
}
function HD(o) {
  return !!o;
}
function xc(o) {
  return o.model.markers.has("mention");
}
class UD extends A {
  toMentionAttribute(n, t) {
    return fv(n, t);
  }
  static get pluginName() {
    return "Mention";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [DD, VD];
  }
}
function lp(o) {
  return o !== void 0 && o.endsWith("px");
}
function Bo(o) {
  return o.toFixed(2).replace(/\.?0+$/, "") + "px";
}
function $D(o, n, t) {
  if (!o.childCount) return;
  const e = new Bn(o.document), i = function(a, l) {
    const c = l.createRangeIn(a), d = [], u = /* @__PURE__ */ new Set();
    for (const h of c.getItems()) {
      if (!h.is("element") || !h.name.match(/^(p|h\d+|li|div)$/)) continue;
      let g = JD(h);
      if (g === void 0 || parseFloat(g) != 0 || Array.from(h.getClassNames()).find((f) => f.startsWith("MsoList")) || (g = void 0), h.hasStyle("mso-list") || g !== void 0 && u.has(g)) {
        const f = ZD(h);
        d.push({ element: h, id: f.id, order: f.order, indent: f.indent, marginLeft: g }), g !== void 0 && u.add(g);
      } else u.clear();
    }
    return d;
  }(o, e);
  if (!i.length) return;
  const r = {}, s = [];
  for (const a of i) if (a.indent !== void 0) {
    qD(a) || (s.length = 0);
    const l = `${a.id}:${a.indent}`, c = Math.min(a.indent - 1, s.length);
    if (c < s.length && s[c].id !== a.id && (s.length = c), c < s.length - 1) s.length = c + 1;
    else {
      const u = GD(a, n);
      if (c > s.length - 1 || s[c].listElement.name != u.type) {
        c == 0 && u.type == "ol" && a.id !== void 0 && r[l] && (u.startIndex = r[l]);
        const h = YD(u, e, t);
        if (lp(a.marginLeft) && (c == 0 || lp(s[c - 1].marginLeft))) {
          let g = a.marginLeft;
          c > 0 && (g = Bo(parseFloat(g) - parseFloat(s[c - 1].marginLeft))), e.setStyle("padding-left", g, h);
        }
        if (s.length == 0) {
          const g = a.element.parent, f = g.getChildIndex(a.element) + 1;
          e.insertChild(f, h, g);
        } else {
          const g = s[c - 1].listItemElements;
          e.appendChild(h, g[g.length - 1]);
        }
        s[c] = { ...a, listElement: h, listItemElements: [] }, c == 0 && a.id !== void 0 && (r[l] = u.startIndex || 1);
      }
    }
    const d = a.element.name == "li" ? a.element : e.createElement("li");
    e.appendChild(d, s[c].listElement), s[c].listItemElements.push(d), c == 0 && a.id !== void 0 && r[l]++, a.element != d && e.appendChild(a.element, d), QD(a.element, e), e.removeStyle("text-indent", a.element), e.removeStyle("margin-left", a.element);
  } else {
    const l = s.find((c) => c.marginLeft == a.marginLeft);
    if (l) {
      const c = l.listItemElements;
      e.appendChild(a.element, c[c.length - 1]), e.removeStyle("margin-left", a.element);
    } else s.length = 0;
  }
}
function qD(o) {
  const n = o.element.previousSibling;
  return WD(n || o.element.parent);
}
function WD(o) {
  return o.is("element", "ol") || o.is("element", "ul");
}
function GD(o, n) {
  const t = new RegExp(`@list l${o.id}:level${o.indent}\\s*({[^}]*)`, "gi"), e = /mso-level-number-format:([^;]{0,100});/gi, i = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi, r = new RegExp(`@list\\s+l${o.id}:level\\d\\s*{[^{]*mso-level-text:"%\\d\\\\.`, "gi"), s = new RegExp(`@list l${o.id}:level\\d\\s*{[^{]*mso-level-number-format:`, "gi"), a = r.exec(n), l = s.exec(n), c = a && !l, d = t.exec(n);
  let u = "decimal", h = "ol", g = null;
  if (d && d[1]) {
    const f = e.exec(d[1]);
    if (f && f[1] && (u = f[1].trim(), h = u !== "bullet" && u !== "image" ? "ol" : "ul"), u === "bullet") {
      const p = function(b) {
        if (b.name == "li" && b.parent.name == "ul" && b.parent.hasAttribute("type")) return b.parent.getAttribute("type");
        const k = function(_) {
          if (_.getChild(0).is("$text")) return null;
          for (const y of _.getChildren()) {
            if (!y.is("element", "span")) continue;
            const C = y.getChild(0);
            if (C) return C.is("$text") ? C : C.getChild(0);
          }
          return null;
        }(b);
        if (!k) return null;
        const w = k._data;
        return w === "o" ? "circle" : w === "" ? "disc" : w === "" ? "square" : null;
      }(o.element);
      p && (u = p);
    } else {
      const p = i.exec(d[1]);
      p && p[1] && (g = parseInt(p[1]));
    }
    c && (h = "ol");
  }
  return { type: h, startIndex: g, style: KD(u), isLegalStyleList: c };
}
function KD(o) {
  if (o.startsWith("arabic-leading-zero")) return "decimal-leading-zero";
  switch (o) {
    case "alpha-upper":
      return "upper-alpha";
    case "alpha-lower":
      return "lower-alpha";
    case "roman-upper":
      return "upper-roman";
    case "roman-lower":
      return "lower-roman";
    case "circle":
    case "disc":
    case "square":
      return o;
    default:
      return null;
  }
}
function YD(o, n, t) {
  const e = n.createElement(o.type);
  return o.style && n.setStyle("list-style-type", o.style, e), o.startIndex && o.startIndex > 1 && n.setAttribute("start", o.startIndex, e), o.isLegalStyleList && t && n.addClass("legal-list", e), e;
}
function ZD(o) {
  const n = o.getStyle("mso-list");
  if (n === void 0) return {};
  const t = n.match(/(^|\s{1,100})l(\d+)/i), e = n.match(/\s{0,100}lfo(\d+)/i), i = n.match(/\s{0,100}level(\d+)/i);
  return t && e && i ? { id: t[2], order: e[1], indent: parseInt(i[1]) } : { indent: 1 };
}
function QD(o, n) {
  const t = new We({ name: "span", styles: { "mso-list": "Ignore" } }), e = n.createRangeIn(o);
  for (const i of e) i.type === "elementStart" && t.match(i.item) && n.remove(i.item);
}
function JD(o) {
  const n = o.getStyle("margin-left");
  return n === void 0 || n.endsWith("px") ? n : function(t) {
    const e = parseFloat(t);
    return t.endsWith("pt") ? Bo(96 * e / 72) : t.endsWith("pc") ? Bo(12 * e * 96 / 72) : t.endsWith("in") ? Bo(96 * e) : t.endsWith("cm") ? Bo(96 * e / 2.54) : t.endsWith("mm") ? Bo(e / 10 * 96 / 2.54) : t;
  }(n);
}
function XD(o, n) {
  if (!o.childCount) return;
  const t = new Bn(o.document), e = function(r, s) {
    const a = s.createRangeIn(r), l = new We({ name: /v:(.+)/ }), c = [];
    for (const d of a) {
      if (d.type != "elementStart") continue;
      const u = d.item, h = u.previousSibling, g = h && h.is("element") ? h.name : null, f = ["Chart"], p = l.match(u), b = u.getAttribute("o:gfxdata"), k = g === "v:shapetype", w = b && f.some((_) => u.getAttribute("id").includes(_));
      p && b && !k && !w && c.push(d.item.getAttribute("id"));
    }
    return c;
  }(o, t);
  (function(r, s, a) {
    const l = a.createRangeIn(s), c = new We({ name: "img" }), d = [];
    for (const u of l) if (u.item.is("element") && c.match(u.item)) {
      const h = u.item, g = h.getAttribute("v:shapes") ? h.getAttribute("v:shapes").split(" ") : [];
      g.length && g.every((f) => r.indexOf(f) > -1) ? d.push(h) : h.getAttribute("src") || d.push(h);
    }
    for (const u of d) a.remove(u);
  })(e, o, t), function(r, s, a) {
    const l = a.createRangeIn(s), c = [];
    for (const h of l) if (h.type == "elementStart" && h.item.is("element", "v:shape")) {
      const g = h.item.getAttribute("id");
      if (r.includes(g)) continue;
      d(h.item.parent.getChildren(), g) || c.push(h.item);
    }
    for (const h of c) {
      const g = { src: u(h) };
      h.hasAttribute("alt") && (g.alt = h.getAttribute("alt"));
      const f = a.createElement("img", g);
      a.insertChild(h.index + 1, f, h.parent);
    }
    function d(h, g) {
      for (const f of h) if (f.is("element") && (f.name == "img" && f.getAttribute("v:shapes") == g || d(f.getChildren(), g)))
        return !0;
      return !1;
    }
    function u(h) {
      for (const g of h.getChildren()) if (g.is("element") && g.getAttribute("src")) return g.getAttribute("src");
    }
  }(e, o, t), function(r, s) {
    const a = s.createRangeIn(r), l = new We({ name: /v:(.+)/ }), c = [];
    for (const d of a) d.type == "elementStart" && l.match(d.item) && c.push(d.item);
    for (const d of c) s.remove(d);
  }(o, t);
  const i = function(r, s) {
    const a = s.createRangeIn(r), l = new We({ name: "img" }), c = [];
    for (const d of a) d.item.is("element") && l.match(d.item) && d.item.getAttribute("src").startsWith("file://") && c.push(d.item);
    return c;
  }(o, t);
  i.length && function(r, s, a) {
    if (r.length === s.length) for (let l = 0; l < r.length; l++) {
      const c = `data:${s[l].type};base64,${t4(s[l].hex)}`;
      a.setAttribute("src", c, r[l]);
    }
  }(i, function(r) {
    if (!r) return [];
    const s = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/, a = new RegExp("(?:(" + s.source + "))([\\da-fA-F\\s]+)\\}", "g"), l = r.match(a), c = [];
    if (l) for (const d of l) {
      let u = !1;
      d.includes("\\pngblip") ? u = "image/png" : d.includes("\\jpegblip") && (u = "image/jpeg"), u && c.push({ hex: d.replace(s, "").replace(/[^\da-fA-F]/g, ""), type: u });
    }
    return c;
  }(n), t);
}
function t4(o) {
  return btoa(o.match(/\w{2}/g).map((n) => String.fromCharCode(parseInt(n, 16))).join(""));
}
const e4 = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i, n4 = /xmlns:o="urn:schemas-microsoft-com/i;
class i4 {
  constructor(n, t = !1) {
    m(this, "document");
    m(this, "hasMultiLevelListPlugin");
    this.document = n, this.hasMultiLevelListPlugin = t;
  }
  isActive(n) {
    return e4.test(n) || n4.test(n);
  }
  execute(n) {
    const t = new Bn(this.document), { body: e, stylesString: i } = n._parsedData;
    (function(r, s) {
      const a = [];
      for (const l of s.createRangeIn(r)) {
        const c = l.item;
        c.is("element", "a") && !c.hasAttribute("href") && (c.hasAttribute("id") || c.hasAttribute("name")) && a.push(c);
      }
      for (const l of a) {
        const c = l.parent.getChildIndex(l) + 1, d = l.getChildren();
        s.insertChild(c, d, l.parent);
      }
    })(e, t), $D(e, i, this.hasMultiLevelListPlugin), XD(e, n.dataTransfer.getData("text/rtf")), function(r) {
      const s = [], a = new Bn(r.document);
      for (const { item: l } of a.createRangeIn(r)) if (l.is("element")) {
        for (const c of l.getClassNames()) /\bmso/gi.exec(c) && a.removeClass(c, l);
        for (const c of l.getStyleNames()) /\bmso/gi.exec(c) && a.removeStyle(c, l);
        (l.is("element", "w:sdt") || l.is("element", "w:sdtpr") && l.isEmpty || l.is("element", "o:p") && l.isEmpty) && s.push(l);
      }
      for (const l of s) {
        const c = l.parent, d = c.getChildIndex(l);
        a.insertChild(d, l.getChildren(), c), a.remove(l);
      }
    }(e), n.content = e;
  }
}
function cp(o, n, t, { blockElements: e, inlineObjectElements: i }) {
  let r = t.createPositionAt(o, n == "forward" ? "after" : "before");
  return r = r.getLastMatchingPosition(({ item: s }) => s.is("element") && !e.includes(s.name) && !i.includes(s.name), { direction: n }), n == "forward" ? r.nodeAfter : r.nodeBefore;
}
function dp(o, n) {
  return !!o && o.is("element") && n.includes(o.name);
}
const o4 = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
class r4 {
  constructor(n) {
    m(this, "document");
    this.document = n;
  }
  isActive(n) {
    return o4.test(n);
  }
  execute(n) {
    const t = new Bn(this.document), { body: e } = n._parsedData;
    (function(i, r) {
      for (const s of i.getChildren()) if (s.is("element", "b") && s.getStyle("font-weight") === "normal") {
        const a = i.getChildIndex(s);
        r.remove(s), r.insertChild(a, s.getChildren(), i);
      }
    })(e, t), function(i, r) {
      for (const s of r.createRangeIn(i)) {
        const a = s.item;
        if (a.is("element", "li")) {
          const l = a.getChild(0);
          l && l.is("element", "p") && r.unwrapElement(l);
        }
      }
    }(e, t), function(i, r) {
      const s = new al(r.document.stylesProcessor), a = new cl(s, { renderingMode: "data" }), l = a.blockElements, c = a.inlineObjectElements, d = [];
      for (const u of r.createRangeIn(i)) {
        const h = u.item;
        if (h.is("element", "br")) {
          const g = cp(h, "forward", r, { blockElements: l, inlineObjectElements: c }), f = cp(h, "backward", r, { blockElements: l, inlineObjectElements: c }), p = dp(g, l);
          (dp(f, l) || p) && d.push(h);
        }
      }
      for (const u of d) u.hasClass("Apple-interchange-newline") ? r.remove(u) : r.replace(u, r.createElement("p"));
    }(e, t), n.content = e;
  }
}
const s4 = /<google-sheets-html-origin/i;
class a4 {
  constructor(n) {
    m(this, "document");
    this.document = n;
  }
  isActive(n) {
    return s4.test(n);
  }
  execute(n) {
    const t = new Bn(this.document), { body: e } = n._parsedData;
    (function(i, r) {
      for (const s of i.getChildren()) if (s.is("element", "google-sheets-html-origin")) {
        const a = i.getChildIndex(s);
        r.remove(s), r.insertChild(a, s.getChildren(), i);
      }
    })(e, t), function(i, r) {
      for (const s of i.getChildren()) s.is("element", "table") && s.hasAttribute("xmlns") && r.removeAttribute("xmlns", s);
    }(e, t), function(i, r) {
      for (const s of i.getChildren()) s.is("element", "table") && s.getStyle("width") === "0px" && r.removeStyle("width", s);
    }(e, t), function(i, r) {
      for (const s of Array.from(i.getChildren())) s.is("element", "style") && r.remove(s);
    }(e, t), n.content = e;
  }
}
function up(o) {
  return o.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (n, t) => t.length === 1 ? " " : Array(t.length + 1).join(" ").substr(0, t.length));
}
function l4(o, n) {
  const t = new DOMParser(), e = function(l) {
    return up(up(l)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/(<span\s+style=['"]letter-spacing:[^'"]+?['"]>)[\r\n]+(<\/span>)/g, "$1 $2").replace(/ <\//g, "</").replace(/ <o:p><\/o:p>/g, "<o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><");
  }(function(l) {
    const c = "</body>", d = "</html>", u = l.indexOf(c);
    if (u < 0) return l;
    const h = l.indexOf(d, u + c.length);
    return l.substring(0, u + c.length) + (h >= 0 ? l.substring(h) : "");
  }(o = (o = o.replace(/<!--\[if gte vml 1]>/g, "")).replace(/<o:SmartTagType(?:\s+[^\s>=]+(?:="[^"]*")?)*\s*\/?>/gi, ""))), i = t.parseFromString(e, "text/html");
  (function(l) {
    l.querySelectorAll("span[style*=spacerun]").forEach((c) => {
      const d = c, u = d.innerText.length || 0;
      d.innerText = Array(u + 1).join(" ").substr(0, u);
    });
  })(i);
  const r = i.body.innerHTML, s = function(l, c) {
    const d = new al(c), u = new cl(d, { renderingMode: "data" }), h = l.createDocumentFragment(), g = l.body.childNodes;
    for (; g.length > 0; ) h.appendChild(g[0]);
    return u.domToView(h, { skipComments: !0 });
  }(i, n), a = function(l) {
    const c = [], d = [], u = Array.from(l.getElementsByTagName("style"));
    for (const h of u) h.sheet && h.sheet.cssRules && h.sheet.cssRules.length && (c.push(h.sheet), d.push(h.innerHTML));
    return { styles: c, stylesString: d.join(" ") };
  }(i);
  return { body: s, bodyString: r, styles: a.styles, stylesString: a.stylesString };
}
class c4 extends A {
  static get pluginName() {
    return "PasteFromOffice";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [De];
  }
  init() {
    const n = this.editor, t = n.plugins.get("ClipboardPipeline"), e = n.editing.view.document, i = [], r = this.editor.plugins.has("MultiLevelList");
    i.push(new i4(e, r)), i.push(new r4(e)), i.push(new a4(e)), t.on("inputTransformation", (s, a) => {
      if (a._isTransformedWithPasteFromOffice || n.model.document.selection.getFirstPosition().parent.is("element", "codeBlock")) return;
      const l = a.dataTransfer.getData("text/html"), c = i.find((d) => d.isActive(l));
      c && (a._parsedData || (a._parsedData = l4(l, e.stylesProcessor)), c.execute(a), a._isTransformedWithPasteFromOffice = !0);
    }, { priority: "high" });
  }
}
const Qs = "removeFormat";
class d4 extends A {
  static get pluginName() {
    return "RemoveFormatUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor;
    n.ui.componentFactory.add(Qs, () => {
      const t = this._createButton(V);
      return t.set({ tooltip: !0 }), t;
    }), n.ui.componentFactory.add(`menuBar:${Qs}`, () => this._createButton(Et));
  }
  _createButton(n) {
    const t = this.editor, e = t.locale, i = t.commands.get(Qs), r = new n(t.locale), s = e.t;
    return r.set({ label: s("Remove Format"), icon: eE }), r.bind("isEnabled").to(i, "isEnabled"), this.listenTo(r, "execute", () => {
      t.execute(Qs), t.editing.view.focus();
    }), r;
  }
}
class u4 extends q {
  refresh() {
    const n = this.editor.model;
    this.isEnabled = !!yt(this._getFormattingItems(n.document.selection, n.schema));
  }
  execute() {
    const n = this.editor.model, t = n.schema;
    n.change((e) => {
      for (const i of this._getFormattingItems(n.document.selection, t)) if (i.is("selection")) for (const r of this._getFormattingAttributes(i, t)) e.removeSelectionAttribute(r);
      else {
        const r = e.createRangeOn(i);
        for (const s of this._getFormattingAttributes(i, t)) e.removeAttribute(s, r);
      }
    });
  }
  *_getFormattingItems(n, t) {
    const e = (i) => !!yt(this._getFormattingAttributes(i, t));
    for (const i of n.getRanges()) for (const r of i.getItems()) !t.isBlock(r) && e(r) && (yield r);
    for (const i of n.getSelectedBlocks()) e(i) && (yield i);
    e(n) && (yield n);
  }
  *_getFormattingAttributes(n, t) {
    for (const [e] of n.getAttributes()) {
      const i = t.getAttributeProperties(e);
      i && i.isFormatting && (yield e);
    }
  }
}
class h4 extends A {
  static get pluginName() {
    return "RemoveFormatEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor;
    n.commands.add("removeFormat", new u4(n));
  }
}
class m4 extends A {
  static get requires() {
    return [h4, d4];
  }
  static get pluginName() {
    return "RemoveFormat";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
class g4 extends L {
  constructor(t) {
    super(t);
    m(this, "tiles");
    m(this, "focusTracker");
    m(this, "keystrokes");
    this.tiles = this.createCollection(), this.setTemplate({ tag: "div", children: [{ tag: "div", attributes: { class: ["ck", "ck-character-grid__tiles"] }, children: this.tiles }], attributes: { class: ["ck", "ck-character-grid"] } }), this.focusTracker = new gt(), this.keystrokes = new Mt(), vs({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.tiles, numberOfColumns: () => N.window.getComputedStyle(this.element.firstChild).getPropertyValue("grid-template-columns").split(" ").length, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection });
  }
  createTile(t, e) {
    const i = new V(this.locale);
    return i.set({ label: t, withText: !0, class: "ck-character-grid__tile" }), i.extendTemplate({ attributes: { title: e }, on: { mouseover: i.bindTemplate.to("mouseover"), focus: i.bindTemplate.to("focus") } }), i.on("mouseover", () => {
      this.fire("tileHover", { name: e, character: t });
    }), i.on("focus", () => {
      this.fire("tileFocus", { name: e, character: t });
    }), i.on("execute", () => {
      this.fire("execute", { name: e, character: t });
    }), i;
  }
  render() {
    super.render();
    for (const t of this.tiles) this.focusTracker.add(t.element);
    this.tiles.on("change", (t, { added: e, removed: i }) => {
      if (e.length > 0) for (const r of e) this.focusTracker.add(r.element);
      if (i.length > 0) for (const r of i) this.focusTracker.remove(r.element);
    }), this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy(), this.keystrokes.destroy();
  }
  focus() {
    this.tiles.first.focus();
  }
}
class f4 extends L {
  constructor(n) {
    super(n);
    const t = this.bindTemplate;
    this.set("character", null), this.set("name", null), this.bind("code").to(this, "character", p4), this.setTemplate({ tag: "div", children: [{ tag: "span", attributes: { class: ["ck-character-info__name"] }, children: [{ text: t.to("name", (e) => e || "") }] }, { tag: "span", attributes: { class: ["ck-character-info__code"] }, children: [{ text: t.to("code") }] }], attributes: { class: ["ck", "ck-character-info"] } });
  }
}
function p4(o) {
  return o === null ? "" : "U+" + ("0000" + o.codePointAt(0).toString(16)).slice(-4);
}
class b4 extends L {
  constructor(t, e, i, r) {
    super(t);
    m(this, "items");
    m(this, "focusTracker");
    m(this, "keystrokes");
    m(this, "_focusCycler");
    m(this, "categoriesView");
    m(this, "gridView");
    m(this, "infoView");
    this.categoriesView = e, this.gridView = i, this.infoView = r, this.items = this.createCollection(), this.focusTracker = new gt(), this.keystrokes = new Mt(), this._focusCycler = new le({ focusables: this.items, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", children: [this.categoriesView, this.gridView, this.infoView], attributes: { tabindex: "-1" } }), this.items.add(this.categoriesView), this.items.add(this.gridView);
  }
  render() {
    super.render(), this.focusTracker.add(this.categoriesView.element), this.focusTracker.add(this.gridView.element), this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  focus() {
    this._focusCycler.focusFirst();
  }
}
class k4 extends L {
  constructor(t, e) {
    super(t);
    m(this, "_groupNames");
    m(this, "_dropdownView");
    this.set("currentGroupName", Array.from(e.entries())[0][0]), this._groupNames = e, this._dropdownView = new Nn(t, jE), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-character-categories"] }, children: [this._dropdownView] });
  }
  render() {
    super.render(), this._setupDropdown();
  }
  focus() {
    this._dropdownView.focus();
  }
  _setupDropdown() {
    const t = new ne();
    for (const [i, r] of this._groupNames) {
      const s = { type: "button", model: new ai({ name: i, label: r, role: "menuitemradio", withText: !0 }) };
      s.model.bind("isOn").to(this, "currentGroupName", (a) => a === i), t.add(s);
    }
    const e = (0, this.locale.t)("Category");
    this._dropdownView.set({ label: e, isEmpty: !1 }), this._dropdownView.fieldView.panelPosition = this.locale.uiLanguageDirection === "rtl" ? "se" : "sw", this._dropdownView.fieldView.buttonView.set({ withText: !0, tooltip: e, ariaLabel: e, ariaLabelledBy: void 0, isOn: !1 }), this._dropdownView.fieldView.buttonView.bind("label").to(this, "currentGroupName", (i) => this._groupNames.get(i)), this._dropdownView.fieldView.on("execute", ({ source: i }) => {
      this.currentGroupName = i.name;
    }), zi(this._dropdownView.fieldView, t, { ariaLabel: e, role: "menu" });
  }
}
const Ec = "All";
class w4 extends A {
  constructor(t) {
    super(t);
    m(this, "_characters");
    m(this, "_groups");
    m(this, "_allSpecialCharactersGroupLabel");
    const e = t.t;
    this._characters = /* @__PURE__ */ new Map(), this._groups = /* @__PURE__ */ new Map(), this._allSpecialCharactersGroupLabel = e("All");
  }
  static get requires() {
    return [gl, no];
  }
  static get pluginName() {
    return "SpecialCharacters";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const t = this.editor;
    t.ui.componentFactory.add("specialCharacters", () => {
      const e = this._createDialogButton(V);
      return e.set({ tooltip: !0 }), e;
    }), t.ui.componentFactory.add("menuBar:specialCharacters", () => this._createDialogButton(Et));
  }
  addItems(t, e, i = { label: t }) {
    if (t === Ec) throw new v("special-character-invalid-group-name", null);
    const r = this._getGroup(t, i.label);
    for (const s of e) r.items.add(s.title), this._characters.set(s.title, s.character);
  }
  getGroups() {
    const t = Array.from(this._groups.keys()), e = this.editor.config.get("specialCharacters.order") || [], i = e.find((r) => !t.includes(r));
    if (i) throw new v("special-character-invalid-order-group-name", null, { invalidGroup: i });
    return /* @__PURE__ */ new Set([...e, ...t]);
  }
  getCharactersForGroup(t) {
    if (t === Ec) return new Set(this._characters.keys());
    const e = this._groups.get(t);
    return e ? e.items : void 0;
  }
  getCharacter(t) {
    return this._characters.get(t);
  }
  _getGroup(t, e) {
    return this._groups.has(t) || this._groups.set(t, { items: /* @__PURE__ */ new Set(), label: e }), this._groups.get(t);
  }
  _updateGrid(t, e) {
    e.tiles.clear();
    const i = this.getCharactersForGroup(t);
    for (const r of i) {
      const s = this.getCharacter(r);
      e.tiles.add(e.createTile(s, r));
    }
  }
  _createDropdownPanelContent(t) {
    const e = Array.from(this.getGroups()).map((l) => [l, this._groups.get(l).label]), i = new Map([[Ec, this._allSpecialCharactersGroupLabel], ...e]), r = new k4(t, i), s = new g4(t), a = new f4(t);
    return s.on("tileHover", (l, c) => {
      a.set(c);
    }), s.on("tileFocus", (l, c) => {
      a.set(c);
    }), r.on("change:currentGroupName", (l, c, d) => {
      this._updateGrid(d, s);
    }), this._updateGrid(r.currentGroupName, s), { categoriesView: r, gridView: s, infoView: a };
  }
  _createDialogButton(t) {
    const e = this.editor, i = e.locale, r = new t(e.locale), s = e.commands.get("insertText"), a = i.t, l = this.editor.plugins.get("Dialog");
    return r.set({ label: a("Special characters"), icon: rE, isToggleable: !0 }), r.bind("isOn").to(l, "id", (c) => c === "specialCharacters"), r.bind("isEnabled").to(s, "isEnabled"), r.on("execute", () => {
      l.id !== "specialCharacters" ? this._showDialog() : l.hide();
    }), r;
  }
  _showDialog() {
    const t = this.editor, e = t.plugins.get("Dialog"), i = t.locale, r = i.t, { categoriesView: s, gridView: a, infoView: l } = this._createDropdownPanelContent(i), c = new b4(i, s, a, l);
    a.on("execute", (d, u) => {
      t.execute("insertText", { text: u.character });
    }), e.show({ id: "specialCharacters", title: r("Special characters"), className: "ck-special-characters", content: c, position: en.EDITOR_TOP_SIDE });
  }
}
class bv extends A {
  static get pluginName() {
    return "SpecialCharactersArrows";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.t;
    n.plugins.get("SpecialCharacters").addItems("Arrows", [{ title: t("leftwards simple arrow"), character: "" }, { title: t("rightwards simple arrow"), character: "" }, { title: t("upwards simple arrow"), character: "" }, { title: t("downwards simple arrow"), character: "" }, { title: t("leftwards double arrow"), character: "" }, { title: t("rightwards double arrow"), character: "" }, { title: t("upwards double arrow"), character: "" }, { title: t("downwards double arrow"), character: "" }, { title: t("leftwards dashed arrow"), character: "" }, { title: t("rightwards dashed arrow"), character: "" }, { title: t("upwards dashed arrow"), character: "" }, { title: t("downwards dashed arrow"), character: "" }, { title: t("leftwards arrow to bar"), character: "" }, { title: t("rightwards arrow to bar"), character: "" }, { title: t("upwards arrow to bar"), character: "" }, { title: t("downwards arrow to bar"), character: "" }, { title: t("up down arrow with base"), character: "" }, { title: t("back with leftwards arrow above"), character: "" }, { title: t("end with leftwards arrow above"), character: "" }, { title: t("on with exclamation mark with left right arrow above"), character: "" }, { title: t("soon with rightwards arrow above"), character: "" }, { title: t("top with upwards arrow above"), character: "" }], { label: t("Arrows") });
  }
}
class kv extends A {
  static get pluginName() {
    return "SpecialCharactersText";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.t;
    n.plugins.get("SpecialCharacters").addItems("Text", [{ character: "", title: t("Single left-pointing angle quotation mark") }, { character: "", title: t("Single right-pointing angle quotation mark") }, { character: "", title: t("Left-pointing double angle quotation mark") }, { character: "", title: t("Right-pointing double angle quotation mark") }, { character: "", title: t("Left single quotation mark") }, { character: "", title: t("Right single quotation mark") }, { character: "", title: t("Left double quotation mark") }, { character: "", title: t("Right double quotation mark") }, { character: "", title: t("Single low-9 quotation mark") }, { character: "", title: t("Double low-9 quotation mark") }, { character: "", title: t("Inverted exclamation mark") }, { character: "", title: t("Inverted question mark") }, { character: "", title: t("Two dot leader") }, { character: "", title: t("Horizontal ellipsis") }, { character: "", title: t("Double dagger") }, { character: "", title: t("Per mille sign") }, { character: "", title: t("Per ten thousand sign") }, { character: "", title: t("Double exclamation mark") }, { character: "", title: t("Question exclamation mark") }, { character: "", title: t("Exclamation question mark") }, { character: "", title: t("Double question mark") }, { character: "", title: t("Copyright sign") }, { character: "", title: t("Registered sign") }, { character: "", title: t("Trade mark sign") }, { character: "", title: t("Section sign") }, { character: "", title: t("Paragraph sign") }, { character: "", title: t("Reversed paragraph sign") }], { label: t("Text") });
  }
}
class wv extends A {
  static get pluginName() {
    return "SpecialCharactersMathematical";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.t;
    n.plugins.get("SpecialCharacters").addItems("Mathematical", [{ character: "<", title: t("Less-than sign") }, { character: ">", title: t("Greater-than sign") }, { character: "", title: t("Less-than or equal to") }, { character: "", title: t("Greater-than or equal to") }, { character: "", title: t("En dash") }, { character: "", title: t("Em dash") }, { character: "", title: t("Macron") }, { character: "", title: t("Overline") }, { character: "", title: t("Degree sign") }, { character: "", title: t("Minus sign") }, { character: "", title: t("Plus-minus sign") }, { character: "", title: t("Division sign") }, { character: "", title: t("Fraction slash") }, { character: "", title: t("Multiplication sign") }, { character: "", title: t("Latin small letter f with hook") }, { character: "", title: t("Integral") }, { character: "", title: t("N-ary summation") }, { character: "", title: t("Infinity") }, { character: "", title: t("Square root") }, { character: "", title: t("Tilde operator") }, { character: "", title: t("Approximately equal to") }, { character: "", title: t("Almost equal to") }, { character: "", title: t("Not equal to") }, { character: "", title: t("Identical to") }, { character: "", title: t("Element of") }, { character: "", title: t("Not an element of") }, { character: "", title: t("Contains as member") }, { character: "", title: t("N-ary product") }, { character: "", title: t("Logical and") }, { character: "", title: t("Logical or") }, { character: "", title: t("Not sign") }, { character: "", title: t("Intersection") }, { character: "", title: t("Union") }, { character: "", title: t("Partial differential") }, { character: "", title: t("For all") }, { character: "", title: t("There exists") }, { character: "", title: t("Empty set") }, { character: "", title: t("Nabla") }, { character: "", title: t("Asterisk operator") }, { character: "", title: t("Proportional to") }, { character: "", title: t("Angle") }, { character: "", title: t("Vulgar fraction one quarter") }, { character: "", title: t("Vulgar fraction one half") }, { character: "", title: t("Vulgar fraction three quarters") }], { label: t("Mathematical") });
  }
}
class _v extends A {
  static get pluginName() {
    return "SpecialCharactersLatin";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.t;
    n.plugins.get("SpecialCharacters").addItems("Latin", [{ character: "", title: t("Latin capital letter a with macron") }, { character: "", title: t("Latin small letter a with macron") }, { character: "", title: t("Latin capital letter a with breve") }, { character: "", title: t("Latin small letter a with breve") }, { character: "", title: t("Latin capital letter a with ogonek") }, { character: "", title: t("Latin small letter a with ogonek") }, { character: "", title: t("Latin capital letter c with acute") }, { character: "", title: t("Latin small letter c with acute") }, { character: "", title: t("Latin capital letter c with circumflex") }, { character: "", title: t("Latin small letter c with circumflex") }, { character: "", title: t("Latin capital letter c with dot above") }, { character: "", title: t("Latin small letter c with dot above") }, { character: "", title: t("Latin capital letter c with caron") }, { character: "", title: t("Latin small letter c with caron") }, { character: "", title: t("Latin capital letter d with caron") }, { character: "", title: t("Latin small letter d with caron") }, { character: "", title: t("Latin capital letter d with stroke") }, { character: "", title: t("Latin small letter d with stroke") }, { character: "", title: t("Latin capital letter e with macron") }, { character: "", title: t("Latin small letter e with macron") }, { character: "", title: t("Latin capital letter e with breve") }, { character: "", title: t("Latin small letter e with breve") }, { character: "", title: t("Latin capital letter e with dot above") }, { character: "", title: t("Latin small letter e with dot above") }, { character: "", title: t("Latin capital letter e with ogonek") }, { character: "", title: t("Latin small letter e with ogonek") }, { character: "", title: t("Latin capital letter e with caron") }, { character: "", title: t("Latin small letter e with caron") }, { character: "", title: t("Latin capital letter g with circumflex") }, { character: "", title: t("Latin small letter g with circumflex") }, { character: "", title: t("Latin capital letter g with breve") }, { character: "", title: t("Latin small letter g with breve") }, { character: "", title: t("Latin capital letter g with dot above") }, { character: "", title: t("Latin small letter g with dot above") }, { character: "", title: t("Latin capital letter g with cedilla") }, { character: "", title: t("Latin small letter g with cedilla") }, { character: "", title: t("Latin capital letter h with circumflex") }, { character: "", title: t("Latin small letter h with circumflex") }, { character: "", title: t("Latin capital letter h with stroke") }, { character: "", title: t("Latin small letter h with stroke") }, { character: "", title: t("Latin capital letter i with tilde") }, { character: "", title: t("Latin small letter i with tilde") }, { character: "", title: t("Latin capital letter i with macron") }, { character: "", title: t("Latin small letter i with macron") }, { character: "", title: t("Latin capital letter i with breve") }, { character: "", title: t("Latin small letter i with breve") }, { character: "", title: t("Latin capital letter i with ogonek") }, { character: "", title: t("Latin small letter i with ogonek") }, { character: "", title: t("Latin capital letter i with dot above") }, { character: "", title: t("Latin small letter dotless i") }, { character: "", title: t("Latin capital ligature ij") }, { character: "", title: t("Latin small ligature ij") }, { character: "", title: t("Latin capital letter j with circumflex") }, { character: "", title: t("Latin small letter j with circumflex") }, { character: "", title: t("Latin capital letter k with cedilla") }, { character: "", title: t("Latin small letter k with cedilla") }, { character: "", title: t("Latin small letter kra") }, { character: "", title: t("Latin capital letter l with acute") }, { character: "", title: t("Latin small letter l with acute") }, { character: "", title: t("Latin capital letter l with cedilla") }, { character: "", title: t("Latin small letter l with cedilla") }, { character: "", title: t("Latin capital letter l with caron") }, { character: "", title: t("Latin small letter l with caron") }, { character: "", title: t("Latin capital letter l with middle dot") }, { character: "", title: t("Latin small letter l with middle dot") }, { character: "", title: t("Latin capital letter l with stroke") }, { character: "", title: t("Latin small letter l with stroke") }, { character: "", title: t("Latin capital letter n with acute") }, { character: "", title: t("Latin small letter n with acute") }, { character: "", title: t("Latin capital letter n with cedilla") }, { character: "", title: t("Latin small letter n with cedilla") }, { character: "", title: t("Latin capital letter n with caron") }, { character: "", title: t("Latin small letter n with caron") }, { character: "", title: t("Latin small letter n preceded by apostrophe") }, { character: "", title: t("Latin capital letter eng") }, { character: "", title: t("Latin small letter eng") }, { character: "", title: t("Latin capital letter o with macron") }, { character: "", title: t("Latin small letter o with macron") }, { character: "", title: t("Latin capital letter o with breve") }, { character: "", title: t("Latin small letter o with breve") }, { character: "", title: t("Latin capital letter o with double acute") }, { character: "", title: t("Latin small letter o with double acute") }, { character: "", title: t("Latin capital ligature oe") }, { character: "", title: t("Latin small ligature oe") }, { character: "", title: t("Latin capital letter r with acute") }, { character: "", title: t("Latin small letter r with acute") }, { character: "", title: t("Latin capital letter r with cedilla") }, { character: "", title: t("Latin small letter r with cedilla") }, { character: "", title: t("Latin capital letter r with caron") }, { character: "", title: t("Latin small letter r with caron") }, { character: "", title: t("Latin capital letter s with acute") }, { character: "", title: t("Latin small letter s with acute") }, { character: "", title: t("Latin capital letter s with circumflex") }, { character: "", title: t("Latin small letter s with circumflex") }, { character: "", title: t("Latin capital letter s with cedilla") }, { character: "", title: t("Latin small letter s with cedilla") }, { character: "", title: t("Latin capital letter s with caron") }, { character: "", title: t("Latin small letter s with caron") }, { character: "", title: t("Latin capital letter t with cedilla") }, { character: "", title: t("Latin small letter t with cedilla") }, { character: "", title: t("Latin capital letter t with caron") }, { character: "", title: t("Latin small letter t with caron") }, { character: "", title: t("Latin capital letter t with stroke") }, { character: "", title: t("Latin small letter t with stroke") }, { character: "", title: t("Latin capital letter u with tilde") }, { character: "", title: t("Latin small letter u with tilde") }, { character: "", title: t("Latin capital letter u with macron") }, { character: "", title: t("Latin small letter u with macron") }, { character: "", title: t("Latin capital letter u with breve") }, { character: "", title: t("Latin small letter u with breve") }, { character: "", title: t("Latin capital letter u with ring above") }, { character: "", title: t("Latin small letter u with ring above") }, { character: "", title: t("Latin capital letter u with double acute") }, { character: "", title: t("Latin small letter u with double acute") }, { character: "", title: t("Latin capital letter u with ogonek") }, { character: "", title: t("Latin small letter u with ogonek") }, { character: "", title: t("Latin capital letter w with circumflex") }, { character: "", title: t("Latin small letter w with circumflex") }, { character: "", title: t("Latin capital letter y with circumflex") }, { character: "", title: t("Latin small letter y with circumflex") }, { character: "", title: t("Latin capital letter y with diaeresis") }, { character: "", title: t("Latin capital letter z with acute") }, { character: "", title: t("Latin small letter z with acute") }, { character: "", title: t("Latin capital letter z with dot above") }, { character: "", title: t("Latin small letter z with dot above") }, { character: "", title: t("Latin capital letter z with caron") }, { character: "", title: t("Latin small letter z with caron") }, { character: "", title: t("Latin small letter long s") }], { label: t("Latin") });
  }
}
class vv extends A {
  static get pluginName() {
    return "SpecialCharactersCurrency";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = n.t;
    n.plugins.get("SpecialCharacters").addItems("Currency", [{ character: "$", title: t("Dollar sign") }, { character: "", title: t("Euro sign") }, { character: "", title: t("Yen sign") }, { character: "", title: t("Pound sign") }, { character: "", title: t("Cent sign") }, { character: "", title: t("Euro-currency sign") }, { character: "", title: t("Colon sign") }, { character: "", title: t("Cruzeiro sign") }, { character: "", title: t("French franc sign") }, { character: "", title: t("Lira sign") }, { character: "", title: t("Currency sign") }, { character: "", title: t("Bitcoin sign") }, { character: "", title: t("Mill sign") }, { character: "", title: t("Naira sign") }, { character: "", title: t("Peseta sign") }, { character: "", title: t("Rupee sign") }, { character: "", title: t("Won sign") }, { character: "", title: t("New sheqel sign") }, { character: "", title: t("Dong sign") }, { character: "", title: t("Kip sign") }, { character: "", title: t("Tugrik sign") }, { character: "", title: t("Drachma sign") }, { character: "", title: t("German penny sign") }, { character: "", title: t("Peso sign") }, { character: "", title: t("Guarani sign") }, { character: "", title: t("Austral sign") }, { character: "", title: t("Hryvnia sign") }, { character: "", title: t("Cedi sign") }, { character: "", title: t("Livre tournois sign") }, { character: "", title: t("Spesmilo sign") }, { character: "", title: t("Tenge sign") }, { character: "", title: t("Indian rupee sign") }, { character: "", title: t("Turkish lira sign") }, { character: "", title: t("Nordic mark sign") }, { character: "", title: t("Manat sign") }, { character: "", title: t("Ruble sign") }], { label: t("Currency") });
  }
}
class _4 extends A {
  static get pluginName() {
    return "SpecialCharactersEssentials";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [vv, kv, wv, bv, _v];
  }
}
function v4(o, n) {
  const { modelAttribute: t, styleName: e, viewElement: i, defaultValue: r, reduceBoxSides: s = !1, shouldUpcast: a = () => !0 } = n;
  o.for("upcast").attributeToAttribute({ view: { name: i, styles: { [e]: /[\s\S]+/ } }, model: { key: t, value: (l, c, d) => {
    if (!a(l)) return;
    const u = C4(r, "", d), h = l.getNormalizedStyle(e), g = s ? A4(h) : h;
    return u !== g ? g : void 0;
  } } });
}
function y4(o, n) {
  const { modelElement: t, modelAttribute: e, styleName: i } = n;
  o.for("downcast").attributeToAttribute({ model: { name: t, key: e }, view: (r) => ({ key: "style", value: { [i]: r } }) });
}
function C4(o, n, t) {
  const e = t.modelRange && yt(t.modelRange.getItems({ shallow: !0 })), i = e && e.is("element") && e.findAncestor("table", { includeSelf: !0 });
  return i && i.getAttribute("tableType") === "layout" ? n : o;
}
function A4(o) {
  if (!o) return;
  const n = ["top", "right", "bottom", "left"];
  if (!n.every((e) => o[e])) return o;
  const t = o.top;
  return n.every((e) => o[e] === t) ? t : o;
}
function Kt(o, n, t, e, i = 1) {
  n != null && i != null && n > i ? e.setAttribute(o, n, t) : e.removeAttribute(o, t);
}
function po(o, n, t = {}) {
  const e = o.createElement("tableCell", t);
  return o.insertElement("paragraph", e), o.insert(e, n), e;
}
function Ld(o, n) {
  const t = n.parent.parent, e = parseInt(t.getAttribute("headingColumns") || "0"), { column: i } = o.getCellLocation(n);
  return !!e && i < e;
}
function x4(o, n, t) {
  const { modelAttribute: e } = t;
  o.extend("tableCell", { allowAttributes: [e] }), v4(n, { viewElement: /^(td|th)$/, ...t }), y4(n, { modelElement: "tableCell", ...t });
}
function E4(o) {
  const n = o.getSelectedElement();
  return n && n.is("element", "table") ? n : o.getFirstPosition().findAncestor("table");
}
function T4() {
  return (o) => {
    o.on("element:table", (n, t, e) => {
      const i = t.viewItem;
      if (!e.consumable.test(i, { name: !0 })) return;
      const { rows: r, headingRows: s, headingColumns: a } = function(d) {
        let u, h = 0;
        const g = [], f = [];
        let p;
        for (const b of Array.from(d.getChildren())) {
          if (b.name !== "tbody" && b.name !== "thead" && b.name !== "tfoot") continue;
          b.name !== "thead" || p || (p = b);
          const k = Array.from(b.getChildren()).filter((_) => _.is("element", "tr"));
          let w = null;
          for (const _ of k) {
            const y = Array.from(_.getChildren()).filter((C) => C.is("element", "td") || C.is("element", "th"));
            if (p && b === p || b.name === "tbody" && y.length > 0 && (w === null || y.length === w) && y.every((C) => C.is("element", "th"))) h++, g.push(_);
            else {
              f.push(_);
              const C = S4(_);
              (!u || C < u) && (u = C);
            }
            w = Math.max(w || 0, y.length);
          }
        }
        return { headingRows: h, headingColumns: u || 0, rows: [...g, ...f] };
      }(i), l = {};
      a && (l.headingColumns = a), s && (l.headingRows = s);
      const c = e.writer.createElement("table", l);
      if (e.safeInsert(c, t.modelCursor)) {
        if (e.consumable.consume(i, { name: !0 }), r.forEach((d) => e.convertItem(d, e.writer.createPositionAt(c, "end"))), e.convertChildren(i, e.writer.createPositionAt(c, "end")), c.isEmpty) {
          const d = e.writer.createElement("tableRow");
          e.writer.insert(d, e.writer.createPositionAt(c, "end")), po(e.writer, e.writer.createPositionAt(d, "end"));
        }
        e.updateConversionResult(c, t);
      }
    });
  };
}
function hp(o) {
  return (n) => {
    n.on(`element:${o}`, (t, e, { writer: i }) => {
      if (!e.modelRange) return;
      const r = e.modelRange.start.nodeAfter, s = i.createPositionAt(r, 0);
      if (e.viewItem.isEmpty) return void i.insertElement("paragraph", s);
      const a = Array.from(r.getChildren());
      if (a.every((l) => l.is("element", "$marker"))) {
        const l = i.createElement("paragraph");
        i.insert(l, i.createPositionAt(r, 0));
        for (const c of a) i.move(i.createRangeOn(c), i.createPositionAt(l, "end"));
      }
    }, { priority: "low" });
  };
}
function S4(o) {
  let n = 0, t = 0;
  const e = Array.from(o.getChildren()).filter((i) => i.name === "th" || i.name === "td");
  for (; t < e.length && e[t].name === "th"; ) {
    const i = e[t];
    n += parseInt(i.getAttribute("colspan") || "1"), t++;
  }
  return n;
}
class wt {
  constructor(n, t = {}) {
    m(this, "_table");
    m(this, "_startRow");
    m(this, "_endRow");
    m(this, "_startColumn");
    m(this, "_endColumn");
    m(this, "_includeAllSlots");
    m(this, "_skipRows");
    m(this, "_row");
    m(this, "_rowIndex");
    m(this, "_column");
    m(this, "_cellIndex");
    m(this, "_spannedCells");
    m(this, "_nextCellAtColumn");
    m(this, "_jumpedToStartRow", !1);
    this._table = n, this._startRow = t.row !== void 0 ? t.row : t.startRow || 0, this._endRow = t.row !== void 0 ? t.row : t.endRow, this._startColumn = t.column !== void 0 ? t.column : t.startColumn || 0, this._endColumn = t.column !== void 0 ? t.column : t.endColumn, this._includeAllSlots = !!t.includeAllSlots, this._skipRows = /* @__PURE__ */ new Set(), this._row = 0, this._rowIndex = 0, this._column = 0, this._cellIndex = 0, this._spannedCells = /* @__PURE__ */ new Map(), this._nextCellAtColumn = -1;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    this._canJumpToStartRow() && this._jumpToNonSpannedRowClosestToStartRow();
    const n = this._table.getChild(this._rowIndex);
    if (!n || this._isOverEndRow()) return { done: !0, value: void 0 };
    if (!n.is("element", "tableRow")) return this._rowIndex++, this.next();
    if (this._isOverEndColumn()) return this._advanceToNextRow();
    let t = null;
    const e = this._getSpanned();
    if (e) this._includeAllSlots && !this._shouldSkipSlot() && (t = this._formatOutValue(e.cell, e.row, e.column));
    else {
      const i = n.getChild(this._cellIndex);
      if (!i) return this._advanceToNextRow();
      const r = parseInt(i.getAttribute("colspan") || "1"), s = parseInt(i.getAttribute("rowspan") || "1");
      (r > 1 || s > 1) && this._recordSpans(i, s, r), this._shouldSkipSlot() || (t = this._formatOutValue(i)), this._nextCellAtColumn = this._column + r;
    }
    return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, t || this.next();
  }
  skipRow(n) {
    this._skipRows.add(n);
  }
  _advanceToNextRow() {
    return this._row++, this._rowIndex++, this._column = 0, this._cellIndex = 0, this._nextCellAtColumn = -1, this.next();
  }
  _isOverEndRow() {
    return this._endRow !== void 0 && this._row > this._endRow;
  }
  _isOverEndColumn() {
    return this._endColumn !== void 0 && this._column > this._endColumn;
  }
  _formatOutValue(n, t = this._row, e = this._column) {
    return { done: !1, value: new I4(this, n, t, e) };
  }
  _shouldSkipSlot() {
    const n = this._skipRows.has(this._row), t = this._row < this._startRow, e = this._column < this._startColumn, i = this._endColumn !== void 0 && this._column > this._endColumn;
    return n || t || e || i;
  }
  _getSpanned() {
    const n = this._spannedCells.get(this._row);
    return n && n.get(this._column) || null;
  }
  _recordSpans(n, t, e) {
    const i = { cell: n, row: this._row, column: this._column };
    for (let r = this._row; r < this._row + t; r++) for (let s = this._column; s < this._column + e; s++) r == this._row && s == this._column || this._markSpannedCell(r, s, i);
  }
  _markSpannedCell(n, t, e) {
    this._spannedCells.has(n) || this._spannedCells.set(n, /* @__PURE__ */ new Map()), this._spannedCells.get(n).set(t, e);
  }
  _canJumpToStartRow() {
    return !!this._startRow && this._startRow > 0 && !this._jumpedToStartRow;
  }
  _jumpToNonSpannedRowClosestToStartRow() {
    const n = this._getRowLength(0);
    for (let t = this._startRow; !this._jumpedToStartRow; t--) n === this._getRowLength(t) && (this._row = t, this._rowIndex = t, this._jumpedToStartRow = !0);
  }
  _getRowLength(n) {
    return [...this._table.getChild(n).getChildren()].reduce((t, e) => t + parseInt(e.getAttribute("colspan") || "1"), 0);
  }
}
class I4 {
  constructor(n, t, e, i) {
    m(this, "cell");
    m(this, "row");
    m(this, "column");
    m(this, "cellAnchorRow");
    m(this, "cellAnchorColumn");
    m(this, "_cellIndex");
    m(this, "_rowIndex");
    m(this, "_table");
    this.cell = t, this.row = n._row, this.column = n._column, this.cellAnchorRow = e, this.cellAnchorColumn = i, this._cellIndex = n._cellIndex, this._rowIndex = n._rowIndex, this._table = n._table;
  }
  get isAnchor() {
    return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;
  }
  get cellWidth() {
    return parseInt(this.cell.getAttribute("colspan") || "1");
  }
  get cellHeight() {
    return parseInt(this.cell.getAttribute("rowspan") || "1");
  }
  get rowIndex() {
    return this._rowIndex;
  }
  getPositionBefore() {
    return this._table.root.document.model.createPositionAt(this._table.getChild(this.row), this._cellIndex);
  }
}
function mp(o, n) {
  return (t, { writer: e }) => {
    const i = t.getAttribute("headingRows") || 0, r = e.createContainerElement("table", null, []), s = e.createContainerElement("figure", { class: "table" }, r);
    i > 0 && e.insert(e.createPositionAt(r, "end"), e.createContainerElement("thead", null, e.createSlot((a) => a.is("element", "tableRow") && a.index < i))), i < o.getRows(t) && e.insert(e.createPositionAt(r, "end"), e.createContainerElement("tbody", null, e.createSlot((a) => a.is("element", "tableRow") && a.index >= i)));
    for (const { positionOffset: a, filter: l } of n.additionalSlots) e.insert(e.createPositionAt(r, a), e.createSlot(l));
    return e.insert(e.createPositionAt(r, "after"), e.createSlot((a) => !a.is("element", "tableRow") && !n.additionalSlots.some(({ filter: l }) => l(a)))), n.asWidget ? function(a, l) {
      return l.setCustomProperty("table", !0, a), bl(a, l, { hasSelectionHandle: !0 });
    }(s, e) : s;
  };
}
function gp(o = {}) {
  return (n, { writer: t }) => {
    const e = n.parent, i = e.parent, r = i.getChildIndex(e), s = new wt(i, { row: r }), a = i.getAttribute("headingRows") || 0, l = i.getAttribute("headingColumns") || 0;
    let c = null;
    for (const d of s) if (d.cell == n) {
      const u = d.row < a || d.column < l ? "th" : "td";
      c = o.asWidget ? a_(t.createEditableElement(u), t, { withAriaRole: !1 }) : t.createContainerElement(u);
      break;
    }
    return c;
  };
}
function fp(o = {}) {
  return (n, { writer: t }) => {
    if (!n.parent.is("element", "tableCell") || !yv(n)) return null;
    if (o.asWidget) return t.createContainerElement("span", { class: "ck-table-bogus-paragraph" });
    {
      const e = t.createContainerElement("p");
      return t.setCustomProperty("dataPipeline:transparentRendering", !0, e), e;
    }
  };
}
function yv(o) {
  return o.parent.childCount == 1 && !function(n) {
    for (const t of n.getAttributeKeys()) if (!t.startsWith("selection:") && t != "htmlEmptyBlock") return !0;
    return !1;
  }(o);
}
class M4 extends q {
  refresh() {
    const n = this.editor.model, t = n.document.selection, e = n.schema;
    this.isEnabled = function(i, r) {
      const s = i.getFirstPosition().parent, a = s === s.root ? s : s.parent;
      return r.checkChild(a, "table");
    }(t, e);
  }
  execute(n = {}) {
    const t = this.editor, e = t.model, i = t.plugins.get("TableUtils"), r = t.config.get("table.defaultHeadings.rows"), s = t.config.get("table.defaultHeadings.columns");
    n.headingRows === void 0 && r && (n.headingRows = r), n.headingColumns === void 0 && s && (n.headingColumns = s), e.change((a) => {
      const l = i.createTable(a, n);
      e.insertObject(l, null, null, { findOptimalPosition: "auto" }), a.setSelection(a.createPositionAt(l.getNodeByPath([0, 0, 0]), 0));
    });
  }
}
class pp extends q {
  constructor(t, e = {}) {
    super(t);
    m(this, "order");
    this.order = e.order || "below";
  }
  refresh() {
    const t = this.editor.model.document.selection, e = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t).length;
    this.isEnabled = e;
  }
  execute() {
    const t = this.editor, e = t.model.document.selection, i = t.plugins.get("TableUtils"), r = this.order === "above", s = i.getSelectionAffectedTableCells(e), a = i.getRowIndexes(s), l = r ? a.first : a.last, c = s[0].findAncestor("table");
    i.insertRows(c, { at: r ? l : l + 1, copyStructureFromAbove: !r });
  }
}
class bp extends q {
  constructor(t, e = {}) {
    super(t);
    m(this, "order");
    this.order = e.order || "right";
  }
  refresh() {
    const t = this.editor.model.document.selection, e = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t).length;
    this.isEnabled = e;
  }
  execute() {
    const t = this.editor, e = t.model.document.selection, i = t.plugins.get("TableUtils"), r = this.order === "left", s = i.getSelectionAffectedTableCells(e), a = i.getColumnIndexes(s), l = r ? a.first : a.last, c = s[0].findAncestor("table");
    i.insertColumns(c, { columns: 1, at: r ? l : l + 1 });
  }
}
class kp extends q {
  constructor(t, e = {}) {
    super(t);
    m(this, "direction");
    this.direction = e.direction || "horizontally";
  }
  refresh() {
    const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
    this.isEnabled = t.length === 1;
  }
  execute() {
    const t = this.editor.plugins.get("TableUtils"), e = t.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
    this.direction === "horizontally" ? t.splitCellHorizontally(e, 2) : t.splitCellVertically(e, 2);
  }
}
function Cv(o, n, t) {
  const { startRow: e, startColumn: i, endRow: r, endColumn: s } = n, a = t.createElement("table"), l = o.getAttribute("tableType");
  l && t.setAttribute("tableType", l, a);
  const c = r - e + 1;
  for (let u = 0; u < c; u++) t.insertElement("tableRow", a, "end");
  const d = [...new wt(o, { startRow: e, endRow: r, startColumn: i, endColumn: s, includeAllSlots: !0 })];
  for (const { row: u, column: h, cell: g, isAnchor: f, cellAnchorRow: p, cellAnchorColumn: b } of d) {
    const k = u - e, w = a.getChild(k);
    if (f) {
      const _ = t.cloneElement(g);
      t.append(_, w), Sv(_, u, h, r, s, t);
    } else (p < e || b < i) && po(t, t.createPositionAt(w, "end"));
  }
  return function(u, h, g, f, p) {
    const b = parseInt(h.getAttribute("headingRows") || "0");
    b > 0 && Kt("headingRows", b - g, u, p, 0);
    const k = parseInt(h.getAttribute("headingColumns") || "0");
    k > 0 && Kt("headingColumns", k - f, u, p, 0);
  }(a, o, e, i, t), a;
}
function Av(o, n, t = 0) {
  const e = [], i = new wt(o, { startRow: t, endRow: n - 1 });
  for (const r of i) {
    const { row: s, cellHeight: a } = r;
    s < n && n <= s + a - 1 && e.push(r);
  }
  return e;
}
function xv(o, n, t) {
  const e = o.parent, i = e.parent, r = e.index, s = n - r, a = {}, l = parseInt(o.getAttribute("rowspan")) - s;
  l > 1 && (a.rowspan = l);
  const c = parseInt(o.getAttribute("colspan") || "1");
  c > 1 && (a.colspan = c);
  const d = r + s, u = [...new wt(i, { startRow: r, endRow: d, includeAllSlots: !0 })];
  let h, g = null;
  for (const f of u) {
    const { row: p, column: b, cell: k } = f;
    k === o && h === void 0 && (h = b), h !== void 0 && h === b && p === d && (g = po(t, f.getPositionBefore(), a));
  }
  return Kt("rowspan", s, o, t), g;
}
function Ev(o, n) {
  const t = [], e = new wt(o);
  for (const i of e) {
    const { column: r, cellWidth: s } = i;
    r < n && n <= r + s - 1 && t.push(i);
  }
  return t;
}
function Tv(o, n, t, e) {
  const i = t - n, r = {}, s = parseInt(o.getAttribute("colspan")) - i;
  s > 1 && (r.colspan = s);
  const a = parseInt(o.getAttribute("rowspan") || "1");
  a > 1 && (r.rowspan = a);
  const l = po(e, e.createPositionAfter(o), r);
  return Kt("colspan", i, o, e), l;
}
function Sv(o, n, t, e, i, r) {
  const s = parseInt(o.getAttribute("colspan") || "1"), a = parseInt(o.getAttribute("rowspan") || "1");
  t + s - 1 > i && Kt("colspan", i - t + 1, o, r, 1), n + a - 1 > e && Kt("rowspan", e - n + 1, o, r, 1);
}
function Bd(o, n) {
  const t = n.getColumns(o), e = new Array(t).fill(0);
  for (const { column: r } of new wt(o)) e[r]++;
  const i = e.reduce((r, s, a) => s ? r : [...r, a], []);
  if (i.length > 0) {
    const r = i[i.length - 1];
    return n.removeColumns(o, { at: r }), !0;
  }
  return !1;
}
function Nd(o, n) {
  const t = [], e = n.getRows(o);
  for (let i = 0; i < e; i++)
    o.getChild(i).isEmpty && t.push(i);
  if (t.length > 0) {
    const i = t[t.length - 1];
    return n.removeRows(o, { at: i }), !0;
  }
  return !1;
}
function $u(o, n) {
  Bd(o, n) || Nd(o, n);
}
function Iv(o, n) {
  const t = Array.from(new wt(o, { startColumn: n.firstColumn, endColumn: n.lastColumn, row: n.lastRow }));
  if (t.every(({ cellHeight: i }) => i === 1)) return n.lastRow;
  const e = t[0].cellHeight - 1;
  return n.lastRow + e;
}
function Mv(o, n) {
  const t = Array.from(new wt(o, { startRow: n.firstRow, endRow: n.lastRow, column: n.lastColumn }));
  if (t.every(({ cellWidth: i }) => i === 1)) return n.lastColumn;
  const e = t[0].cellWidth - 1;
  return n.lastColumn + e;
}
class Js extends q {
  constructor(t, e) {
    super(t);
    m(this, "direction");
    m(this, "isHorizontal");
    this.direction = e.direction, this.isHorizontal = this.direction == "right" || this.direction == "left";
  }
  refresh() {
    const t = this._getMergeableCell();
    this.value = t, this.isEnabled = !!t;
  }
  execute() {
    const t = this.editor.model, e = t.document, i = this.editor.plugins.get("TableUtils").getTableCellsContainingSelection(e.selection)[0], r = this.value, s = this.direction;
    t.change((a) => {
      const l = s == "right" || s == "down", c = l ? i : r, d = l ? r : i, u = d.parent;
      (function(b, k, w) {
        wp(b) || (wp(k) && w.remove(w.createRangeIn(k)), w.move(w.createRangeIn(b), w.createPositionAt(k, "end"))), w.remove(b);
      })(d, c, a);
      const h = this.isHorizontal ? "colspan" : "rowspan", g = parseInt(i.getAttribute(h) || "1"), f = parseInt(r.getAttribute(h) || "1");
      a.setAttribute(h, g + f, c), a.setSelection(a.createRangeIn(c));
      const p = this.editor.plugins.get("TableUtils");
      $u(u.findAncestor("table"), p);
    });
  }
  _getMergeableCell() {
    const t = this.editor.model.document, e = this.editor.plugins.get("TableUtils"), i = e.getTableCellsContainingSelection(t.selection)[0];
    if (!i) return;
    const r = this.isHorizontal ? function(l, c, d) {
      const u = l.parent, h = u.parent, g = c == "right" ? l.nextSibling : l.previousSibling, f = (h.getAttribute("headingColumns") || 0) > 0;
      if (!g) return;
      const p = c == "right" ? l : g, b = c == "right" ? g : l, { column: k } = d.getCellLocation(p), { column: w } = d.getCellLocation(b), _ = parseInt(p.getAttribute("colspan") || "1"), y = Ld(d, p), C = Ld(d, b);
      if (!(f && y != C))
        return k + _ === w ? g : void 0;
    }(i, this.direction, e) : function(l, c, d) {
      const u = l.parent, h = u.parent, g = h.getChildIndex(u);
      if (c == "down" && g === d.getRows(h) - 1 || c == "up" && g === 0) return null;
      const f = parseInt(l.getAttribute("rowspan") || "1"), p = h.getAttribute("headingRows") || 0, b = c == "down" && g + f === p, k = c == "up" && g === p;
      if (p && (b || k)) return null;
      const w = parseInt(l.getAttribute("rowspan") || "1"), _ = c == "down" ? g + w : g, y = [...new wt(h, { endRow: _ })], C = y.find((P) => P.cell === l), x = C.column, I = y.find(({ row: P, cellHeight: Y, column: it }) => it === x && (c == "down" ? P === _ : _ === P + Y));
      return I && I.cell ? I.cell : null;
    }(i, this.direction, e);
    if (!r) return;
    const s = this.isHorizontal ? "rowspan" : "colspan", a = parseInt(i.getAttribute(s) || "1");
    return parseInt(r.getAttribute(s) || "1") === a ? r : void 0;
  }
}
function wp(o) {
  const n = o.getChild(0);
  return o.childCount == 1 && n.is("element", "paragraph") && n.isEmpty;
}
class D4 extends q {
  refresh() {
    const n = this.editor.plugins.get("TableUtils"), t = n.getSelectionAffectedTableCells(this.editor.model.document.selection), e = t[0];
    if (e) {
      const i = e.findAncestor("table"), r = n.getRows(i) - 1, s = n.getRowIndexes(t), a = s.first === 0 && s.last === r;
      this.isEnabled = !a;
    } else this.isEnabled = !1;
  }
  execute() {
    const n = this.editor.model, t = this.editor.plugins.get("TableUtils"), e = t.getSelectionAffectedTableCells(n.document.selection), i = t.getRowIndexes(e), r = e[0], s = r.findAncestor("table"), a = t.getCellLocation(r).column;
    n.change((l) => {
      const c = i.last - i.first + 1;
      t.removeRows(s, { at: i.first, rows: c });
      const d = function(u, h, g, f) {
        const p = u.getChild(Math.min(h, f - 1));
        let b = p.getChild(0), k = 0;
        for (const w of p.getChildren()) {
          if (k > g) return b;
          b = w, k += parseInt(w.getAttribute("colspan") || "1");
        }
        return b;
      }(s, i.first, a, t.getRows(s));
      l.setSelection(l.createPositionAt(d, 0));
    });
  }
}
class P4 extends q {
  refresh() {
    const n = this.editor.plugins.get("TableUtils"), t = n.getSelectionAffectedTableCells(this.editor.model.document.selection), e = t[0];
    if (e) {
      const i = e.findAncestor("table"), r = n.getColumns(i), { first: s, last: a } = n.getColumnIndexes(t);
      this.isEnabled = a - s < r - 1;
    } else this.isEnabled = !1;
  }
  execute() {
    const n = this.editor.plugins.get("TableUtils"), [t, e] = function(l, c) {
      const d = c.getSelectionAffectedTableCells(l), u = d[0], h = d.pop(), g = [u, h];
      return u.isBefore(h) ? g : g.reverse();
    }(this.editor.model.document.selection, n), i = t.parent.parent, r = [...new wt(i)], s = { first: r.find((l) => l.cell === t).column, last: r.find((l) => l.cell === e).column }, a = function(l, c, d, u) {
      return parseInt(d.getAttribute("colspan") || "1") > 1 ? d : c.previousSibling || d.nextSibling ? d.nextSibling || c.previousSibling : u.first ? l.reverse().find(({ column: g }) => g < u.first).cell : l.reverse().find(({ column: g }) => g > u.last).cell;
    }(r, t, e, s);
    this.editor.model.change((l) => {
      const c = s.last - s.first + 1;
      n.removeColumns(i, { at: s.first, columns: c }), l.setSelection(l.createPositionAt(a, 0));
    });
  }
}
class L4 extends q {
  refresh() {
    const n = this.editor.plugins.get("TableUtils"), t = this.editor.model, e = n.getSelectionAffectedTableCells(t.document.selection);
    if (e.length === 0) return this.isEnabled = !1, void (this.value = !1);
    const i = e[0].findAncestor("table");
    this.isEnabled = t.schema.checkAttribute(i, "headingRows"), this.value = e.every((r) => this._isInHeading(r, r.parent.parent));
  }
  execute(n = {}) {
    if (n.forceValue === this.value) return;
    const t = this.editor.plugins.get("TableUtils"), e = this.editor.model, i = t.getSelectionAffectedTableCells(e.document.selection), r = i[0].findAncestor("table"), { first: s, last: a } = t.getRowIndexes(i), l = this.value ? s : a + 1, c = r.getAttribute("headingRows") || 0;
    e.change((d) => {
      if (l) {
        const u = Av(r, l, l > c ? c : 0);
        for (const { cell: h } of u) xv(h, l, d);
      }
      Kt("headingRows", l, r, d, 0);
    });
  }
  _isInHeading(n, t) {
    const e = parseInt(t.getAttribute("headingRows") || "0");
    return !!e && n.parent.index < e;
  }
}
class B4 extends q {
  refresh() {
    const n = this.editor.plugins.get("TableUtils"), t = this.editor.model, e = n.getSelectionAffectedTableCells(t.document.selection);
    if (e.length === 0) return this.isEnabled = !1, void (this.value = !1);
    const i = e[0].findAncestor("table");
    this.isEnabled = t.schema.checkAttribute(i, "headingColumns"), this.value = e.every((r) => Ld(n, r));
  }
  execute(n = {}) {
    if (n.forceValue === this.value) return;
    const t = this.editor.plugins.get("TableUtils"), e = this.editor.model, i = t.getSelectionAffectedTableCells(e.document.selection), r = i[0].findAncestor("table"), { first: s, last: a } = t.getColumnIndexes(i), l = this.value ? s : a + 1;
    e.change((c) => {
      if (l) {
        const d = Ev(r, l);
        for (const { cell: u, column: h } of d) Tv(u, h, l, c);
      }
      Kt("headingColumns", l, r, c, 0);
    });
  }
}
function N4(o, n) {
  return 4e3 / Dv(o, n);
}
function Dv(o, n) {
  const t = _p(o, "tbody", n) || _p(o, "thead", n);
  return zd(n.editing.view.domConverter.mapViewToDom(t));
}
function _p(o, n, t) {
  return [...[...t.editing.mapper.toViewElement(o).getChildren()].find((e) => e.is("element", "table")).getChildren()].find((e) => e.is("element", n));
}
function zd(o) {
  const n = N.window.getComputedStyle(o);
  return n.boxSizing === "border-box" ? parseFloat(n.width) - parseFloat(n.paddingLeft) - parseFloat(n.paddingRight) - parseFloat(n.borderLeftWidth) - parseFloat(n.borderRightWidth) : parseFloat(n.width);
}
function rn(o) {
  const n = Math.pow(10, 2), t = typeof o == "number" ? o : parseFloat(o);
  return Math.round(t * n) / n;
}
function Wr(o) {
  return o.map((n) => typeof n == "number" ? n : parseFloat(n)).filter((n) => !Number.isNaN(n)).reduce((n, t) => n + t, 0);
}
function qu(o) {
  let n = function(e) {
    const i = e.filter((a) => a === "auto").length;
    if (i === 0) return e.map((a) => rn(a));
    const r = Wr(e), s = Math.max((100 - r) / i, 5);
    return e.map((a) => a === "auto" ? s : a).map((a) => rn(a));
  }(o.map((e) => e === "auto" ? e : parseFloat(e.replace("%", ""))));
  const t = Wr(n);
  return t !== 100 && (n = n.map((e) => rn(100 * e / t)).map((e, i, r) => i !== r.length - 1 ? e : rn(e + 100 - Wr(r)))), n.map((e) => e + "%");
}
function z4(o) {
  const n = N.window.getComputedStyle(o);
  return n.boxSizing === "border-box" ? parseInt(n.width) : parseFloat(n.width) + parseFloat(n.paddingLeft) + parseFloat(n.paddingRight) + parseFloat(n.borderWidth);
}
function Pv(o, n, t, e) {
  for (let i = 0; i < Math.max(t.length, o.length); i++) {
    const r = o[i], s = t[i];
    s ? r ? e.setAttribute("columnWidth", s, r) : e.appendElement("tableColumn", { columnWidth: s }, n) : e.remove(r);
  }
}
function Gr(o) {
  if (o.is("element", "tableColumnGroup")) return o;
  const n = o.getChildren();
  return Array.from(n).find((t) => t.is("element", "tableColumnGroup"));
}
function hs(o) {
  const n = Gr(o);
  return n ? Array.from(n.getChildren()) : [];
}
class he extends A {
  static get pluginName() {
    return "TableUtils";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    this.decorate("insertColumns"), this.decorate("insertRows");
  }
  getCellLocation(n) {
    const t = n.parent, e = t.parent, i = e.getChildIndex(t), r = new wt(e, { row: i });
    for (const { cell: s, row: a, column: l } of r) if (s === n) return { row: a, column: l };
  }
  createTable(n, t) {
    const e = n.createElement("table"), i = t.rows || 2, r = t.columns || 2;
    return Tc(n, e, 0, i, r), t.headingRows && Kt("headingRows", Math.min(t.headingRows, i), e, n, 0), t.headingColumns && Kt("headingColumns", Math.min(t.headingColumns, r), e, n, 0), e;
  }
  insertRows(n, t = {}) {
    const e = this.editor.model, i = t.at || 0, r = t.rows || 1, s = t.copyStructureFromAbove !== void 0, a = t.copyStructureFromAbove ? i - 1 : i, l = this.getRows(n), c = this.getColumns(n);
    if (i > l) throw new v("tableutils-insertrows-insert-out-of-range", this, { options: t });
    e.change((d) => {
      const u = n.getAttribute("headingRows") || 0;
      if (u > i && Kt("headingRows", u + r, n, d, 0), !s && (i === 0 || i === l)) return void Tc(d, n, i, r, c);
      const h = s ? Math.max(i, a) : i, g = new wt(n, { endRow: h }), f = new Array(c).fill(1);
      for (const { row: p, column: b, cellHeight: k, cellWidth: w, cell: _ } of g) {
        const y = p + k - 1, C = p <= a && a <= y;
        p < i && i <= y ? (d.setAttribute("rowspan", k + r, _), f[b] = -w) : s && C && (f[b] = w);
      }
      for (let p = 0; p < r; p++) {
        const b = d.createElement("tableRow");
        d.insert(b, n, i);
        for (let k = 0; k < f.length; k++) {
          const w = f[k], _ = d.createPositionAt(b, "end");
          w > 0 && po(d, _, w > 1 ? { colspan: w } : void 0), k += Math.abs(w) - 1;
        }
      }
    });
  }
  insertColumns(n, t = {}) {
    const e = this.editor.model, i = t.at || 0, r = t.columns || 1;
    e.change((s) => {
      const a = n.getAttribute("headingColumns");
      i < a && s.setAttribute("headingColumns", a + r, n);
      const l = this.getColumns(n);
      if (i === 0 || l === i) {
        for (const d of n.getChildren()) d.is("element", "tableRow") && No(r, s, s.createPositionAt(d, i ? "end" : 0));
        return;
      }
      const c = new wt(n, { column: i, includeAllSlots: !0 });
      for (const d of c) {
        const { row: u, cell: h, cellAnchorColumn: g, cellAnchorRow: f, cellWidth: p, cellHeight: b } = d;
        if (g < i) {
          s.setAttribute("colspan", p + r, h);
          const k = f + b - 1;
          for (let w = u; w <= k; w++) c.skipRow(w);
        } else No(r, s, d.getPositionBefore());
      }
    });
  }
  removeRows(n, t) {
    const e = this.editor.model, i = t.rows || 1, r = this.getRows(n), s = t.at, a = s + i - 1;
    if (a > r - 1) throw new v("tableutils-removerows-row-index-out-of-range", this, { table: n, options: t });
    e.change((l) => {
      const c = { first: s, last: a }, { cellsToMove: d, cellsToTrim: u } = function(h, { first: g, last: f }) {
        const p = /* @__PURE__ */ new Map(), b = [];
        for (const { row: k, column: w, cellHeight: _, cell: y } of new wt(h, { endRow: f })) {
          const C = k + _ - 1;
          if (k >= g && k <= f && C > f) {
            const x = _ - (f - k + 1);
            p.set(w, { cell: y, rowspan: x });
          }
          if (k < g && C >= g) {
            let x;
            x = C >= f ? f - g + 1 : C - g + 1, b.push({ cell: y, rowspan: _ - x });
          }
        }
        return { cellsToMove: p, cellsToTrim: b };
      }(n, c);
      d.size && function(h, g, f, p) {
        const b = new wt(h, { includeAllSlots: !0, row: g }), k = [...b], w = h.getChild(g);
        let _;
        for (const { column: y, cell: C, isAnchor: x } of k) if (f.has(y)) {
          const { cell: I, rowspan: P } = f.get(y), Y = _ ? p.createPositionAfter(_) : p.createPositionAt(w, 0);
          p.move(p.createRangeOn(I), Y), Kt("rowspan", P, I, p), _ = I;
        } else x && (_ = C);
      }(n, a + 1, d, l);
      for (let h = a; h >= s; h--) l.remove(n.getChild(h));
      for (const { rowspan: h, cell: g } of u) Kt("rowspan", h, g, l);
      (function(h, { first: g, last: f }, p) {
        const b = h.getAttribute("headingRows") || 0;
        g < b && Kt("headingRows", f < b ? b - (f - g + 1) : g, h, p, 0);
      })(n, c, l), Bd(n, this) || Nd(n, this);
    });
  }
  removeColumns(n, t) {
    const e = this.editor.model, i = t.at, r = t.columns || 1, s = t.at + r - 1;
    e.change((a) => {
      (function(c, d, u) {
        const h = c.getAttribute("headingColumns") || 0;
        if (h && d.first < h) {
          const g = Math.min(h - 1, d.last) - d.first + 1;
          u.setAttribute("headingColumns", h - g, c);
        }
      })(n, { first: i, last: s }, a);
      const l = hs(n);
      for (let c = s; c >= i; c--) {
        for (const { cell: d, column: u, cellWidth: h } of [...new wt(n)]) u <= c && h > 1 && u + h > c ? Kt("colspan", h - 1, d, a) : u === c && a.remove(d);
        if (l[c]) {
          const d = c === 0 ? l[1] : l[c - 1], u = parseFloat(l[c].getAttribute("columnWidth")), h = parseFloat(d.getAttribute("columnWidth"));
          a.remove(l[c]), a.setAttribute("columnWidth", u + h + "%", d);
        }
      }
      Nd(n, this) || Bd(n, this);
    });
  }
  splitCellVertically(n, t = 2) {
    const e = this.editor.model, i = n.parent.parent, r = parseInt(n.getAttribute("rowspan") || "1"), s = parseInt(n.getAttribute("colspan") || "1");
    e.change((a) => {
      if (s > 1) {
        const { newCellsSpan: l, updatedSpan: c } = vp(s, t);
        Kt("colspan", c, n, a);
        const d = {};
        l > 1 && (d.colspan = l), r > 1 && (d.rowspan = r), No(s > t ? t - 1 : s - 1, a, a.createPositionAfter(n), d);
      }
      if (s < t) {
        const l = t - s, c = [...new wt(i)], { column: d } = c.find(({ cell: f }) => f === n), u = c.filter(({ cell: f, cellWidth: p, column: b }) => f !== n && b === d || b < d && b + p > d);
        for (const { cell: f, cellWidth: p } of u) a.setAttribute("colspan", p + l, f);
        const h = {};
        r > 1 && (h.rowspan = r), No(l, a, a.createPositionAfter(n), h);
        const g = i.getAttribute("headingColumns") || 0;
        g > d && Kt("headingColumns", g + l, i, a);
      }
    });
  }
  splitCellHorizontally(n, t = 2) {
    const e = this.editor.model, i = n.parent, r = i.parent, s = r.getChildIndex(i), a = parseInt(n.getAttribute("rowspan") || "1"), l = parseInt(n.getAttribute("colspan") || "1");
    e.change((c) => {
      if (a > 1) {
        const d = [...new wt(r, { startRow: s, endRow: s + a - 1, includeAllSlots: !0 })], { newCellsSpan: u, updatedSpan: h } = vp(a, t);
        Kt("rowspan", h, n, c);
        const { column: g } = d.find(({ cell: b }) => b === n), f = {};
        u > 1 && (f.rowspan = u), l > 1 && (f.colspan = l);
        let p = 0;
        for (const b of d) {
          const { column: k, row: w } = b, _ = k === g;
          p >= u && _ && (p = 0), w >= s + h && _ && (p || No(1, c, b.getPositionBefore(), f), p++);
        }
      }
      if (a < t) {
        const d = t - a, u = [...new wt(r, { startRow: 0, endRow: s })];
        for (const { cell: f, cellHeight: p, row: b } of u) if (f !== n && b + p > s) {
          const k = p + d;
          c.setAttribute("rowspan", k, f);
        }
        const h = {};
        l > 1 && (h.colspan = l), Tc(c, r, s + 1, d, 1, h);
        const g = r.getAttribute("headingRows") || 0;
        g > s && Kt("headingRows", g + d, r, c);
      }
    });
  }
  getColumns(n) {
    return [...n.getChild(0).getChildren()].filter((t) => t.is("element", "tableCell")).reduce((t, e) => t + parseInt(e.getAttribute("colspan") || "1"), 0);
  }
  getRows(n) {
    return Array.from(n.getChildren()).reduce((t, e) => e.is("element", "tableRow") ? t + 1 : t, 0);
  }
  createTableWalker(n, t = {}) {
    return new wt(n, t);
  }
  getSelectedTableCells(n) {
    const t = [];
    for (const e of this.sortRanges(n.getRanges())) {
      const i = e.getContainedElement();
      i && i.is("element", "tableCell") && t.push(i);
    }
    return t;
  }
  getTableCellsContainingSelection(n) {
    const t = [];
    for (const e of n.getRanges()) {
      const i = e.start.findAncestor("tableCell");
      i && t.push(i);
    }
    return t;
  }
  getSelectionAffectedTableCells(n) {
    const t = this.getSelectedTableCells(n);
    return t.length ? t : this.getTableCellsContainingSelection(n);
  }
  getRowIndexes(n) {
    const t = n.map((e) => e.parent.index);
    return this._getFirstLastIndexesObject(t);
  }
  getColumnIndexes(n) {
    const t = n[0].findAncestor("table"), e = [...new wt(t)].filter((i) => n.includes(i.cell)).map((i) => i.column);
    return this._getFirstLastIndexesObject(e);
  }
  isSelectionRectangular(n) {
    if (n.length < 2 || !this._areCellInTheSameTableSection(n)) return !1;
    const t = /* @__PURE__ */ new Set(), e = /* @__PURE__ */ new Set();
    let i = 0;
    for (const s of n) {
      const { row: a, column: l } = this.getCellLocation(s), c = parseInt(s.getAttribute("rowspan")) || 1, d = parseInt(s.getAttribute("colspan")) || 1;
      t.add(a), e.add(l), c > 1 && t.add(a + c - 1), d > 1 && e.add(l + d - 1), i += c * d;
    }
    return function(s, a) {
      const l = Array.from(s.values()), c = Array.from(a.values()), d = Math.max(...l), u = Math.min(...l), h = Math.max(...c), g = Math.min(...c);
      return (d - u + 1) * (h - g + 1);
    }(t, e) == i;
  }
  sortRanges(n) {
    return Array.from(n).sort(O4);
  }
  _getFirstLastIndexesObject(n) {
    const t = n.sort((e, i) => e - i);
    return { first: t[0], last: t[t.length - 1] };
  }
  _areCellInTheSameTableSection(n) {
    const t = n[0].findAncestor("table"), e = this.getRowIndexes(n), i = parseInt(t.getAttribute("headingRows")) || 0;
    if (!this._areIndexesInSameSection(e, i)) return !1;
    const r = this.getColumnIndexes(n), s = parseInt(t.getAttribute("headingColumns")) || 0;
    return this._areIndexesInSameSection(r, s);
  }
  _areIndexesInSameSection({ first: n, last: t }, e) {
    return n < e == t < e;
  }
}
function Tc(o, n, t, e, i, r = {}) {
  for (let s = 0; s < e; s++) {
    const a = o.createElement("tableRow");
    o.insert(a, n, t), No(i, o, o.createPositionAt(a, "end"), r);
  }
}
function No(o, n, t, e = {}) {
  for (let i = 0; i < o; i++) po(n, t, e);
}
function vp(o, n) {
  if (o < n) return { newCellsSpan: 1, updatedSpan: 1 };
  const t = Math.floor(o / n);
  return { newCellsSpan: t, updatedSpan: o - t * n + t };
}
function O4(o, n) {
  const t = o.start, e = n.start;
  return t.isBefore(e) ? -1 : 1;
}
class R4 extends q {
  refresh() {
    const n = this.editor.plugins.get(he), t = n.getSelectedTableCells(this.editor.model.document.selection);
    this.isEnabled = n.isSelectionRectangular(t);
  }
  execute() {
    const n = this.editor.model, t = this.editor.plugins.get(he);
    n.change((e) => {
      const i = t.getSelectedTableCells(n.document.selection), r = i.shift(), { mergeWidth: s, mergeHeight: a } = function(l, c, d) {
        let u = 0, h = 0;
        for (const k of c) {
          const { row: w, column: _ } = d.getCellLocation(k);
          u = Cp(k, _, u, "colspan"), h = Cp(k, w, h, "rowspan");
        }
        const { row: g, column: f } = d.getCellLocation(l), p = u - f, b = h - g;
        return { mergeWidth: p, mergeHeight: b };
      }(r, i, t);
      Kt("colspan", s, r, e), Kt("rowspan", a, r, e);
      for (const l of i) V4(l, r, e);
      $u(r.findAncestor("table"), t), e.setSelection(r, "in");
    });
  }
}
function V4(o, n, t) {
  yp(o) || (yp(n) && t.remove(t.createRangeIn(n)), t.move(t.createRangeIn(o), t.createPositionAt(n, "end"))), t.remove(o);
}
function yp(o) {
  const n = o.getChild(0);
  return o.childCount == 1 && n.is("element", "paragraph") && n.isEmpty;
}
function Cp(o, n, t, e) {
  const i = parseInt(o.getAttribute(e) || "1");
  return Math.max(t, n + i);
}
class F4 extends q {
  constructor(n) {
    super(n), this.affectsData = !1;
  }
  refresh() {
    const n = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
    this.isEnabled = n.length > 0;
  }
  execute() {
    const n = this.editor.model, t = this.editor.plugins.get("TableUtils"), e = t.getSelectionAffectedTableCells(n.document.selection), i = t.getRowIndexes(e), r = e[0].findAncestor("table"), s = [];
    for (let a = i.first; a <= i.last; a++) for (const l of r.getChild(a).getChildren()) s.push(n.createRangeOn(l));
    n.change((a) => {
      a.setSelection(s);
    });
  }
}
class j4 extends q {
  constructor(n) {
    super(n), this.affectsData = !1;
  }
  refresh() {
    const n = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
    this.isEnabled = n.length > 0;
  }
  execute() {
    const n = this.editor.plugins.get("TableUtils"), t = this.editor.model, e = n.getSelectionAffectedTableCells(t.document.selection), i = e[0], r = e.pop(), s = i.findAncestor("table"), a = n.getCellLocation(i), l = n.getCellLocation(r), c = Math.min(a.column, l.column), d = Math.max(a.column, l.column), u = [];
    for (const h of new wt(s, { startColumn: c, endColumn: d })) u.push(t.createRangeOn(h.cell));
    t.change((h) => {
      h.setSelection(u);
    });
  }
}
function H4(o) {
  o.document.registerPostFixer((n) => function(t, e) {
    const i = e.document.differ.getChanges();
    let r = !1;
    const s = /* @__PURE__ */ new Set();
    for (const a of i) {
      let l = null;
      a.type == "insert" && a.name == "table" && (l = a.position.nodeAfter), a.type != "insert" && a.type != "remove" || a.name != "tableRow" && a.name != "tableCell" || (l = a.position.findAncestor("table")), q4(a) && (l = a.range.start.findAncestor("table")), l && !s.has(l) && (r = U4(l, t) || r, r = $4(l, t) || r, s.add(l));
    }
    return r;
  }(n, o));
}
function U4(o, n) {
  let t = !1;
  const e = function(i) {
    const r = parseInt(i.getAttribute("headingRows") || "0"), s = Array.from(i.getChildren()).reduce((l, c) => c.is("element", "tableRow") ? l + 1 : l, 0), a = [];
    for (const { row: l, cell: c, cellHeight: d } of new wt(i)) {
      if (d < 2) continue;
      const u = l < r ? r : s;
      if (l + d > u) {
        const h = u - l;
        a.push({ cell: c, rowspan: h });
      }
    }
    return a;
  }(o);
  if (e.length) {
    t = !0;
    for (const i of e) Kt("rowspan", i.rowspan, i.cell, n, 1);
  }
  return t;
}
function $4(o, n) {
  let t = !1;
  const e = function(a) {
    const l = new Array(a.childCount).fill(0);
    for (const { rowIndex: c } of new wt(a, { includeAllSlots: !0 })) l[c]++;
    return l;
  }(o), i = [];
  for (const [a, l] of e.entries()) !l && o.getChild(a).is("element", "tableRow") && i.push(a);
  if (i.length) {
    t = !0;
    for (const a of i.reverse()) n.remove(o.getChild(a)), e.splice(a, 1);
  }
  const r = e.filter((a, l) => o.getChild(l).is("element", "tableRow")), s = r[0];
  if (!r.every((a) => a === s)) {
    const a = r.reduce((l, c) => c > l ? c : l, 0);
    for (const [l, c] of r.entries()) {
      const d = a - c;
      if (d) {
        for (let u = 0; u < d; u++) po(n, n.createPositionAt(o.getChild(l), "end"));
        t = !0;
      }
    }
  }
  return t;
}
function q4(o) {
  if (o.type !== "attribute") return !1;
  const n = o.attributeKey;
  return n === "headingRows" || n === "colspan" || n === "rowspan";
}
function W4(o) {
  o.document.registerPostFixer((n) => function(t, e) {
    const i = e.document.differ.getChanges();
    let r = !1;
    for (const s of i) s.type == "insert" && s.name == "table" && (r = G4(s.position.nodeAfter, t) || r), s.type == "insert" && s.name == "tableRow" && (r = Lv(s.position.nodeAfter, t) || r), s.type == "insert" && s.name == "tableCell" && (r = Od(s.position.nodeAfter, t) || r), s.type != "remove" && s.type != "insert" || !K4(s) || (r = Od(s.position.parent, t) || r);
    return r;
  }(n, o));
}
function G4(o, n) {
  let t = !1;
  for (const e of o.getChildren()) e.is("element", "tableRow") && (t = Lv(e, n) || t);
  return t;
}
function Lv(o, n) {
  let t = !1;
  for (const e of o.getChildren()) t = Od(e, n) || t;
  return t;
}
function Od(o, n) {
  if (o.childCount == 0) return n.insertElement("paragraph", o), !0;
  const t = Array.from(o.getChildren()).filter((e) => e.is("$text"));
  for (const e of t) n.wrap(n.createRangeOn(e), "paragraph");
  return !!t.length;
}
function K4(o) {
  return !!o.position.parent.is("element", "tableCell") && (o.type == "insert" && o.name == "$text" || o.type == "remove");
}
function Y4(o, n) {
  if (!o.is("element", "paragraph")) return !1;
  const t = n.toViewElement(o);
  return !!t && yv(o) !== t.is("element", "span");
}
class Wu extends A {
  constructor(t) {
    super(t);
    m(this, "_additionalSlots");
    this._additionalSlots = [];
  }
  static get pluginName() {
    return "TableEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [he];
  }
  init() {
    const t = this.editor, e = t.model, i = e.schema, r = t.conversion, s = t.plugins.get(he);
    i.register("table", { inheritAllFrom: "$blockObject", allowAttributes: ["headingRows", "headingColumns"] }), i.register("tableRow", { allowIn: "table", isLimit: !0 }), i.register("tableCell", { allowContentOf: "$container", allowIn: "tableRow", allowAttributes: ["colspan", "rowspan"], isLimit: !0, isSelectable: !0 }), r.for("upcast").add((a) => {
      a.on("element:figure", (l, c, d) => {
        if (!d.consumable.test(c.viewItem, { name: !0, classes: "table" })) return;
        const u = function(g) {
          for (const f of g.getChildren()) if (f.is("element", "table")) return f;
        }(c.viewItem);
        if (!u || !d.consumable.test(u, { name: !0 })) return;
        d.consumable.consume(c.viewItem, { name: !0, classes: "table" });
        const h = yt(d.convertItem(u, c.modelCursor).modelRange.getItems());
        h ? (d.convertChildren(c.viewItem, d.writer.createPositionAt(h, "end")), d.updateConversionResult(h, c)) : d.consumable.revert(c.viewItem, { name: !0, classes: "table" });
      });
    }), r.for("upcast").add(T4()), r.for("editingDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: mp(s, { asWidget: !0, additionalSlots: this._additionalSlots }) }), r.for("dataDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: mp(s, { additionalSlots: this._additionalSlots }) }), r.for("upcast").elementToElement({ model: "tableRow", view: "tr" }), r.for("upcast").add((a) => {
      a.on("element:tr", (l, c) => {
        c.viewItem.isEmpty && c.modelCursor.index == 0 && l.stop();
      }, { priority: "high" });
    }), r.for("downcast").elementToElement({ model: "tableRow", view: (a, { writer: l }) => a.isEmpty ? l.createEmptyElement("tr") : l.createContainerElement("tr") }), r.for("upcast").elementToElement({ model: "tableCell", view: "td" }), r.for("upcast").elementToElement({ model: "tableCell", view: "th" }), r.for("upcast").add(hp("td")), r.for("upcast").add(hp("th")), r.for("editingDowncast").elementToElement({ model: "tableCell", view: gp({ asWidget: !0 }) }), r.for("dataDowncast").elementToElement({ model: "tableCell", view: gp() }), r.for("editingDowncast").elementToElement({ model: "paragraph", view: fp({ asWidget: !0 }), converterPriority: "high" }), r.for("dataDowncast").elementToElement({ model: "paragraph", view: fp(), converterPriority: "high" }), r.for("downcast").attributeToAttribute({ model: "colspan", view: "colspan" }), r.for("upcast").attributeToAttribute({ model: { key: "colspan", value: Ap("colspan") }, view: "colspan" }), r.for("downcast").attributeToAttribute({ model: "rowspan", view: "rowspan" }), r.for("upcast").attributeToAttribute({ model: { key: "rowspan", value: Ap("rowspan") }, view: "rowspan" }), t.config.define("table.defaultHeadings.rows", 0), t.config.define("table.defaultHeadings.columns", 0), t.commands.add("insertTable", new M4(t)), t.commands.add("insertTableRowAbove", new pp(t, { order: "above" })), t.commands.add("insertTableRowBelow", new pp(t, { order: "below" })), t.commands.add("insertTableColumnLeft", new bp(t, { order: "left" })), t.commands.add("insertTableColumnRight", new bp(t, { order: "right" })), t.commands.add("removeTableRow", new D4(t)), t.commands.add("removeTableColumn", new P4(t)), t.commands.add("splitTableCellVertically", new kp(t, { direction: "vertically" })), t.commands.add("splitTableCellHorizontally", new kp(t, { direction: "horizontally" })), t.commands.add("mergeTableCells", new R4(t)), t.commands.add("mergeTableCellRight", new Js(t, { direction: "right" })), t.commands.add("mergeTableCellLeft", new Js(t, { direction: "left" })), t.commands.add("mergeTableCellDown", new Js(t, { direction: "down" })), t.commands.add("mergeTableCellUp", new Js(t, { direction: "up" })), t.commands.add("setTableColumnHeader", new B4(t)), t.commands.add("setTableRowHeader", new L4(t)), t.commands.add("selectTableRow", new F4(t)), t.commands.add("selectTableColumn", new j4(t)), H4(e), W4(e), this.listenTo(e.document, "change:data", () => {
      (function(a, l) {
        const c = a.document.differ;
        for (const d of c.getChanges()) {
          let u, h = !1;
          if (d.type == "attribute") {
            const b = d.range.start.nodeAfter;
            if (!b || !b.is("element", "table") || d.attributeKey != "headingRows" && d.attributeKey != "headingColumns") continue;
            u = b, h = d.attributeKey == "headingRows";
          } else d.name != "tableRow" && d.name != "tableCell" || (u = d.position.findAncestor("table"), h = d.name == "tableRow");
          if (!u) continue;
          const g = u.getAttribute("headingRows") || 0, f = u.getAttribute("headingColumns") || 0, p = new wt(u);
          for (const b of p) {
            const k = b.row < g || b.column < f ? "th" : "td", w = l.mapper.toViewElement(b.cell);
            w && w.is("element") && w.name != k && l.reconvertItem(h ? b.cell.parent : b.cell);
          }
        }
      })(e, t.editing), function(a, l) {
        const c = a.document.differ, d = /* @__PURE__ */ new Set();
        for (const u of c.getChanges()) {
          const h = u.type == "attribute" ? u.range.start.parent : u.position.parent;
          h.is("element", "tableCell") && d.add(h);
        }
        for (const u of d.values()) {
          const h = Array.from(u.getChildren()).filter((g) => Y4(g, l.mapper));
          for (const g of h) l.reconvertItem(g);
        }
      }(e, t.editing);
    });
  }
  registerAdditionalSlot(t) {
    this._additionalSlots.push(t);
  }
}
function Ap(o) {
  return (n) => {
    const t = parseInt(n.getAttribute(o));
    return Number.isNaN(t) || t <= 0 ? null : t;
  };
}
class xp extends L {
  constructor(t) {
    super(t);
    m(this, "items");
    m(this, "keystrokes");
    m(this, "focusTracker");
    const e = this.bindTemplate;
    this.items = this._createGridCollection(), this.keystrokes = new Mt(), this.focusTracker = new gt(), this.set("rows", 0), this.set("columns", 0), this.bind("label").to(this, "columns", this, "rows", (i, r) => `${r}  ${i}`), this.setTemplate({ tag: "div", attributes: { class: ["ck"] }, children: [{ tag: "div", attributes: { class: ["ck-insert-table-dropdown__grid"] }, on: { "mouseover@.ck-insert-table-dropdown-grid-box": e.to("boxover") }, children: this.items }, { tag: "div", attributes: { class: ["ck", "ck-insert-table-dropdown__label"], "aria-hidden": !0 }, children: [{ text: e.to("label") }] }], on: { mousedown: e.to((i) => {
      i.preventDefault();
    }), click: e.to(() => {
      this.fire("execute");
    }) } }), this.on("boxover", (i, r) => {
      const { row: s, column: a } = r.target.dataset;
      this.items.get(10 * (parseInt(s, 10) - 1) + (parseInt(a, 10) - 1)).focus();
    }), this.focusTracker.on("change:focusedElement", (i, r, s) => {
      if (!s) return;
      const { row: a, column: l } = s.dataset;
      this.set({ rows: parseInt(a), columns: parseInt(l) });
    }), this.on("change:columns", () => this._highlightGridBoxes()), this.on("change:rows", () => this._highlightGridBoxes());
  }
  render() {
    super.render(), vs({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.items, numberOfColumns: 10, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection });
    for (const t of this.items) this.focusTracker.add(t.element);
    this.keystrokes.listenTo(this.element);
  }
  reset() {
    this.set({ rows: 1, columns: 1 });
  }
  focus() {
    this.items.get(0).focus();
  }
  focusLast() {
    this.items.get(0).focus();
  }
  _highlightGridBoxes() {
    const t = this.rows, e = this.columns;
    this.items.map((i, r) => {
      const s = Math.floor(r / 10) < t && r % 10 < e;
      i.set("isOn", s);
    });
  }
  _createGridButton(t, e, i, r) {
    const s = new V(t);
    return s.set({ label: r, class: "ck-insert-table-dropdown-grid-box" }), s.extendTemplate({ attributes: { "data-row": e, "data-column": i } }), s;
  }
  _createGridCollection() {
    const t = [];
    for (let e = 0; e < 100; e++) {
      const i = Math.floor(e / 10), r = e % 10, s = `${i + 1}  ${r + 1}`;
      t.push(this._createGridButton(this.locale, i + 1, r + 1, s));
    }
    return this.createCollection(t);
  }
}
class Z4 extends A {
  static get pluginName() {
    return "TableUI";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    const n = this.editor, t = this.editor.t, e = n.locale.contentLanguageDirection === "ltr";
    n.ui.componentFactory.add("insertTable", (i) => {
      const r = n.commands.get("insertTable"), s = ge(i);
      let a;
      return s.bind("isEnabled").to(r), s.buttonView.set({ icon: Um, label: t("Insert table"), tooltip: !0 }), s.on("change:isOpen", () => {
        a || (a = new xp(i), s.panelView.children.add(a), a.delegate("execute").to(s), s.on("execute", () => {
          n.execute("insertTable", { rows: a.rows, columns: a.columns }), n.editing.view.focus();
        }));
      }), s;
    }), n.ui.componentFactory.add("menuBar:insertTable", (i) => {
      const r = n.commands.get("insertTable"), s = new Me(i), a = new xp(i);
      return a.delegate("execute").to(s), s.on("change:isOpen", (l, c, d) => {
        d || a.reset();
      }), a.on("execute", () => {
        n.execute("insertTable", { rows: a.rows, columns: a.columns }), n.editing.view.focus();
      }), s.buttonView.set({ label: t("Table"), icon: Um }), s.panelView.children.add(a), s.bind("isEnabled").to(r), s;
    }), n.ui.componentFactory.add("tableColumn", (i) => {
      const r = [{ type: "switchbutton", model: { commandName: "setTableColumnHeader", label: t("Header column"), bindIsOn: !0 } }, { type: "separator" }, { type: "button", model: { commandName: e ? "insertTableColumnLeft" : "insertTableColumnRight", label: t("Insert column left") } }, { type: "button", model: { commandName: e ? "insertTableColumnRight" : "insertTableColumnLeft", label: t("Insert column right") } }, { type: "button", model: { commandName: "removeTableColumn", label: t("Delete column") } }, { type: "button", model: { commandName: "selectTableColumn", label: t("Select column") } }];
      return this._prepareDropdown(t("Column"), cE, r, i);
    }), n.ui.componentFactory.add("tableRow", (i) => {
      const r = [{ type: "switchbutton", model: { commandName: "setTableRowHeader", label: t("Header row"), bindIsOn: !0 } }, { type: "separator" }, { type: "button", model: { commandName: "insertTableRowAbove", label: t("Insert row above") } }, { type: "button", model: { commandName: "insertTableRowBelow", label: t("Insert row below") } }, { type: "button", model: { commandName: "removeTableRow", label: t("Delete row") } }, { type: "button", model: { commandName: "selectTableRow", label: t("Select row") } }];
      return this._prepareDropdown(t("Row"), uE, r, i);
    }), n.ui.componentFactory.add("mergeTableCells", (i) => {
      const r = [{ type: "button", model: { commandName: "mergeTableCellUp", label: t("Merge cell up") } }, { type: "button", model: { commandName: e ? "mergeTableCellRight" : "mergeTableCellLeft", label: t("Merge cell right") } }, { type: "button", model: { commandName: "mergeTableCellDown", label: t("Merge cell down") } }, { type: "button", model: { commandName: e ? "mergeTableCellLeft" : "mergeTableCellRight", label: t("Merge cell left") } }, { type: "separator" }, { type: "button", model: { commandName: "splitTableCellVertically", label: t("Split cell vertically") } }, { type: "button", model: { commandName: "splitTableCellHorizontally", label: t("Split cell horizontally") } }];
      return this._prepareMergeSplitButtonDropdown(t("Merge cells"), dE, r, i);
    });
  }
  _prepareDropdown(n, t, e, i) {
    const r = this.editor, s = ge(i), a = this._fillDropdownWithListOptions(s, e);
    return s.buttonView.set({ label: n, icon: t, tooltip: !0 }), s.bind("isEnabled").toMany(a, "isEnabled", (...l) => l.some((c) => c)), this.listenTo(s, "execute", (l) => {
      r.execute(l.source.commandName), l.source instanceof ys || r.editing.view.focus();
    }), s;
  }
  _prepareMergeSplitButtonDropdown(n, t, e, i) {
    const r = this.editor, s = ge(i, mo), a = "mergeTableCells", l = r.commands.get(a), c = this._fillDropdownWithListOptions(s, e);
    return s.buttonView.set({ label: n, icon: t, tooltip: !0, isEnabled: !0 }), s.bind("isEnabled").toMany([l, ...c], "isEnabled", (...d) => d.some((u) => u)), this.listenTo(s.buttonView, "execute", () => {
      r.execute(a), r.editing.view.focus();
    }), this.listenTo(s, "execute", (d) => {
      r.execute(d.source.commandName), r.editing.view.focus();
    }), s;
  }
  _fillDropdownWithListOptions(n, t) {
    const e = this.editor, i = [], r = new ne();
    for (const s of t) Q4(s, e, i, r);
    return zi(n, r), i;
  }
}
function Q4(o, n, t, e) {
  if (o.type === "button" || o.type === "switchbutton") {
    const i = o.model = new ai(o.model), { commandName: r, bindIsOn: s } = o.model, a = n.commands.get(r);
    t.push(a), i.set({ commandName: r }), i.bind("isEnabled").to(a), s && i.bind("isOn").to(a, "value"), i.set({ withText: !0 });
  }
  e.add(o);
}
class xi extends A {
  static get pluginName() {
    return "TableSelection";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [he, he];
  }
  init() {
    const n = this.editor, t = n.model, e = n.editing.view;
    this.listenTo(t, "deleteContent", (i, r) => this._handleDeleteContent(i, r), { priority: "high" }), this.listenTo(e.document, "insertText", (i, r) => this._handleInsertTextEvent(i, r), { priority: "high" }), this._defineSelectionConverter(), this._enablePluginDisabling();
  }
  getSelectedTableCells() {
    const n = this.editor.plugins.get(he), t = this.editor.model.document.selection, e = n.getSelectedTableCells(t);
    return e.length == 0 ? null : e;
  }
  getSelectionAsFragment() {
    const n = this.editor.plugins.get(he), t = this.getSelectedTableCells();
    return t ? this.editor.model.change((e) => {
      const i = e.createDocumentFragment(), { first: r, last: s } = n.getColumnIndexes(t), { first: a, last: l } = n.getRowIndexes(t), c = t[0].findAncestor("table");
      let d = l, u = s;
      if (n.isSelectionRectangular(t)) {
        const g = { firstColumn: r, lastColumn: s, firstRow: a, lastRow: l };
        d = Iv(c, g), u = Mv(c, g);
      }
      const h = Cv(c, { startRow: a, startColumn: r, endRow: d, endColumn: u }, e);
      return e.insert(h, i, 0), i;
    }) : null;
  }
  setCellSelection(n, t) {
    const e = this._getCellsToSelect(n, t);
    this.editor.model.change((i) => {
      i.setSelection(e.cells.map((r) => i.createRangeOn(r)), { backward: e.backward });
    });
  }
  getFocusCell() {
    const n = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
    return n && n.is("element", "tableCell") ? n : null;
  }
  getAnchorCell() {
    const n = yt(this.editor.model.document.selection.getRanges()).getContainedElement();
    return n && n.is("element", "tableCell") ? n : null;
  }
  _defineSelectionConverter() {
    const n = this.editor, t = /* @__PURE__ */ new Set();
    n.conversion.for("editingDowncast").add((e) => e.on("selection", (i, r, s) => {
      const a = s.writer;
      (function(d) {
        for (const u of t) d.removeClass("ck-editor__editable_selected", u);
        t.clear();
      })(a);
      const l = this.getSelectedTableCells();
      if (!l) return;
      for (const d of l) {
        const u = s.mapper.toViewElement(d);
        a.addClass("ck-editor__editable_selected", u), t.add(u);
      }
      const c = s.mapper.toViewElement(l[l.length - 1]);
      a.setSelection(c, 0);
    }, { priority: "lowest" }));
  }
  _enablePluginDisabling() {
    const n = this.editor;
    this.on("change:isEnabled", () => {
      if (!this.isEnabled) {
        const t = this.getSelectedTableCells();
        if (!t) return;
        n.model.change((e) => {
          const i = e.createPositionAt(t[0], 0), r = n.model.schema.getNearestSelectionRange(i);
          e.setSelection(r);
        });
      }
    });
  }
  _handleDeleteContent(n, t) {
    const e = this.editor.plugins.get(he), i = t[0], r = t[1], s = this.editor.model, a = !r || r.direction == "backward", l = e.getSelectedTableCells(i);
    l.length && (n.stop(), s.change((c) => {
      const d = l[a ? l.length - 1 : 0];
      s.change((h) => {
        for (const g of l) s.deleteContent(h.createSelection(g, "in"));
      });
      const u = s.schema.getNearestSelectionRange(c.createPositionAt(d, 0));
      i.is("documentSelection") ? c.setSelection(u) : i.setTo(u);
    }));
  }
  _handleInsertTextEvent(n, t) {
    const e = this.editor, i = this.getSelectedTableCells();
    if (!i) return;
    const r = e.editing.view, s = e.editing.mapper, a = i.map((l) => r.createRangeOn(s.toViewElement(l)));
    t.selection = r.createSelection(a);
  }
  _getCellsToSelect(n, t) {
    const e = this.editor.plugins.get("TableUtils"), i = e.getCellLocation(n), r = e.getCellLocation(t), s = Math.min(i.row, r.row), a = Math.max(i.row, r.row), l = Math.min(i.column, r.column), c = parseInt(t.getAttribute("colspan") || "1") - 1, d = Math.max(i.column, r.column + c), u = new Array(a - s + 1).fill(null).map(() => []), h = { startRow: s, endRow: a, startColumn: l, endColumn: d };
    for (const { row: p, cell: b } of new wt(n.findAncestor("table"), h)) u[p - s].push(b);
    const g = r.row < i.row, f = r.column < i.column;
    return g && u.reverse(), f && u.forEach((p) => p.reverse()), { cells: u.flat(), backward: g || f };
  }
}
class J4 extends A {
  static get pluginName() {
    return "TableClipboard";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [qr, De, xi, he];
  }
  init() {
    const n = this.editor.editing.view.document;
    this.listenTo(n, "copy", (t, e) => this._onCopyCut(t, e)), this.listenTo(n, "cut", (t, e) => this._onCopyCut(t, e)), this._listenToContentInsertion(), this.decorate("_replaceTableSlotCell");
  }
  _listenToContentInsertion() {
    const { editor: n } = this, t = n.plugins.get(De), e = n.plugins.get(xi);
    let i = !1;
    t.on("contentInsertion", (r, s) => {
      i = s.method === "paste";
    }), this.listenTo(n.model, "insertContent", (r, [s, a]) => {
      (i || e.getSelectedTableCells() !== null) && this._onInsertContent(r, s, a);
    }, { priority: "high" }), t.on("contentInsertion", () => {
      i = !1;
    }, { priority: "lowest" });
  }
  _onCopyCut(n, t) {
    const e = this.editor.editing.view, i = this.editor.plugins.get(xi), r = this.editor.plugins.get(qr);
    i.getSelectedTableCells() && (n.name != "cut" || this.editor.model.canEditAt(this.editor.model.document.selection)) && (t.preventDefault(), n.stop(), this.editor.model.enqueueChange({ isUndoable: n.name === "cut" }, () => {
      const s = r._copySelectedFragmentWithMarkers(n.name, this.editor.model.document.selection, () => i.getSelectionAsFragment());
      e.document.fire("clipboardOutput", { dataTransfer: t.dataTransfer, content: this.editor.data.toView(s), method: n.name });
    }));
  }
  _onInsertContent(n, t, e) {
    if (e && !e.is("documentSelection")) return;
    const i = this.editor.model, r = this.editor.plugins.get(he), s = this.editor.plugins.get(qr), a = this.getTableIfOnlyTableInContent(t, i);
    if (!a) return;
    const l = r.getSelectionAffectedTableCells(i.document.selection);
    l.length ? (n.stop(), t.is("documentFragment") ? s._pasteMarkersIntoTransformedElement(t.markers, (c) => this._replaceSelectedCells(a, l, c)) : this.editor.model.change((c) => {
      this._replaceSelectedCells(a, l, c);
    })) : $u(a, r);
  }
  _replaceSelectedCells(n, t, e) {
    const i = this.editor.plugins.get(he), r = { width: i.getColumns(n), height: i.getRows(n) }, s = function(u, h, g, f) {
      const p = u[0].findAncestor("table"), b = f.getColumnIndexes(u), k = f.getRowIndexes(u), w = { firstColumn: b.first, lastColumn: b.last, firstRow: k.first, lastRow: k.last }, _ = u.length === 1;
      return _ && (w.lastRow += h.height - 1, w.lastColumn += h.width - 1, function(y, C, x, I) {
        const P = I.getColumns(y), Y = I.getRows(y);
        x > P && I.insertColumns(y, { at: P, columns: x - P }), C > Y && I.insertRows(y, { at: Y, rows: C - Y });
      }(p, w.lastRow + 1, w.lastColumn + 1, f)), _ || !f.isSelectionRectangular(u) ? function(y, C, x) {
        const { firstRow: I, lastRow: P, firstColumn: Y, lastColumn: it } = C, te = { first: I, last: P }, ct = { first: Y, last: it };
        Ic(y, Y, te, x), Ic(y, it + 1, te, x), Sc(y, I, ct, x), Sc(y, P + 1, ct, x, I);
      }(p, w, g) : (w.lastRow = Iv(p, w), w.lastColumn = Mv(p, w)), w;
    }(t, r, e, i), a = s.lastRow - s.firstRow + 1, l = s.lastColumn - s.firstColumn + 1;
    n = Cv(n, { startRow: 0, startColumn: 0, endRow: Math.min(a, r.height) - 1, endColumn: Math.min(l, r.width) - 1 }, e);
    const c = t[0].findAncestor("table"), d = this._replaceSelectedCellsWithPasted(n, r, c, s, e);
    if (this.editor.plugins.get("TableSelection").isEnabled) {
      const u = i.sortRanges(d.map((h) => e.createRangeOn(h)));
      e.setSelection(u);
    } else e.setSelection(d[0], 0);
    return c;
  }
  _replaceSelectedCellsWithPasted(n, t, e, i, r) {
    const { width: s, height: a } = t, l = function(b, k, w) {
      const _ = new Array(w).fill(null).map(() => new Array(k).fill(null));
      for (const { column: y, row: C, cell: x } of new wt(b)) _[C][y] = x;
      return _;
    }(n, s, a), c = [...new wt(e, { startRow: i.firstRow, endRow: i.lastRow, startColumn: i.firstColumn, endColumn: i.lastColumn, includeAllSlots: !0 })], d = [];
    let u;
    for (const b of c) {
      const { row: k, column: w } = b;
      w === i.firstColumn && (u = b.getPositionBefore());
      const _ = k - i.firstRow, y = w - i.firstColumn, C = l[_ % a][y % s], x = C ? r.cloneElement(C) : null, I = this._replaceTableSlotCell(b, x, u, r);
      I && (Sv(I, k, w, i.lastRow, i.lastColumn, r), d.push(I), u = r.createPositionAfter(I));
    }
    const h = parseInt(e.getAttribute("headingRows") || "0"), g = parseInt(e.getAttribute("headingColumns") || "0"), f = i.firstRow < h && h <= i.lastRow, p = i.firstColumn < g && g <= i.lastColumn;
    if (f) {
      const b = Sc(e, h, { first: i.firstColumn, last: i.lastColumn }, r, i.firstRow);
      d.push(...b);
    }
    if (p) {
      const b = Ic(e, g, { first: i.firstRow, last: i.lastRow }, r);
      d.push(...b);
    }
    return d;
  }
  _replaceTableSlotCell(n, t, e, i) {
    const { cell: r, isAnchor: s } = n;
    return s && i.remove(r), t ? (i.insert(t, e), t) : null;
  }
  getTableIfOnlyTableInContent(n, t) {
    if (!n.is("documentFragment") && !n.is("element")) return null;
    if (n.is("element", "table")) return n;
    if (n.childCount == 1 && n.getChild(0).is("element", "table")) return n.getChild(0);
    const e = t.createRangeIn(n);
    for (const i of e.getItems()) if (i.is("element", "table")) {
      const r = t.createRange(e.start, t.createPositionBefore(i));
      if (t.hasContent(r, { ignoreWhitespaces: !0 })) return null;
      const s = t.createRange(t.createPositionAfter(i), e.end);
      return t.hasContent(s, { ignoreWhitespaces: !0 }) ? null : i;
    }
    return null;
  }
}
function Sc(o, n, t, e, i = 0) {
  if (!(n < 1))
    return Av(o, n, i).filter(({ column: r, cellWidth: s }) => Bv(r, s, t)).map(({ cell: r }) => xv(r, n, e));
}
function Ic(o, n, t, e) {
  if (!(n < 1))
    return Ev(o, n).filter(({ row: i, cellHeight: r }) => Bv(i, r, t)).map(({ cell: i, column: r }) => Tv(i, r, n, e));
}
function Bv(o, n, t) {
  const e = o + n - 1, { first: i, last: r } = t;
  return o >= i && o <= r || o < i && e >= i;
}
class X4 extends A {
  static get pluginName() {
    return "TableKeyboard";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [xi, he];
  }
  init() {
    const n = this.editor, t = n.editing.view.document, e = n.t;
    this.listenTo(t, "arrowKey", (...i) => this._onArrowKey(...i), { context: "table" }), this.listenTo(t, "tab", (...i) => this._handleTabOnSelectedTable(...i), { context: "figure" }), this.listenTo(t, "tab", (...i) => this._handleTab(...i), { context: ["th", "td"] }), n.accessibility.addKeystrokeInfoGroup({ id: "table", label: e("Keystrokes that can be used in a table cell"), keystrokes: [{ label: e("Move the selection to the next cell"), keystroke: "Tab" }, { label: e("Move the selection to the previous cell"), keystroke: "Shift+Tab" }, { label: e("Insert a new table row (when in the last cell of a table)"), keystroke: "Tab" }, { label: e("Navigate through the table"), keystroke: [["arrowup"], ["arrowright"], ["arrowdown"], ["arrowleft"]] }] });
  }
  _handleTabOnSelectedTable(n, t) {
    const e = this.editor, i = e.model.document.selection.getSelectedElement();
    i && i.is("element", "table") && (t.preventDefault(), t.stopPropagation(), n.stop(), e.model.change((r) => {
      r.setSelection(r.createRangeIn(i.getChild(0).getChild(0)));
    }));
  }
  _handleTab(n, t) {
    const e = this.editor, i = this.editor.plugins.get(he), r = this.editor.plugins.get("TableSelection"), s = e.model.document.selection, a = !t.shiftKey;
    let l = i.getTableCellsContainingSelection(s)[0];
    if (l || (l = r.getFocusCell()), !l) return;
    t.preventDefault(), t.stopPropagation(), n.stop();
    const c = l.parent, d = c.parent, u = d.getChildIndex(c), h = c.getChildIndex(l), g = h === 0;
    if (!a && g && u === 0) return void e.model.change((k) => {
      k.setSelection(k.createRangeOn(d));
    });
    const f = h === c.childCount - 1, p = u === i.getRows(d) - 1;
    if (a && p && f && (e.execute("insertTableRowBelow"), u === i.getRows(d) - 1)) return void e.model.change((k) => {
      k.setSelection(k.createRangeOn(d));
    });
    let b;
    if (a && f)
      b = d.getChild(u + 1).getChild(0);
    else if (!a && g) {
      const k = d.getChild(u - 1);
      b = k.getChild(k.childCount - 1);
    } else b = c.getChild(h + (a ? 1 : -1));
    e.model.change((k) => {
      k.setSelection(k.createRangeIn(b));
    });
  }
  _onArrowKey(n, t) {
    const e = this.editor, i = rl(t.keyCode, e.locale.contentLanguageDirection);
    this._handleArrowKeys(i, t.shiftKey) && (t.preventDefault(), t.stopPropagation(), n.stop());
  }
  _handleArrowKeys(n, t) {
    const e = this.editor.plugins.get(he), i = this.editor.plugins.get("TableSelection"), r = this.editor.model, s = r.document.selection, a = ["right", "down"].includes(n), l = e.getSelectedTableCells(s);
    if (l.length) {
      let d;
      return d = t ? i.getFocusCell() : a ? l[l.length - 1] : l[0], this._navigateFromCellInDirection(d, n, t), !0;
    }
    const c = s.focus.findAncestor("tableCell");
    if (!c) return !1;
    if (!s.isCollapsed) if (t) {
      if (s.isBackward == a && !s.containsEntireContent(c)) return !1;
    } else {
      const d = s.getSelectedElement();
      if (!d || !r.schema.isObject(d)) return !1;
    }
    return !!this._isSelectionAtCellEdge(s, c, a) && (this._navigateFromCellInDirection(c, n, t), !0);
  }
  _isSelectionAtCellEdge(n, t, e) {
    const i = this.editor.model, r = this.editor.model.schema, s = e ? n.getLastPosition() : n.getFirstPosition();
    if (!r.getLimitElement(s).is("element", "tableCell"))
      return i.createPositionAt(t, e ? "end" : 0).isTouching(s);
    const a = i.createSelection(s);
    return i.modifySelection(a, { direction: e ? "forward" : "backward" }), s.isEqual(a.focus);
  }
  _navigateFromCellInDirection(n, t, e = !1) {
    const i = this.editor.model, r = n.findAncestor("table"), s = [...new wt(r, { includeAllSlots: !0 })], { row: a, column: l } = s[s.length - 1], c = s.find(({ cell: p }) => p == n);
    let { row: d, column: u } = c;
    switch (t) {
      case "left":
        u--;
        break;
      case "up":
        d--;
        break;
      case "right":
        u += c.cellWidth;
        break;
      case "down":
        d += c.cellHeight;
    }
    if (d < 0 || d > a || u < 0 && d <= 0 || u > l && d >= a) return void i.change((p) => {
      p.setSelection(p.createRangeOn(r));
    });
    u < 0 ? (u = e ? 0 : l, d--) : u > l && (u = e ? l : 0, d++);
    const h = s.find((p) => p.row == d && p.column == u).cell, g = ["right", "down"].includes(t), f = this.editor.plugins.get("TableSelection");
    if (e && f.isEnabled) {
      const p = f.getAnchorCell() || n;
      f.setCellSelection(p, h);
    } else {
      const p = i.createPositionAt(h, g ? 0 : "end");
      i.change((b) => {
        b.setSelection(p);
      });
    }
  }
}
class Nv extends Fn {
  constructor() {
    super(...arguments);
    m(this, "domEventType", ["mousemove", "mouseleave"]);
  }
  onDomEvent(t) {
    this.fire(t.type, t);
  }
}
class t3 extends A {
  static get pluginName() {
    return "TableMouse";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [xi, he];
  }
  init() {
    this.editor.editing.view.addObserver(Nv), this._enableShiftClickSelection(), this._enableMouseDragSelection();
  }
  _enableShiftClickSelection() {
    const n = this.editor, t = n.plugins.get(he);
    let e = !1;
    const i = n.plugins.get(xi);
    this.listenTo(n.editing.view.document, "mousedown", (r, s) => {
      const a = n.model.document.selection;
      if (!this.isEnabled || !i.isEnabled || !s.domEvent.shiftKey) return;
      const l = i.getAnchorCell() || t.getTableCellsContainingSelection(a)[0];
      if (!l) return;
      const c = this._getModelTableCellFromDomEvent(s);
      c && Ep(l, c) && (e = !0, i.setCellSelection(l, c), s.preventDefault());
    }), this.listenTo(n.editing.view.document, "mouseup", () => {
      e = !1;
    }), this.listenTo(n.editing.view.document, "selectionChange", (r) => {
      e && r.stop();
    }, { priority: "highest" });
  }
  _enableMouseDragSelection() {
    const n = this.editor;
    let t, e, i = !1, r = !1;
    const s = n.plugins.get(xi);
    this.listenTo(n.editing.view.document, "mousedown", (a, l) => {
      this.isEnabled && s.isEnabled && (l.domEvent.shiftKey || l.domEvent.ctrlKey || l.domEvent.altKey || (t = this._getModelTableCellFromDomEvent(l)));
    }), this.listenTo(n.editing.view.document, "mousemove", (a, l) => {
      if (!l.domEvent.buttons || !t) return;
      const c = this._getModelTableCellFromDomEvent(l);
      c && Ep(t, c) && (e = c, i || e == t || (i = !0)), i && (r = !0, s.setCellSelection(t, e), l.preventDefault());
    }), this.listenTo(n.editing.view.document, "mouseup", () => {
      i = !1, r = !1, t = null, e = null;
    }), this.listenTo(n.editing.view.document, "selectionChange", (a) => {
      r && a.stop();
    }, { priority: "highest" });
  }
  _getModelTableCellFromDomEvent(n) {
    const t = n.target, e = this.editor.editing.view.createPositionAt(t, 0);
    return this.editor.editing.mapper.toModelPosition(e).parent.findAncestor("tableCell", { includeSelf: !0 });
  }
}
function Ep(o, n) {
  return o.parent.parent == n.parent.parent;
}
class e3 extends A {
  static get requires() {
    return [Wu, Z4, xi, t3, X4, J4, cr];
  }
  static get pluginName() {
    return "Table";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
function n3(o) {
  const n = o.getSelectedElement();
  return n && zv(n) ? n : null;
}
function i3(o) {
  const n = o.getFirstPosition();
  if (!n) return null;
  let t = n.parent;
  for (; t; ) {
    if (t.is("element") && zv(t)) return t;
    t = t.parent;
  }
  return null;
}
function zv(o) {
  return !!o.getCustomProperty("table") && Yt(o);
}
class o3 extends A {
  static get requires() {
    return [La];
  }
  static get pluginName() {
    return "TableToolbar";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  afterInit() {
    const n = this.editor, t = n.t, e = n.plugins.get(La), i = n.config.get("table.contentToolbar"), r = n.config.get("table.tableToolbar");
    i && e.register("tableContent", { ariaLabel: t("Table toolbar"), items: i, getRelatedElement: i3 }), r && e.register("table", { ariaLabel: t("Table toolbar"), items: r, getRelatedElement: n3 });
  }
}
[se.defaultPositions.northArrowSouth, se.defaultPositions.northArrowSouthWest, se.defaultPositions.northArrowSouthEast, se.defaultPositions.southArrowNorth, se.defaultPositions.southArrowNorthWest, se.defaultPositions.southArrowNorthEast, se.defaultPositions.viewportStickyNorth];
function r3(o, n) {
  const t = parseFloat(o);
  return Number.isNaN(t) || String(t) !== String(o) ? o : `${t}${n}`;
}
function s3(o, n = {}) {
  const t = { borderStyle: "none", borderWidth: "", borderColor: "", backgroundColor: "", width: "", height: "", ...o };
  return n.includeAlignmentProperty && !t.alignment && (t.alignment = "center"), n.includePaddingProperty && !t.padding && (t.padding = ""), n.includeVerticalAlignmentProperty && !t.verticalAlignment && (t.verticalAlignment = "middle"), n.includeHorizontalAlignmentProperty && !t.horizontalAlignment && (t.horizontalAlignment = n.isRightToLeftContent ? "right" : "left"), t;
}
function a3(o, n) {
  return s3({ borderStyle: "solid", borderColor: "hsl(0, 0%, 75%)", borderWidth: "1px", ...o }, n);
}
class l3 extends q {
  constructor(t, e, i) {
    super(t);
    m(this, "attributeName");
    m(this, "_defaultValue");
    m(this, "_defaultContentTableValue");
    m(this, "_defaultLayoutTableValue");
    switch (this.attributeName = e, this._defaultContentTableValue = i, e) {
      case "tableCellBorderStyle":
        this._defaultLayoutTableValue = "none";
        break;
      case "tableCellHorizontalAlignment":
        this._defaultLayoutTableValue = "left";
        break;
      case "tableCellVerticalAlignment":
        this._defaultLayoutTableValue = "middle";
        break;
      default:
        this._defaultLayoutTableValue = void 0;
    }
  }
  refresh() {
    const t = this.editor.model.document.selection, e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t), i = E4(t);
    this._defaultValue = i && i.getAttribute("tableType") === "layout" ? this._defaultLayoutTableValue : this._defaultContentTableValue, this.isEnabled = !!e.length, this.value = this._getSingleValue(e);
  }
  execute(t = {}) {
    const { value: e, batch: i } = t, r = this.editor.model, s = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(r.document.selection), a = this._getValueToSet(e);
    r.enqueueChange(i, (l) => {
      a ? s.forEach((c) => l.setAttribute(this.attributeName, a, c)) : s.forEach((c) => l.removeAttribute(this.attributeName, c));
    });
  }
  _getAttribute(t) {
    if (!t) return;
    const e = t.getAttribute(this.attributeName);
    return e !== this._defaultValue ? e : void 0;
  }
  _getValueToSet(t) {
    if (t !== this._defaultValue) return t;
  }
  _getSingleValue(t) {
    const e = this._getAttribute(t[0]);
    return t.every((i) => this._getAttribute(i) === e) ? e : void 0;
  }
}
class c3 extends l3 {
  constructor(n, t) {
    super(n, "tableCellWidth", t);
  }
  _getValueToSet(n) {
    if ((n = r3(n, "px")) !== this._defaultValue) return n;
  }
}
class d3 extends A {
  static get pluginName() {
    return "TableCellWidthEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  static get requires() {
    return [Wu];
  }
  init() {
    const n = this.editor, t = a3(n.config.get("table.tableCellProperties.defaultProperties"));
    x4(n.model.schema, n.conversion, { modelAttribute: "tableCellWidth", styleName: "width", defaultValue: t.width }), n.commands.add("tableCellWidth", new c3(n, t.width));
  }
}
class u3 extends q {
  refresh() {
    this.isEnabled = !0;
  }
  execute(n = {}) {
    const { model: t, plugins: e } = this.editor;
    let { table: i = t.document.selection.getSelectedElement(), columnWidths: r, tableWidth: s } = n;
    r && (r = Array.isArray(r) ? r : r.split(",")), t.change((a) => {
      s ? a.setAttribute("tableWidth", s, i) : a.removeAttribute("tableWidth", i);
      const l = e.get("TableColumnResizeEditing").getColumnGroupElement(i);
      if (!r && !l) return;
      if (!r) return a.remove(l);
      const c = qu(r);
      if (l) Array.from(l.getChildren()).forEach((d, u) => a.setAttribute("columnWidth", c[u], d));
      else {
        const d = a.createElement("tableColumnGroup");
        c.forEach((u) => a.appendElement("tableColumn", { columnWidth: u }, d)), a.append(d, i);
      }
    });
  }
}
function h3(o) {
  return (n) => n.on("element:colgroup", (t, e, i) => {
    const r = e.modelCursor.findAncestor("table"), s = Gr(r);
    if (!s) return;
    const a = hs(s), l = o.getColumns(r);
    let c = (d = s, u = i.writer, hs(d).reduce((h, g) => {
      const f = g.getAttribute("columnWidth"), p = g.getAttribute("colSpan");
      if (!p) return h.push(f), h;
      for (let b = 0; b < p; b++) h.push(f);
      return u.removeAttribute("colSpan", g), h;
    }, []));
    var d, u;
    c = Array.from({ length: l }, (h, g) => c[g] || "auto"), (c.length != a.length || c.includes("auto")) && Pv(a, s, qu(c), i.writer);
  }, { priority: "low" });
}
const Tp = Li("px");
class m3 extends A {
  constructor(t) {
    super(t);
    m(this, "_isResizingActive");
    m(this, "_resizingData");
    m(this, "_domEmitter");
    m(this, "_tableUtilsPlugin");
    m(this, "_initialMouseEventData", null);
    this._isResizingActive = !1, this.set("_isResizingAllowed", !0), this._resizingData = null, this._domEmitter = new (Pe())(), this._tableUtilsPlugin = t.plugins.get("TableUtils"), this.on("change:_isResizingAllowed", (e, i, r) => {
      const s = r ? "removeClass" : "addClass";
      t.editing.view.change((a) => {
        for (const l of t.editing.view.document.roots) a[s]("ck-column-resize_disabled", t.editing.view.document.getRoot(l.rootName));
      });
    });
  }
  static get requires() {
    return [Wu, he];
  }
  static get pluginName() {
    return "TableColumnResizeEditing";
  }
  static get isOfficialPlugin() {
    return !0;
  }
  init() {
    this._extendSchema(), this._registerPostFixer(), this._registerConverters(), this._registerResizingListeners(), this._registerResizerInserter();
    const t = this.editor, e = t.plugins.get("TableColumnResize");
    t.plugins.get("TableEditing").registerAdditionalSlot({ filter: (r) => r.is("element", "tableColumnGroup"), positionOffset: 0 });
    const i = new u3(t);
    t.commands.add("resizeTableWidth", i), t.commands.add("resizeColumnWidths", i), this.bind("_isResizingAllowed").to(t, "isReadOnly", e, "isEnabled", i, "isEnabled", (r, s, a) => !r && s && a);
  }
  destroy() {
    this._domEmitter.stopListening(), super.destroy();
  }
  getColumnGroupElement(t) {
    return Gr(t);
  }
  getTableColumnElements(t) {
    return hs(t);
  }
  getTableColumnsWidths(t) {
    return function(e) {
      return hs(e).map((i) => i.getAttribute("columnWidth"));
    }(t);
  }
  _extendSchema() {
    this.editor.model.schema.extend("table", { allowAttributes: ["tableWidth"] }), this.editor.model.schema.register("tableColumnGroup", { allowIn: "table", isLimit: !0 }), this.editor.model.schema.register("tableColumn", { allowIn: "tableColumnGroup", allowAttributes: ["columnWidth", "colSpan"], isLimit: !0 });
  }
  _registerPostFixer() {
    const t = this.editor.model;
    function e(i, r, s) {
      const a = s._tableUtilsPlugin.getColumns(r);
      if (a - i.length === 0) return i;
      const l = i.map((u) => Number(u.replace("%", ""))), c = function(u, h) {
        const g = /* @__PURE__ */ new Set();
        for (const f of u.getChanges()) if (f.type == "insert" && f.position.nodeAfter && f.position.nodeAfter.name == "tableCell" && f.position.nodeAfter.getAncestors().includes(h)) g.add(f.position.nodeAfter);
        else if (f.type == "remove") {
          const p = f.position.nodeBefore || f.position.nodeAfter;
          p.name == "tableCell" && p.getAncestors().includes(h) && g.add(p);
        }
        return g;
      }(s.editor.model.document.differ, r);
      for (const u of c) {
        const h = a - l.length;
        if (h === 0) continue;
        const g = h > 0, f = s._tableUtilsPlugin.getCellLocation(u).column;
        if (g) {
          const p = N4(r, s.editor), b = (d = p, Array(h).fill(d));
          l.splice(f, 0, ...b);
        } else {
          const p = l.splice(f, Math.abs(h));
          l[f] += Wr(p);
        }
      }
      var d;
      return l.map((u) => u + "%");
    }
    t.document.registerPostFixer((i) => {
      let r = !1;
      for (const s of function(a) {
        const l = /* @__PURE__ */ new Set();
        for (const c of a.document.differ.getChanges()) {
          let d = null;
          switch (c.type) {
            case "insert":
              d = ["table", "tableRow", "tableCell"].includes(c.name) ? c.position : null;
              break;
            case "remove":
              d = ["tableRow", "tableCell"].includes(c.name) ? c.position : null;
              break;
            case "attribute":
              c.range.start.nodeAfter && (d = ["table", "tableRow", "tableCell"].includes(c.range.start.nodeAfter.name) ? c.range.start : null);
          }
          if (!d) continue;
          const u = d.nodeAfter && d.nodeAfter.is("element", "table") ? d.nodeAfter : d.findAncestor("table");
          for (const h of a.createRangeOn(u).getItems()) h.is("element", "table") && Gr(h) && l.add(h);
        }
        return l;
      }(t)) {
        const a = this.getColumnGroupElement(s), l = this.getTableColumnElements(a), c = this.getTableColumnsWidths(a);
        let d = qu(c);
        d = e(d, s, this), ba(c, d) || (Pv(l, a, d, i), r = !0);
      }
      return r;
    });
  }
  _registerConverters() {
    const t = this.editor.conversion;
    t.for("upcast").attributeToAttribute({ view: { name: /^(figure|table)$/, styles: { width: /[\s\S]+/ } }, model: { name: "table", key: "tableWidth", value: (e) => e.getStyle("width") } }), t.for("downcast").attributeToAttribute({ model: { name: "table", key: "tableWidth" }, view: (e) => ({ name: "figure", key: "style", value: { width: e } }) }), t.elementToElement({ model: "tableColumnGroup", view: "colgroup" }), t.elementToElement({ model: "tableColumn", view: "col" }), t.for("downcast").add((e) => e.on("insert:table", (i, r, s) => {
      const a = s.writer, l = r.item, c = s.mapper.toViewElement(l), d = c.is("element", "table") ? c : Array.from(c.getChildren()).find((u) => u.is("element", "table"));
      Gr(l) ? a.addClass("ck-table-resized", d) : a.removeClass("ck-table-resized", d);
    }, { priority: "low" })), t.for("upcast").add(h3(this._tableUtilsPlugin)), t.for("upcast").attributeToAttribute({ view: { name: "col", styles: { width: /.*/ } }, model: { key: "columnWidth", value: (e) => {
      const i = e.getStyle("width");
      return i && (i.endsWith("%") || i.endsWith("pt")) ? i : "auto";
    } } }), t.for("upcast").attributeToAttribute({ view: { name: "col", key: "span" }, model: "colSpan" }), t.for("downcast").attributeToAttribute({ model: { name: "tableColumn", key: "columnWidth" }, view: (e) => ({ key: "style", value: { width: e } }) });
  }
  _registerResizingListeners() {
    const t = this.editor.editing.view;
    t.addObserver(Nv), t.document.on("mouseover", this._onMouseOverHandler.bind(this), { priority: "high" }), t.document.on("mousedown", this._onMouseDownHandler.bind(this), { priority: "high" }), t.document.on("mouseout", this._onMouseOutHandler.bind(this), { priority: "high" }), this._domEmitter.listenTo(N.window.document, "mousemove", Qo(this._onMouseMoveHandler.bind(this), 50)), this._domEmitter.listenTo(N.window.document, "mouseup", this._onMouseUpHandler.bind(this));
  }
  _recalculateResizerElement(t) {
    const e = this.editor, i = e.editing.view.domConverter, r = i.mapViewToDom(t.findAncestor("table")), s = i.mapViewToDom(t.findAncestor((u) => ["td", "th"].includes(u.name))), a = new K(r), l = new K(s), c = Tp(Number((a.top - l.top).toFixed(4))), d = Tp(Number((l.bottom - a.bottom).toFixed(4)));
    e.editing.view.change((u) => {
      u.setStyle("top", c, t), u.setStyle("bottom", d, t);
    });
  }
  _resetResizerStyles(t) {
    this.editor.editing.view.change((e) => {
      e.removeStyle("top", t), e.removeStyle("bottom", t);
    });
  }
  _onMouseOverHandler(t, e) {
    const i = e.target;
    i.hasClass("ck-table-column-resizer") && this._isResizingAllowed && this._recalculateResizerElement(i);
  }
  _onMouseOutHandler(t, e) {
    const i = e.target;
    i.hasClass("ck-table-column-resizer") && this._isResizingAllowed && (this._isResizingActive || this._resetResizerStyles(i));
  }
  _onMouseDownHandler(t, e) {
    const i = e.target;
    if (!i.hasClass("ck-table-column-resizer") || !this._isResizingAllowed) return;
    const r = this.editor, s = r.editing.mapper.toModelElement(i.findAncestor("figure"));
    r.model.canEditAt(s) && (e.preventDefault(), t.stop(), this._initialMouseEventData = e);
  }
  _startResizingAfterThreshold() {
    const t = this._initialMouseEventData, { target: e } = t, i = this.editor.editing.mapper.toModelElement(e.findAncestor("figure")), r = e.findAncestor("table"), s = function(a, l, c) {
      const d = Array(l.getColumns(a)), u = new wt(a);
      for (const h of u) {
        const g = c.editing.mapper.toViewElement(h.cell), f = z4(c.editing.view.domConverter.mapViewToDom(g));
        (!d[h.column] || f < d[h.column]) && (d[h.column] = rn(f));
      }
      return d;
    }(i, this._tableUtilsPlugin, this.editor);
    Array.from(r.getChildren()).find((a) => a.is("element", "colgroup")) || this.editor.editing.view.change((a) => {
      (function(l, c, d) {
        const u = l.createContainerElement("colgroup");
        for (let h = 0; h < c.length; h++) {
          const g = l.createEmptyElement("col"), f = `${rn(c[h] / Wr(c) * 100)}%`;
          l.setStyle("width", f, g), l.insert(l.createPositionAt(u, "end"), g);
        }
        l.insert(l.createPositionAt(d, 0), u);
      })(a, s, r);
    }), this._isResizingActive = !0, this._resizingData = this._getResizingData(t, s), this.editor.editing.view.change((a) => function(l, c, d) {
      const u = d.widths.viewFigureWidth / d.widths.viewFigureParentWidth;
      l.addClass("ck-table-resized", c), l.addClass("ck-table-column-resizer__active", d.elements.viewResizer), l.setStyle("width", `${rn(100 * u)}%`, c.findAncestor("figure"));
    }(a, r, this._resizingData));
  }
  _onMouseMoveHandler(t, e) {
    if (this._initialMouseEventData) {
      const I = this._initialMouseEventData.domEvent;
      if (!(Math.abs(e.clientX - I.clientX) >= 3)) return;
      this._startResizingAfterThreshold(), this._initialMouseEventData = null;
    }
    if (!this._isResizingActive) return;
    if (!this._isResizingAllowed) return void this._onMouseUpHandler();
    const { columnPosition: i, flags: { isRightEdge: r, isTableCentered: s, isLtrContent: a }, elements: { viewFigure: l, viewLeftColumn: c, viewRightColumn: d, viewResizer: u }, widths: { viewFigureParentWidth: h, tableWidth: g, leftColumnWidth: f, rightColumnWidth: p } } = this._resizingData, b = 40 - f, k = r ? h - g : p - 40, w = (a ? 1 : -1) * (r && s ? 2 : 1), _ = (y = (e.clientX - i) * w, C = Math.min(b, 0), x = Math.max(k, 0), rn(y <= C ? C : y >= x ? x : y));
    var y, C, x;
    _ !== 0 && (this.editor.editing.view.change((I) => {
      const P = rn(100 * (f + _) / g);
      if (I.setStyle("width", `${P}%`, c), r) {
        const Y = rn(100 * (g + _) / h);
        I.setStyle("width", `${Y}%`, l);
      } else {
        const Y = rn(100 * (p - _) / g);
        I.setStyle("width", `${Y}%`, d);
      }
    }), this._recalculateResizerElement(u));
  }
  _onMouseUpHandler() {
    if (this._initialMouseEventData = null, !this._isResizingActive) return;
    const { viewResizer: t, modelTable: e, viewFigure: i, viewColgroup: r } = this._resizingData.elements, s = this.editor, a = s.editing.view, l = this.getColumnGroupElement(e), c = Array.from(r.getChildren()).filter((b) => b.is("view:element")), d = l ? this.getTableColumnsWidths(l) : null, u = c.map((b) => b.getStyle("width")), h = !ba(d, u), g = e.getAttribute("tableWidth"), f = i.getStyle("width"), p = g !== f;
    (h || p) && (this._isResizingAllowed ? s.execute("resizeTableWidth", { table: e, tableWidth: `${rn(f)}%`, columnWidths: u }) : a.change((b) => {
      if (d) for (const k of c) b.setStyle("width", d.shift(), k);
      else b.remove(r);
      p && (g ? b.setStyle("width", g, i) : b.removeStyle("width", i)), d || g || b.removeClass("ck-table-resized", [...i.getChildren()].find((k) => k.name === "table"));
    })), a.change((b) => {
      b.removeClass("ck-table-column-resizer__active", t);
    }), a.domConverter.mapViewToDom(t).matches(":hover") || this._resetResizerStyles(t), this._isResizingActive = !1, this._resizingData = null;
  }
  _getResizingData(t, e) {
    const i = this.editor, r = t.domEvent.clientX, s = t.target, a = s.findAncestor("td") || s.findAncestor("th"), l = i.editing.mapper.toModelElement(a), c = l.findAncestor("table"), d = function(_, y) {
      const C = y.getCellLocation(_).column;
      return { leftEdge: C, rightEdge: C + (_.getAttribute("colspan") || 1) - 1 };
    }(l, this._tableUtilsPlugin).rightEdge, u = d === this._tableUtilsPlugin.getColumns(c) - 1, h = !c.hasAttribute("tableAlignment"), g = i.locale.contentLanguageDirection !== "rtl", f = a.findAncestor("table"), p = f.findAncestor("figure"), b = [...f.getChildren()].find((_) => _.is("element", "colgroup")), k = b.getChild(d), w = u ? void 0 : b.getChild(d + 1);
    return { columnPosition: r, flags: { isRightEdge: u, isTableCentered: h, isLtrContent: g }, elements: { viewResizer: s, modelTable: c, viewFigure: p, viewColgroup: b, viewLeftColumn: k, viewRightColumn: w }, widths: { viewFigureParentWidth: zd(i.editing.view.domConverter.mapViewToDom(p.parent)), viewFigureWidth: zd(i.editing.view.domConverter.mapViewToDom(p)), tableWidth: Dv(c, i), leftColumnWidth: e[d], rightColumnWidth: u ? void 0 : e[d + 1] } };
  }
  _registerResizerInserter() {
    this.editor.conversion.for("editingDowncast").add((t) => {
      t.on("insert:tableCell", (e, i, r) => {
        const s = i.item, a = r.mapper.toViewElement(s), l = r.writer;
        l.insert(l.createPositionAt(a, "end"), l.createUIElement("div", { class: "ck-table-column-resizer" }));
      }, { priority: "lowest" });
    });
  }
}
class g3 extends A {
  static get requires() {
    return [m3, d3];
  }
  static get pluginName() {
    return "TableColumnResize";
  }
  static get isOfficialPlugin() {
    return !0;
  }
}
const f3 = `:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-dialog-background:var(--ck-custom-background);--ck-color-dialog-form-header-border:var(--ck-custom-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-color-light-red:#fcc;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;box-sizing:border-box;height:auto;margin:0;padding:0;position:static;text-decoration:none;transition:none;vertical-align:middle;width:auto}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}.ck.ck-autocomplete>.ck-search__results{background:var(--ck-color-base-background);border:1px solid var(--ck-color-dropdown-panel-border);border-radius:0;max-height:200px;min-width:auto;overflow-y:auto}.ck-rounded-corners .ck.ck-autocomplete>.ck-search__results,.ck.ck-autocomplete>.ck-search__results.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-autocomplete>.ck-search__results{box-shadow:var(--ck-drop-shadow),0 0}.ck.ck-autocomplete>.ck-search__results.ck-search__results_n{border-bottom-left-radius:0;border-bottom-right-radius:0;margin-bottom:-1px}.ck.ck-autocomplete>.ck-search__results.ck-search__results_s{border-top-left-radius:0;border-top-right-radius:0;margin-top:-1px}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;background:var(--ck-color-button-default-background);border:1px solid transparent;border-radius:0;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}@media (prefers-reduced-motion:reduce){.ck.ck-button,a.ck.ck-button{transition:none}}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit;opacity:.5}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-right:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-medium)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background);color:var(--ck-color-button-on-color)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background);color:var(--ck-color-button-action-text)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;border-radius:0;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);border-radius:0;height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}@media (prefers-reduced-motion:reduce){.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{transition:none}}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}.ck.ck-button.ck-list-item-button{padding:var(--ck-spacing-tiny) calc(var(--ck-spacing-standard)*2)}.ck.ck-button.ck-list-item-button,.ck.ck-button.ck-list-item-button.ck-on{background:var(--ck-color-list-background);color:var(--ck-color-text)}[dir=ltr] .ck.ck-button.ck-list-item-button:has(.ck-list-item-button__check-holder){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-list-item-button:has(.ck-list-item-button__check-holder){padding-right:var(--ck-spacing-small)}.ck.ck-button.ck-list-item-button.ck-button.ck-on:hover,.ck.ck-button.ck-list-item-button.ck-on:hover,.ck.ck-button.ck-list-item-button.ck-on:not(.ck-list-item-button_toggleable),.ck.ck-button.ck-list-item-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-button.ck-list-item-button.ck-button.ck-on:hover:not(.ck-disabled),.ck.ck-button.ck-list-item-button.ck-on:hover:not(.ck-disabled),.ck.ck-button.ck-list-item-button.ck-on:not(.ck-list-item-button_toggleable):not(.ck-disabled),.ck.ck-button.ck-list-item-button:hover:not(.ck-disabled):not(.ck-disabled){color:var(--ck-color-text)}:root{--ck-collapsible-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-collapsible>.ck.ck-button{border-radius:0;color:inherit;font-weight:700;width:100%}.ck.ck-collapsible>.ck.ck-button:focus{background:transparent}.ck.ck-collapsible>.ck.ck-button:active,.ck.ck-collapsible>.ck.ck-button:hover:not(:focus),.ck.ck-collapsible>.ck.ck-button:not(:focus){background:transparent;border-color:transparent;box-shadow:none}.ck.ck-collapsible>.ck.ck-button>.ck-icon{margin-right:var(--ck-spacing-medium);width:var(--ck-collapsible-arrow-size)}.ck.ck-collapsible>.ck-collapsible__children{padding:var(--ck-spacing-medium) var(--ck-spacing-large) var(--ck-spacing-large)}.ck.ck-collapsible.ck-collapsible_collapsed>.ck.ck-button .ck-icon{transform:rotate(-90deg)}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{transition:box-shadow .2s ease}@media (forced-colors:none){.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile.ck-color-selector__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}}@media (forced-colors:active){.ck.ck-color-grid__tile{height:unset;min-height:unset;min-width:unset;padding:0 var(--ck-spacing-small);width:unset}.ck.ck-color-grid__tile .ck-button__label{display:inline-block}}@media (prefers-reduced-motion:reduce){.ck.ck-color-grid__tile{transition:none}}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{width:100%}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-left:var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment label.ck.ck-color-grid__label{font-weight:unset}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker{padding:8px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker{height:100px;min-width:180px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation){border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue){border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius)}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue-pointer),.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation-pointer){height:15px;width:15px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{padding:0 8px 8px}:root{--ck-dialog-overlay-background-color:rgba(0,0,0,.5);--ck-dialog-drop-shadow:0px 0px 6px 2px rgba(0,0,0,.15);--ck-dialog-max-width:100vw;--ck-dialog-max-height:90vh;--ck-color-dialog-background:var(--ck-color-base-background);--ck-color-dialog-form-header-border:var(--ck-color-base-border)}.ck.ck-dialog-overlay{animation:ck-dialog-fade-in .3s;background:var(--ck-dialog-overlay-background-color);z-index:var(--ck-z-dialog)}.ck.ck-dialog{--ck-drop-shadow:var(--ck-dialog-drop-shadow);background:var(--ck-color-dialog-background);border:1px solid var(--ck-color-base-border);border-radius:0;max-height:var(--ck-dialog-max-height);max-width:var(--ck-dialog-max-width);overscroll-behavior:contain}.ck-rounded-corners .ck.ck-dialog,.ck.ck-dialog.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dialog{box-shadow:var(--ck-drop-shadow),0 0}.ck.ck-dialog .ck.ck-form__header{border-bottom:1px solid var(--ck-color-dialog-form-header-border)}.ck-dialog-scroll-locked{overflow:hidden}@keyframes ck-dialog-fade-in{0%{background:transparent}to{background:var(--ck-dialog-overlay-background-color)}}.ck.ck-dialog .ck.ck-dialog__actions{padding:var(--ck-spacing-large)}.ck.ck-dialog .ck.ck-dialog__actions>*+*{margin-left:var(--ck-spacing-large)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);border-radius:0;bottom:0;min-width:100%}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{box-shadow:var(--ck-drop-shadow),0 0}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}.ck.ck-dropdown__panel:focus{outline:none}.ck.ck-dropdown>.ck-dropdown__panel>.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown>.ck-dropdown__panel>.ck-list,.ck.ck-dropdown>.ck-dropdown__panel>.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown>.ck-dropdown__panel>.ck-list .ck-list__item:first-child>.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown>.ck-dropdown__panel>.ck-list .ck-list__item:first-child>.ck-button,.ck.ck-dropdown>.ck-dropdown__panel>.ck-list .ck-list__item:first-child>.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown>.ck-dropdown__panel>.ck-list .ck-list__item:last-child>.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown>.ck-dropdown__panel>.ck-list .ck-list__item:last-child>.ck-button,.ck.ck-dropdown>.ck-dropdown__panel>.ck-list .ck-list__item:last-child>.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}.ck.ck-button.ck-dropdown-menu-list__nested-menu__button{border-radius:0;padding:var(--ck-spacing-tiny) calc(var(--ck-spacing-standard)*2);width:100%}.ck.ck-button.ck-dropdown-menu-list__nested-menu__button:focus{border-color:transparent;box-shadow:none}.ck.ck-button.ck-dropdown-menu-list__nested-menu__button:focus:not(.ck-on){background:var(--ck-color-button-default-hover-background)}.ck.ck-button.ck-dropdown-menu-list__nested-menu__button>.ck-button__label{flex-grow:1;overflow:hidden;text-overflow:ellipsis}.ck.ck-button.ck-dropdown-menu-list__nested-menu__button.ck-disabled>.ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-dropdown-menu-list__nested-menu__button.ck-icon-spacing:not(:has(.ck-button__icon))>.ck-button__label{margin-left:calc(var(--ck-icon-size) - var(--ck-spacing-small))}.ck.ck-button.ck-dropdown-menu-list__nested-menu__button>.ck-dropdown-menu-list__nested-menu__button__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-button.ck-dropdown-menu-list__nested-menu__button>.ck-dropdown-menu-list__nested-menu__button__arrow{margin-right:calc(var(--ck-spacing-small)*-1);transform:rotate(-90deg)}[dir=rtl] .ck.ck-button.ck-dropdown-menu-list__nested-menu__button>.ck-dropdown-menu-list__nested-menu__button__arrow{margin-left:calc(var(--ck-spacing-small)*-1);transform:rotate(90deg)}.ck.ck-button.ck-dropdown-menu-list__nested-menu__button.ck-disabled>.ck-dropdown-menu-list__nested-menu__button__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-button.ck-dropdown-menu-list__nested-menu__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=ltr] .ck.ck-button.ck-dropdown-menu-list__nested-menu__button>.ck-dropdown-menu-list__nested-menu__button__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-dropdown-menu-list__nested-menu__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-dropdown-menu-list__nested-menu__button>.ck-dropdown-menu-list__nested-menu__button__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}:root{--ck-dropdown-menu-menu-item-min-width:18em}.ck.ck-dropdown-menu-list__nested-menu__item{min-width:var(--ck-dropdown-menu-menu-item-min-width)}.ck-button.ck-dropdown-menu-list__nested-menu__item__button{border-radius:0}.ck-button.ck-dropdown-menu-list__nested-menu__item__button>.ck-spinner-container,.ck-button.ck-dropdown-menu-list__nested-menu__item__button>.ck-spinner-container .ck-spinner{--ck-toolbar-spinner-size:20px}.ck-button.ck-dropdown-menu-list__nested-menu__item__button>.ck-spinner-container{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}.ck-button.ck-dropdown-menu-list__nested-menu__item__button:focus{border-color:transparent;box-shadow:none}.ck-button.ck-dropdown-menu-list__nested-menu__item__button:focus:not(.ck-on){background:var(--ck-color-button-default-hover-background)}:root{--ck-dropdown-menu-menu-panel-max-width:75vw}.ck.ck-balloon-panel.ck-dropdown-menu__nested-menu__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;height:fit-content;max-width:var(--ck-dropdown-menu-menu-panel-max-width)}.ck.ck-balloon-panel.ck-dropdown-menu__nested-menu__panel:after,.ck.ck-balloon-panel.ck-dropdown-menu__nested-menu__panel:before{display:none}.ck.ck-balloon-panel.ck-dropdown-menu__nested-menu__panel.ck-balloon-panel_es,.ck.ck-balloon-panel.ck-dropdown-menu__nested-menu__panel.ck-balloon-panel_se{border-top-left-radius:0}.ck.ck-balloon-panel.ck-dropdown-menu__nested-menu__panel.ck-balloon-panel_sw,.ck.ck-balloon-panel.ck-dropdown-menu__nested-menu__panel.ck-balloon-panel_ws{border-top-right-radius:0}.ck.ck-balloon-panel.ck-dropdown-menu__nested-menu__panel.ck-balloon-panel_en,.ck.ck-balloon-panel.ck-dropdown-menu__nested-menu__panel.ck-balloon-panel_ne{border-bottom-left-radius:0}.ck.ck-balloon-panel.ck-dropdown-menu__nested-menu__panel.ck-balloon-panel_nw,.ck.ck-balloon-panel.ck-dropdown-menu__nested-menu__panel.ck-balloon-panel_wn{border-bottom-right-radius:0}.ck.ck-balloon-panel.ck-dropdown-menu__nested-menu__panel:focus{outline:none}:root{--ck-accessibility-help-dialog-max-width:600px;--ck-accessibility-help-dialog-max-height:400px;--ck-accessibility-help-dialog-border-color:#ccced1;--ck-accessibility-help-dialog-code-background-color:#ededed;--ck-accessibility-help-dialog-kbd-shadow-color:#9c9c9c}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content{border:1px solid transparent;max-height:var(--ck-accessibility-help-dialog-max-height);max-width:var(--ck-accessibility-help-dialog-max-width);overflow:auto;padding:var(--ck-spacing-large);user-select:text}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content *{white-space:normal}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content .ck-label{display:none}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content h3{font-size:1.2em;font-weight:700}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content h4{font-size:1em;font-weight:700}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content h3,.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content h4,.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content p,.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content table{margin:1em 0}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content dl{border-bottom:none;border-top:1px solid var(--ck-accessibility-help-dialog-border-color);display:grid;grid-template-columns:2fr 1fr}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content dl dd,.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content dl dt{border-bottom:1px solid var(--ck-accessibility-help-dialog-border-color);padding:.4em 0}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content dl dt{grid-column-start:1}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content dl dd{grid-column-start:2;text-align:right}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content code,.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content kbd{background:var(--ck-accessibility-help-dialog-code-background-color);border-radius:2px;display:inline-block;font-size:.9em;line-height:1;padding:.4em;text-align:center;vertical-align:middle}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content code{font-family:monospace}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content kbd{box-shadow:0 1px 1px var(--ck-accessibility-help-dialog-kbd-shadow-color);margin:0 1px;min-width:1.8em}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content kbd+kbd{margin-left:2px}:root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background)}:root{--ck-form-header-height:44px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}[dir=ltr] .ck.ck-form__header>.ck-icon{margin-right:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-form__header>.ck-icon{margin-left:var(--ck-spacing-medium)}.ck.ck-form__header .ck-form__header__label{--ck-font-size-base:15px;font-weight:700}.ck.ck-form__header:has(.ck-button-back.ck-hidden){padding-inline:var(--ck-spacing-large) var(--ck-spacing-large)}.ck.ck-form__header:has(.ck-button-back:not(.ck-hidden)){padding-inline:var(--ck-spacing-small) var(--ck-spacing-small)}.ck.ck-form__header>.ck-button-back{margin-inline-end:var(--ck-spacing-small)}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal));--ck-icon-font-size:.8333350694em}.ck.ck-icon{font-size:var(--ck-icon-font-size);height:var(--ck-icon-size);width:var(--ck-icon-size)}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}:root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);border-radius:0;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}@media (prefers-reduced-motion:reduce){.ck.ck-input{transition:none}}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}@media (prefers-reduced-motion:reduce){.ck.ck-input.ck-error{animation:none}}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}.ck.ck-label{font-weight:700}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;top:0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0;transform:translate(calc(var(--ck-spacing-medium)*-1),-6px) scale(.75);transform-origin:100% 0}@media (prefers-reduced-motion:reduce){.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transition:none}}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty:not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder):not(.ck-error)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty:not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder):not(.ck-error)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty:not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder):not(.ck-error)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}.ck.ck-labeled-field-view.ck-labeled-field-view_full-width{flex-grow:1}.ck.ck-labeled-input .ck-labeled-input__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-input .ck-labeled-input__status_error{color:var(--ck-color-base-error)}.ck.ck-list{background:var(--ck-color-list-background);border-radius:0;list-style-type:none;padding:var(--ck-spacing-small) 0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list__item{cursor:default;min-width:15em}.ck.ck-list__item>.ck-button:not(.ck-list-item-button){border-radius:0;min-height:unset;padding:var(--ck-spacing-tiny) calc(var(--ck-spacing-standard)*2);width:100%}[dir=ltr] .ck.ck-list__item>.ck-button:not(.ck-list-item-button){text-align:left}[dir=rtl] .ck.ck-list__item>.ck-button:not(.ck-list-item-button){text-align:right}.ck.ck-list__item>.ck-button:not(.ck-list-item-button) .ck-button__label{line-height:calc(var(--ck-line-height-base)*var(--ck-font-size-base))}.ck.ck-list__item>.ck-button:not(.ck-list-item-button):active{box-shadow:none}.ck.ck-list__item>.ck-button.ck-on:not(.ck-list-item-button){background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item>.ck-button.ck-on:not(.ck-list-item-button):active{box-shadow:none}.ck.ck-list__item>.ck-button.ck-on:not(.ck-list-item-button):hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item>.ck-button.ck-on:not(.ck-list-item-button):focus:not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item>.ck-button:not(.ck-list-item-button):hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item>.ck-button.ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item>.ck-button.ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck-list .ck-list__group{padding-top:var(--ck-spacing-medium)}.ck-list .ck-list__group:first-child{padding-top:0}:not(.ck-hidden)~.ck-list .ck-list__group{border-top:1px solid var(--ck-color-base-border)}.ck-list .ck-list__group>.ck-label{font-size:11px;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-large) 0}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;margin:var(--ck-spacing-small) 0;width:100%}.ck.ck-menu-bar{background:var(--ck-color-base-background);border:1px solid var(--ck-color-toolbar-border);display:flex;flex-wrap:wrap;gap:var(--ck-spacing-small);justify-content:flex-start;padding:var(--ck-spacing-small);width:100%}.ck.ck-menu-bar__menu{font-size:inherit}.ck.ck-menu-bar__menu.ck-menu-bar__menu_top-level{max-width:100%}.ck.ck-menu-bar__menu>.ck-menu-bar__menu__button{width:100%}.ck.ck-menu-bar__menu>.ck-menu-bar__menu__button>.ck-button__label{flex-grow:1;overflow:hidden;text-overflow:ellipsis}.ck.ck-menu-bar__menu>.ck-menu-bar__menu__button.ck-disabled>.ck-button__label{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-menu-bar__menu>.ck-menu-bar__menu__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-menu-bar__menu>.ck-menu-bar__menu__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-menu-bar__menu.ck-menu-bar__menu_top-level>.ck-menu-bar__menu__button{min-height:unset;padding:var(--ck-spacing-small) var(--ck-spacing-medium)}.ck.ck-menu-bar__menu.ck-menu-bar__menu_top-level>.ck-menu-bar__menu__button .ck-button__label{line-height:unset;overflow:visible;width:unset}.ck.ck-menu-bar__menu.ck-menu-bar__menu_top-level>.ck-menu-bar__menu__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-menu-bar__menu.ck-menu-bar__menu_top-level>.ck-menu-bar__menu__button .ck-icon{display:none}.ck.ck-menu-bar__menu:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button{border-radius:0}.ck.ck-menu-bar__menu:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button>.ck-menu-bar__menu__button__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-menu-bar__menu:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button>.ck-menu-bar__menu__button__arrow{margin-left:var(--ck-spacing-standard);margin-right:calc(var(--ck-spacing-small)*-1);transform:rotate(-90deg)}[dir=rtl] .ck.ck-menu-bar__menu:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button>.ck-menu-bar__menu__button__arrow{left:var(--ck-spacing-standard);margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small);transform:rotate(90deg)}.ck.ck-menu-bar__menu:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button.ck-disabled>.ck-menu-bar__menu__button__arrow{opacity:var(--ck-disabled-opacity)}:root{--ck-menu-bar-menu-item-min-width:18em}.ck.ck-menu-bar__menu .ck.ck-menu-bar__menu__item{min-width:var(--ck-menu-bar-menu-item-min-width)}.ck.ck-menu-bar__menu .ck-button.ck-menu-bar__menu__item__button{border-radius:0}.ck.ck-menu-bar__menu .ck-button.ck-menu-bar__menu__item__button>.ck-spinner-container,.ck.ck-menu-bar__menu .ck-button.ck-menu-bar__menu__item__button>.ck-spinner-container .ck-spinner{--ck-toolbar-spinner-size:20px}.ck.ck-menu-bar__menu .ck-button.ck-menu-bar__menu__item__button>.ck-spinner-container{font-size:var(--ck-icon-font-size)}[dir=ltr] .ck.ck-menu-bar__menu .ck-button.ck-menu-bar__menu__item__button>.ck-spinner-container{margin-right:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-menu-bar__menu .ck-button.ck-menu-bar__menu__item__button>.ck-spinner-container{margin-left:var(--ck-spacing-medium)}:root{--ck-menu-bar-menu-panel-max-width:75vw}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);border-radius:0;bottom:0;height:fit-content;max-width:var(--ck-menu-bar-menu-panel-max-width)}.ck-rounded-corners .ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel{box-shadow:var(--ck-drop-shadow),0 0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_es,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_se{border-top-left-radius:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_sw,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_ws{border-top-right-radius:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_en,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_ne{border-bottom-left-radius:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_nw,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_wn{border-bottom-right-radius:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel:focus{outline:none}.ck.ck-menu-bar .ck-list-item-button:active,.ck.ck-menu-bar .ck-list-item-button:focus{border-color:transparent;box-shadow:none}.ck.ck-menu-bar.ck-menu-bar_focus-border-enabled .ck-list-item-button:active,.ck.ck-menu-bar.ck-menu-bar_focus-border-enabled .ck-list-item-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none;position:relative;z-index:2}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);border-radius:0;min-height:15px}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{box-shadow:var(--ck-drop-shadow),0 0}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-number,.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}:root{--ck-search-field-view-horizontal-spacing:calc(var(--ck-icon-size) + var(--ck-spacing-medium))}.ck.ck-search>.ck-labeled-field-view .ck-input{width:100%}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon{--ck-labeled-field-label-default-position-x:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon>.ck-labeled-field-view__input-wrapper>.ck-icon{opacity:.5;pointer-events:none}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input{width:100%}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input,[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input:not(.ck-input-text_empty){padding-left:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset{--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset.ck-labeled-field-view_empty{--ck-labeled-field-empty-unfocused-max-width:100% - var(--ck-search-field-view-horizontal-spacing) - var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{background:none;min-height:auto;min-width:auto;opacity:.5;padding:0}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{right:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{left:var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset:hover{opacity:1}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input{width:100%}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input:not(.ck-input-text_empty),[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input{padding-right:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-search__results{min-width:100%}.ck.ck-search>.ck-search__results>.ck-search__info{padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-search>.ck-search__results>.ck-search__info *{white-space:normal}.ck.ck-search>.ck-search__results>.ck-search__info>span:first-child{font-weight:700}.ck.ck-search>.ck-search__results>.ck-search__info>span:last-child{margin-top:var(--ck-spacing-medium)}.ck.ck-spinner-container{animation:ck-spinner-rotate 1.5s linear infinite;height:var(--ck-toolbar-spinner-size);width:var(--ck-toolbar-spinner-size)}@media (prefers-reduced-motion:reduce){.ck.ck-spinner-container{animation-duration:3s}}.ck.ck-spinner{border:2px solid var(--ck-color-text);border-radius:50%;border-top:2px solid transparent;height:var(--ck-toolbar-spinner-size);width:var(--ck-toolbar-spinner-size)}@keyframes ck-spinner-rotate{to{transform:rotate(1turn)}}.ck-textarea{overflow-x:hidden}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);border-radius:0;padding:0 var(--ck-spacing-small)}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar .ck.ck-toolbar__separator{background:var(--ck-color-toolbar-border);height:var(--ck-icon-size);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck.ck-toolbar:focus{outline:none}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}.ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-tooltip-text-padding:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);box-shadow:none;padding:0 var(--ck-spacing-medium)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip.ck-tooltip_multi-line .ck-tooltip__text{display:inline-block;max-width:200px;padding:var(--ck-tooltip-text-padding) 0;white-space:break-spaces}.ck.ck-balloon-panel.ck-tooltip:before{display:none}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content{border:solid var(--ck-color-base-border);border-radius:0;border-width:1px 1px 0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content.ck-sticky-panel__content_sticky{border-bottom-width:1px}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content .ck-menu-bar{border:0;border-bottom:1px solid var(--ck-color-base-border)}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content .ck-toolbar{border:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}:root{--ck-bookmark-icon-hover-fill-color:var(--ck-color-widget-hover-border);--ck-bookmark-icon-selected-fill-color:var(--ck-color-focus-border);--ck-bookmark-icon-animation-duration:var(--ck-widget-handler-animation-duration);--ck-bookmark-icon-animation-curve:var(--ck-widget-handler-animation-curve)}.ck .ck-bookmark.ck-widget{display:inline-block;outline:none}.ck .ck-bookmark.ck-widget .ck-bookmark__icon .ck-icon__fill{transition:fill var(--ck-bookmark-icon-animation-duration) var(--ck-bookmark-icon-animation-curve)}.ck .ck-bookmark.ck-widget:hover .ck-bookmark__icon .ck-icon__fill{fill:var(--ck-bookmark-icon-hover-fill-color)}.ck .ck-bookmark.ck-widget.ck-widget_selected .ck-bookmark__icon .ck-icon__fill{fill:var(--ck-bookmark-icon-selected-fill-color)}.ck .ck-bookmark.ck-widget.ck-widget_selected,.ck .ck-bookmark.ck-widget.ck-widget_selected:hover{outline:none}.ck .ck-bookmark.ck-widget .ck-bookmark__icon{display:block;position:relative;top:-.1em}.ck .ck-bookmark.ck-widget .ck-bookmark__icon .ck-icon{height:1.2em;vertical-align:middle;width:auto}.ck .ck-fake-bookmark-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-bookmark-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}:root{--ck-bookmark-form-width:340px}@media screen and (max-width:600px){:root{--ck-bookmark-form-width:300px}}.ck.ck-bookmark-form{width:var(--ck-bookmark-form-width)}.ck.ck-bookmark-balloon .ck.ck-toolbar>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-bookmark-toolbar__preview{cursor:default;font-weight:400;max-width:var(--ck-input-width);min-width:3em;overflow:hidden;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}.ck.ck-clipboard-drop-target-line{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);height:0;margin-top:-1px}.ck.ck-clipboard-drop-target-line:before{border-style:solid;content:"";height:0;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-width)*-.5);width:0}[dir=ltr] .ck.ck-clipboard-drop-target-line:before{border-color:transparent transparent transparent var(--ck-clipboard-drop-target-color);border-width:calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5) var(--ck-clipboard-drop-target-dot-height);left:-1px}[dir=rtl] .ck.ck-clipboard-drop-target-line:before{border-color:transparent var(--ck-clipboard-drop-target-color) transparent transparent;border-width:calc(var(--ck-clipboard-drop-target-dot-width)*.5) var(--ck-clipboard-drop-target-dot-height) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0;right:-1px}:root{--ck-color-code-block-label-background:#757575}.ck.ck-editor__editable pre[data-language]:after{background:var(--ck-color-code-block-label-background);color:#fff;font-family:var(--ck-font-face);font-size:10px;line-height:16px;padding:var(--ck-spacing-tiny) var(--ck-spacing-medium);right:10px;top:-1px;white-space:nowrap}.ck.ck-code-block-dropdown .ck-dropdown__panel{max-height:250px;overflow-x:hidden;overflow-y:auto}@media (forced-colors:active){.ck .ck-placeholder,.ck.ck-placeholder{forced-color-adjust:preserve-parent-color}}.ck .ck-placeholder:before,.ck.ck-placeholder:before{cursor:text}@media (forced-colors:none){.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text)}}@media (forced-colors:active){.ck .ck-placeholder:before,.ck.ck-placeholder:before{font-style:italic;margin-left:1px}}.ck.ck-find-and-replace-form{width:400px}.ck.ck-find-and-replace-form:focus{outline:none}.ck.ck-find-and-replace-form .ck-find-and-replace-form__actions,.ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs{align-content:stretch;align-items:center;flex:1 1 auto;flex-direction:row;flex-wrap:wrap;margin:0;padding:var(--ck-spacing-large)}.ck.ck-find-and-replace-form .ck-find-and-replace-form__actions>.ck-button,.ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs>.ck-button{flex:0 0 auto}[dir=ltr] .ck.ck-find-and-replace-form .ck-find-and-replace-form__actions>*+*,[dir=ltr] .ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs>*+*{margin-left:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-find-and-replace-form .ck-find-and-replace-form__actions>*+*,[dir=rtl] .ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs>*+*{margin-right:var(--ck-spacing-standard)}.ck.ck-find-and-replace-form .ck-find-and-replace-form__actions .ck-labeled-field-view,.ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs .ck-labeled-field-view{flex:1 1 auto}.ck.ck-find-and-replace-form .ck-find-and-replace-form__actions .ck-labeled-field-view .ck-input,.ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs .ck-labeled-field-view .ck-input{min-width:50px;width:100%}.ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs{align-items:flex-start}.ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs>.ck-button-prev>.ck-icon{transform:rotate(90deg)}.ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs>.ck-button-next>.ck-icon{transform:rotate(-90deg)}.ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs .ck-results-counter{color:var(--ck-color-base-border);top:50%;transform:translateY(-50%)}[dir=ltr] .ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs .ck-results-counter{right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs .ck-results-counter{left:var(--ck-spacing-standard)}.ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs>.ck-labeled-field-replace{flex:0 0 100%;padding-top:var(--ck-spacing-standard)}[dir=ltr] .ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs>.ck-labeled-field-replace{margin-left:0}[dir=rtl] .ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs>.ck-labeled-field-replace{margin-right:0}.ck.ck-find-and-replace-form .ck-find-and-replace-form__actions{flex-wrap:wrap;justify-content:flex-end;margin-top:calc(var(--ck-spacing-large)*-1)}.ck.ck-find-and-replace-form .ck-find-and-replace-form__actions>.ck-button-find{font-weight:700}.ck.ck-find-and-replace-form .ck-find-and-replace-form__actions>.ck-button-find .ck-button__label{padding-left:var(--ck-spacing-large);padding-right:var(--ck-spacing-large)}.ck.ck-find-and-replace-form .ck-switchbutton{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between;width:100%}@media screen and (max-width:600px){.ck.ck-find-and-replace-form{max-width:100%;width:300px}.ck.ck-find-and-replace-form.ck-find-and-replace-form__input{flex-wrap:wrap}.ck.ck-find-and-replace-form.ck-find-and-replace-form__input .ck-labeled-field-view{flex:1 0 auto;margin-bottom:var(--ck-spacing-standard);width:100%}.ck.ck-find-and-replace-form.ck-find-and-replace-form__input>.ck-button{text-align:center}.ck.ck-find-and-replace-form.ck-find-and-replace-form__input>.ck-button:first-of-type{flex:1 1 auto}[dir=ltr] .ck.ck-find-and-replace-form.ck-find-and-replace-form__input>.ck-button:first-of-type{margin-left:0}[dir=rtl] .ck.ck-find-and-replace-form.ck-find-and-replace-form__input>.ck-button:first-of-type{margin-right:0}.ck.ck-find-and-replace-form.ck-find-and-replace-form__input>.ck-button:first-of-type .ck-button__label{text-align:center;width:100%}.ck.ck-find-and-replace-form.ck-find-and-replace-form__actions>:not(.ck-labeled-field-view){flex:1 1 auto;flex-wrap:wrap}.ck.ck-find-and-replace-form.ck-find-and-replace-form__actions>:not(.ck-labeled-field-view)>.ck-button{text-align:center}.ck.ck-find-and-replace-form.ck-find-and-replace-form__actions>:not(.ck-labeled-field-view)>.ck-button:first-of-type{flex:1 1 auto}[dir=ltr] .ck.ck-find-and-replace-form.ck-find-and-replace-form__actions>:not(.ck-labeled-field-view)>.ck-button:first-of-type{margin-left:0}[dir=rtl] .ck.ck-find-and-replace-form.ck-find-and-replace-form__actions>:not(.ck-labeled-field-view)>.ck-button:first-of-type{margin-right:0}.ck.ck-find-and-replace-form.ck-find-and-replace-form__actions>:not(.ck-labeled-field-view)>.ck-button .ck-button__label{text-align:center;width:100%}}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}:root{--ck-html-embed-content-width:calc(100% - var(--ck-icon-size)*1.5);--ck-html-embed-source-height:10em;--ck-html-embed-unfocused-outline-width:1px;--ck-html-embed-content-min-height:calc(var(--ck-icon-size) + var(--ck-spacing-standard));--ck-html-embed-source-disabled-background:var(--ck-color-base-foreground);--ck-html-embed-source-disabled-color:#737373}.ck-widget.raw-html-embed{background-color:var(--ck-color-base-foreground);font-size:var(--ck-font-size-base)}.ck-widget.raw-html-embed:not(.ck-widget_selected):not(:hover){outline:var(--ck-html-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border)}.ck-widget.raw-html-embed[dir=ltr]{text-align:left}.ck-widget.raw-html-embed[dir=rtl]{text-align:right}.ck-widget.raw-html-embed:before{background:#999;border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius);color:var(--ck-color-base-background);content:attr(data-html-embed-label);font-family:var(--ck-font-face);font-size:var(--ck-font-size-tiny);left:var(--ck-spacing-standard);padding:calc(var(--ck-spacing-tiny) + var(--ck-html-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);top:calc(var(--ck-html-embed-unfocused-outline-width)*-1);transition:background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck-widget.raw-html-embed[dir=rtl]:before{left:auto;right:var(--ck-spacing-standard)}.ck-widget.raw-html-embed[dir=ltr] .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before{margin-left:50px}.ck.ck-editor__editable.ck-blurred .ck-widget.raw-html-embed.ck-widget_selected:before{padding:var(--ck-spacing-tiny) var(--ck-spacing-small);top:0}.ck.ck-editor__editable:not(.ck-blurred) .ck-widget.raw-html-embed.ck-widget_selected:before{background:var(--ck-color-focus-border);padding:var(--ck-spacing-tiny) var(--ck-spacing-small);top:0}.ck.ck-editor__editable .ck-widget.raw-html-embed:not(.ck-widget_selected):hover:before{padding:var(--ck-spacing-tiny) var(--ck-spacing-small);top:0}.ck-widget.raw-html-embed .raw-html-embed__content-wrapper{padding:var(--ck-spacing-standard)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper{right:var(--ck-spacing-standard);top:var(--ck-spacing-standard)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper .ck-button.raw-html-embed__save-button{color:var(--ck-color-button-save)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper .ck-button.raw-html-embed__cancel-button{color:var(--ck-color-button-cancel)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper .ck-button:not(:first-child){margin-top:var(--ck-spacing-small)}.ck-widget.raw-html-embed[dir=rtl] .raw-html-embed__buttons-wrapper{left:var(--ck-spacing-standard);right:auto}.ck-widget.raw-html-embed .raw-html-embed__source{box-sizing:border-box;direction:ltr;font-family:monospace;font-size:var(--ck-font-size-base);height:var(--ck-html-embed-source-height);min-width:0;padding:var(--ck-spacing-standard);resize:none;tab-size:4;text-align:left;white-space:pre-wrap;width:var(--ck-html-embed-content-width)}.ck-widget.raw-html-embed .raw-html-embed__source[disabled]{-webkit-text-fill-color:var(--ck-html-embed-source-disabled-color);background:var(--ck-html-embed-source-disabled-background);color:var(--ck-html-embed-source-disabled-color);opacity:1}.ck-widget.raw-html-embed .raw-html-embed__preview{min-height:var(--ck-html-embed-content-min-height);width:var(--ck-html-embed-content-width)}.ck-editor__editable:not(.ck-read-only) .ck-widget.raw-html-embed .raw-html-embed__preview{pointer-events:none}.ck-widget.raw-html-embed .raw-html-embed__preview-content{background-color:var(--ck-color-base-foreground);box-sizing:border-box}.ck-widget.raw-html-embed .raw-html-embed__preview-content>*{margin-left:auto;margin-right:auto}.ck-widget.raw-html-embed .raw-html-embed__preview-placeholder{color:var(--ck-html-embed-source-disabled-color)}:root{--ck-image-insert-insert-by-url-width:250px}.ck.ck-image-insert-url{--ck-input-width:100%}.ck.ck-image-insert-url .ck-image-insert-url__action-row{grid-column-gap:var(--ck-spacing-large);margin-top:var(--ck-spacing-large)}.ck.ck-image-insert-url .ck-image-insert-url__action-row .ck-button-cancel,.ck.ck-image-insert-url .ck-image-insert-url__action-row .ck-button-save{justify-content:center;min-width:auto}.ck.ck-image-insert-url .ck-image-insert-url__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}.ck.ck-image-insert-form>.ck.ck-button{display:block;width:100%}[dir=ltr] .ck.ck-image-insert-form>.ck.ck-button{text-align:left}[dir=rtl] .ck.ck-image-insert-form>.ck.ck-button{text-align:right}.ck.ck-image-insert-form>.ck.ck-collapsible{min-width:var(--ck-image-insert-insert-by-url-width)}.ck.ck-image-insert-form>.ck.ck-collapsible:not(:first-child){border-top:1px solid var(--ck-color-base-border)}.ck.ck-image-insert-form>.ck.ck-collapsible:not(:last-child){border-bottom:1px solid var(--ck-color-base-border)}.ck.ck-image-insert-form>.ck.ck-image-insert-url{min-width:var(--ck-image-insert-insert-by-url-width);padding:var(--ck-spacing-large)}.ck.ck-image-insert-form:focus{outline:none}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@media (prefers-reduced-motion:reduce){.ck-image-upload-complete-icon{animation-duration:0ms}.ck-image-upload-complete-icon:after{animation:none;height:.45em;opacity:1;width:.3em}}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}@media (prefers-reduced-motion:reduce){.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:none;opacity:1}}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}:root{--ck-text-alternative-form-width:340px}@media screen and (max-width:600px){:root{--ck-text-alternative-form-width:300px}}.ck.ck-text-alternative-form.ck-responsive-form{width:var(--ck-text-alternative-form-width)}:root{--ck-image-custom-resize-form-width:340px}@media screen and (max-width:600px){:root{--ck-image-custom-resize-form-width:300px}}.ck.ck-image-custom-resize-form.ck-responsive-form{width:var(--ck-image-custom-resize-form-width)}.ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}:root{--ck-link-bookmark-icon-size:calc(var(--ck-icon-size)*0.7)}.ck.ck-toolbar.ck-link-toolbar>.ck-toolbar__items{flex-wrap:nowrap}a.ck.ck-button.ck-link-toolbar__preview{color:var(--ck-color-link-default);cursor:pointer;justify-content:center;padding:0 var(--ck-spacing-medium)}a.ck.ck-button.ck-link-toolbar__preview .ck.ck-button__label{max-width:var(--ck-input-width);text-overflow:ellipsis}a.ck.ck-button.ck-link-toolbar__preview,a.ck.ck-button.ck-link-toolbar__preview:active,a.ck.ck-button.ck-link-toolbar__preview:focus,a.ck.ck-button.ck-link-toolbar__preview:hover{background:none}a.ck.ck-button.ck-link-toolbar__preview:active{box-shadow:none}a.ck.ck-button.ck-link-toolbar__preview:focus,a.ck.ck-button.ck-link-toolbar__preview:hover{text-decoration:underline}a.ck.ck-button.ck-link-toolbar__preview.ck-button_with-text .ck.ck-icon.ck-button__icon{height:var(--ck-link-bookmark-icon-size);width:var(--ck-link-bookmark-icon-size)}[dir=ltr] a.ck.ck-button.ck-link-toolbar__preview.ck-button_with-text .ck.ck-icon.ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-tiny)}[dir=rtl] a.ck.ck-button.ck-link-toolbar__preview.ck-button_with-text .ck.ck-icon.ck-button__icon{margin-left:var(--ck-spacing-tiny);margin-right:var(--ck-spacing-small)}a.ck.ck-button.ck-link-toolbar__preview:has(.ck-icon){padding-left:var(--ck-spacing-extra-tiny )}:root{--ck-link-panel-width:340px;--ck-link-provider-list-item-text-height:calc(var(--ck-line-height-base)*var(--ck-font-size-base));--ck-link-provider-list-item-height:calc(var(--ck-link-provider-list-item-text-height) + var(--ck-spacing-small) + var(--ck-spacing-small))}@media screen and (max-width:600px){:root{--ck-link-panel-width:300px}}.ck.ck-form.ck-link-form{padding-bottom:0;width:var(--ck-link-panel-width)}@media screen and (max-width:600px){.ck.ck-form.ck-link-form.ck-responsive-form .ck-labeled-field-view{margin:0}}.ck.ck-form.ck-link-form .ck-link-form__providers-list{border-top:1px solid var(--ck-color-base-border)}.ck.ck-form.ck-link-form .ck-link-form__providers-list:has(.ck-list__item:nth-child(n+5)){max-height:calc(var(--ck-link-provider-list-item-height)*4 + var(--ck-spacing-large) + 1px);overflow:auto}.ck.ck-form.ck-link-form .ck-link-form__providers-list .ck-link__button{border-radius:0;padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form.ck-link-form .ck-link-form__providers-list .ck-link__button>.ck-button__label{overflow:hidden;text-overflow:ellipsis}:root{--ck-link-image-indicator-icon-size:20;--ck-link-image-indicator-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{background-color:rgba(0,0,0,.4);background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");background-position:50%;background-repeat:no-repeat;background-size:14px;border-radius:100%;content:"";height:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size));overflow:hidden;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);width:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size))}:root{--ck-link-properties-width:340px}@media screen and (max-width:600px){:root{--ck-link-properties-width:300px}}.ck.ck-link-properties{width:var(--ck-link-properties-width)}:root{--ck-link-providers-width:340px;--ck-link-list-view-max-height:240px;--ck-link-list-view-icon-size:calc(var(--ck-icon-size)*0.8)}@media screen and (max-width:600px){:root{--ck-link-providers-width:300px}}.ck.ck-link-providers{width:var(--ck-link-providers-width)}.ck.ck-link-providers .ck-form__header__label{overflow:hidden;text-overflow:ellipsis}.ck.ck-link-providers>.ck-link-providers__list{max-height:min(var(--ck-link-list-view-max-height),40vh)}.ck.ck-link-providers>.ck-link-providers__list .ck-button>.ck-icon{height:var(--ck-link-list-view-icon-size);width:var(--ck-link-list-view-icon-size)}.ck.ck-link-providers>.ck-link-providers__list .ck-button>.ck-button__label{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ck.ck-link-providers .ck-link__empty-list-info{font-style:italic;padding:calc(var(--ck-spacing-large)*2) var(--ck-spacing-medium);text-align:center}.ck.ck-list-properties.ck-list-properties_without-styles{padding:var(--ck-spacing-large)}.ck.ck-list-properties.ck-list-properties_without-styles>*{min-width:14em}.ck.ck-list-properties.ck-list-properties_without-styles>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-list-styles-list{grid-template-columns:repeat(4,auto)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible{border-top:1px solid var(--ck-color-base-border)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*{width:100%}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties .ck.ck-numbered-list-properties__start-index .ck-input{min-width:auto;width:100%}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order{background:transparent;margin-bottom:calc(var(--ck-spacing-tiny)*-1);padding-left:0;padding-right:0}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:active,.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:hover{background:none;border-color:transparent;box-shadow:none}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-list{column-gap:var(--ck-spacing-medium);grid-template-columns:repeat(3,auto);padding:var(--ck-spacing-large);row-gap:var(--ck-spacing-medium)}.ck.ck-list-styles-list .ck-button{box-sizing:content-box;margin:0;padding:0}.ck.ck-list-styles-list .ck-button,.ck.ck-list-styles-list .ck-button .ck-icon{height:var(--ck-list-style-button-size);width:var(--ck-list-style-button-size)}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{background:var(--ck-color-base-foreground);padding:calc(var(--ck-spacing-standard)*3)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{background-position:50%;background-size:cover;height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);min-width:var(--ck-media-embed-placeholder-icon-size)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{height:100%;width:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);font-style:italic;text-align:center;text-overflow:ellipsis;white-space:nowrap}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-height:380px;max-width:300px}.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Im0yMDYuNDc3IDI2MC45LTI4Ljk4NyAyOC45ODdhNS4yMTggNS4yMTggMCAwIDAgMy43OCAxLjYxaDQ5LjYyMWMxLjY5NCAwIDMuMTktLjc5OCA0LjE0Ni0yLjAzN3oiIGZpbGw9IiM1Yzg4YzUiLz48cGF0aCBkPSJNMjI2Ljc0MiAyMjIuOTg4Yy05LjI2NiAwLTE2Ljc3NyA3LjE3LTE2Ljc3NyAxNi4wMTQuMDA3IDIuNzYyLjY2MyA1LjQ3NCAyLjA5MyA3Ljg3NS40My43MDMuODMgMS40MDggMS4xOSAyLjEwNy4zMzMuNTAyLjY1IDEuMDA1Ljk1IDEuNTA4LjM0My40NzcuNjczLjk1Ny45ODggMS40NCAxLjMxIDEuNzY5IDIuNSAzLjUwMiAzLjYzNyA1LjE2OC43OTMgMS4yNzUgMS42ODMgMi42NCAyLjQ2NiAzLjk5IDIuMzYzIDQuMDk0IDQuMDA3IDguMDkyIDQuNiAxMy45MTR2LjAxMmMuMTgyLjQxMi41MTYuNjY2Ljg3OS42NjcuNDAzLS4wMDEuNzY4LS4zMTQuOTMtLjc5OS42MDMtNS43NTYgMi4yMzgtOS43MjkgNC41ODUtMTMuNzk0Ljc4Mi0xLjM1IDEuNjczLTIuNzE1IDIuNDY1LTMuOTkgMS4xMzctMS42NjYgMi4zMjgtMy40IDMuNjM4LTUuMTY5LjMxNS0uNDgyLjY0NS0uOTYyLjk4OC0xLjQzOS4zLS41MDMuNjE3LTEuMDA2Ljk1LTEuNTA4LjM1OS0uNy43Ni0xLjQwNCAxLjE5LTIuMTA3IDEuNDI2LTIuNDAyIDItNS4xMTQgMi4wMDQtNy44NzUgMC04Ljg0NC03LjUxMS0xNi4wMTQtMTYuNzc2LTE2LjAxNHoiIGZpbGw9IiNkZDRiM2UiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PGVsbGlwc2Ugcnk9IjUuNTY0IiByeD0iNS44MjgiIGN5PSIyMzkuMDAyIiBjeD0iMjI2Ljc0MiIgZmlsbD0iIzgwMmQyNyIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMTkwLjMwMSAyMzcuMjgzYy00LjY3IDAtOC40NTcgMy44NTMtOC40NTcgOC42MDZzMy43ODYgOC42MDcgOC40NTcgOC42MDdjMy4wNDMgMCA0LjgwNi0uOTU4IDYuMzM3LTIuNTE2IDEuNTMtMS41NTcgMi4wODctMy45MTMgMi4wODctNi4yOSAwLS4zNjItLjAyMy0uNzIyLS4wNjQtMS4wNzloLTguMjU3djMuMDQzaDQuODVjLS4xOTcuNzU5LS41MzEgMS40NS0xLjA1OCAxLjk4Ni0uOTQyLjk1OC0yLjAyOCAxLjU0OC0zLjkwMSAxLjU0OC0yLjg3NiAwLTUuMjA4LTIuMzcyLTUuMjA4LTUuMjk5IDAtMi45MjYgMi4zMzItNS4yOTkgNS4yMDgtNS4yOTkgMS4zOTkgMCAyLjYxOC40MDcgMy41ODQgMS4yOTNsMi4zODEtMi4zOGMwLS4wMDItLjAwMy0uMDA0LS4wMDQtLjAwNS0xLjU4OC0xLjUyNC0zLjYyLTIuMjE1LTUuOTU1LTIuMjE1em00LjQzIDUuNjYuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0ibTIxNS4xODQgMjUxLjkyOS03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVhNS4yMzMgNS4yMzMgMCAwIDAgLjQ0OS0yLjEyM3YtMzEuMTY1Yy0uNDY5LjY3NS0uOTM0IDEuMzQ5LTEuMzgyIDIuMDA1LS43OTIgMS4yNzUtMS42ODIgMi42NC0yLjQ2NSAzLjk5LTIuMzQ3IDQuMDY1LTMuOTgyIDguMDM4LTQuNTg1IDEzLjc5NC0uMTYyLjQ4NS0uNTI3Ljc5OC0uOTMuNzk5LS4zNjMtLjAwMS0uNjk3LS4yNTUtLjg3OS0uNjY3di0uMDEyYy0uNTkzLTUuODIyLTIuMjM3LTkuODItNC42LTEzLjkxNC0uNzgzLTEuMzUtMS42NzMtMi43MTUtMi40NjYtMy45OS0xLjEzNy0xLjY2Ni0yLjMyNy0zLjQtMy42MzctNS4xNjlsLS4wMDItLjAwM3oiIGZpbGw9IiNjM2MzYzMiLz48cGF0aCBkPSJtMjEyLjk4MyAyNDguNDk1LTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOCA1LjIzOGgxLjAxNWwzNS42NjYtMzUuNjY2YTEzNi4yNzUgMTM2LjI3NSAwIDAgMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAgMC0uOTg5LTEuNDQgMzUuMTI3IDM1LjEyNyAwIDAgMC0uOTUtMS41MDhjLS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJtMjExLjk5OCAyNjEuMDgzLTYuMTUyIDYuMTUxIDI0LjI2NCAyNC4yNjRoLjc4MWE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OVptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OVoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzNabTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1Wm0xNjQuNzA2LTUuMTExYzAgMTYuNjk2LTEzLjUzNSAzMC4yMy0zMC4yMzEgMzAuMjMtMTYuNjk1IDAtMzAuMjMtMTMuNTM0LTMwLjIzLTMwLjIzIDAtMTYuNjk2IDEzLjUzNS0zMC4yMzEgMzAuMjMtMzAuMjMxIDE2LjY5NiAwIDMwLjIzMSAxMy41MzUgMzAuMjMxIDMwLjIzMSIgZmlsbD0iI0ZGRiIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MDAgNDAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIHN0eWxlPSJmaWxsOiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}:root{--ck-color-mention-background:rgba(153,0,48,.1);--ck-color-mention-text:#990030}.ck-content .mention{background:var(--ck-color-mention-background);color:var(--ck-color-mention-text)}:root{--ck-color-restricted-editing-exception-background:rgba(255,169,77,.2);--ck-color-restricted-editing-exception-hover-background:rgba(255,169,77,.35);--ck-color-restricted-editing-exception-brackets:rgba(204,105,0,.4);--ck-color-restricted-editing-selected-exception-background:rgba(255,169,77,.5);--ck-color-restricted-editing-selected-exception-brackets:rgba(204,105,0,.6)}.ck-editor__editable .restricted-editing-exception{background-color:var(--ck-color-restricted-editing-exception-background);border:1px solid;border-image:linear-gradient(to right,var(--ck-color-restricted-editing-exception-brackets) 0,var(--ck-color-restricted-editing-exception-brackets) 5px,transparent 6px,transparent calc(100% - 6px),var(--ck-color-restricted-editing-exception-brackets) calc(100% - 5px),var(--ck-color-restricted-editing-exception-brackets) 100%) 1;transition:background .2s ease-in-out}@media (prefers-reduced-motion:reduce){.ck-editor__editable .restricted-editing-exception{transition:none}}.ck-editor__editable .restricted-editing-exception.restricted-editing-exception_selected{background-color:var(--ck-color-restricted-editing-selected-exception-background);border-image:linear-gradient(to right,var(--ck-color-restricted-editing-selected-exception-brackets) 0,var(--ck-color-restricted-editing-selected-exception-brackets) 5px,var(--ck-color-restricted-editing-selected-exception-brackets) calc(100% - 5px),var(--ck-color-restricted-editing-selected-exception-brackets) 100%) 1}.ck-editor__editable .restricted-editing-exception.restricted-editing-exception_collapsed{padding-left:1ch}.ck-restricted-editing_mode_restricted,.ck-restricted-editing_mode_restricted *{cursor:default}.ck-restricted-editing_mode_restricted .restricted-editing-exception,.ck-restricted-editing_mode_restricted .restricted-editing-exception *{cursor:text}.ck-restricted-editing_mode_restricted .restricted-editing-exception:hover{background:var(--ck-color-restricted-editing-exception-hover-background)}:root{--ck-character-grid-tile-size:24px}.ck.ck-character-grid{overflow-x:hidden;overflow-y:auto}.ck.ck-character-grid .ck-character-grid__tiles{grid-gap:var(--ck-spacing-standard);grid-template-columns:repeat(auto-fill,minmax(var(--ck-character-grid-tile-size),1fr));margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-character-grid .ck-character-grid__tile{border:0;font-size:1.5em;height:var(--ck-character-grid-tile-size);min-height:var(--ck-character-grid-tile-size);min-width:var(--ck-character-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-character-grid-tile-size)}@media (prefers-reduced-motion:reduce){.ck.ck-character-grid .ck-character-grid__tile{transition:none}}.ck.ck-character-grid .ck-character-grid__tile:focus:not(.ck-disabled),.ck.ck-character-grid .ck-character-grid__tile:hover:not(.ck-disabled){border:0;box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-character-grid .ck-character-grid__tile .ck-button__label{line-height:var(--ck-character-grid-tile-size);text-align:center;width:100%}.ck.ck-character-info{border-top:1px solid var(--ck-color-base-border);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-character-info>*{font-size:var(--ck-font-size-small);text-transform:uppercase}.ck.ck-character-info .ck-character-info__name{max-width:280px;overflow:hidden;text-overflow:ellipsis}.ck.ck-character-info .ck-character-info__code{opacity:.6}.ck.ck-special-characters-navigation>.ck-label{max-width:160px;overflow:hidden;text-overflow:ellipsis}.ck.ck-special-characters-navigation>.ck-dropdown .ck-dropdown__panel{max-height:250px;overflow-x:hidden;overflow-y:auto}@media screen and (max-width:600px){.ck.ck-special-characters-navigation{max-width:190px}.ck.ck-special-characters-navigation>.ck-form__header__label{overflow:hidden;text-overflow:ellipsis}}.ck.ck-dropdown.ck-style-dropdown.ck-style-dropdown_multiple-active>.ck-button>.ck-button__label{font-style:italic}:root{--ck-style-panel-button-width:120px;--ck-style-panel-button-height:80px;--ck-style-panel-button-label-background:#f0f0f0;--ck-style-panel-button-hover-label-background:#ebebeb;--ck-style-panel-button-hover-border-color:#b3b3b3}.ck.ck-style-panel .ck-style-grid{column-gap:var(--ck-spacing-large);row-gap:var(--ck-spacing-large)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button{--ck-color-button-default-hover-background:var(--ck-color-base-background);--ck-color-button-default-active-background:var(--ck-color-base-background);height:var(--ck-style-panel-button-height);padding:0;width:var(--ck-style-panel-button-width)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button .ck-button__label{flex-shrink:0;height:22px;line-height:22px;overflow:hidden;padding:0 var(--ck-spacing-medium);text-overflow:ellipsis;width:100%}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button .ck-style-grid__button__preview{background:var(--ck-color-base-background);border:2px solid var(--ck-color-base-background);opacity:.9;overflow:hidden;padding:var(--ck-spacing-medium);width:100%}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button.ck-disabled{--ck-color-button-default-disabled-background:var(--ck-color-base-foreground)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button.ck-disabled:not(:focus){border-color:var(--ck-style-panel-button-label-background)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button.ck-disabled .ck-style-grid__button__preview{border-color:var(--ck-color-base-foreground);filter:saturate(.3);opacity:.4}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button.ck-on{border-color:var(--ck-color-base-active)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button.ck-on .ck-button__label{box-shadow:0 -1px 0 var(--ck-color-base-active);z-index:1}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button.ck-on:hover{border-color:var(--ck-color-base-active-focus)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button:not(.ck-on) .ck-button__label{background:var(--ck-style-panel-button-label-background)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button:not(.ck-on):hover .ck-button__label{background:var(--ck-style-panel-button-hover-label-background)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button:hover:not(.ck-disabled):not(.ck-on){border-color:var(--ck-style-panel-button-hover-border-color)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button:hover:not(.ck-disabled):not(.ck-on) .ck-style-grid__button__preview{opacity:1}.ck.ck-style-panel .ck-style-panel__style-group>.ck-label{margin:var(--ck-spacing-large) 0}.ck.ck-style-panel .ck-style-panel__style-group:first-child>.ck-label{margin-top:0}:root{--ck-style-panel-max-height:470px}.ck.ck-style-panel{max-height:var(--ck-style-panel-max-height);overflow-y:auto;padding:var(--ck-spacing-large)}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-input-color>.ck.ck-input-text:focus{z-index:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-left-radius:0;border-top-left-radius:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-left:1px solid transparent}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-right:1px solid transparent}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border:1px solid var(--ck-color-input-border);border-radius:0;height:20px;width:20px}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{background:red;border-radius:2px;height:150%;left:50%;top:-30%;transform:rotate(45deg);transform-origin:50%;width:8%}.ck.ck-input-color .ck.ck-input-color__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);width:100%}.ck.ck-input-color .ck.ck-input-color__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-input-border)}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard);margin-right:0}.ck.ck-form__row>:not(.ck-label)+*{margin-inline-start:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{min-width:100%;width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label,.ck[dir=rtl] .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;margin:var(--ck-insert-table-dropdown-box-margin);min-height:var(--ck-insert-table-dropdown-box-height);min-width:var(--ck-insert-table-dropdown-box-width);outline:none;transition:none}@media (prefers-reduced-motion:reduce){.ck .ck-insert-table-dropdown-grid-box{transition:none}}.ck .ck-insert-table-dropdown-grid-box:focus{box-shadow:none}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}.ck.ck-table-cell-properties-form{width:320px}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__padding-row{align-self:flex-end;padding:0;width:25%}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}:root{--ck-color-selector-focused-cell-background:rgba(158,201,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-selector-focused-cell-background);outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{max-width:80px;min-width:80px;width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:flex-end;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-field-view{padding-top:var(--ck-spacing-standard)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both;background:var(--ck-color-base-error);border-radius:0;color:var(--ck-color-base-background);min-width:var(--ck-table-properties-min-error-width);padding:var(--ck-spacing-small) var(--ck-spacing-medium);text-align:center}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status,.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-color:transparent transparent var(--ck-color-base-error) transparent;border-style:solid;border-width:0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size)}@media (prefers-reduced-motion:reduce){.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:none}}.ck.ck-table-form .ck.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-self:flex-end;padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}:root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}:root{--ck-table-layout-widget-type-around-button-size:16px;--ck-table-layout-widget-type-around-icon-width:10px;--ck-table-layout-widget-type-around-icon-height:8px;--ck-table-layout-widget-handler-icon-size:10px;--ck-table-layout-default-border-color:#d4d4d4}.ck-editor__editable .table.layout-table>table{border-collapse:revert;height:100%;width:100%}.ck-editor__editable .table.layout-table>table:not([style*="border:"],[style*=border-top],[style*=border-bottom],[style*=border-left],[style*=border-right],[style*=border-width],[style*=border-style],[style*=border-color]){border-color:transparent;border-width:0;outline:none}.ck-editor__editable .table.layout-table>table>tbody>tr>td{box-shadow:revert;min-width:2em;padding:revert;text-indent:1px}.ck-editor__editable .table.layout-table>table>tbody>tr>td[style*=" width:"],.ck-editor__editable .table.layout-table>table>tbody>tr>td[style*="'width:"],.ck-editor__editable .table.layout-table>table>tbody>tr>td[style*=";width:"],.ck-editor__editable .table.layout-table>table>tbody>tr>td[style^="width:"]{min-width:auto}.ck-editor__editable .table.layout-table>table>tbody>tr>td:focus{background-color:transparent}.ck-editor__editable .table.layout-table>table>tbody>tr>td:not([style*="border:"],[style*=border-top],[style*=border-bottom],[style*=border-left],[style*=border-right],[style*=border-width],[style*=border-style],[style*=border-color]){border-color:transparent;border-width:0;outline:var(--ck-table-layout-default-border-color) 1px dashed;outline-offset:-1px}.ck-editor__editable .table.layout-table>table>tbody>tr>td:not([style*="border:"],[style*=border-top],[style*=border-bottom],[style*=border-left],[style*=border-right],[style*=border-width],[style*=border-style],[style*=border-color]):focus{outline:var(--ck-color-focus-border) 1px solid}.ck-editor__editable .table.layout-table>table>tbody>tr>td>.ck-table-bogus-paragraph{text-indent:0;width:calc(100% - 1px)}.ck-editor__editable .table.layout-table.ck-widget>.ck-widget__type-around{--ck-widget-type-around-button-size:var(--ck-table-layout-widget-type-around-button-size)}.ck-editor__editable .table.layout-table.ck-widget>.ck-widget__type-around>.ck-widget__type-around__button.ck-widget__type-around__button_after,.ck-editor__editable .table.layout-table.ck-widget>.ck-widget__type-around>.ck-widget__type-around__button.ck-widget__type-around__button_before{transform:translateY(0);z-index:2}.ck-editor__editable .table.layout-table.ck-widget>.ck-widget__type-around>.ck-widget__type-around__button.ck-widget__type-around__button_before{border-radius:0 0 100px 100px;left:min(10%,30px);margin-left:var(--ck-table-layout-widget-type-around-button-size)}.ck-editor__editable .table.layout-table.ck-widget>.ck-widget__type-around>.ck-widget__type-around__button.ck-widget__type-around__button_before:after{border-radius:0 0 100px 100px}.ck-editor__editable .table.layout-table.ck-widget>.ck-widget__type-around>.ck-widget__type-around__button.ck-widget__type-around__button_after,.ck-editor__editable .table.layout-table.ck-widget>.ck-widget__type-around>.ck-widget__type-around__button.ck-widget__type-around__button_after:after{border-radius:100px 100px 0 0}.ck-editor__editable .table.layout-table.ck-widget>.ck-widget__type-around>.ck-widget__type-around__button svg{height:var(--ck-table-layout-widget-type-around-icon-height);width:var(--ck-table-layout-widget-type-around-icon-width)}.ck-editor__editable .table.layout-table.ck-widget.ck-widget_with-selection-handle>.ck-widget__selection-handle{--ck-widget-handler-icon-size:var(--ck-table-layout-widget-handler-icon-size);transform:translateY(calc(0px - var(--ck-widget-outline-thickness)));z-index:3}.ck-editor__editable .table.layout-table.ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{top:0}.ck-editor__editable .table.layout-table.ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:0}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}@media (prefers-reduced-motion:reduce){.ck .ck-widget{transition:none}}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{box-shadow:var(--ck-inner-shadow),0 0}@media (forced-colors:none){.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background)}}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused:not(td,th),.ck .ck-editor__nested-editable:focus:not(td,th){border:var(--ck-focus-ring);outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}@media (prefers-reduced-motion:reduce){.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{transition:none}}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}@media (prefers-reduced-motion:reduce){.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{transition:none}}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck .ck-widget:has(.ck-widget.table:hover){outline-color:transparent}.ck .ck-widget.ck-widget_with-selection-handle:has(.ck-widget.table:hover)>.ck-widget__selection-handle{opacity:0;visibility:hidden}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}@media (prefers-reduced-motion:reduce){.ck .ck-widget .ck-widget__type-around__button{transition:none}}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}@media (prefers-reduced-motion:reduce){.ck .ck-widget .ck-widget__type-around__button svg{transition:none}}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}@media (prefers-reduced-motion:reduce){.ck .ck-widget .ck-widget__type-around__button:hover,.ck .ck-widget .ck-widget__type-around__button:hover svg line,.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:none}}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget:has(.ck-widget.table:hover)>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}.ck-content code{background-color:hsla(0,0%,78%,.3);border-radius:2px;padding:.15em}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}.ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}:root{--ck-image-processing-highlight-color:#f9fafa;--ck-image-processing-background-color:#e3e5e8}.ck.ck-editor__editable .image.image-processing{position:relative}.ck.ck-editor__editable .image.image-processing:before{animation:ck-image-processing-animation 2s linear infinite;background:linear-gradient(90deg,var(--ck-image-processing-background-color),var(--ck-image-processing-highlight-color),var(--ck-image-processing-background-color));background-size:200% 100%;content:"";height:100%;left:0;position:absolute;top:0;width:100%;z-index:1}.ck.ck-editor__editable .image.image-processing img{height:100%}@keyframes ck-image-processing-animation{0%{background-position:200% 0}to{background-position:-200% 0}}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}.ck.ck-clipboard-drop-target-line{pointer-events:none;position:absolute}.ck-content pre{background:hsla(0,0%,78%,.3);border:1px solid #c4c4c4;border-radius:2px;color:#353535;direction:ltr;font-style:normal;min-width:200px;padding:1em;tab-size:4;text-align:left;white-space:pre-wrap}.ck-content pre code{background:unset;border-radius:0;padding:0}.ck.ck-editor__editable pre{position:relative}.ck.ck-editor__editable pre[data-language]:after{content:attr(data-language);position:absolute}.ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-panel)}.ck.ck-menu-bar{border:none;border-bottom:1px solid var(--ck-color-toolbar-border)}:root{--ck-emoji-grid-tile-size:27px}.ck.ck-emoji .ck.ck-emoji__tiles{border-top:1px solid var(--ck-color-base-border);max-height:min(265px,40vh);max-width:100%;overflow-x:hidden;overflow-y:auto}.ck.ck-emoji .ck.ck-emoji__tiles .ck-emoji__grid{grid-gap:var(--ck-spacing-small);display:grid;grid-template-columns:repeat(auto-fill,minmax(var(--ck-emoji-grid-tile-size),1fr));margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-emoji .ck.ck-emoji__tiles .ck-emoji__tile{border:0;font-size:1.5em;height:var(--ck-emoji-grid-tile-size);min-height:var(--ck-emoji-grid-tile-size);min-width:var(--ck-emoji-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-emoji-grid-tile-size)}@media (prefers-reduced-motion:reduce){.ck.ck-emoji .ck.ck-emoji__tiles .ck-emoji__tile{transition:none}}.ck.ck-emoji .ck.ck-emoji__tiles .ck-emoji__tile:focus:not(.ck-disabled),.ck.ck-emoji .ck.ck-emoji__tiles .ck-emoji__tile:hover:not(.ck-disabled){border:0;box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-emoji .ck.ck-emoji__tiles .ck-emoji__tile .ck-button__label{line-height:var(--ck-emoji-grid-tile-size);text-align:center;width:100%}.ck.ck-emoji__categories-list{display:flex;justify-content:space-between;margin:0 var(--ck-spacing-large)}.ck.ck-emoji__categories-list>.ck.ck-button.ck-button_with-text{border-width:0;border-bottom:2px solid transparent;font-size:var(--ck-font-size-big);min-height:var(--ck-font-size-big);min-width:var(--ck-font-size-big);padding:0}.ck.ck-emoji__categories-list>.ck.ck-button.ck-button_with-text.ck-emoji__category-item.ck-on{border-bottom-color:var(--ck-color-base-active)}.ck.ck-emoji__categories-list>.ck.ck-button.ck-button_with-text>span{margin:auto}.ck.ck-emoji__skin-tone{margin-left:var(--ck-spacing-standard)}.ck.ck-emoji__skin-tone>.ck.ck-dropdown .ck.ck-list__item{min-width:1em}.ck.ck-emoji__skin-tone>.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{width:auto}.ck.ck-form.ck-emoji-picker-form{padding-bottom:0}.ck.ck-form.ck-emoji-picker-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border-color:transparent}.ck.ck-emoji{width:320px}.ck .ck.ck-emoji__search{align-items:center;display:flex;justify-content:space-between;padding:var(--ck-spacing-large);padding-bottom:var(--ck-spacing-medium)}.ck .ck.ck-emoji__search>.ck.ck-search{flex:1}.ck .ck-fake-emoji-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-emoji-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}div.ck.ck-balloon-panel.ck-emoji-picker-balloon{z-index:calc(var( --ck-z-dialog ) + 1)}.ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}.ck-find-result{background:var(--ck-color-highlight-background);color:var(--ck-color-text)}.ck-find-result_selected{background:#ff9633}.ck.ck-find-and-replace-form{max-width:100%}.ck.ck-find-and-replace-form .ck-find-and-replace-form__actions,.ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs{display:flex}.ck.ck-find-and-replace-form .ck-find-and-replace-form__actions.ck-find-and-replace-form__inputs .ck-results-counter,.ck.ck-find-and-replace-form .ck-find-and-replace-form__inputs.ck-find-and-replace-form__inputs .ck-results-counter{position:absolute}.ck-content .text-tiny{font-size:.7em}.ck-content .text-small{font-size:.85em}.ck-content .text-big{font-size:1.4em}.ck-content .text-huge{font-size:1.8em}body.ck-fullscreen,html.ck-fullscreen{--ck-z-fullscreen:10000;--ck-z-default:calc(var(--ck-z-fullscreen) + 1);--ck-z-panel:calc(var(--ck-z-default) + 999);--ck-z-dialog:100000;overflow:hidden}body.ck-fullscreen .ckbox-reset:not(#n)>.ckbox--dialog,html.ck-fullscreen .ckbox-reset:not(#n)>.ckbox--dialog{--ckbox-z-index-root:calc(var(--ck-z-dialog) + 1)}body.ck-fullscreen .ckbox:not(#n) .ckbox-img-editor,html.ck-fullscreen .ckbox:not(#n) .ckbox-img-editor{--ckbox-z-index-preview:calc(var(--ck-z-dialog) + 1)}body.ck-fullscreen .ck-pagination-view-line,html.ck-fullscreen .ck-pagination-view-line{z-index:calc(var(--ck-z-fullscreen) + 1)}body.ck-fullscreen .page-break__label,html.ck-fullscreen .page-break__label{z-index:calc(var(--ck-z-fullscreen) + 2)}.ck.ck-fullscreen__main-wrapper{background:var(--ck-color-base-foreground);display:flex;flex-direction:column;height:100%;left:0;position:fixed;top:0;width:100%;z-index:var(--ck-z-fullscreen)}.ck.ck-fullscreen__main-wrapper .ck.ck-revision-history-ui__changes-navigation{margin-bottom:0;margin-top:0}:not(body>.ck-fullscreen__main-wrapper).ck-fullscreen__main-wrapper{position:absolute}.ck-fullscreen__menu-bar .ck.ck-menu-bar{border:none}.ck-fullscreen__main-wrapper .ck-fullscreen__editable-wrapper{--ck-fullscreen-editor-top-margin:28px;--ck-fullscreen-editor-bottom-margin:28px;display:flex;justify-content:flex-start;max-height:100%;overflow:auto}.ck-fullscreen__sidebar{flex-shrink:0;margin-left:10px;margin-top:var(--ck-fullscreen-editor-top-margin);width:300px}.ck-fullscreen__sidebar[data-ck-fullscreen=right-sidebar]{margin-right:auto}.ck-fullscreen__main-wrapper .ck-fullscreen__editable{height:100%;margin-bottom:56px;margin-left:auto;margin-top:var(--ck-fullscreen-editor-top-margin)}.ck-fullscreen__main-wrapper .ck-fullscreen__editable:after{content:"";display:block;height:var(--ck-fullscreen-editor-bottom-margin)}.ck-fullscreen__main-wrapper .ck-fullscreen__editable .ck.ck-editor__editable:not(.ck-editor__nested-editable){background:#fff;border:1px solid var(--ck-color-base-border);box-shadow:0 2px 3px rgba(0,0,0,.078);box-sizing:border-box;height:fit-content;min-height:297mm;padding:20mm 12mm;width:210.52917mm}.ck-fullscreen__main-wrapper .ck-fullscreen__editable .ck-source-editing-area{width:210.52917mm}.ck-fullscreen__left-sidebar{--ck-user-avatar-size:28px;align-self:flex-start;background-color:transparent;box-sizing:border-box;display:flex;flex-direction:column;font-family:Helvetica,Arial,sans-serif;height:100%;margin-top:0;position:sticky;top:0}.ck-fullscreen__left-sidebar .ck.ck-presence-list--collapsed{--ck-user-avatar-size:32px}.ck-fullscreen__left-sidebar>:first-child{padding-top:var(--ck-fullscreen-editor-top-margin)}.ck-fullscreen__left-sidebar .ck-presence-list__users-counter__text,.ck-fullscreen__left-sidebar .ck-user{font-size:.85em}.ck-fullscreen__left-sidebar-item{margin-bottom:var(--ck-spacing-medium);padding:var(--ck-spacing-medium)}.ck-fullscreen__left-sidebar-item:last-child{margin-bottom:0}.ck-fullscreen__left-sidebar-header{--ck-fullscreen-presence-list-header-font-size:0.875em;color:var(--ck-document-outline-item-default-color);font-size:var(--ck-fullscreen-presence-list-header-font-size);font-weight:700;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ck-fullscreen__left-sidebar--sticky{position:sticky;top:0}.ck-fullscreen__left-sidebar--sticky>:first-child{padding-top:0}.ck-fullscreen__presence-list{margin-top:var(--ck-spacing-medium)}.ck-fullscreen__left-sidebar-item--no-margin{margin:0}.ck-fullscreen__left-sidebar .ck.ck-document-outline{padding-left:0;padding-right:0;padding-top:0}.ck-fullscreen__document-outline-wrapper{overflow-y:auto;padding-top:0}.ck.ck-heading_heading1 .ck-button__label{font-size:20px}.ck.ck-heading_heading2 .ck-button__label{font-size:17px}.ck.ck-heading_heading3 .ck-button__label{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}:root{--ck-highlight-marker-yellow:#fdfd77;--ck-highlight-marker-green:#62f962;--ck-highlight-marker-pink:#fc7899;--ck-highlight-marker-blue:#72ccfd;--ck-highlight-pen-red:#e71313;--ck-highlight-pen-green:#128a00}.ck-content .marker-yellow{background-color:var(--ck-highlight-marker-yellow)}.ck-content .marker-green{background-color:var(--ck-highlight-marker-green)}.ck-content .marker-pink{background-color:var(--ck-highlight-marker-pink)}.ck-content .marker-blue{background-color:var(--ck-highlight-marker-blue)}.ck-content .pen-red{background-color:transparent;color:var(--ck-highlight-pen-red)}.ck-content .pen-green{background-color:transparent;color:var(--ck-highlight-pen-green)}.ck-editor__editable .ck-horizontal-line{display:flow-root}.ck-content hr{background:#dedede;border:0;height:4px;margin:15px 0}.ck-widget.raw-html-embed{display:flow-root;font-style:normal;margin:.9em auto;min-width:15em;position:relative}.ck-widget.raw-html-embed:before{position:absolute;z-index:1}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper{display:flex;flex-direction:column;position:absolute}.ck-widget.raw-html-embed .raw-html-embed__preview{display:flex;overflow:hidden;position:relative}.ck-widget.raw-html-embed .raw-html-embed__preview-content{border-collapse:separate;border-spacing:7px;display:table;margin:auto;position:relative;width:100%}.ck-widget.raw-html-embed .raw-html-embed__preview-placeholder{align-items:center;bottom:0;display:flex;justify-content:center;left:0;position:absolute;right:0;top:0}:root{--ck-html-object-embed-unfocused-outline-width:1px}.ck-widget.html-object-embed{background-color:var(--ck-color-base-foreground);font-size:var(--ck-font-size-base);min-width:calc(76px + var(--ck-spacing-standard));padding:var(--ck-spacing-small);padding-top:calc(var(--ck-font-size-tiny) + var(--ck-spacing-large))}.ck-widget.html-object-embed:not(.ck-widget_selected):not(:hover){outline:var(--ck-html-object-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border)}.ck-widget.html-object-embed:before{background:#999;border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius);color:var(--ck-color-base-background);content:attr(data-html-object-embed-label);font-family:var(--ck-font-face);font-size:var(--ck-font-size-tiny);font-style:normal;font-weight:400;left:var(--ck-spacing-standard);padding:calc(var(--ck-spacing-tiny) + var(--ck-html-object-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);position:absolute;top:0;transition:background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck-widget.html-object-embed .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before{margin-left:50px}.ck-widget.html-object-embed .html-object-embed__content{pointer-events:none}div.ck-widget.html-object-embed{margin:1em auto}span.ck-widget.html-object-embed{display:inline-block}:root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highlighted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}@media (forced-colors:active){.ck-content .image>figcaption{background-color:unset;color:unset}}@media (forced-colors:none){.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}}@media (prefers-reduced-motion:reduce){.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:none}}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highlighted-background)}to{background-color:var(--ck-color-image-caption-background)}}.ck.ck-image-insert-url{padding:var(--ck-spacing-large) var(--ck-spacing-large) 0;width:400px}.ck.ck-image-insert-url .ck-image-insert-url__action-row{display:grid;grid-template-columns:repeat(2,1fr)}.ck-content img.image_resized{height:auto}.ck-content .image.image_resized{box-sizing:border-box;display:block;max-width:100%}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}.ck.ck-editor__editable td .image-inline.image_resized img,.ck.ck-editor__editable th .image-inline.image_resized img{max-width:100%}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}:root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image.image-style-block-align-left,.ck-content .image.image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image.image-style-align-left,.ck-content .image.image-style-align-right{clear:none}.ck-content .image.image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image.image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image.image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image.image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image.image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content p+.image.image-style-align-left,.ck-content p+.image.image-style-align-right,.ck-content p+.image.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}.ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}.ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;height:auto;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image{z-index:1}.ck.ck-editor__editable .image.ck-widget_selected{z-index:2}.ck.ck-editor__editable .image-inline{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected{z-index:2}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable .image-inline img{height:auto}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}.ck.ck-editor__editable img.image_placeholder{background-size:100% 100%}.ck.ck-link-providers>.ck-link-providers__list{overflow-x:hidden;overflow-y:auto;overscroll-behavior:contain}.ck.ck-link-providers>.ck-link-providers__list .ck-button>.ck-icon{flex-shrink:0}.ck.ck-link-toolbar__preview{display:inline-block}.ck.ck-link-toolbar__preview .ck-button__label{overflow:hidden}.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{display:block;position:absolute}.ck.ck-link-form .ck-link-form__providers-list{display:flex;flex-direction:column}.ck.ck-link-form .ck-link-form__providers-list .ck-link__button>.ck-button__label{flex-grow:1}.ck.ck-link-form .ck-link__items:empty{display:none}.ck-editor__editable .ck-list-bogus-paragraph{display:block}.ck.ck-list-styles-list{display:grid}.ck-content ol{list-style-type:decimal}.ck-content ol ol{list-style-type:lower-latin}.ck-content ol ol ol{list-style-type:lower-roman}.ck-content ol ol ol ol{list-style-type:upper-latin}.ck-content ol ol ol ol ol{list-style-type:upper-roman}.ck-content ul{list-style-type:disc}.ck-content ul ul{list-style-type:circle}.ck-content ul ul ul,.ck-content ul ul ul ul{list-style-type:square}:root{--ck-todo-list-checkmark-size:16px}.ck-content .todo-list{list-style:none}.ck-content .todo-list li{margin-bottom:5px;position:relative}.ck-content .todo-list li .todo-list{margin-top:5px}.ck-content .todo-list .todo-list__label>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-content[dir=rtl] .todo-list .todo-list__label>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-content .todo-list .todo-list__label>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out;width:100%}@media (prefers-reduced-motion:reduce){.ck-content .todo-list .todo-list__label>input:before{transition:none}}.ck-content .todo-list .todo-list__label>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-content .todo-list .todo-list__label>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-content .todo-list .todo-list__label>input[checked]:after{border-color:#fff}.ck-content .todo-list .todo-list__label .todo-list__label__description{vertical-align:middle}.ck-content .todo-list .todo-list__label.todo-list__label_without-description input[type=checkbox]{position:absolute}.ck-editor__editable.ck-content .todo-list .todo-list__label>input,.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input{cursor:pointer}.ck-editor__editable.ck-content .todo-list .todo-list__label>input:hover:before,.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:hover:before{box-shadow:0 0 0 5px rgba(0,0,0,.1)}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-editor__editable.ck-content[dir=rtl] .todo-list .todo-list__label>span[contenteditable=false]>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out;width:100%}@media (prefers-reduced-motion:reduce){.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:before{transition:none}}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input[checked]:after{border-color:#fff}.ck-editor__editable.ck-content .todo-list .todo-list__label.todo-list__label_without-description input[type=checkbox]{position:absolute}.ck-content .media{clear:both;display:block;margin:.9em 0;min-width:15em}.ck-media__wrapper .ck-media__placeholder{align-items:center;display:flex;flex-direction:column}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{display:block;overflow:hidden}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck.ck-media-form{align-items:flex-start;display:flex;flex-direction:row;flex-wrap:nowrap;width:400px}.ck.ck-media-form .ck-labeled-field-view{display:inline-block;width:100%}.ck.ck-media-form .ck-label{display:none}.ck.ck-media-form .ck-input{width:100%}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}:root{--ck-mention-list-max-height:300px}.ck.ck-mentions{max-height:var(--ck-mention-list-max-height);overflow-x:hidden;overflow-y:auto;overscroll-behavior:contain}.ck.ck-mentions>.ck-list__item{flex-shrink:0;overflow:hidden}div.ck.ck-balloon-panel.ck-mention-balloon{z-index:calc(var( --ck-z-dialog ) + 1)}:root{--ck-color-minimap-tracker-background:208,0%,51%;--ck-color-minimap-iframe-outline:#bfbfbf;--ck-color-minimap-iframe-shadow:rgba(0,0,0,.11);--ck-color-minimap-progress-background:#666}.ck.ck-minimap{background:var(--ck-color-base-background);position:absolute;user-select:none}.ck.ck-minimap,.ck.ck-minimap iframe{height:100%;width:100%}.ck.ck-minimap iframe{border:0;box-shadow:0 2px 5px var(--ck-color-minimap-iframe-shadow);margin:0;outline:1px solid var(--ck-color-minimap-iframe-outline);pointer-events:none;position:relative}.ck.ck-minimap .ck.ck-minimap__position-tracker{background:hsla(var(--ck-color-minimap-tracker-background),.2);position:absolute;top:0;transition:background .1s ease-in-out;width:100%;z-index:1}@media (prefers-reduced-motion:reduce){.ck.ck-minimap .ck.ck-minimap__position-tracker{transition:none}}.ck.ck-minimap .ck.ck-minimap__position-tracker:hover{background:hsla(var(--ck-color-minimap-tracker-background),.3)}.ck.ck-minimap .ck.ck-minimap__position-tracker.ck-minimap__position-tracker_dragging,.ck.ck-minimap .ck.ck-minimap__position-tracker.ck-minimap__position-tracker_dragging:hover{background:hsla(var(--ck-color-minimap-tracker-background),.4)}.ck.ck-minimap .ck.ck-minimap__position-tracker.ck-minimap__position-tracker_dragging:after,.ck.ck-minimap .ck.ck-minimap__position-tracker.ck-minimap__position-tracker_dragging:hover:after{opacity:1}.ck.ck-minimap .ck.ck-minimap__position-tracker:after{background:var(--ck-color-minimap-progress-background);border:1px solid var(--ck-color-base-background);border-radius:3px;color:var(--ck-color-base-background);content:attr(data-progress) "%";font-size:10px;opacity:0;padding:2px 4px;position:absolute;right:5px;top:5px;transition:opacity .1s ease-in-out}@media (prefers-reduced-motion:reduce){.ck.ck-minimap .ck.ck-minimap__position-tracker:after{transition:none}}.ck-content .page-break{align-items:center;clear:both;display:flex;justify-content:center;padding:5px 0;position:relative}.ck-content .page-break:after{border-bottom:2px dashed #c4c4c4;content:"";position:absolute;width:100%}.ck-content .page-break__label{background:#fff;border:1px solid #c4c4c4;border-radius:2px;box-shadow:2px 2px 1px rgba(0,0,0,.15);color:#333;display:block;font-family:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;font-size:.75em;font-weight:700;padding:.3em .6em;position:relative;text-transform:uppercase;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1}@media print{.ck-content .page-break{padding:0}.ck-content .page-break:after{display:none}.ck-content :has(+.page-break){margin-bottom:0}}:root{--ck-show-blocks-border-color:#757575}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) address{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) address:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) address{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>ADDRESS</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) address{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>ADDRESS</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) aside{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) aside:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) aside{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>ASIDE</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) aside{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>ASIDE</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) blockquote{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) blockquote:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) blockquote{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>BLOCKQUOTE</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) blockquote{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>BLOCKQUOTE</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) details{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) details:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) details{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>DETAILS</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) details{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>DETAILS</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) div:not(.ck-widget,.ck-widget *){background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) div:not(.ck-widget,.ck-widget *):not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) div:not(.ck-widget,.ck-widget *){background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>DIV</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) div:not(.ck-widget,.ck-widget *){background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>DIV</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) footer{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) footer:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) footer{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>FOOTER</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) footer{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>FOOTER</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h1{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h1:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h1{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>H1</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h1{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>H1</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h2{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h2:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h2{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>H2</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h2{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>H2</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h3{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h3:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h3{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>H3</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h3{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>H3</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h4{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h4:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h4{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>H4</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h4{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>H4</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h5{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h5:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h5{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>H5</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h5{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>H5</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h6{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h6:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h6{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>H6</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) h6{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>H6</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) header{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) header:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) header{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>HEADER</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) header{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>HEADER</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) main{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) main:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) main{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>MAIN</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) main{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>MAIN</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) nav{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) nav:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) nav{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>NAV</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) nav{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>NAV</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) pre{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) pre:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) pre{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>PRE</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) pre{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>PRE</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) ol{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) ol:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) ol{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>OL</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) ol{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>OL</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) ul{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) ul:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) ul{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>UL</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) ul{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>UL</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) p{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) p:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) p{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>P</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) p{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>P</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) section{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) section:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) section{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>SECTION</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) section{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>SECTION</text></svg>");background-position:calc(100% - 1px) 1px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) :where(figure.image,figure.table) figcaption{background-repeat:no-repeat;padding-top:15px}.ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) :where(figure.image,figure.table) figcaption:not(.ck-widget_selected):not(.ck-widget:hover){outline:1px dashed var(--ck-show-blocks-border-color)}[dir=ltr] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) :where(figure.image,figure.table) figcaption{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='3' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>FIGCAPTION</text></svg>");background-position:1px 1px}[dir=rtl] .ck.ck-editor__editable.ck-editor__editable_inline.ck-show-blocks:not(.ck-widget) :where(figure.image,figure.table) figcaption{background-image:url("data:image/svg+xml;utf8,<svg width='120' height='12' xmlns='http://www.w3.org/2000/svg' ><text style='paint-order:stroke fill; clip-path: inset(-3px); transform:translate(-2px, 0)' stroke='%23EAEAEA' stroke-width='13' dominant-baseline='middle' fill='black' x='100%' text-anchor='end' y='7' font-size='9px' font-family='Consolas, %22Lucida Console%22, %22Lucida Sans Typewriter%22, %22DejaVu Sans Mono%22, %22Bitstream Vera Sans Mono%22, %22Liberation Mono%22, Monaco, %22Courier New%22, Courier, monospace'>FIGCAPTION</text></svg>");background-position:calc(100% - 1px) 1px}.ck-source-editing-area{overflow:hidden;position:relative}.ck-source-editing-area textarea,.ck-source-editing-area:after{border:1px solid transparent;font-family:monospace;font-size:var(--ck-font-size-normal);line-height:var(--ck-line-height-base);margin:0;padding:var(--ck-spacing-large);white-space:pre-wrap}.ck-source-editing-area:after{content:attr(data-value) " ";display:block;visibility:hidden}.ck-source-editing-area textarea{border-color:var(--ck-color-base-border);border-radius:0;box-sizing:border-box;height:100%;outline:none;overflow:hidden;position:absolute;resize:none;width:100%}.ck-rounded-corners .ck-source-editing-area textarea,.ck-source-editing-area textarea.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck-source-editing-area textarea:not([readonly]):focus{border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-character-grid{max-width:100%}.ck.ck-character-grid .ck-character-grid__tiles{display:grid}.ck.ck-character-info{display:flex;justify-content:space-between}.ck.ck-special-characters>.ck-dialog__content>div{grid-column-gap:0;grid-row-gap:0;display:grid;grid-template-columns:1fr;grid-template-rows:auto 1fr auto;height:100%;max-width:100%;width:350px}.ck.ck-special-characters>.ck-dialog__content>div>.ck-character-categories{grid-area:1/1/2/2;padding:var(--ck-spacing-medium) var(--ck-spacing-large)}.ck.ck-special-characters>.ck-dialog__content>div>.ck-character-categories>.ck-labeled-field-view{padding-top:var(--ck-spacing-standard);width:100%}.ck.ck-special-characters>.ck-dialog__content>div>.ck-character-categories>.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both;background:var(--ck-color-base-error);color:var(--ck-color-base-background);min-width:var(--ck-table-properties-min-error-width);padding:var(--ck-spacing-small) var(--ck-spacing-medium);text-align:center}.ck.ck-special-characters>.ck-dialog__content>div>.ck-character-categories>.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-color:transparent transparent var(--ck-color-base-error) transparent;border-style:solid;border-width:0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size)}@media (prefers-reduced-motion:reduce){.ck.ck-special-characters>.ck-dialog__content>div>.ck-character-categories>.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:none}}.ck.ck-special-characters>.ck-dialog__content>div>.ck-character-categories>.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}.ck.ck-special-characters>.ck-dialog__content>div>.ck-character-categories>.ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-special-characters>.ck-dialog__content>div>.ck-character-categories .ck-dropdown{display:block;width:100%}.ck.ck-special-characters>.ck-dialog__content>div>.ck-character-categories .ck-dropdown>button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-special-characters>.ck-dialog__content>div>.ck-character-categories .ck-dropdown>button>span{width:100%}.ck.ck-special-characters>.ck-dialog__content>div>.ck-character-grid{grid-area:2/1/3/2;max-height:200px}.ck.ck-special-characters>.ck-dialog__content>div>.ck-character-info{grid-area:3/1/4/2}:root{--ck-style-panel-columns:3}.ck.ck-style-panel .ck-style-grid{display:grid;grid-template-columns:repeat(var(--ck-style-panel-columns),auto);justify-content:start}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button{display:flex;flex-direction:column;justify-content:space-between}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button .ck-style-grid__button__preview{align-content:center;align-items:center;display:flex;flex-basis:100%;flex-grow:1;justify-content:flex-start}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-content figure.table:not(.layout-table){display:table}.ck-content figure.table:not(.layout-table)>table{height:100%;width:100%}.ck-content figure.table:not(.layout-table),.ck-content table.table:not(.layout-table){margin:.9em auto}.ck-content figure.table:not(.layout-table)>table,.ck-content table.table:not(.layout-table){border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0}.ck-content figure.table:not(.layout-table)>table>tbody>tr>th,.ck-content figure.table:not(.layout-table)>table>thead>tr>th,.ck-content table.table:not(.layout-table)>tbody>tr>th,.ck-content table.table:not(.layout-table)>thead>tr>th{background:rgba(0,0,0,.05);font-weight:700}.ck-content figure.table:not(.layout-table)>table>tbody>tr>td,.ck-content figure.table:not(.layout-table)>table>tbody>tr>th,.ck-content figure.table:not(.layout-table)>table>thead>tr>td,.ck-content figure.table:not(.layout-table)>table>thead>tr>th,.ck-content table.table:not(.layout-table)>tbody>tr>td,.ck-content table.table:not(.layout-table)>tbody>tr>th,.ck-content table.table:not(.layout-table)>thead>tr>td,.ck-content table.table:not(.layout-table)>thead>tr>th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}@media print{.ck-content figure.table>table{height:auto}}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}.ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row{flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:first-of-type{flex-grow:0.57}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:last-of-type{flex-grow:0.43}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar .ck-button{flex-grow:1}.ck.ck-input-color{display:flex;flex-direction:row-reverse;width:100%}.ck.ck-input-color>input.ck.ck-input-text{flex-grow:1;min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button{display:flex}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{overflow:hidden;position:relative}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{display:block;position:absolute}.ck-editor__editable.ck-editor__editable_inline>.ck-widget.ck-widget_with-selection-handle.layout-table:first-child{margin-top:var(--ck-spacing-large)}.ck-editor__editable.ck-editor__editable_inline>.ck-widget.ck-widget_with-selection-handle.layout-table:last-child,.ck-editor__editable.ck-editor__editable_inline>.ck-widget.ck-widget_with-selection-handle.layout-table:nth-last-child(2):has(+.ck-fake-selection-container){margin-bottom:var(--ck-spacing-large)}.ck-editor__editable .table.layout-table{display:table;margin:0}.ck-editor__editable .table.layout-table.ck-widget:hover{z-index:var(--ck-z-default)}.ck-editor__editable .table.layout-table.ck-widget:hover>.ck-widget__selection-handle{opacity:.75;visibility:visible}.ck-editor__editable .table.layout-table.ck-widget:hover>.ck-widget__selection-handle:hover{opacity:1}.ck-editor__editable .table.layout-table.ck-widget:has(.ck-widget.table:hover)>.ck-widget__selection-handle{opacity:0;visibility:hidden}.ck-editor__editable .table.layout-table.ck-widget.ck-widget_selected{z-index:var(--ck-z-default)}.ck-content figure.table.layout-table,.ck-content table.table.layout-table{margin-bottom:0;margin-top:0}.ck-content figure.table.layout-table>table,.ck-content table.table.layout-table{border-spacing:0}:root{--ck-form-default-width:340px}.ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form.ck-form_default-width{width:var(--ck-form-default-width)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-number,.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}@media screen and (max-width:600px){.ck.ck-form.ck-responsive-form .ck.ck-form__row.ck-form__row_with-submit{align-items:stretch;flex-direction:column;padding:0}.ck.ck-form.ck-responsive-form .ck.ck-form__row.ck-form__row_with-submit>.ck{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-form.ck-responsive-form .ck.ck-form__row.ck-form__row_with-submit .ck-button_with-text{justify-content:center}.ck.ck-form.ck-responsive-form .ck.ck-form__row.ck-form__row_large-bottom-padding{padding-bottom:var(--ck-spacing-large)}}[dir=ltr] .ck.ck-form.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-form.ck-responsive-form>:not(:last-child){margin-left:0}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-table-form .ck-form__row.ck-table-form__background-row,.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{align-items:center;flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view{align-items:center;display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck-form__row>:not(.ck-label,.ck-table-form__dimension-operator){flex-grow:1}.ck.ck-table-form .ck.ck-labeled-field-view{position:relative}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{bottom:calc(var(--ck-table-properties-error-arrow-size)*-1);left:50%;position:absolute;transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{content:"";left:50%;position:absolute;top:calc(var(--ck-table-properties-error-arrow-size)*-1);transform:translateX(-50%)}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-content:baseline;flex-basis:0;flex-wrap:wrap}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}:root{--ck-color-selector-caption-background:#f7f7f7;--ck-color-selector-caption-text:#333;--ck-color-selector-caption-highlighted-background:#fd0}.ck-content .table>figcaption{background-color:var(--ck-color-selector-caption-background);caption-side:top;color:var(--ck-color-selector-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;text-align:center;word-break:break-word}@media (forced-colors:active){.ck-content .table>figcaption{background-color:unset;color:unset}}@media (forced-colors:none){.ck.ck-editor__editable .table>figcaption.table__caption_highlighted{animation:ck-table-caption-highlight .6s ease-out}}.ck.ck-editor__editable .table>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}@keyframes ck-table-caption-highlight{0%{background-color:var(--ck-color-selector-caption-highlighted-background)}to{background-color:var(--ck-color-selector-caption-background)}}:root{--ck-color-selector-column-resizer-hover:var(--ck-color-base-active);--ck-table-column-resizer-width:7px;--ck-table-column-resizer-position-offset:calc(var(--ck-table-column-resizer-width)*-0.5 - 0.5px)}.ck-content .table .ck-table-resized{table-layout:fixed}.ck-content .table td,.ck-content .table th{overflow-wrap:break-word}.ck.ck-editor__editable .table td,.ck.ck-editor__editable .table th{position:relative}.ck.ck-editor__editable .table .ck-table-column-resizer{bottom:0;cursor:col-resize;position:absolute;right:var(--ck-table-column-resizer-position-offset);top:0;user-select:none;width:var(--ck-table-column-resizer-width);z-index:var(--ck-z-default)}.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer,.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer{display:none}.ck.ck-editor__editable .table .ck-table-column-resizer:hover,.ck.ck-editor__editable .table .ck-table-column-resizer__active{background-color:var(--ck-color-selector-column-resizer-hover);opacity:.25}.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer{left:var(--ck-table-column-resizer-position-offset);right:unset}.ck-hidden{display:none!important}:root{--ck-z-default:1;--ck-z-panel:calc(var(--ck-z-default) + 999);--ck-z-dialog:9999}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-powered-by-font-size:calc(var(--ck-font-size-base)*7.5/13);--ck-powered-by-line-height:calc(var(--ck-font-size-base)*10/13);--ck-powered-by-letter-spacing:calc(var(--ck-font-size-base)*-0.2/13);--ck-powered-by-padding-vertical:2px;--ck-powered-by-padding-horizontal:4px;--ck-powered-by-text-color:#4f4f4f;--ck-powered-by-border-radius:var(--ck-border-radius);--ck-powered-by-background:#fff;--ck-powered-by-border-color:var(--ck-color-focus-border);--ck-powered-by-svg-width:53;--ck-powered-by-svg-height:10;--ck-powered-by-icon-width:calc(var(--ck-font-size-base)*var(--ck-powered-by-svg-width)/13);--ck-powered-by-icon-height:calc(var(--ck-font-size-base)*var(--ck-powered-by-svg-height)/13)}.ck.ck-balloon-panel.ck-powered-by-balloon{--ck-border-radius:var(--ck-powered-by-border-radius);background:var(--ck-powered-by-background);box-shadow:none;min-height:unset;z-index:calc(var(--ck-z-panel) - 1)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by{line-height:var(--ck-powered-by-line-height)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by a{align-items:center;cursor:pointer;display:flex;filter:grayscale(80%);line-height:var(--ck-powered-by-line-height);opacity:.66;padding:var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-powered-by__label{color:var(--ck-powered-by-text-color);cursor:pointer;font-size:var(--ck-powered-by-font-size);font-weight:700;letter-spacing:var(--ck-powered-by-letter-spacing);line-height:normal;margin-right:4px;padding-left:2px;text-transform:uppercase}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-icon{cursor:pointer;display:block;height:var(--ck-powered-by-icon-height);width:var(--ck-powered-by-icon-width)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by:hover a{filter:grayscale(0);opacity:1}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_inside]{border-color:transparent}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_border]{border:var(--ck-focus-ring);border-color:var(--ck-powered-by-border-color)}:root{--ck-evaluation-badge-font-size:calc(var(--ck-font-size-base)*7.5/13);--ck-evaluation-badge-line-height:calc(var(--ck-font-size-base)*7.5/13);--ck-evaluation-badge-letter-spacing:calc(var(--ck-font-size-base)*-0.2/13);--ck-evaluation-badge-padding-vertical:2px;--ck-evaluation-badge-padding-horizontal:4px;--ck-evaluation-badge-text-color:#4f4f4f;--ck-evaluation-badge-border-radius:var(--ck-border-radius);--ck-evaluation-badge-background:#fff;--ck-evaluation-badge-border-color:var(--ck-color-focus-border)}.ck.ck-balloon-panel.ck-evaluation-badge-balloon{--ck-border-radius:var(--ck-evaluation-badge-border-radius);background:var(--ck-evaluation-badge-background);box-shadow:none;min-height:unset;z-index:calc(var(--ck-z-panel) - 1)}.ck.ck-balloon-panel.ck-evaluation-badge-balloon .ck.ck-evaluation-badge{line-height:var(--ck-evaluation-badge-line-height);padding:var(--ck-evaluation-badge-padding-vertical) var(--ck-evaluation-badge-padding-horizontal)}.ck.ck-balloon-panel.ck-evaluation-badge-balloon .ck.ck-evaluation-badge .ck-evaluation-badge__label{color:var(--ck-evaluation-badge-text-color);display:block;font-size:var(--ck-evaluation-badge-font-size);font-weight:700;letter-spacing:var(--ck-evaluation-badge-letter-spacing);line-height:normal;padding:0 2px;text-transform:uppercase}.ck.ck-balloon-panel.ck-evaluation-badge-balloon[class*=position_inside]{border-color:transparent}.ck.ck-balloon-panel.ck-evaluation-badge-balloon[class*=position_border]{border:var(--ck-focus-ring);border-color:var(--ck-evaluation-badge-border-color)}.ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}[dir=ltr] .ck.ck-button,[dir=ltr] a.ck.ck-button{justify-content:left}[dir=rtl] .ck.ck-button,[dir=rtl] a.ck.ck-button{justify-content:right}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}.ck.ck-list-item-button{border-radius:0;min-height:unset;width:100%}[dir=ltr] .ck.ck-list-item-button{text-align:left}[dir=rtl] .ck.ck-list-item-button{text-align:right}[dir=ltr] .ck.ck-list-item-button.ck-list-item-button_toggleable{padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-list-item-button.ck-list-item-button_toggleable{padding-right:var(--ck-spacing-small)}.ck.ck-list-item-button .ck-list-item-button__check-holder{display:inline-flex;height:.9em;width:.9em}[dir=ltr] .ck.ck-list-item-button .ck-list-item-button__check-holder{margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-list-item-button .ck-list-item-button__check-holder{margin-left:var(--ck-spacing-small)}.ck.ck-list-item-button .ck-list-item-button__check-icon{height:100%}.ck.ck-collapsible.ck-collapsible_collapsed>.ck-collapsible__children{display:none}.ck.ck-color-grid{display:grid}.color-picker-hex-input{width:max-content}.color-picker-hex-input .ck.ck-input{min-width:unset}.ck.ck-color-picker__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between;margin:var(--ck-spacing-large) 0 0;width:unset}.ck.ck-color-picker__row .ck.ck-labeled-field-view{padding-top:unset}.ck.ck-color-picker__row .ck.ck-input-text{width:unset}.ck.ck-color-picker__row .ck-color-picker__hash-view{padding-right:var(--ck-spacing-medium);padding-top:var(--ck-spacing-tiny)}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{align-items:center;display:flex}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{justify-content:flex-start}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{display:flex;flex-direction:row;justify-content:space-around}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-cancel,.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-save{flex:1}.ck.ck-dialog .ck.ck-dialog__actions{display:flex;justify-content:flex-end}.ck.ck-dialog-overlay{bottom:0;left:0;overscroll-behavior:none;position:fixed;right:0;top:0;user-select:none}.ck.ck-dialog-overlay.ck-dialog-overlay__transparent{animation:none;background:none;pointer-events:none}.ck.ck-dialog{overscroll-behavior:none;position:absolute;width:fit-content}.ck.ck-dialog .ck.ck-form__header{flex-shrink:0}.ck.ck-dialog:not(.ck-dialog_modal) .ck.ck-form__header .ck-form__header__label{cursor:grab}.ck.ck-dialog-overlay.ck-dialog-overlay__transparent .ck.ck-dialog{pointer-events:all}:root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-panel)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-panel) + 1)}.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-dropdown-menu-list__nested-menu__button>.ck-dropdown-menu-list__nested-menu__button__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-balloon-panel.ck-dropdown-menu__nested-menu__panel{max-height:314px;overflow-y:auto;position:absolute;z-index:calc(var(--ck-z-panel) + 1)}.ck.ck-dropdown-menu-list__nested-menu{display:block}.ck.ck-aria-live-announcer{left:-10000px;position:absolute;top:-10000px}.ck.ck-aria-live-region-list{list-style-type:none}.ck.ck-form__row{align-items:flex-start;display:flex;flex-direction:row;justify-content:space-between;padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}.ck.ck-form__row.ck-form__row_large-top-padding{padding-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-form__row_large-bottom-padding{padding-bottom:var(--ck-spacing-large)}.ck.ck-form__row.ck-form__row_with-submit{flex-wrap:nowrap}.ck.ck-form__row.ck-form__row_with-submit>:not(:first-child){margin-inline-start:var(--ck-spacing-standard)}.ck.ck-form__row>.ck.ck-form__row{padding:0}.ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__header h2.ck-form__header__label{flex-grow:1}.ck.ck-icon{vertical-align:middle}.ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}.ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}:root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-panel)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}.ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-panel) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-panel)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-autocomplete{position:relative}.ck.ck-autocomplete>.ck-search__results{position:absolute;z-index:var(--ck-z-panel)}.ck.ck-autocomplete>.ck-search__results.ck-search__results_n{bottom:100%}.ck.ck-autocomplete>.ck-search__results.ck-search__results_s{bottom:auto;top:100%}.ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr] .ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{left:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{right:var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view .ck-search__reset{position:absolute;top:50%;transform:translateY(-50%)}.ck.ck-search>.ck-search__results>.ck-search__info>span:first-child{display:block}.ck.ck-search>.ck-search__results>.ck-search__info:not(.ck-hidden)~*{display:none}.ck.ck-highlighted-text mark{background:var(--ck-color-highlight-background);font-size:inherit;font-weight:inherit;line-height:inherit;vertical-align:initial}.ck.ck-balloon-panel.ck-tooltip{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;z-index:calc(var(--ck-z-dialog) + 100)}:root{--ck-toolbar-spinner-size:18px}.ck.ck-spinner-container{display:block;position:relative}.ck.ck-spinner{left:0;margin:0 auto;position:absolute;right:0;top:50%;transform:translateY(-50%);z-index:1}.ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}.ck.ck-menu-bar__menu>.ck-menu-bar__menu__button>.ck-menu-bar__menu__button__arrow{pointer-events:none;z-index:var(--ck-z-default)}:root{--ck-menu-bar-menu-max-width:75vw;--ck-menu-bar-nested-menu-horizontal-offset:5px}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel{max-width:var(--ck-menu-bar-menu-max-width);position:absolute;z-index:var(--ck-z-panel)}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_ne,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_nw{bottom:100%}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_se,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_sw{bottom:auto;top:100%}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_ne,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_se{left:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_nw,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_sw{right:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_en,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_es{left:calc(100% - var(--ck-menu-bar-nested-menu-horizontal-offset))}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_es{top:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_en{bottom:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_wn,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_ws{right:calc(100% - var(--ck-menu-bar-nested-menu-horizontal-offset))}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_ws{top:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_wn{bottom:0}.ck.ck-menu-bar__menu{display:block;position:relative}:root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}.ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}`;
var p3 = /* @__PURE__ */ W('<div class="editor-container editor-container_balloon-editor editor-container_include-block-toolbar" id="editor-container" style="margin: 0px 34px; min-height: 34px;"><div class="editor-container__editor"><div id="editorContent"></div></div></div>');
const b3 = { hash: "svelte-32ttx", code: "" };
function k3(o, n) {
  Ve(n, !0), fe(o, b3);
  let t = $(n, "editorContent", 11, ""), e;
  wb(() => {
    const s = document.createElement("style");
    s.textContent = f3, document.head.appendChild(s), i();
  });
  function i() {
    let s = document.getElementById("editorContent");
    YT.create(s, {
      toolbar: {
        items: [
          "heading",
          "|",
          "fontSize",
          "fontFamily",
          "fontColor",
          "fontBackgroundColor",
          "|",
          "bold",
          "italic",
          "underline",
          "strikethrough",
          "subscript",
          "superscript",
          "code",
          "removeFormat",
          "|",
          "emoji",
          "specialCharacters",
          "horizontalLine",
          "link",
          "insertImage",
          "mediaEmbed",
          "insertTable",
          "highlight",
          "blockQuote",
          "codeBlock",
          "|",
          "alignment",
          "|",
          "bulletedList",
          "numberedList",
          "todoList",
          "outdent",
          "indent"
        ],
        shouldNotGroupWhenFull: !1
      },
      plugins: [
        N5,
        H5,
        lI,
        j_,
        U5,
        i2,
        bT,
        M5,
        W5,
        Y5,
        WT,
        dS,
        yS,
        FS,
        zS,
        SS,
        PS,
        GS,
        eI,
        rI,
        pI,
        yI,
        kI,
        DI,
        B_,
        RI,
        jI,
        Ou,
        HI,
        L_,
        qI,
        GI,
        J5,
        cM,
        gM,
        CM,
        PM,
        _D,
        ID,
        UD,
        Oa,
        yD,
        c4,
        m4,
        w4,
        bv,
        vv,
        _4,
        _v,
        wv,
        kv,
        eT,
        oT,
        aT,
        e3,
        g3,
        o3,
        KS,
        RM,
        dT
      ],
      blockToolbar: [
        "fontSize",
        "fontColor",
        "fontBackgroundColor",
        "|",
        "bold",
        "italic",
        "|",
        "link",
        "insertImage",
        "insertTable",
        "|",
        "bulletedList",
        "numberedList",
        "outdent",
        "indent"
      ],
      fontFamily: { supportAllValues: !0 },
      fontSize: {
        options: [10, 12, 14, "default", 18, 20, 22],
        supportAllValues: !0
      },
      heading: {
        options: [
          {
            model: "paragraph",
            title: "Paragraph",
            class: "ck-heading_paragraph"
          },
          {
            model: "heading1",
            view: "h1",
            title: "Heading 1",
            class: "ck-heading_heading1"
          },
          {
            model: "heading2",
            view: "h2",
            title: "Heading 2",
            class: "ck-heading_heading2"
          },
          {
            model: "heading3",
            view: "h3",
            title: "Heading 3",
            class: "ck-heading_heading3"
          },
          {
            model: "heading4",
            view: "h4",
            title: "Heading 4",
            class: "ck-heading_heading4"
          },
          {
            model: "heading5",
            view: "h5",
            title: "Heading 5",
            class: "ck-heading_heading5"
          },
          {
            model: "heading6",
            view: "h6",
            title: "Heading 6",
            class: "ck-heading_heading6"
          }
        ]
      },
      image: {
        toolbar: [
          "toggleImageCaption",
          "imageTextAlternative",
          "|",
          "imageStyle:inline",
          "imageStyle:wrapText",
          "imageStyle:breakText",
          "|",
          "resizeImage"
        ]
      },
      initialData: `<h2>Congratulations on setting up CKEditor 5! </h2>
<p>
	You've successfully created a CKEditor 5 project. This powerful text editor
	will enhance your application, enabling rich text editing capabilities that
	are customizable and easy to use.
</p>
<h3>What's next?</h3>
<ol>
	<li>
		<strong>Integrate into your app</strong>: time to bring the editing into
		your application. Take the code you created and add to your application.
	</li>
	<li>
		<strong>Explore features:</strong> Experiment with different plugins and
		toolbar options to discover what works best for your needs.
	</li>
	<li>
		<strong>Customize your editor:</strong> Tailor the editor's
		configuration to match your application's style and requirements. Or
		even write your plugin!
	</li>
</ol>
<p>
	Keep experimenting, and don't hesitate to push the boundaries of what you
	can achieve with CKEditor 5. Your feedback is invaluable to us as we strive
	to improve and evolve. Happy editing!
</p>
<h3>Helpful resources</h3>
<ul>
	<li> <a href="https://portal.ckeditor.com/checkout?plan=free">Trial sign up</a>,</li>
	<li> <a href="https://ckeditor.com/docs/ckeditor5/latest/installation/index.html">Documentation</a>,</li>
	<li> <a href="https://github.com/ckeditor/ckeditor5">GitHub</a> (star us if you can!),</li>
	<li> <a href="https://ckeditor.com">CKEditor Homepage</a>,</li>
	<li> <a href="https://ckeditor.com/ckeditor-5/demo/">CKEditor 5 Demos</a>,</li>
</ul>
<h3>Need help?</h3>
<p>
	See this text, but the editor is not starting up? Check the browser's
	console for clues and guidance. It may be related to an incorrect license
	key if you use premium features or another feature-related requirement. If
	you cannot make it work, file a GitHub issue, and we will help as soon as
	possible!
</p>
`,
      licenseKey: "GPL",
      link: {
        addTargetToExternalLinks: !0,
        defaultProtocol: "https://",
        decorators: {
          toggleDownloadable: {
            mode: "manual",
            label: "Downloadable",
            attributes: { download: "file" }
          }
        }
      },
      list: {
        properties: {
          styles: !0,
          startIndex: !0,
          reversed: !0
        }
      },
      mention: {
        feeds: [
          {
            marker: "@",
            feed: []
            /* See: https://ckeditor.com/docs/ckeditor5/latest/features/mentions.html */
          }
        ]
      },
      placeholder: "Type or paste your content here!",
      table: {
        contentToolbar: ["tableColumn", "tableRow", "mergeTableCells"]
      },
      autosave: {
        save(a) {
          let l = a.getData();
          alert(l);
        }
      }
    }).then((a) => {
      e = a, t() && (console.log("Setting loaded to true in editor create"), e.setData(t()));
    });
  }
  var r = p3();
  U(o, r), Fe();
}
customElements.define("gen-editor-new", ae(k3, { editorContent: { reflect: !0 } }, [], [], !1));
export {
  Ny as ElegantBuffet,
  Ab as ElegantHeader,
  Eb as ElegantHeroSearch,
  xb as ElegantSearch,
  Ry as ElegantSpinner,
  Pb as ElegantTable,
  jy as GenEditor,
  k3 as GenEditorNew,
  S1 as IngBuffet,
  r1 as IngButton,
  yb as IngHeaderLite,
  vb as IngInput,
  N1 as IngTable
};
